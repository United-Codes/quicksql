var Ft = {};
Ft.colors = [];
Ft.FONT_FAMILY = 'var(--qs-diagram-font-family, "Arial")';
Ft.colors.TABLE_BACKGROUND = "var(--qs-diagram-table-background-color, rgb(254,246,222))";
Ft.colors.TABLE_BORDER = "var(--qs-diagram-table-border-color, rgba(0,0,0,.1))";
Ft.colors.TABLE_NAME_TEXT = "var(--qs-diagram-table-name-text-color, var(--qs-diagram-table-text-color, rgba(0,0,0,.8)))";
Ft.colors.TABLE_COLUMN_TEXT = "var(--qs-diagram-table-column-text-color, var(--qs-diagram-table-text-color, rgba(0,0,0,.8)))";
Ft.colors.TABLE_DATA_TYPE_TEXT = "var(--qs-diagram-table-data-type-text-color, var(--qs-diagram-table-text-color, rgba(0,0,0,.4)))";
typeof document < "u" && (Ft.TABLE_BORDER_RADIUS = getComputedStyle(document.documentElement).getPropertyValue("--qs-diagram-table-border-radius"));
Ft.TABLE_BORDER_RADIUS = Ft.TABLE_BORDER_RADIUS ? Ft.TABLE_BORDER_RADIUS : 0;
Ft.colors.VIEW_BACKGROUND = "var(--qs-diagram-view-background-color, rgb(236,245,231))";
Ft.colors.VIEW_BORDER = "var(--qs-diagram-view-border-color, rgba(0,0,0,.1))";
Ft.colors.VIEW_NAME_TEXT = "var(--qs-diagram-view-text-color, rgb(0,0,0))";
Ft.colors.VIEW_COLUMN_TEXT = "var(--qs-diagram-view-column-text-color, var(--qs-diagram-view-text-color, rgba(0,0,0,.8)))";
Ft.colors.VIEW_DATA_TYPE_TEXT = "var(--qs-diagram-view-data-type-text-color, var(--qs-diagram-view-text-color, rgba(0,0,0,.4)))";
typeof document < "u" && (Ft.VIEW_BORDER_RADIUS = getComputedStyle(document.documentElement).getPropertyValue("--qs-diagram-view-border-radius"));
Ft.VIEW_BORDER_RADIUS = Ft.VIEW_BORDER_RADIUS ? Ft.VIEW_BORDER_RADIUS : 4;
Ft.colors.LINK = "var(--qs-diagram-link-color, rgba(140,140,140,1))";
typeof joint < "u" && (joint.shapes.quicksql = {}, joint.shapes.quicksql.Table = joint.shapes.standard.HeaderedRecord.define("quicksql.Table", {
  z: 0,
  columns: [],
  padding: { top: 25, bottom: 5, left: 0, right: 0 },
  size: { width: 60 },
  itemMinLabelWidth: 60,
  itemHeight: 16,
  itemOverflow: !0,
  attrs: {
    root: {
      magnet: !1
    },
    body: {
      // cursor: 'default',
      rx: Ft.TABLE_BORDER_RADIUS,
      ry: Ft.TABLE_BORDER_RADIUS,
      fill: Ft.colors.TABLE_BACKGROUND,
      stroke: Ft.colors.TABLE_BORDER,
      "stroke-width": 1,
      refWidth: "100%",
      refHeight: "100%"
    },
    headerLabel: {
      // cursor: 'default',
      y: -4,
      fontFamily: Ft.FONT_FAMILY,
      fill: Ft.colors.TABLE_NAME_TEXT,
      fontWeight: "bold",
      fontSize: 12,
      textWrap: {
        ellipsis: !0,
        height: 20
      }
    },
    separator: {
      // cursor: 'default',
      stroke: Ft.colors.TABLE_BORDER,
      strokeWidth: 1
    },
    itemBodies_0: {
      magnet: !1,
      pointerEvents: "none"
    },
    group_1: {
      pointerEvents: "none"
    },
    itemLabels: {
      fontFamily: Ft.FONT_FAMILY,
      fontWeight: "bold",
      fontSize: 10,
      fill: Ft.colors.TABLE_COLUMN_TEXT,
      pointerEvents: "none"
    },
    itemLabels_1: {
      fill: Ft.colors.TABLE_DATA_TYPE_TEXT,
      textAnchor: "end",
      x: "calc(0.5 * w - 20)"
    }
  }
}, {
  markup: [{
    tagName: "rect",
    selector: "body"
  }, {
    tagName: "text",
    selector: "headerLabel"
  }, {
    tagName: "path",
    selector: "separator"
  }],
  setName(t, e) {
    return this.attr(["headerLabel", "text"], t, e);
  },
  setColumns(t = []) {
    const e = [], r = [], n = /* @__PURE__ */ new Set();
    t.forEach((i, a) => {
      if (!i.name)
        return;
      let s = i.name;
      n.has(s) && (s = `${i.name}_${a}`), n.add(s), e.push({
        id: s,
        label: i.name,
        span: 2
      });
      const o = {
        id: `${i.datatype}_${a}`,
        label: i.datatype
      };
      r.push(o);
    }), this.set("items", [e, r]), this.removeInvalidLinks();
  }
}), joint.shapes.quicksql.TableView = joint.shapes.standard.RecordView.extend({
  initialize: function() {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments), this.updatePath();
  },
  updatePath: function() {
    var t = "M 0 20 L " + this.model.get("size").width + " 20";
    this.model.attr("separator/d", t, {
      silent: !0
    });
  }
}), joint.shapes.quicksql.View = joint.shapes.quicksql.Table.define("quicksql.View", {
  attrs: {
    body: {
      rx: Ft.VIEW_BORDER_RADIUS,
      ry: Ft.VIEW_BORDER_RADIUS,
      fill: Ft.colors.VIEW_BACKGROUND,
      stroke: Ft.colors.VIEW_BORDER
    },
    headerLabel: {
      fontFamily: Ft.FONT_FAMILY,
      fill: Ft.colors.VIEW_NAME_TEXT
    },
    separator: {
      stroke: Ft.colors.TABLE_BORDER
    },
    itemLabels: {
      fill: Ft.colors.VIEW_COLUMN_TEXT
    },
    itemLabels_1: {
      fill: Ft.colors.VIEW_DATA_TYPE_TEXT
    }
  }
}), joint.shapes.quicksql.ViewView = joint.shapes.quicksql.TableView, joint.shapes.quicksql.Relation = joint.shapes.standard.Link.define("quicksql.Relation", {
  z: -1,
  attrs: {
    line: {
      stroke: Ft.colors.LINK,
      strokeWidth: 1,
      strokeDasharray: "none",
      sourceMarker: {
        d: "M 5 -4 L 0 0 L 5 4 z",
        fill: Ft.colors.LINK,
        stroke: Ft.colors.LINK
      },
      targetMarker: {
        d: ""
      }
    }
  },
  style: "none",
  sourceTable: "",
  targetTable: ""
}, {
  initialize: function() {
    joint.shapes.standard.Link.prototype.initialize.apply(this, arguments), this.updateStyle();
  },
  updateStyle: function() {
    this.attr("line/strokeDasharray", this.get("style") === "dash" ? "5 5" : "none");
  }
}));
var Aa = {};
const u5 = typeof document < "u" && getComputedStyle(document.querySelector(":root")).getPropertyValue("--qs-diagram-font-family") || "Arial";
Aa.newGuid = function() {
  function t(e) {
    var r = (Math.random().toString(16) + "000000000").substr(2, 8);
    return e ? "-" + r.substr(0, 4) + "-" + r.substr(4, 4) : r;
  }
  return t() + t(!0) + t(!0) + t();
};
Aa.calcWidth = function(t, e, r) {
  var n = e;
  t && (n = t.concat(".").concat(e));
  for (var i = Aa.getTextWidth(n, `12pt ${u5}`) + 0, a = 0, s = 0, o = 0; o < r.length; o++)
    a = Math.max(a, Aa.getTextWidth(r[o].name, `10pt ${u5}`)), s = Math.max(s, Aa.getTextWidth(r[o].datatype, `10pt ${u5}`));
  const l = s > a ? s * 2 + 20 : a + s + 20;
  let u = Math.max(i, l);
  return Math.max(u, 230);
};
Aa.getTextWidth = function(t, e) {
  var r = Aa.getTextWidth.canvas || (Aa.getTextWidth.canvas = document.createElement("canvas")), n = r.getContext("2d");
  n.font = e;
  var i = n.measureText(t);
  return i.width;
};
var Y7 = {
  name: "mermaid",
  version: "11.12.2",
  description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
  type: "module",
  module: "./dist/mermaid.core.mjs",
  types: "./dist/mermaid.d.ts",
  exports: {
    ".": {
      types: "./dist/mermaid.d.ts",
      import: "./dist/mermaid.core.mjs",
      default: "./dist/mermaid.core.mjs"
    },
    "./*": "./*"
  },
  keywords: [
    "diagram",
    "markdown",
    "flowchart",
    "sequence diagram",
    "gantt",
    "class diagram",
    "git graph",
    "mindmap",
    "packet diagram",
    "c4 diagram",
    "er diagram",
    "pie chart",
    "pie diagram",
    "quadrant chart",
    "requirement diagram",
    "graph"
  ],
  scripts: {
    clean: "rimraf dist",
    dev: "pnpm -w dev",
    "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
    "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
    "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
    "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
    "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
    "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
    "docs:spellcheck": 'cspell "src/docs/**/*.md"',
    "docs:release-version": "tsx scripts/update-release-version.mts",
    "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
    "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
    "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
    checkCircle: "npx madge --circular ./src",
    prepublishOnly: "pnpm docs:verify-version"
  },
  repository: {
    type: "git",
    url: "https://github.com/mermaid-js/mermaid"
  },
  author: "Knut Sveidqvist",
  license: "MIT",
  standard: {
    ignore: [
      "**/parser/*.js",
      "dist/**/*.js",
      "cypress/**/*.js"
    ],
    globals: [
      "page"
    ]
  },
  dependencies: {
    "@braintree/sanitize-url": "^7.1.1",
    "@iconify/utils": "^3.0.1",
    "@mermaid-js/parser": "workspace:^",
    "@types/d3": "^7.4.3",
    cytoscape: "^3.29.3",
    "cytoscape-cose-bilkent": "^4.1.0",
    "cytoscape-fcose": "^2.2.0",
    d3: "^7.9.0",
    "d3-sankey": "^0.12.3",
    "dagre-d3-es": "7.0.13",
    dayjs: "^1.11.18",
    dompurify: "^3.2.5",
    katex: "^0.16.22",
    khroma: "^2.1.0",
    "lodash-es": "^4.17.21",
    marked: "^16.2.1",
    roughjs: "^4.6.6",
    stylis: "^4.3.6",
    "ts-dedent": "^2.2.0",
    uuid: "^11.1.0"
  },
  devDependencies: {
    "@adobe/jsonschema2md": "^8.0.5",
    "@iconify/types": "^2.0.0",
    "@types/cytoscape": "^3.21.9",
    "@types/cytoscape-fcose": "^2.2.4",
    "@types/d3-sankey": "^0.12.4",
    "@types/d3-scale": "^4.0.9",
    "@types/d3-scale-chromatic": "^3.1.0",
    "@types/d3-selection": "^3.0.11",
    "@types/d3-shape": "^3.1.7",
    "@types/jsdom": "^21.1.7",
    "@types/katex": "^0.16.7",
    "@types/lodash-es": "^4.17.12",
    "@types/micromatch": "^4.0.9",
    "@types/stylis": "^4.2.7",
    "@types/uuid": "^10.0.0",
    ajv: "^8.17.1",
    canvas: "^3.1.2",
    chokidar: "3.6.0",
    concurrently: "^9.1.2",
    "csstree-validator": "^4.0.1",
    globby: "^14.1.0",
    jison: "^0.4.18",
    "js-base64": "^3.7.8",
    jsdom: "^26.1.0",
    "json-schema-to-typescript": "^15.0.4",
    micromatch: "^4.0.8",
    "path-browserify": "^1.0.1",
    prettier: "^3.5.3",
    remark: "^15.0.1",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    rimraf: "^6.0.1",
    "start-server-and-test": "^2.0.13",
    "type-fest": "^4.35.0",
    typedoc: "^0.28.12",
    "typedoc-plugin-markdown": "^4.8.1",
    typescript: "~5.7.3",
    "unist-util-flatmap": "^1.0.0",
    "unist-util-visit": "^5.0.0",
    vitepress: "^1.6.4",
    "vitepress-plugin-search": "1.0.4-alpha.22"
  },
  files: [
    "dist/",
    "README.md"
  ],
  publishConfig: {
    access: "public"
  }
}, Jm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oc(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var my = { exports: {} }, mhe = my.exports, SM;
function vhe() {
  return SM || (SM = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(mhe, (function() {
      var r = 1e3, n = 6e4, i = 36e5, a = "millisecond", s = "second", o = "minute", l = "hour", u = "day", h = "week", f = "month", d = "quarter", p = "year", g = "date", m = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(C) {
        var I = ["th", "st", "nd", "rd"], N = C % 100;
        return "[" + C + (I[(N - 20) % 10] || I[N] || I[0]) + "]";
      } }, x = function(C, I, N) {
        var O = String(C);
        return !O || O.length >= I ? C : "" + Array(I + 1 - O.length).join(N) + C;
      }, T = { s: x, z: function(C) {
        var I = -C.utcOffset(), N = Math.abs(I), O = Math.floor(N / 60), D = N % 60;
        return (I <= 0 ? "+" : "-") + x(O, 2, "0") + ":" + x(D, 2, "0");
      }, m: function C(I, N) {
        if (I.date() < N.date()) return -C(N, I);
        var O = 12 * (N.year() - I.year()) + (N.month() - I.month()), D = I.clone().add(O, f), $ = N - D < 0, z = I.clone().add(O + ($ ? -1 : 1), f);
        return +(-(O + (N - D) / ($ ? D - z : z - D)) || 0);
      }, a: function(C) {
        return C < 0 ? Math.ceil(C) || 0 : Math.floor(C);
      }, p: function(C) {
        return { M: f, y: p, w: h, d: u, D: g, h: l, m: o, s, ms: a, Q: d }[C] || String(C || "").toLowerCase().replace(/s$/, "");
      }, u: function(C) {
        return C === void 0;
      } }, E = "en", A = {};
      A[E] = b;
      var S = "$isDayjsObject", k = function(C) {
        return C instanceof M || !(!C || !C[S]);
      }, _ = function C(I, N, O) {
        var D;
        if (!I) return E;
        if (typeof I == "string") {
          var $ = I.toLowerCase();
          A[$] && (D = $), N && (A[$] = N, D = $);
          var z = I.split("-");
          if (!D && z.length > 1) return C(z[0]);
        } else {
          var B = I.name;
          A[B] = I, D = B;
        }
        return !O && D && (E = D), D || !O && E;
      }, R = function(C, I) {
        if (k(C)) return C.clone();
        var N = typeof I == "object" ? I : {};
        return N.date = C, N.args = arguments, new M(N);
      }, L = T;
      L.l = _, L.i = k, L.w = function(C, I) {
        return R(C, { locale: I.$L, utc: I.$u, x: I.$x, $offset: I.$offset });
      };
      var M = (function() {
        function C(N) {
          this.$L = _(N.locale, null, !0), this.parse(N), this.$x = this.$x || N.x || {}, this[S] = !0;
        }
        var I = C.prototype;
        return I.parse = function(N) {
          this.$d = (function(O) {
            var D = O.date, $ = O.utc;
            if (D === null) return /* @__PURE__ */ new Date(NaN);
            if (L.u(D)) return /* @__PURE__ */ new Date();
            if (D instanceof Date) return new Date(D);
            if (typeof D == "string" && !/Z$/i.test(D)) {
              var z = D.match(v);
              if (z) {
                var B = z[2] - 1 || 0, G = (z[7] || "0").substring(0, 3);
                return $ ? new Date(Date.UTC(z[1], B, z[3] || 1, z[4] || 0, z[5] || 0, z[6] || 0, G)) : new Date(z[1], B, z[3] || 1, z[4] || 0, z[5] || 0, z[6] || 0, G);
              }
            }
            return new Date(D);
          })(N), this.init();
        }, I.init = function() {
          var N = this.$d;
          this.$y = N.getFullYear(), this.$M = N.getMonth(), this.$D = N.getDate(), this.$W = N.getDay(), this.$H = N.getHours(), this.$m = N.getMinutes(), this.$s = N.getSeconds(), this.$ms = N.getMilliseconds();
        }, I.$utils = function() {
          return L;
        }, I.isValid = function() {
          return this.$d.toString() !== m;
        }, I.isSame = function(N, O) {
          var D = R(N);
          return this.startOf(O) <= D && D <= this.endOf(O);
        }, I.isAfter = function(N, O) {
          return R(N) < this.startOf(O);
        }, I.isBefore = function(N, O) {
          return this.endOf(O) < R(N);
        }, I.$g = function(N, O, D) {
          return L.u(N) ? this[O] : this.set(D, N);
        }, I.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, I.valueOf = function() {
          return this.$d.getTime();
        }, I.startOf = function(N, O) {
          var D = this, $ = !!L.u(O) || O, z = L.p(N), B = function(J, ee) {
            var j = L.w(D.$u ? Date.UTC(D.$y, ee, J) : new Date(D.$y, ee, J), D);
            return $ ? j : j.endOf(u);
          }, G = function(J, ee) {
            return L.w(D.toDate()[J].apply(D.toDate("s"), ($ ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ee)), D);
          }, W = this.$W, V = this.$M, U = this.$D, Z = "set" + (this.$u ? "UTC" : "");
          switch (z) {
            case p:
              return $ ? B(1, 0) : B(31, 11);
            case f:
              return $ ? B(1, V) : B(0, V + 1);
            case h:
              var K = this.$locale().weekStart || 0, ce = (W < K ? W + 7 : W) - K;
              return B($ ? U - ce : U + (6 - ce), V);
            case u:
            case g:
              return G(Z + "Hours", 0);
            case l:
              return G(Z + "Minutes", 1);
            case o:
              return G(Z + "Seconds", 2);
            case s:
              return G(Z + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, I.endOf = function(N) {
          return this.startOf(N, !1);
        }, I.$set = function(N, O) {
          var D, $ = L.p(N), z = "set" + (this.$u ? "UTC" : ""), B = (D = {}, D[u] = z + "Date", D[g] = z + "Date", D[f] = z + "Month", D[p] = z + "FullYear", D[l] = z + "Hours", D[o] = z + "Minutes", D[s] = z + "Seconds", D[a] = z + "Milliseconds", D)[$], G = $ === u ? this.$D + (O - this.$W) : O;
          if ($ === f || $ === p) {
            var W = this.clone().set(g, 1);
            W.$d[B](G), W.init(), this.$d = W.set(g, Math.min(this.$D, W.daysInMonth())).$d;
          } else B && this.$d[B](G);
          return this.init(), this;
        }, I.set = function(N, O) {
          return this.clone().$set(N, O);
        }, I.get = function(N) {
          return this[L.p(N)]();
        }, I.add = function(N, O) {
          var D, $ = this;
          N = Number(N);
          var z = L.p(O), B = function(V) {
            var U = R($);
            return L.w(U.date(U.date() + Math.round(V * N)), $);
          };
          if (z === f) return this.set(f, this.$M + N);
          if (z === p) return this.set(p, this.$y + N);
          if (z === u) return B(1);
          if (z === h) return B(7);
          var G = (D = {}, D[o] = n, D[l] = i, D[s] = r, D)[z] || 1, W = this.$d.getTime() + N * G;
          return L.w(W, this);
        }, I.subtract = function(N, O) {
          return this.add(-1 * N, O);
        }, I.format = function(N) {
          var O = this, D = this.$locale();
          if (!this.isValid()) return D.invalidDate || m;
          var $ = N || "YYYY-MM-DDTHH:mm:ssZ", z = L.z(this), B = this.$H, G = this.$m, W = this.$M, V = D.weekdays, U = D.months, Z = D.meridiem, K = function(ee, j, X, re) {
            return ee && (ee[j] || ee(O, $)) || X[j].slice(0, re);
          }, ce = function(ee) {
            return L.s(B % 12 || 12, ee, "0");
          }, J = Z || function(ee, j, X) {
            var re = ee < 12 ? "AM" : "PM";
            return X ? re.toLowerCase() : re;
          };
          return $.replace(y, (function(ee, j) {
            return j || (function(X) {
              switch (X) {
                case "YY":
                  return String(O.$y).slice(-2);
                case "YYYY":
                  return L.s(O.$y, 4, "0");
                case "M":
                  return W + 1;
                case "MM":
                  return L.s(W + 1, 2, "0");
                case "MMM":
                  return K(D.monthsShort, W, U, 3);
                case "MMMM":
                  return K(U, W);
                case "D":
                  return O.$D;
                case "DD":
                  return L.s(O.$D, 2, "0");
                case "d":
                  return String(O.$W);
                case "dd":
                  return K(D.weekdaysMin, O.$W, V, 2);
                case "ddd":
                  return K(D.weekdaysShort, O.$W, V, 3);
                case "dddd":
                  return V[O.$W];
                case "H":
                  return String(B);
                case "HH":
                  return L.s(B, 2, "0");
                case "h":
                  return ce(1);
                case "hh":
                  return ce(2);
                case "a":
                  return J(B, G, !0);
                case "A":
                  return J(B, G, !1);
                case "m":
                  return String(G);
                case "mm":
                  return L.s(G, 2, "0");
                case "s":
                  return String(O.$s);
                case "ss":
                  return L.s(O.$s, 2, "0");
                case "SSS":
                  return L.s(O.$ms, 3, "0");
                case "Z":
                  return z;
              }
              return null;
            })(ee) || z.replace(":", "");
          }));
        }, I.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, I.diff = function(N, O, D) {
          var $, z = this, B = L.p(O), G = R(N), W = (G.utcOffset() - this.utcOffset()) * n, V = this - G, U = function() {
            return L.m(z, G);
          };
          switch (B) {
            case p:
              $ = U() / 12;
              break;
            case f:
              $ = U();
              break;
            case d:
              $ = U() / 3;
              break;
            case h:
              $ = (V - W) / 6048e5;
              break;
            case u:
              $ = (V - W) / 864e5;
              break;
            case l:
              $ = V / i;
              break;
            case o:
              $ = V / n;
              break;
            case s:
              $ = V / r;
              break;
            default:
              $ = V;
          }
          return D ? $ : L.a($);
        }, I.daysInMonth = function() {
          return this.endOf(f).$D;
        }, I.$locale = function() {
          return A[this.$L];
        }, I.locale = function(N, O) {
          if (!N) return this.$L;
          var D = this.clone(), $ = _(N, O, !0);
          return $ && (D.$L = $), D;
        }, I.clone = function() {
          return L.w(this.$d, this);
        }, I.toDate = function() {
          return new Date(this.valueOf());
        }, I.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, I.toISOString = function() {
          return this.$d.toISOString();
        }, I.toString = function() {
          return this.$d.toUTCString();
        }, C;
      })(), P = M.prototype;
      return R.prototype = P, [["$ms", a], ["$s", s], ["$m", o], ["$H", l], ["$W", u], ["$M", f], ["$y", p], ["$D", g]].forEach((function(C) {
        P[C[1]] = function(I) {
          return this.$g(I, C[0], C[1]);
        };
      })), R.extend = function(C, I) {
        return C.$i || (C(I, M, R), C.$i = !0), R;
      }, R.locale = _, R.isDayjs = k, R.unix = function(C) {
        return R(1e3 * C);
      }, R.en = A[E], R.Ls = A, R.p = {}, R;
    }));
  })(my)), my.exports;
}
var yhe = vhe();
const Qn = /* @__PURE__ */ Oc(yhe);
var zY = Object.defineProperty, w = (t, e) => zY(t, "name", { value: e, configurable: !0 }), Mx = (t, e) => {
  for (var r in e)
    zY(t, r, { get: e[r], enumerable: !0 });
}, Po = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
}, ae = {
  trace: /* @__PURE__ */ w((...t) => {
  }, "trace"),
  debug: /* @__PURE__ */ w((...t) => {
  }, "debug"),
  info: /* @__PURE__ */ w((...t) => {
  }, "info"),
  warn: /* @__PURE__ */ w((...t) => {
  }, "warn"),
  error: /* @__PURE__ */ w((...t) => {
  }, "error"),
  fatal: /* @__PURE__ */ w((...t) => {
  }, "fatal")
}, o9 = /* @__PURE__ */ w(function(t = "fatal") {
  let e = Po.fatal;
  typeof t == "string" ? t.toLowerCase() in Po && (e = Po[t]) : typeof t == "number" && (e = t), ae.trace = () => {
  }, ae.debug = () => {
  }, ae.info = () => {
  }, ae.warn = () => {
  }, ae.error = () => {
  }, ae.fatal = () => {
  }, e <= Po.fatal && (ae.fatal = console.error ? console.error.bind(console, za("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", za("FATAL"))), e <= Po.error && (ae.error = console.error ? console.error.bind(console, za("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", za("ERROR"))), e <= Po.warn && (ae.warn = console.warn ? console.warn.bind(console, za("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", za("WARN"))), e <= Po.info && (ae.info = console.info ? console.info.bind(console, za("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", za("INFO"))), e <= Po.debug && (ae.debug = console.debug ? console.debug.bind(console, za("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", za("DEBUG"))), e <= Po.trace && (ae.trace = console.debug ? console.debug.bind(console, za("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", za("TRACE")));
}, "setLogLevel"), za = /* @__PURE__ */ w((t) => `%c${Qn().format("ss.SSS")} : ${t} : `, "format");
const vy = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    g: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    b: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    h: (t) => t % 360,
    s: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    l: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    a: (t) => t >= 1 ? 1 : t < 0 ? 0 : t
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (t) => {
    const e = t / 255;
    return t > 0.03928 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (t, e, r) => (r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t),
  hsl2rgb: ({ h: t, s: e, l: r }, n) => {
    if (!e)
      return r * 2.55;
    t /= 360, e /= 100, r /= 100;
    const i = r < 0.5 ? r * (1 + e) : r + e - r * e, a = 2 * r - i;
    switch (n) {
      case "r":
        return vy.hue2rgb(a, i, t + 1 / 3) * 255;
      case "g":
        return vy.hue2rgb(a, i, t) * 255;
      case "b":
        return vy.hue2rgb(a, i, t - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: t, g: e, b: r }, n) => {
    t /= 255, e /= 255, r /= 255;
    const i = Math.max(t, e, r), a = Math.min(t, e, r), s = (i + a) / 2;
    if (n === "l")
      return s * 100;
    if (i === a)
      return 0;
    const o = i - a, l = s > 0.5 ? o / (2 - i - a) : o / (i + a);
    if (n === "s")
      return l * 100;
    switch (i) {
      case t:
        return ((e - r) / o + (e < r ? 6 : 0)) * 60;
      case e:
        return ((r - t) / o + 2) * 60;
      case r:
        return ((t - e) / o + 4) * 60;
      default:
        return -1;
    }
  }
}, bhe = {
  /* API */
  clamp: (t, e, r) => e > r ? Math.min(e, Math.max(r, t)) : Math.min(r, Math.max(e, t)),
  round: (t) => Math.round(t * 1e10) / 1e10
}, xhe = {
  /* API */
  dec2hex: (t) => {
    const e = Math.round(t).toString(16);
    return e.length > 1 ? e : `0${e}`;
  }
}, Kt = {
  channel: vy,
  lang: bhe,
  unit: xhe
}, Vl = {};
for (let t = 0; t <= 255; t++)
  Vl[t] = Kt.unit.dec2hex(t);
const wi = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
let whe = class {
  constructor() {
    this.type = wi.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(e) {
    if (this.type && this.type !== e)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = e;
  }
  reset() {
    this.type = wi.ALL;
  }
  is(e) {
    return this.type === e;
  }
};
class The {
  /* CONSTRUCTOR */
  constructor(e, r) {
    this.color = r, this.changed = !1, this.data = e, this.type = new whe();
  }
  /* API */
  set(e, r) {
    return this.color = r, this.changed = !1, this.data = e, this.type.type = wi.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const e = this.data, { h: r, s: n, l: i } = e;
    r === void 0 && (e.h = Kt.channel.rgb2hsl(e, "h")), n === void 0 && (e.s = Kt.channel.rgb2hsl(e, "s")), i === void 0 && (e.l = Kt.channel.rgb2hsl(e, "l"));
  }
  _ensureRGB() {
    const e = this.data, { r, g: n, b: i } = e;
    r === void 0 && (e.r = Kt.channel.hsl2rgb(e, "r")), n === void 0 && (e.g = Kt.channel.hsl2rgb(e, "g")), i === void 0 && (e.b = Kt.channel.hsl2rgb(e, "b"));
  }
  /* GETTERS */
  get r() {
    const e = this.data, r = e.r;
    return !this.type.is(wi.HSL) && r !== void 0 ? r : (this._ensureHSL(), Kt.channel.hsl2rgb(e, "r"));
  }
  get g() {
    const e = this.data, r = e.g;
    return !this.type.is(wi.HSL) && r !== void 0 ? r : (this._ensureHSL(), Kt.channel.hsl2rgb(e, "g"));
  }
  get b() {
    const e = this.data, r = e.b;
    return !this.type.is(wi.HSL) && r !== void 0 ? r : (this._ensureHSL(), Kt.channel.hsl2rgb(e, "b"));
  }
  get h() {
    const e = this.data, r = e.h;
    return !this.type.is(wi.RGB) && r !== void 0 ? r : (this._ensureRGB(), Kt.channel.rgb2hsl(e, "h"));
  }
  get s() {
    const e = this.data, r = e.s;
    return !this.type.is(wi.RGB) && r !== void 0 ? r : (this._ensureRGB(), Kt.channel.rgb2hsl(e, "s"));
  }
  get l() {
    const e = this.data, r = e.l;
    return !this.type.is(wi.RGB) && r !== void 0 ? r : (this._ensureRGB(), Kt.channel.rgb2hsl(e, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(e) {
    this.type.set(wi.RGB), this.changed = !0, this.data.r = e;
  }
  set g(e) {
    this.type.set(wi.RGB), this.changed = !0, this.data.g = e;
  }
  set b(e) {
    this.type.set(wi.RGB), this.changed = !0, this.data.b = e;
  }
  set h(e) {
    this.type.set(wi.HSL), this.changed = !0, this.data.h = e;
  }
  set s(e) {
    this.type.set(wi.HSL), this.changed = !0, this.data.s = e;
  }
  set l(e) {
    this.type.set(wi.HSL), this.changed = !0, this.data.l = e;
  }
  set a(e) {
    this.changed = !0, this.data.a = e;
  }
}
const Nx = new The({ r: 0, g: 0, b: 0, a: 0 }, "transparent"), Lf = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (t) => {
    if (t.charCodeAt(0) !== 35)
      return;
    const e = t.match(Lf.re);
    if (!e)
      return;
    const r = e[1], n = parseInt(r, 16), i = r.length, a = i % 4 === 0, s = i > 4, o = s ? 1 : 17, l = s ? 8 : 4, u = a ? 0 : -1, h = s ? 255 : 15;
    return Nx.set({
      r: (n >> l * (u + 3) & h) * o,
      g: (n >> l * (u + 2) & h) * o,
      b: (n >> l * (u + 1) & h) * o,
      a: a ? (n & h) * o / 255 : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a: i } = t;
    return i < 1 ? `#${Vl[Math.round(e)]}${Vl[Math.round(r)]}${Vl[Math.round(n)]}${Vl[Math.round(i * 255)]}` : `#${Vl[Math.round(e)]}${Vl[Math.round(r)]}${Vl[Math.round(n)]}`;
  }
}, Au = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (t) => {
    const e = t.match(Au.hueRe);
    if (e) {
      const [, r, n] = e;
      switch (n) {
        case "grad":
          return Kt.channel.clamp.h(parseFloat(r) * 0.9);
        case "rad":
          return Kt.channel.clamp.h(parseFloat(r) * 180 / Math.PI);
        case "turn":
          return Kt.channel.clamp.h(parseFloat(r) * 360);
      }
    }
    return Kt.channel.clamp.h(parseFloat(t));
  },
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 104 && e !== 72)
      return;
    const r = t.match(Au.re);
    if (!r)
      return;
    const [, n, i, a, s, o] = r;
    return Nx.set({
      h: Au._hue2deg(n),
      s: Kt.channel.clamp.s(parseFloat(i)),
      l: Kt.channel.clamp.l(parseFloat(a)),
      a: s ? Kt.channel.clamp.a(o ? parseFloat(s) / 100 : parseFloat(s)) : 1
    }, t);
  },
  stringify: (t) => {
    const { h: e, s: r, l: n, a: i } = t;
    return i < 1 ? `hsla(${Kt.lang.round(e)}, ${Kt.lang.round(r)}%, ${Kt.lang.round(n)}%, ${i})` : `hsl(${Kt.lang.round(e)}, ${Kt.lang.round(r)}%, ${Kt.lang.round(n)}%)`;
  }
}, Ng = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (t) => {
    t = t.toLowerCase();
    const e = Ng.colors[t];
    if (e)
      return Lf.parse(e);
  },
  stringify: (t) => {
    const e = Lf.stringify(t);
    for (const r in Ng.colors)
      if (Ng.colors[r] === e)
        return r;
  }
}, Ap = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 114 && e !== 82)
      return;
    const r = t.match(Ap.re);
    if (!r)
      return;
    const [, n, i, a, s, o, l, u, h] = r;
    return Nx.set({
      r: Kt.channel.clamp.r(i ? parseFloat(n) * 2.55 : parseFloat(n)),
      g: Kt.channel.clamp.g(s ? parseFloat(a) * 2.55 : parseFloat(a)),
      b: Kt.channel.clamp.b(l ? parseFloat(o) * 2.55 : parseFloat(o)),
      a: u ? Kt.channel.clamp.a(h ? parseFloat(u) / 100 : parseFloat(u)) : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a: i } = t;
    return i < 1 ? `rgba(${Kt.lang.round(e)}, ${Kt.lang.round(r)}, ${Kt.lang.round(n)}, ${Kt.lang.round(i)})` : `rgb(${Kt.lang.round(e)}, ${Kt.lang.round(r)}, ${Kt.lang.round(n)})`;
  }
}, Is = {
  /* VARIABLES */
  format: {
    keyword: Ng,
    hex: Lf,
    rgb: Ap,
    rgba: Ap,
    hsl: Au,
    hsla: Au
  },
  /* API */
  parse: (t) => {
    if (typeof t != "string")
      return t;
    const e = Lf.parse(t) || Ap.parse(t) || Au.parse(t) || Ng.parse(t);
    if (e)
      return e;
    throw new Error(`Unsupported color format: "${t}"`);
  },
  stringify: (t) => !t.changed && t.color ? t.color : t.type.is(wi.HSL) || t.data.r === void 0 ? Au.stringify(t) : t.a < 1 || !Number.isInteger(t.r) || !Number.isInteger(t.g) || !Number.isInteger(t.b) ? Ap.stringify(t) : Lf.stringify(t)
}, qY = (t, e) => {
  const r = Is.parse(t);
  for (const n in e)
    r[n] = Kt.channel.clamp[n](e[n]);
  return Is.stringify(r);
}, ac = (t, e, r = 0, n = 1) => {
  if (typeof t != "number")
    return qY(t, { a: e });
  const i = Nx.set({
    r: Kt.channel.clamp.r(t),
    g: Kt.channel.clamp.g(e),
    b: Kt.channel.clamp.b(r),
    a: Kt.channel.clamp.a(n)
  });
  return Is.stringify(i);
}, l9 = (t, e) => Kt.lang.round(Is.parse(t)[e]), Ehe = (t) => {
  const { r: e, g: r, b: n } = Is.parse(t), i = 0.2126 * Kt.channel.toLinear(e) + 0.7152 * Kt.channel.toLinear(r) + 0.0722 * Kt.channel.toLinear(n);
  return Kt.lang.round(i);
}, She = (t) => Ehe(t) >= 0.5, Pc = (t) => !She(t), GY = (t, e, r) => {
  const n = Is.parse(t), i = n[e], a = Kt.channel.clamp[e](i + r);
  return i !== a && (n[e] = a), Is.stringify(n);
}, _t = (t, e) => GY(t, "l", e), Nt = (t, e) => GY(t, "l", -e), De = (t, e) => {
  const r = Is.parse(t), n = {};
  for (const i in e)
    e[i] && (n[i] = r[i] + e[i]);
  return qY(t, n);
}, khe = (t, e, r = 50) => {
  const { r: n, g: i, b: a, a: s } = Is.parse(t), { r: o, g: l, b: u, a: h } = Is.parse(e), f = r / 100, d = f * 2 - 1, p = s - h, m = ((d * p === -1 ? d : (d + p) / (1 + d * p)) + 1) / 2, v = 1 - m, y = n * m + o * v, b = i * m + l * v, x = a * m + u * v, T = s * f + h * (1 - f);
  return ac(y, b, x, T);
}, yt = (t, e = 100) => {
  const r = Is.parse(t);
  return r.r = 255 - r.r, r.g = 255 - r.g, r.b = 255 - r.b, khe(r, t, e);
};
/*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE */
const {
  entries: UY,
  setPrototypeOf: kM,
  isFrozen: Che,
  getPrototypeOf: _he,
  getOwnPropertyDescriptor: Ahe
} = Object;
let {
  freeze: Wi,
  seal: rs,
  create: X7
} = Object, {
  apply: j7,
  construct: K7
} = typeof Reflect < "u" && Reflect;
Wi || (Wi = function(e) {
  return e;
});
rs || (rs = function(e) {
  return e;
});
j7 || (j7 = function(e, r) {
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    i[a - 2] = arguments[a];
  return e.apply(r, i);
});
K7 || (K7 = function(e) {
  for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
    n[i - 1] = arguments[i];
  return new e(...n);
});
const ev = Yi(Array.prototype.forEach), Lhe = Yi(Array.prototype.lastIndexOf), CM = Yi(Array.prototype.pop), Q0 = Yi(Array.prototype.push), Rhe = Yi(Array.prototype.splice), yy = Yi(String.prototype.toLowerCase), h5 = Yi(String.prototype.toString), f5 = Yi(String.prototype.match), J0 = Yi(String.prototype.replace), Ihe = Yi(String.prototype.indexOf), Mhe = Yi(String.prototype.trim), gs = Yi(Object.prototype.hasOwnProperty), Di = Yi(RegExp.prototype.test), ep = Nhe(TypeError);
function Yi(t) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return j7(t, e, n);
  };
}
function Nhe(t) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return K7(t, r);
  };
}
function sr(t, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : yy;
  kM && kM(t, null);
  let n = e.length;
  for (; n--; ) {
    let i = e[n];
    if (typeof i == "string") {
      const a = r(i);
      a !== i && (Che(e) || (e[n] = a), i = a);
    }
    t[i] = !0;
  }
  return t;
}
function Dhe(t) {
  for (let e = 0; e < t.length; e++)
    gs(t, e) || (t[e] = null);
  return t;
}
function Ws(t) {
  const e = X7(null);
  for (const [r, n] of UY(t))
    gs(t, r) && (Array.isArray(n) ? e[r] = Dhe(n) : n && typeof n == "object" && n.constructor === Object ? e[r] = Ws(n) : e[r] = n);
  return e;
}
function tp(t, e) {
  for (; t !== null; ) {
    const n = Ahe(t, e);
    if (n) {
      if (n.get)
        return Yi(n.get);
      if (typeof n.value == "function")
        return Yi(n.value);
    }
    t = _he(t);
  }
  function r() {
    return null;
  }
  return r;
}
const _M = Wi(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), d5 = Wi(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), p5 = Wi(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Ohe = Wi(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), g5 = Wi(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Phe = Wi(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), AM = Wi(["#text"]), LM = Wi(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), m5 = Wi(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), RM = Wi(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), tv = Wi(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), $he = rs(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Bhe = rs(/<%[\w\W]*|[\w\W]*%>/gm), Fhe = rs(/\$\{[\w\W]*/gm), zhe = rs(/^data-[\-\w.\u00B7-\uFFFF]+$/), qhe = rs(/^aria-[\-\w]+$/), VY = rs(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), Ghe = rs(/^(?:\w+script|data):/i), Uhe = rs(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), HY = rs(/^html$/i), Vhe = rs(/^[a-z][.\w]*(-[.\w]+)+$/i);
var IM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: qhe,
  ATTR_WHITESPACE: Uhe,
  CUSTOM_ELEMENT: Vhe,
  DATA_ATTR: zhe,
  DOCTYPE_NAME: HY,
  ERB_EXPR: Bhe,
  IS_ALLOWED_URI: VY,
  IS_SCRIPT_OR_DATA: Ghe,
  MUSTACHE_EXPR: $he,
  TMPLIT_EXPR: Fhe
});
const rp = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, Hhe = function() {
  return typeof window > "u" ? null : window;
}, Whe = function(e, r) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const i = "data-tt-policy-suffix";
  r && r.hasAttribute(i) && (n = r.getAttribute(i));
  const a = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(a, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + a + " could not be created."), null;
  }
}, MM = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function WY() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Hhe();
  const e = (ft) => WY(ft);
  if (e.version = "3.3.1", e.removed = [], !t || !t.document || t.document.nodeType !== rp.document || !t.Element)
    return e.isSupported = !1, e;
  let {
    document: r
  } = t;
  const n = r, i = n.currentScript, {
    DocumentFragment: a,
    HTMLTemplateElement: s,
    Node: o,
    Element: l,
    NodeFilter: u,
    NamedNodeMap: h = t.NamedNodeMap || t.MozNamedAttrMap,
    HTMLFormElement: f,
    DOMParser: d,
    trustedTypes: p
  } = t, g = l.prototype, m = tp(g, "cloneNode"), v = tp(g, "remove"), y = tp(g, "nextSibling"), b = tp(g, "childNodes"), x = tp(g, "parentNode");
  if (typeof s == "function") {
    const ft = r.createElement("template");
    ft.content && ft.content.ownerDocument && (r = ft.content.ownerDocument);
  }
  let T, E = "";
  const {
    implementation: A,
    createNodeIterator: S,
    createDocumentFragment: k,
    getElementsByTagName: _
  } = r, {
    importNode: R
  } = n;
  let L = MM();
  e.isSupported = typeof UY == "function" && typeof x == "function" && A && A.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: M,
    ERB_EXPR: P,
    TMPLIT_EXPR: C,
    DATA_ATTR: I,
    ARIA_ATTR: N,
    IS_SCRIPT_OR_DATA: O,
    ATTR_WHITESPACE: D,
    CUSTOM_ELEMENT: $
  } = IM;
  let {
    IS_ALLOWED_URI: z
  } = IM, B = null;
  const G = sr({}, [..._M, ...d5, ...p5, ...g5, ...AM]);
  let W = null;
  const V = sr({}, [...LM, ...m5, ...RM, ...tv]);
  let U = Object.seal(X7(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Z = null, K = null;
  const ce = Object.seal(X7(null, {
    tagCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    }
  }));
  let J = !0, ee = !0, j = !1, X = !0, re = !1, Q = !0, ue = !1, ne = !1, xe = !1, Y = !1, Ne = !1, fe = !1, qe = !0, ze = !1;
  const Ge = "user-content-";
  let Ee = !0, Oe = !1, Ce = {}, Ae = null;
  const $e = sr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let me = null;
  const Ie = sr({}, ["audio", "video", "img", "source", "image", "track"]);
  let te = null;
  const he = sr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), F = "http://www.w3.org/1998/Math/MathML", oe = "http://www.w3.org/2000/svg", se = "http://www.w3.org/1999/xhtml";
  let ge = se, de = !1, we = null;
  const _e = sr({}, [F, oe, se], h5);
  let Se = sr({}, ["mi", "mo", "mn", "ms", "mtext"]), Me = sr({}, ["annotation-xml"]);
  const Xe = sr({}, ["title", "style", "font", "a", "script"]);
  let We = null;
  const Ke = ["application/xhtml+xml", "text/html"], Ze = "text/html";
  let Pe = null, Ve = null;
  const ht = r.createElement("form"), st = function(ke) {
    return ke instanceof RegExp || ke instanceof Function;
  }, Ue = function() {
    let ke = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(Ve && Ve === ke)) {
      if ((!ke || typeof ke != "object") && (ke = {}), ke = Ws(ke), We = // eslint-disable-next-line unicorn/prefer-includes
      Ke.indexOf(ke.PARSER_MEDIA_TYPE) === -1 ? Ze : ke.PARSER_MEDIA_TYPE, Pe = We === "application/xhtml+xml" ? h5 : yy, B = gs(ke, "ALLOWED_TAGS") ? sr({}, ke.ALLOWED_TAGS, Pe) : G, W = gs(ke, "ALLOWED_ATTR") ? sr({}, ke.ALLOWED_ATTR, Pe) : V, we = gs(ke, "ALLOWED_NAMESPACES") ? sr({}, ke.ALLOWED_NAMESPACES, h5) : _e, te = gs(ke, "ADD_URI_SAFE_ATTR") ? sr(Ws(he), ke.ADD_URI_SAFE_ATTR, Pe) : he, me = gs(ke, "ADD_DATA_URI_TAGS") ? sr(Ws(Ie), ke.ADD_DATA_URI_TAGS, Pe) : Ie, Ae = gs(ke, "FORBID_CONTENTS") ? sr({}, ke.FORBID_CONTENTS, Pe) : $e, Z = gs(ke, "FORBID_TAGS") ? sr({}, ke.FORBID_TAGS, Pe) : Ws({}), K = gs(ke, "FORBID_ATTR") ? sr({}, ke.FORBID_ATTR, Pe) : Ws({}), Ce = gs(ke, "USE_PROFILES") ? ke.USE_PROFILES : !1, J = ke.ALLOW_ARIA_ATTR !== !1, ee = ke.ALLOW_DATA_ATTR !== !1, j = ke.ALLOW_UNKNOWN_PROTOCOLS || !1, X = ke.ALLOW_SELF_CLOSE_IN_ATTR !== !1, re = ke.SAFE_FOR_TEMPLATES || !1, Q = ke.SAFE_FOR_XML !== !1, ue = ke.WHOLE_DOCUMENT || !1, Y = ke.RETURN_DOM || !1, Ne = ke.RETURN_DOM_FRAGMENT || !1, fe = ke.RETURN_TRUSTED_TYPE || !1, xe = ke.FORCE_BODY || !1, qe = ke.SANITIZE_DOM !== !1, ze = ke.SANITIZE_NAMED_PROPS || !1, Ee = ke.KEEP_CONTENT !== !1, Oe = ke.IN_PLACE || !1, z = ke.ALLOWED_URI_REGEXP || VY, ge = ke.NAMESPACE || se, Se = ke.MATHML_TEXT_INTEGRATION_POINTS || Se, Me = ke.HTML_INTEGRATION_POINTS || Me, U = ke.CUSTOM_ELEMENT_HANDLING || {}, ke.CUSTOM_ELEMENT_HANDLING && st(ke.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (U.tagNameCheck = ke.CUSTOM_ELEMENT_HANDLING.tagNameCheck), ke.CUSTOM_ELEMENT_HANDLING && st(ke.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (U.attributeNameCheck = ke.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), ke.CUSTOM_ELEMENT_HANDLING && typeof ke.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (U.allowCustomizedBuiltInElements = ke.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), re && (ee = !1), Ne && (Y = !0), Ce && (B = sr({}, AM), W = [], Ce.html === !0 && (sr(B, _M), sr(W, LM)), Ce.svg === !0 && (sr(B, d5), sr(W, m5), sr(W, tv)), Ce.svgFilters === !0 && (sr(B, p5), sr(W, m5), sr(W, tv)), Ce.mathMl === !0 && (sr(B, g5), sr(W, RM), sr(W, tv))), ke.ADD_TAGS && (typeof ke.ADD_TAGS == "function" ? ce.tagCheck = ke.ADD_TAGS : (B === G && (B = Ws(B)), sr(B, ke.ADD_TAGS, Pe))), ke.ADD_ATTR && (typeof ke.ADD_ATTR == "function" ? ce.attributeCheck = ke.ADD_ATTR : (W === V && (W = Ws(W)), sr(W, ke.ADD_ATTR, Pe))), ke.ADD_URI_SAFE_ATTR && sr(te, ke.ADD_URI_SAFE_ATTR, Pe), ke.FORBID_CONTENTS && (Ae === $e && (Ae = Ws(Ae)), sr(Ae, ke.FORBID_CONTENTS, Pe)), ke.ADD_FORBID_CONTENTS && (Ae === $e && (Ae = Ws(Ae)), sr(Ae, ke.ADD_FORBID_CONTENTS, Pe)), Ee && (B["#text"] = !0), ue && sr(B, ["html", "head", "body"]), B.table && (sr(B, ["tbody"]), delete Z.tbody), ke.TRUSTED_TYPES_POLICY) {
        if (typeof ke.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw ep('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof ke.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw ep('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        T = ke.TRUSTED_TYPES_POLICY, E = T.createHTML("");
      } else
        T === void 0 && (T = Whe(p, i)), T !== null && typeof E == "string" && (E = T.createHTML(""));
      Wi && Wi(ke), Ve = ke;
    }
  }, Et = sr({}, [...d5, ...p5, ...Ohe]), He = sr({}, [...g5, ...Phe]), rt = function(ke) {
    let Je = x(ke);
    (!Je || !Je.tagName) && (Je = {
      namespaceURI: ge,
      tagName: "template"
    });
    const xt = yy(ke.tagName), lr = yy(Je.tagName);
    return we[ke.namespaceURI] ? ke.namespaceURI === oe ? Je.namespaceURI === se ? xt === "svg" : Je.namespaceURI === F ? xt === "svg" && (lr === "annotation-xml" || Se[lr]) : !!Et[xt] : ke.namespaceURI === F ? Je.namespaceURI === se ? xt === "math" : Je.namespaceURI === oe ? xt === "math" && Me[lr] : !!He[xt] : ke.namespaceURI === se ? Je.namespaceURI === oe && !Me[lr] || Je.namespaceURI === F && !Se[lr] ? !1 : !He[xt] && (Xe[xt] || !Et[xt]) : !!(We === "application/xhtml+xml" && we[ke.namespaceURI]) : !1;
  }, ct = function(ke) {
    Q0(e.removed, {
      element: ke
    });
    try {
      x(ke).removeChild(ke);
    } catch {
      v(ke);
    }
  }, ut = function(ke, Je) {
    try {
      Q0(e.removed, {
        attribute: Je.getAttributeNode(ke),
        from: Je
      });
    } catch {
      Q0(e.removed, {
        attribute: null,
        from: Je
      });
    }
    if (Je.removeAttribute(ke), ke === "is")
      if (Y || Ne)
        try {
          ct(Je);
        } catch {
        }
      else
        try {
          Je.setAttribute(ke, "");
        } catch {
        }
  }, nt = function(ke) {
    let Je = null, xt = null;
    if (xe)
      ke = "<remove></remove>" + ke;
    else {
      const hr = f5(ke, /^[\r\n\t ]+/);
      xt = hr && hr[0];
    }
    We === "application/xhtml+xml" && ge === se && (ke = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ke + "</body></html>");
    const lr = T ? T.createHTML(ke) : ke;
    if (ge === se)
      try {
        Je = new d().parseFromString(lr, We);
      } catch {
      }
    if (!Je || !Je.documentElement) {
      Je = A.createDocument(ge, "template", null);
      try {
        Je.documentElement.innerHTML = de ? E : lr;
      } catch {
      }
    }
    const Vr = Je.body || Je.documentElement;
    return ke && xt && Vr.insertBefore(r.createTextNode(xt), Vr.childNodes[0] || null), ge === se ? _.call(Je, ue ? "html" : "body")[0] : ue ? Je.documentElement : Vr;
  }, bt = function(ke) {
    return S.call(
      ke.ownerDocument || ke,
      ke,
      // eslint-disable-next-line no-bitwise
      u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION,
      null
    );
  }, er = function(ke) {
    return ke instanceof f && (typeof ke.nodeName != "string" || typeof ke.textContent != "string" || typeof ke.removeChild != "function" || !(ke.attributes instanceof h) || typeof ke.removeAttribute != "function" || typeof ke.setAttribute != "function" || typeof ke.namespaceURI != "string" || typeof ke.insertBefore != "function" || typeof ke.hasChildNodes != "function");
  }, Dt = function(ke) {
    return typeof o == "function" && ke instanceof o;
  };
  function ir(ft, ke, Je) {
    ev(ft, (xt) => {
      xt.call(e, ke, Je, Ve);
    });
  }
  const wr = function(ke) {
    let Je = null;
    if (ir(L.beforeSanitizeElements, ke, null), er(ke))
      return ct(ke), !0;
    const xt = Pe(ke.nodeName);
    if (ir(L.uponSanitizeElement, ke, {
      tagName: xt,
      allowedTags: B
    }), Q && ke.hasChildNodes() && !Dt(ke.firstElementChild) && Di(/<[/\w!]/g, ke.innerHTML) && Di(/<[/\w!]/g, ke.textContent) || ke.nodeType === rp.progressingInstruction || Q && ke.nodeType === rp.comment && Di(/<[/\w]/g, ke.data))
      return ct(ke), !0;
    if (!(ce.tagCheck instanceof Function && ce.tagCheck(xt)) && (!B[xt] || Z[xt])) {
      if (!Z[xt] && Wt(xt) && (U.tagNameCheck instanceof RegExp && Di(U.tagNameCheck, xt) || U.tagNameCheck instanceof Function && U.tagNameCheck(xt)))
        return !1;
      if (Ee && !Ae[xt]) {
        const lr = x(ke) || ke.parentNode, Vr = b(ke) || ke.childNodes;
        if (Vr && lr) {
          const hr = Vr.length;
          for (let Kr = hr - 1; Kr >= 0; --Kr) {
            const bi = m(Vr[Kr], !0);
            bi.__removalCount = (ke.__removalCount || 0) + 1, lr.insertBefore(bi, y(ke));
          }
        }
      }
      return ct(ke), !0;
    }
    return ke instanceof l && !rt(ke) || (xt === "noscript" || xt === "noembed" || xt === "noframes") && Di(/<\/no(script|embed|frames)/i, ke.innerHTML) ? (ct(ke), !0) : (re && ke.nodeType === rp.text && (Je = ke.textContent, ev([M, P, C], (lr) => {
      Je = J0(Je, lr, " ");
    }), ke.textContent !== Je && (Q0(e.removed, {
      element: ke.cloneNode()
    }), ke.textContent = Je)), ir(L.afterSanitizeElements, ke, null), !1);
  }, ar = function(ke, Je, xt) {
    if (qe && (Je === "id" || Je === "name") && (xt in r || xt in ht))
      return !1;
    if (!(ee && !K[Je] && Di(I, Je))) {
      if (!(J && Di(N, Je))) {
        if (!(ce.attributeCheck instanceof Function && ce.attributeCheck(Je, ke))) {
          if (!W[Je] || K[Je]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(Wt(ke) && (U.tagNameCheck instanceof RegExp && Di(U.tagNameCheck, ke) || U.tagNameCheck instanceof Function && U.tagNameCheck(ke)) && (U.attributeNameCheck instanceof RegExp && Di(U.attributeNameCheck, Je) || U.attributeNameCheck instanceof Function && U.attributeNameCheck(Je, ke)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              Je === "is" && U.allowCustomizedBuiltInElements && (U.tagNameCheck instanceof RegExp && Di(U.tagNameCheck, xt) || U.tagNameCheck instanceof Function && U.tagNameCheck(xt)))
            ) return !1;
          } else if (!te[Je]) {
            if (!Di(z, J0(xt, D, ""))) {
              if (!((Je === "src" || Je === "xlink:href" || Je === "href") && ke !== "script" && Ihe(xt, "data:") === 0 && me[ke])) {
                if (!(j && !Di(O, J0(xt, D, "")))) {
                  if (xt)
                    return !1;
                }
              }
            }
          }
        }
      }
    }
    return !0;
  }, Wt = function(ke) {
    return ke !== "annotation-xml" && f5(ke, $);
  }, ur = function(ke) {
    ir(L.beforeSanitizeAttributes, ke, null);
    const {
      attributes: Je
    } = ke;
    if (!Je || er(ke))
      return;
    const xt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: W,
      forceKeepAttr: void 0
    };
    let lr = Je.length;
    for (; lr--; ) {
      const Vr = Je[lr], {
        name: hr,
        namespaceURI: Kr,
        value: bi
      } = Vr, En = Pe(hr), Sn = bi;
      let dt = hr === "value" ? Sn : Mhe(Sn);
      if (xt.attrName = En, xt.attrValue = dt, xt.keepAttr = !0, xt.forceKeepAttr = void 0, ir(L.uponSanitizeAttribute, ke, xt), dt = xt.attrValue, ze && (En === "id" || En === "name") && (ut(hr, ke), dt = Ge + dt), Q && Di(/((--!?|])>)|<\/(style|title|textarea)/i, dt)) {
        ut(hr, ke);
        continue;
      }
      if (En === "attributename" && f5(dt, "href")) {
        ut(hr, ke);
        continue;
      }
      if (xt.forceKeepAttr)
        continue;
      if (!xt.keepAttr) {
        ut(hr, ke);
        continue;
      }
      if (!X && Di(/\/>/i, dt)) {
        ut(hr, ke);
        continue;
      }
      re && ev([M, P, C], (lt) => {
        dt = J0(dt, lt, " ");
      });
      const wt = Pe(ke.nodeName);
      if (!ar(wt, En, dt)) {
        ut(hr, ke);
        continue;
      }
      if (T && typeof p == "object" && typeof p.getAttributeType == "function" && !Kr)
        switch (p.getAttributeType(wt, En)) {
          case "TrustedHTML": {
            dt = T.createHTML(dt);
            break;
          }
          case "TrustedScriptURL": {
            dt = T.createScriptURL(dt);
            break;
          }
        }
      if (dt !== Sn)
        try {
          Kr ? ke.setAttributeNS(Kr, hr, dt) : ke.setAttribute(hr, dt), er(ke) ? ct(ke) : CM(e.removed);
        } catch {
          ut(hr, ke);
        }
    }
    ir(L.afterSanitizeAttributes, ke, null);
  }, cn = function ft(ke) {
    let Je = null;
    const xt = bt(ke);
    for (ir(L.beforeSanitizeShadowDOM, ke, null); Je = xt.nextNode(); )
      ir(L.uponSanitizeShadowNode, Je, null), wr(Je), ur(Je), Je.content instanceof a && ft(Je.content);
    ir(L.afterSanitizeShadowDOM, ke, null);
  };
  return e.sanitize = function(ft) {
    let ke = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Je = null, xt = null, lr = null, Vr = null;
    if (de = !ft, de && (ft = "<!-->"), typeof ft != "string" && !Dt(ft))
      if (typeof ft.toString == "function") {
        if (ft = ft.toString(), typeof ft != "string")
          throw ep("dirty is not a string, aborting");
      } else
        throw ep("toString is not a function");
    if (!e.isSupported)
      return ft;
    if (ne || Ue(ke), e.removed = [], typeof ft == "string" && (Oe = !1), Oe) {
      if (ft.nodeName) {
        const bi = Pe(ft.nodeName);
        if (!B[bi] || Z[bi])
          throw ep("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (ft instanceof o)
      Je = nt("<!---->"), xt = Je.ownerDocument.importNode(ft, !0), xt.nodeType === rp.element && xt.nodeName === "BODY" || xt.nodeName === "HTML" ? Je = xt : Je.appendChild(xt);
    else {
      if (!Y && !re && !ue && // eslint-disable-next-line unicorn/prefer-includes
      ft.indexOf("<") === -1)
        return T && fe ? T.createHTML(ft) : ft;
      if (Je = nt(ft), !Je)
        return Y ? null : fe ? E : "";
    }
    Je && xe && ct(Je.firstChild);
    const hr = bt(Oe ? ft : Je);
    for (; lr = hr.nextNode(); )
      wr(lr), ur(lr), lr.content instanceof a && cn(lr.content);
    if (Oe)
      return ft;
    if (Y) {
      if (Ne)
        for (Vr = k.call(Je.ownerDocument); Je.firstChild; )
          Vr.appendChild(Je.firstChild);
      else
        Vr = Je;
      return (W.shadowroot || W.shadowrootmode) && (Vr = R.call(n, Vr, !0)), Vr;
    }
    let Kr = ue ? Je.outerHTML : Je.innerHTML;
    return ue && B["!doctype"] && Je.ownerDocument && Je.ownerDocument.doctype && Je.ownerDocument.doctype.name && Di(HY, Je.ownerDocument.doctype.name) && (Kr = "<!DOCTYPE " + Je.ownerDocument.doctype.name + `>
` + Kr), re && ev([M, P, C], (bi) => {
      Kr = J0(Kr, bi, " ");
    }), T && fe ? T.createHTML(Kr) : Kr;
  }, e.setConfig = function() {
    let ft = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ue(ft), ne = !0;
  }, e.clearConfig = function() {
    Ve = null, ne = !1;
  }, e.isValidAttribute = function(ft, ke, Je) {
    Ve || Ue({});
    const xt = Pe(ft), lr = Pe(ke);
    return ar(xt, lr, Je);
  }, e.addHook = function(ft, ke) {
    typeof ke == "function" && Q0(L[ft], ke);
  }, e.removeHook = function(ft, ke) {
    if (ke !== void 0) {
      const Je = Lhe(L[ft], ke);
      return Je === -1 ? void 0 : Rhe(L[ft], Je, 1)[0];
    }
    return CM(L[ft]);
  }, e.removeHooks = function(ft) {
    L[ft] = [];
  }, e.removeAllHooks = function() {
    L = MM();
  }, e;
}
var Hd = WY(), YY = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s, Dg = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, Yhe = /\s*%%.*\n/gm, Yf, XY = (Yf = class extends Error {
  constructor(e) {
    super(e), this.name = "UnknownDiagramError";
  }
}, w(Yf, "UnknownDiagramError"), Yf), qu = {}, c9 = /* @__PURE__ */ w(function(t, e) {
  t = t.replace(YY, "").replace(Dg, "").replace(Yhe, `
`);
  for (const [r, { detector: n }] of Object.entries(qu))
    if (n(t, e))
      return r;
  throw new XY(
    `No diagram type detected matching given configuration for text: ${t}`
  );
}, "detectType"), Z7 = /* @__PURE__ */ w((...t) => {
  for (const { id: e, detector: r, loader: n } of t)
    jY(e, r, n);
}, "registerLazyLoadedDiagrams"), jY = /* @__PURE__ */ w((t, e, r) => {
  qu[t] && ae.warn(`Detector with key ${t} already exists. Overwriting.`), qu[t] = { detector: e, loader: r }, ae.debug(`Detector with key ${t} added${r ? " with loader" : ""}`);
}, "addDetector"), Xhe = /* @__PURE__ */ w((t) => qu[t].loader, "getDiagramLoader"), Q7 = /* @__PURE__ */ w((t, e, { depth: r = 2, clobber: n = !1 } = {}) => {
  const i = { depth: r, clobber: n };
  return Array.isArray(e) && !Array.isArray(t) ? (e.forEach((a) => Q7(t, a, i)), t) : Array.isArray(e) && Array.isArray(t) ? (e.forEach((a) => {
    t.includes(a) || t.push(a);
  }), t) : t === void 0 || r <= 0 ? t != null && typeof t == "object" && typeof e == "object" ? Object.assign(t, e) : e : (e !== void 0 && typeof t == "object" && typeof e == "object" && Object.keys(e).forEach((a) => {
    typeof e[a] == "object" && (t[a] === void 0 || typeof t[a] == "object") ? (t[a] === void 0 && (t[a] = Array.isArray(e[a]) ? [] : {}), t[a] = Q7(t[a], e[a], { depth: r - 1, clobber: n })) : (n || typeof t[a] != "object" && typeof e[a] != "object") && (t[a] = e[a]);
  }), t);
}, "assignWithDepth"), bn = Q7, Dx = "#ffffff", Ox = "#f2f2f2", zi = /* @__PURE__ */ w((t, e) => e ? De(t, { s: -40, l: 10 }) : De(t, { s: -40, l: -10 }), "mkBorder"), Xf, jhe = (Xf = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
  }
  updateColors() {
    if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || De(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || De(this.primaryColor, { h: 180, l: 5 }), this.primaryBorderColor = this.primaryBorderColor || zi(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || zi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || zi(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || zi(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || yt(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || yt(this.tertiaryColor), this.lineColor = this.lineColor || yt(this.background), this.arrowheadColor = this.arrowheadColor || yt(this.background), this.textColor = this.textColor || this.primaryTextColor, this.border2 = this.border2 || this.tertiaryBorderColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? Nt(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || this.actorBorder, this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || Nt(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || yt(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || _t(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.vertLineColor = this.vertLineColor || "navy", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.darkMode ? (this.rowOdd = this.rowOdd || Nt(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || Nt(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || _t(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || _t(this.mainBkg, 5)), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || De(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || De(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || De(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || De(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || De(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || De(this.primaryColor, { h: 210, l: 150 }), this.cScale9 = this.cScale9 || De(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || De(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || De(this.primaryColor, { h: 330 }), this.darkMode)
      for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
        this["cScale" + r] = Nt(this["cScale" + r], 75);
    else
      for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
        this["cScale" + r] = Nt(this["cScale" + r], 25);
    for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
      this["cScaleInv" + r] = this["cScaleInv" + r] || yt(this["cScale" + r]);
    for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
      this.darkMode ? this["cScalePeer" + r] = this["cScalePeer" + r] || _t(this["cScale" + r], 10) : this["cScalePeer" + r] = this["cScalePeer" + r] || Nt(this["cScale" + r], 10);
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
      this["cScaleLabel" + r] = this["cScaleLabel" + r] || this.scaleLabelColor;
    const e = this.darkMode ? -4 : -1;
    for (let r = 0; r < 5; r++)
      this["surface" + r] = this["surface" + r] || De(this.mainBkg, { h: 180, s: -15, l: e * (5 + r * 3) }), this["surfacePeer" + r] = this["surfacePeer" + r] || De(this.mainBkg, { h: 180, s: -15, l: e * (8 + r * 3) });
    this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || De(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || De(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || De(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || De(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || De(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || De(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || De(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || De(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || De(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || De(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || De(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || De(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || De(this.primaryColor, { h: 60, l: -20 }), this.pie11 = this.pie11 || De(this.primaryColor, { h: -60, l: -20 }), this.pie12 = this.pie12 || De(this.primaryColor, { h: 120, l: -10 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.archEdgeColor = this.archEdgeColor || "#777", this.archEdgeArrowColor = this.archEdgeArrowColor || "#777", this.archEdgeWidth = this.archEdgeWidth || "3", this.archGroupBorderColor = this.archGroupBorderColor || "#000", this.archGroupBorderWidth = this.archGroupBorderWidth || "2px", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || De(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || De(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || De(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || De(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || De(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || De(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Pc(this.quadrant1Fill) ? _t(this.quadrant1Fill) : Nt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Nt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || De(this.primaryColor, { h: -30 }), this.git4 = this.git4 || De(this.primaryColor, { h: -60 }), this.git5 = this.git5 || De(this.primaryColor, { h: -90 }), this.git6 = this.git6 || De(this.primaryColor, { h: 60 }), this.git7 = this.git7 || De(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = _t(this.git0, 25), this.git1 = _t(this.git1, 25), this.git2 = _t(this.git2, 25), this.git3 = _t(this.git3, 25), this.git4 = _t(this.git4, 25), this.git5 = _t(this.git5, 25), this.git6 = _t(this.git6, 25), this.git7 = _t(this.git7, 25)) : (this.git0 = Nt(this.git0, 25), this.git1 = Nt(this.git1, 25), this.git2 = Nt(this.git2, 25), this.git3 = Nt(this.git3, 25), this.git4 = Nt(this.git4, 25), this.git5 = Nt(this.git5, 25), this.git6 = Nt(this.git6, 25), this.git7 = Nt(this.git7, 25)), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Dx, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ox;
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
}, w(Xf, "Theme"), Xf), Khe = /* @__PURE__ */ w((t) => {
  const e = new jhe();
  return e.calculate(t), e;
}, "getThemeVariables"), jf, Zhe = (jf = class {
  constructor() {
    this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = _t(this.primaryColor, 16), this.tertiaryColor = De(this.primaryColor, { h: -160 }), this.primaryBorderColor = yt(this.background), this.secondaryBorderColor = zi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = zi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.tertiaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = _t(yt("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#ccc", this.border2 = ac(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = Nt("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.excludeBkgColor = Nt(this.sectionBkgColor, 10), this.taskBorderColor = ac(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = ac(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || _t(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || Nt(this.mainBkg, 10), this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
  }
  updateColors() {
    this.secondBkg = _t(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = _t(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.actorBorder, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = _t(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = De(this.primaryColor, { h: 64 }), this.fillType3 = De(this.secondaryColor, { h: 64 }), this.fillType4 = De(this.primaryColor, { h: -64 }), this.fillType5 = De(this.secondaryColor, { h: -64 }), this.fillType6 = De(this.primaryColor, { h: 128 }), this.fillType7 = De(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || De(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || De(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || De(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || De(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || De(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || De(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || De(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || De(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || De(this.primaryColor, { h: 330 });
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || yt(this["cScale" + e]);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScalePeer" + e] = this["cScalePeer" + e] || _t(this["cScale" + e], 10);
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || De(this.mainBkg, { h: 30, s: -30, l: -(-10 + e * 4) }), this["surfacePeer" + e] = this["surfacePeer" + e] || De(this.mainBkg, { h: 30, s: -30, l: -(-7 + e * 4) });
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["pie" + e] = this["cScale" + e];
    this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || De(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || De(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || De(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || De(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || De(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || De(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Pc(this.quadrant1Fill) ? _t(this.quadrant1Fill) : Nt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
    }, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.background
    }, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Nt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = _t(this.secondaryColor, 20), this.git1 = _t(this.pie2 || this.secondaryColor, 20), this.git2 = _t(this.pie3 || this.tertiaryColor, 20), this.git3 = _t(this.pie4 || De(this.primaryColor, { h: -30 }), 20), this.git4 = _t(this.pie5 || De(this.primaryColor, { h: -60 }), 20), this.git5 = _t(this.pie6 || De(this.primaryColor, { h: -90 }), 10), this.git6 = _t(this.pie7 || De(this.primaryColor, { h: 60 }), 10), this.git7 = _t(this.pie8 || De(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || yt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || yt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || _t(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || _t(this.background, 2), this.nodeBorder = this.nodeBorder || "#999";
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
}, w(jf, "Theme"), jf), Qhe = /* @__PURE__ */ w((t) => {
  const e = new Zhe();
  return e.calculate(t), e;
}, "getThemeVariables"), Kf, Jhe = (Kf = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = De(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = De(this.primaryColor, { h: -160 }), this.primaryBorderColor = zi(this.primaryColor, this.darkMode), this.secondaryBorderColor = zi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = zi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.tertiaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "rgba(232,232,232, 0.8)", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.sectionBkgColor = ac(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "navy", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = "calculated", this.rowEven = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || De(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || De(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || De(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || De(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || De(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || De(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || De(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || De(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || De(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || Nt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || Nt(this.tertiaryColor, 40);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScale" + e] = Nt(this["cScale" + e], 10), this["cScalePeer" + e] = this["cScalePeer" + e] || Nt(this["cScale" + e], 25);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || De(this["cScale" + e], { h: 180 });
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || De(this.mainBkg, { h: 30, l: -(5 + e * 5) }), this["surfacePeer" + e] = this["surfacePeer" + e] || De(this.mainBkg, { h: 30, l: -(7 + e * 5) });
    if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || yt(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || yt(this.labelTextColor);
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.labelTextColor;
    }
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = _t(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || _t(this.primaryColor, 75) || "#ffffff", this.rowEven = this.rowEven || _t(this.primaryColor, 1), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = De(this.primaryColor, { h: 64 }), this.fillType3 = De(this.secondaryColor, { h: 64 }), this.fillType4 = De(this.primaryColor, { h: -64 }), this.fillType5 = De(this.secondaryColor, { h: -64 }), this.fillType6 = De(this.primaryColor, { h: 128 }), this.fillType7 = De(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || De(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || De(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || De(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || De(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || De(this.primaryColor, { h: 60, l: -20 }), this.pie8 = this.pie8 || De(this.primaryColor, { h: -60, l: -40 }), this.pie9 = this.pie9 || De(this.primaryColor, { h: 120, l: -40 }), this.pie10 = this.pie10 || De(this.primaryColor, { h: 60, l: -40 }), this.pie11 = this.pie11 || De(this.primaryColor, { h: -90, l: -40 }), this.pie12 = this.pie12 || De(this.primaryColor, { h: 120, l: -30 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || De(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || De(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || De(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || De(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || De(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || De(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Pc(this.quadrant1Fill) ? _t(this.quadrant1Fill) : Nt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || De(this.primaryColor, { h: -30 }), this.git4 = this.git4 || De(this.primaryColor, { h: -60 }), this.git5 = this.git5 || De(this.primaryColor, { h: -90 }), this.git6 = this.git6 || De(this.primaryColor, { h: 60 }), this.git7 = this.git7 || De(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = _t(this.git0, 25), this.git1 = _t(this.git1, 25), this.git2 = _t(this.git2, 25), this.git3 = _t(this.git3, 25), this.git4 = _t(this.git4, 25), this.git5 = _t(this.git5, 25), this.git6 = _t(this.git6, 25), this.git7 = _t(this.git7, 25)) : (this.git0 = Nt(this.git0, 25), this.git1 = Nt(this.git1, 25), this.git2 = Nt(this.git2, 25), this.git3 = Nt(this.git3, 25), this.git4 = Nt(this.git4, 25), this.git5 = Nt(this.git5, 25), this.git6 = Nt(this.git6, 25), this.git7 = Nt(this.git7, 25)), this.gitInv0 = this.gitInv0 || Nt(yt(this.git0), 25), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || yt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || yt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Dx, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ox;
  }
  calculate(e) {
    if (Object.keys(this).forEach((n) => {
      this[n] === "calculated" && (this[n] = void 0);
    }), typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
}, w(Kf, "Theme"), Kf), Px = /* @__PURE__ */ w((t) => {
  const e = new Jhe();
  return e.calculate(t), e;
}, "getThemeVariables"), Zf, efe = (Zf = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = _t("#cde498", 10), this.primaryBorderColor = zi(this.primaryColor, this.darkMode), this.secondaryBorderColor = zi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = zi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.primaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.actorBorder = Nt(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || De(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || De(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || De(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || De(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || De(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || De(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || De(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || De(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || De(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || Nt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || Nt(this.tertiaryColor, 40);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScale" + e] = Nt(this["cScale" + e], 10), this["cScalePeer" + e] = this["cScalePeer" + e] || Nt(this["cScale" + e], 25);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || De(this["cScale" + e], { h: 180 });
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || De(this.mainBkg, { h: 30, s: -30, l: -(5 + e * 5) }), this["surfacePeer" + e] = this["surfacePeer" + e] || De(this.mainBkg, { h: 30, s: -30, l: -(8 + e * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || _t(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || _t(this.mainBkg, 20), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = De(this.primaryColor, { h: 64 }), this.fillType3 = De(this.secondaryColor, { h: 64 }), this.fillType4 = De(this.primaryColor, { h: -64 }), this.fillType5 = De(this.secondaryColor, { h: -64 }), this.fillType6 = De(this.primaryColor, { h: 128 }), this.fillType7 = De(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || De(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || De(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || De(this.tertiaryColor, { h: 40, l: -40 }), this.pie7 = this.pie7 || De(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || De(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || De(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || De(this.primaryColor, { h: 60, l: -50 }), this.pie11 = this.pie11 || De(this.primaryColor, { h: -60, l: -50 }), this.pie12 = this.pie12 || De(this.primaryColor, { h: 120, l: -50 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || De(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || De(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || De(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || De(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || De(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || De(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Pc(this.quadrant1Fill) ? _t(this.quadrant1Fill) : Nt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.mainBkg
    }, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || De(this.primaryColor, { h: -30 }), this.git4 = this.git4 || De(this.primaryColor, { h: -60 }), this.git5 = this.git5 || De(this.primaryColor, { h: -90 }), this.git6 = this.git6 || De(this.primaryColor, { h: 60 }), this.git7 = this.git7 || De(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = _t(this.git0, 25), this.git1 = _t(this.git1, 25), this.git2 = _t(this.git2, 25), this.git3 = _t(this.git3, 25), this.git4 = _t(this.git4, 25), this.git5 = _t(this.git5, 25), this.git6 = _t(this.git6, 25), this.git7 = _t(this.git7, 25)) : (this.git0 = Nt(this.git0, 25), this.git1 = Nt(this.git1, 25), this.git2 = Nt(this.git2, 25), this.git3 = Nt(this.git3, 25), this.git4 = Nt(this.git4, 25), this.git5 = Nt(this.git5, 25), this.git6 = Nt(this.git6, 25), this.git7 = Nt(this.git7, 25)), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || yt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || yt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Dx, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ox;
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
}, w(Zf, "Theme"), Zf), tfe = /* @__PURE__ */ w((t) => {
  const e = new efe();
  return e.calculate(t), e;
}, "getThemeVariables"), Qf, rfe = (Qf = class {
  constructor() {
    this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = _t(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = De(this.primaryColor, { h: -160 }), this.primaryBorderColor = zi(this.primaryColor, this.darkMode), this.secondaryBorderColor = zi(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = zi(this.tertiaryColor, this.darkMode), this.primaryTextColor = yt(this.primaryColor), this.secondaryTextColor = yt(this.secondaryColor), this.tertiaryTextColor = yt(this.tertiaryColor), this.lineColor = yt(this.background), this.textColor = yt(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = this.actorBorder, this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || _t(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || "#f4f4f4", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.secondBkg = _t(this.contrast, 55), this.border2 = this.contrast, this.actorBorder = _t(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.actorBorder, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || yt(this["cScale" + e]);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || _t(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || Nt(this["cScale" + e], 10);
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || De(this.mainBkg, { l: -(5 + e * 5) }), this["surfacePeer" + e] = this["surfacePeer" + e] || De(this.mainBkg, { l: -(8 + e * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.sectionBkgColor = _t(this.contrast, 30), this.sectionBkgColor2 = _t(this.contrast, 30), this.taskBorderColor = Nt(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = _t(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = Nt(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.vertLineColor = this.critBkgColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = De(this.primaryColor, { h: 64 }), this.fillType3 = De(this.secondaryColor, { h: 64 }), this.fillType4 = De(this.primaryColor, { h: -64 }), this.fillType5 = De(this.secondaryColor, { h: -64 }), this.fillType6 = De(this.primaryColor, { h: 128 }), this.fillType7 = De(this.secondaryColor, { h: 128 });
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["pie" + e] = this["cScale" + e];
    this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || De(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || De(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || De(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || De(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || De(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || De(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Pc(this.quadrant1Fill) ? _t(this.quadrant1Fill) : Nt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
    }, this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = Nt(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || De(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || De(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || De(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || De(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || De(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || yt(this.git0), this.gitInv1 = this.gitInv1 || yt(this.git1), this.gitInv2 = this.gitInv2 || yt(this.git2), this.gitInv3 = this.gitInv3 || yt(this.git3), this.gitInv4 = this.gitInv4 || yt(this.git4), this.gitInv5 = this.gitInv5 || yt(this.git5), this.gitInv6 = this.gitInv6 || yt(this.git6), this.gitInv7 = this.gitInv7 || yt(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Dx, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ox;
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
}, w(Qf, "Theme"), Qf), nfe = /* @__PURE__ */ w((t) => {
  const e = new rfe();
  return e.calculate(t), e;
}, "getThemeVariables"), il = {
  base: {
    getThemeVariables: Khe
  },
  dark: {
    getThemeVariables: Qhe
  },
  default: {
    getThemeVariables: Px
  },
  forest: {
    getThemeVariables: tfe
  },
  neutral: {
    getThemeVariables: nfe
  }
}, Gs = {
  flowchart: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    subGraphTitleMargin: {
      top: 0,
      bottom: 0
    },
    diagramPadding: 8,
    htmlLabels: !0,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    defaultRenderer: "dagre-wrapper",
    wrappingWidth: 200,
    inheritDir: !1
  },
  sequence: {
    useMaxWidth: !0,
    hideUnusedParticipants: !1,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: !0,
    forceMenus: !1,
    bottomMarginAdj: 1,
    rightAngles: !1,
    showSequenceNumbers: !1,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: !1,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20
  },
  gantt: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    topAxis: !1,
    displayMode: "",
    weekday: "sunday"
  },
  journey: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    maxLabelWidth: 360,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    titleColor: "",
    titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    titleFontSize: "4ex"
  },
  class: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    arrowMarkerAbsolute: !1,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    defaultRenderer: "dagre-wrapper",
    htmlLabels: !1,
    hideEmptyMembersBox: !1
  },
  state: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    nodeSpacing: 140,
    rankSpacing: 80,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12
  },
  pie: {
    useMaxWidth: !0,
    textPosition: 0.75
  },
  quadrantChart: {
    useMaxWidth: !0,
    chartWidth: 500,
    chartHeight: 500,
    titleFontSize: 20,
    titlePadding: 10,
    quadrantPadding: 5,
    xAxisLabelPadding: 5,
    yAxisLabelPadding: 5,
    xAxisLabelFontSize: 16,
    yAxisLabelFontSize: 16,
    quadrantLabelFontSize: 16,
    quadrantTextTopPadding: 5,
    pointTextPadding: 5,
    pointLabelFontSize: 12,
    pointRadius: 5,
    xAxisPosition: "top",
    yAxisPosition: "left",
    quadrantInternalBorderStrokeWidth: 1,
    quadrantExternalBorderStrokeWidth: 2
  },
  xyChart: {
    useMaxWidth: !0,
    width: 700,
    height: 500,
    titleFontSize: 20,
    titlePadding: 10,
    showDataLabel: !1,
    showTitle: !0,
    xAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: !0,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: !0,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: !0,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: !0,
      axisLineWidth: 2
    },
    yAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: !0,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: !0,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: !0,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: !0,
      axisLineWidth: 2
    },
    chartOrientation: "vertical",
    plotReservedSpacePercent: 50
  },
  requirement: {
    useMaxWidth: !0,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  mindmap: {
    useMaxWidth: !0,
    padding: 10,
    maxNodeWidth: 200,
    layoutAlgorithm: "cose-bilkent"
  },
  kanban: {
    useMaxWidth: !0,
    padding: 8,
    sectionWidth: 200,
    ticketBaseUrl: ""
  },
  timeline: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    disableMulticolor: !1
  },
  gitGraph: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: !0,
    showBranches: !0,
    rotateCommitLabel: !0,
    parallelCommits: !1,
    arrowMarkerAbsolute: !1
  },
  c4: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: !0,
    wrapPadding: 10,
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  sankey: {
    useMaxWidth: !0,
    width: 600,
    height: 400,
    linkColor: "gradient",
    nodeAlignment: "justify",
    showValues: !0,
    prefix: "",
    suffix: ""
  },
  block: {
    useMaxWidth: !0,
    padding: 8
  },
  packet: {
    useMaxWidth: !0,
    rowHeight: 32,
    bitWidth: 32,
    bitsPerRow: 32,
    showBits: !0,
    paddingX: 5,
    paddingY: 5
  },
  architecture: {
    useMaxWidth: !0,
    padding: 40,
    iconSize: 80,
    fontSize: 16
  },
  radar: {
    useMaxWidth: !0,
    width: 600,
    height: 600,
    marginTop: 50,
    marginRight: 50,
    marginBottom: 50,
    marginLeft: 50,
    axisScaleFactor: 1,
    axisLabelFactor: 1.05,
    curveTension: 0.17
  },
  theme: "default",
  look: "classic",
  handDrawnSeed: 0,
  layout: "dagre",
  maxTextSize: 5e4,
  maxEdges: 500,
  darkMode: !1,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: !0,
  arrowMarkerAbsolute: !1,
  secure: [
    "secure",
    "securityLevel",
    "startOnLoad",
    "maxTextSize",
    "suppressErrorRendering",
    "maxEdges"
  ],
  legacyMathML: !1,
  forceLegacyMathML: !1,
  deterministicIds: !1,
  fontSize: 16,
  markdownAutoWrap: !0,
  suppressErrorRendering: !1
}, KY = {
  ...Gs,
  // Set, even though they're `undefined` so that `configKeys` finds these keys
  // TODO: Should we replace these with `null` so that they can go in the JSON Schema?
  deterministicIDSeed: void 0,
  elk: {
    // mergeEdges is needed here to be considered
    mergeEdges: !1,
    nodePlacementStrategy: "BRANDES_KOEPF",
    forceNodeModelOrder: !1,
    considerModelOrder: "NODES_AND_EDGES"
  },
  themeCSS: void 0,
  // add non-JSON default config values
  themeVariables: il.default.getThemeVariables(),
  sequence: {
    ...Gs.sequence,
    messageFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont"),
    noteFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    }, "noteFont"),
    actorFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }, "actorFont")
  },
  class: {
    hideEmptyMembersBox: !1
  },
  gantt: {
    ...Gs.gantt,
    tickInterval: void 0,
    useWidth: void 0
    // can probably be removed since `configKeys` already includes this
  },
  c4: {
    ...Gs.c4,
    useWidth: void 0,
    personFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    }, "personFont"),
    flowchart: {
      ...Gs.flowchart,
      inheritDir: !1
      // default to legacy behavior
    },
    external_personFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    }, "external_personFont"),
    systemFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    }, "systemFont"),
    external_systemFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    }, "external_systemFont"),
    system_dbFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    }, "system_dbFont"),
    external_system_dbFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    }, "external_system_dbFont"),
    system_queueFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    }, "system_queueFont"),
    external_system_queueFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    }, "external_system_queueFont"),
    containerFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    }, "containerFont"),
    external_containerFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    }, "external_containerFont"),
    container_dbFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    }, "container_dbFont"),
    external_container_dbFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    }, "external_container_dbFont"),
    container_queueFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    }, "container_queueFont"),
    external_container_queueFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    }, "external_container_queueFont"),
    componentFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    }, "componentFont"),
    external_componentFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    }, "external_componentFont"),
    component_dbFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    }, "component_dbFont"),
    external_component_dbFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    }, "external_component_dbFont"),
    component_queueFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    }, "component_queueFont"),
    external_component_queueFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    }, "external_component_queueFont"),
    boundaryFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    }, "boundaryFont"),
    messageFont: /* @__PURE__ */ w(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont")
  },
  pie: {
    ...Gs.pie,
    useWidth: 984
  },
  xyChart: {
    ...Gs.xyChart,
    useWidth: void 0
  },
  requirement: {
    ...Gs.requirement,
    useWidth: void 0
  },
  packet: {
    ...Gs.packet
  },
  radar: {
    ...Gs.radar
  },
  treemap: {
    useMaxWidth: !0,
    padding: 10,
    diagramPadding: 8,
    showValues: !0,
    nodeWidth: 100,
    nodeHeight: 40,
    borderWidth: 1,
    valueFontSize: 12,
    labelFontSize: 14,
    valueFormat: ","
  }
}, ZY = /* @__PURE__ */ w((t, e = "") => Object.keys(t).reduce((r, n) => Array.isArray(t[n]) ? r : typeof t[n] == "object" && t[n] !== null ? [...r, e + n, ...ZY(t[n], "")] : [...r, e + n], []), "keyify"), ife = new Set(ZY(KY, "")), fr = KY, k2 = /* @__PURE__ */ w((t) => {
  if (ae.debug("sanitizeDirective called with", t), !(typeof t != "object" || t == null)) {
    if (Array.isArray(t)) {
      t.forEach((e) => k2(e));
      return;
    }
    for (const e of Object.keys(t)) {
      if (ae.debug("Checking key", e), e.startsWith("__") || e.includes("proto") || e.includes("constr") || !ife.has(e) || t[e] == null) {
        ae.debug("sanitize deleting key: ", e), delete t[e];
        continue;
      }
      if (typeof t[e] == "object") {
        ae.debug("sanitizing object", e), k2(t[e]);
        continue;
      }
      const r = ["themeCSS", "fontFamily", "altFontFamily"];
      for (const n of r)
        e.includes(n) && (ae.debug("sanitizing css option", e), t[e] = afe(t[e]));
    }
    if (t.themeVariables)
      for (const e of Object.keys(t.themeVariables)) {
        const r = t.themeVariables[e];
        r?.match && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (t.themeVariables[e] = "");
      }
    ae.debug("After sanitization", t);
  }
}, "sanitizeDirective"), afe = /* @__PURE__ */ w((t) => {
  let e = 0, r = 0;
  for (const n of t) {
    if (e < r)
      return "{ /* ERROR: Unbalanced CSS */ }";
    n === "{" ? e++ : n === "}" && r++;
  }
  return e !== r ? "{ /* ERROR: Unbalanced CSS */ }" : t;
}, "sanitizeCss"), Wd = Object.freeze(fr), ia = bn({}, Wd), C2, Gu = [], Og = bn({}, Wd), $x = /* @__PURE__ */ w((t, e) => {
  let r = bn({}, t), n = {};
  for (const i of e)
    eX(i), n = bn(n, i);
  if (r = bn(r, n), n.theme && n.theme in il) {
    const i = bn({}, C2), a = bn(
      i.themeVariables || {},
      n.themeVariables
    );
    r.theme && r.theme in il && (r.themeVariables = il[r.theme].getThemeVariables(a));
  }
  return Og = r, tX(Og), Og;
}, "updateCurrentConfig"), sfe = /* @__PURE__ */ w((t) => (ia = bn({}, Wd), ia = bn(ia, t), t.theme && il[t.theme] && (ia.themeVariables = il[t.theme].getThemeVariables(t.themeVariables)), $x(ia, Gu), ia), "setSiteConfig"), ofe = /* @__PURE__ */ w((t) => {
  C2 = bn({}, t);
}, "saveConfigFromInitialize"), lfe = /* @__PURE__ */ w((t) => (ia = bn(ia, t), $x(ia, Gu), ia), "updateSiteConfig"), QY = /* @__PURE__ */ w(() => bn({}, ia), "getSiteConfig"), JY = /* @__PURE__ */ w((t) => (tX(t), bn(Og, t), mr()), "setConfig"), mr = /* @__PURE__ */ w(() => bn({}, Og), "getConfig"), eX = /* @__PURE__ */ w((t) => {
  t && (["secure", ...ia.secure ?? []].forEach((e) => {
    Object.hasOwn(t, e) && (ae.debug(`Denied attempt to modify a secure key ${e}`, t[e]), delete t[e]);
  }), Object.keys(t).forEach((e) => {
    e.startsWith("__") && delete t[e];
  }), Object.keys(t).forEach((e) => {
    typeof t[e] == "string" && (t[e].includes("<") || t[e].includes(">") || t[e].includes("url(data:")) && delete t[e], typeof t[e] == "object" && eX(t[e]);
  }));
}, "sanitize"), cfe = /* @__PURE__ */ w((t) => {
  k2(t), t.fontFamily && !t.themeVariables?.fontFamily && (t.themeVariables = {
    ...t.themeVariables,
    fontFamily: t.fontFamily
  }), Gu.push(t), $x(ia, Gu);
}, "addDirective"), _2 = /* @__PURE__ */ w((t = ia) => {
  Gu = [], $x(t, Gu);
}, "reset"), ufe = {
  LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
}, NM = {}, hfe = /* @__PURE__ */ w((t) => {
  NM[t] || (ae.warn(ufe[t]), NM[t] = !0);
}, "issueWarning"), tX = /* @__PURE__ */ w((t) => {
  t && (t.lazyLoadedDiagrams || t.loadExternalDiagramsAtStartup) && hfe("LAZY_LOAD_DEPRECATED");
}, "checkConfig"), ffe = /* @__PURE__ */ w(() => {
  let t = {};
  C2 && (t = bn(t, C2));
  for (const e of Gu)
    t = bn(t, e);
  return t;
}, "getUserDefinedConfig"), C0 = /<br\s*\/?>/gi, dfe = /* @__PURE__ */ w((t) => t ? iX(t).replace(/\\n/g, "#br#").split("#br#") : [""], "getRows"), pfe = /* @__PURE__ */ (() => {
  let t = !1;
  return () => {
    t || (rX(), t = !0);
  };
})();
function rX() {
  const t = "data-temp-href-target";
  Hd.addHook("beforeSanitizeAttributes", (e) => {
    e.tagName === "A" && e.hasAttribute("target") && e.setAttribute(t, e.getAttribute("target") ?? "");
  }), Hd.addHook("afterSanitizeAttributes", (e) => {
    e.tagName === "A" && e.hasAttribute(t) && (e.setAttribute("target", e.getAttribute(t) ?? ""), e.removeAttribute(t), e.getAttribute("target") === "_blank" && e.setAttribute("rel", "noopener"));
  });
}
w(rX, "setupDompurifyHooks");
var nX = /* @__PURE__ */ w((t) => (pfe(), Hd.sanitize(t)), "removeScript"), DM = /* @__PURE__ */ w((t, e) => {
  if (e.flowchart?.htmlLabels !== !1) {
    const r = e.securityLevel;
    r === "antiscript" || r === "strict" ? t = nX(t) : r !== "loose" && (t = iX(t), t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;"), t = t.replace(/=/g, "&equals;"), t = yfe(t));
  }
  return t;
}, "sanitizeMore"), pr = /* @__PURE__ */ w((t, e) => t && (e.dompurifyConfig ? t = Hd.sanitize(DM(t, e), e.dompurifyConfig).toString() : t = Hd.sanitize(DM(t, e), {
  FORBID_TAGS: ["style"]
}).toString(), t), "sanitizeText"), gfe = /* @__PURE__ */ w((t, e) => typeof t == "string" ? pr(t, e) : t.flat().map((r) => pr(r, e)), "sanitizeTextOrArray"), mfe = /* @__PURE__ */ w((t) => C0.test(t), "hasBreaks"), vfe = /* @__PURE__ */ w((t) => t.split(C0), "splitBreaks"), yfe = /* @__PURE__ */ w((t) => t.replace(/#br#/g, "<br/>"), "placeholderToBreak"), iX = /* @__PURE__ */ w((t) => t.replace(C0, "#br#"), "breakToPlaceholder"), Bx = /* @__PURE__ */ w((t) => {
  let e = "";
  return t && (e = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, e = CSS.escape(e)), e;
}, "getUrl"), Nr = /* @__PURE__ */ w((t) => !(t === !1 || ["false", "null", "0"].includes(String(t).trim().toLowerCase())), "evaluate"), bfe = /* @__PURE__ */ w(function(...t) {
  const e = t.filter((r) => !isNaN(r));
  return Math.max(...e);
}, "getMax"), xfe = /* @__PURE__ */ w(function(...t) {
  const e = t.filter((r) => !isNaN(r));
  return Math.min(...e);
}, "getMin"), Hl = /* @__PURE__ */ w(function(t) {
  const e = t.split(/(,)/), r = [];
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (i === "," && n > 0 && n + 1 < e.length) {
      const a = e[n - 1], s = e[n + 1];
      wfe(a, s) && (i = a + "," + s, n++, r.pop());
    }
    r.push(Tfe(i));
  }
  return r.join("");
}, "parseGenericTypes"), J7 = /* @__PURE__ */ w((t, e) => Math.max(0, t.split(e).length - 1), "countOccurrence"), wfe = /* @__PURE__ */ w((t, e) => {
  const r = J7(t, "~"), n = J7(e, "~");
  return r === 1 && n === 1;
}, "shouldCombineSets"), Tfe = /* @__PURE__ */ w((t) => {
  const e = J7(t, "~");
  let r = !1;
  if (e <= 1)
    return t;
  e % 2 !== 0 && t.startsWith("~") && (t = t.substring(1), r = !0);
  const n = [...t];
  let i = n.indexOf("~"), a = n.lastIndexOf("~");
  for (; i !== -1 && a !== -1 && i !== a; )
    n[i] = "<", n[a] = ">", i = n.indexOf("~"), a = n.lastIndexOf("~");
  return r && n.unshift("~"), n.join("");
}, "processSet"), OM = /* @__PURE__ */ w(() => window.MathMLElement !== void 0, "isMathMLSupported"), e_ = /\$\$(.*)\$\$/g, dn = /* @__PURE__ */ w((t) => (t.match(e_)?.length ?? 0) > 0, "hasKatex"), K1 = /* @__PURE__ */ w(async (t, e) => {
  const r = document.createElement("div");
  r.innerHTML = await Z1(t, e), r.id = "katex-temp", r.style.visibility = "hidden", r.style.position = "absolute", r.style.top = "0", document.querySelector("body")?.insertAdjacentElement("beforeend", r);
  const i = { width: r.clientWidth, height: r.clientHeight };
  return r.remove(), i;
}, "calculateMathMLDimensions"), Efe = /* @__PURE__ */ w(async (t, e) => {
  if (!dn(t))
    return t;
  if (!(OM() || e.legacyMathML || e.forceLegacyMathML))
    return t.replace(e_, "MathML is unsupported in this environment.");
  {
    const { default: r } = await Promise.resolve().then(() => BCe), n = e.forceLegacyMathML || !OM() && e.legacyMathML ? "htmlAndMathml" : "mathml";
    return t.split(C0).map(
      (i) => dn(i) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${i}</div>` : `<div>${i}</div>`
    ).join("").replace(
      e_,
      (i, a) => r.renderToString(a, {
        throwOnError: !0,
        displayMode: !0,
        output: n
      }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, "")
    );
  }
}, "renderKatexUnsanitized"), Z1 = /* @__PURE__ */ w(async (t, e) => pr(await Efe(t, e), e), "renderKatexSanitized"), at = {
  getRows: dfe,
  sanitizeText: pr,
  sanitizeTextOrArray: gfe,
  hasBreaks: mfe,
  splitBreaks: vfe,
  lineBreakRegex: C0,
  removeScript: nX,
  getUrl: Bx,
  evaluate: Nr,
  getMax: bfe,
  getMin: xfe
}, Sfe = /* @__PURE__ */ w(function(t, e) {
  for (let r of e)
    t.attr(r[0], r[1]);
}, "d3Attrs"), kfe = /* @__PURE__ */ w(function(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  return r ? (n.set("width", "100%"), n.set("style", `max-width: ${e}px;`)) : (n.set("height", t), n.set("width", e)), n;
}, "calculateSvgSizeAttrs"), Qi = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = kfe(e, r, n);
  Sfe(t, i);
}, "configureSvgSize"), Q1 = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = e.node().getBBox(), a = i.width, s = i.height;
  ae.info(`SVG bounds: ${a}x${s}`, i);
  let o = 0, l = 0;
  ae.info(`Graph bounds: ${o}x${l}`, t), o = a + r * 2, l = s + r * 2, ae.info(`Calculated bounds: ${o}x${l}`), Qi(e, l, o, n);
  const u = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`;
  e.attr("viewBox", u);
}, "setupGraphViewbox"), by = {}, Cfe = /* @__PURE__ */ w((t, e, r) => {
  let n = "";
  return t in by && by[t] ? n = by[t](r) : ae.warn(`No theme found for ${t}`), ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${n}

  ${e}
`;
}, "getStyles"), _fe = /* @__PURE__ */ w((t, e) => {
  e !== void 0 && (by[t] = e);
}, "addStylesForDiagram"), Afe = Cfe, u9 = {};
Mx(u9, {
  clear: () => In,
  getAccDescription: () => Yn,
  getAccTitle: () => Hn,
  getDiagramTitle: () => Mn,
  setAccDescription: () => Wn,
  setAccTitle: () => Ln,
  setDiagramTitle: () => ti
});
var h9 = "", f9 = "", d9 = "", p9 = /* @__PURE__ */ w((t) => pr(t, mr()), "sanitizeText"), In = /* @__PURE__ */ w(() => {
  h9 = "", d9 = "", f9 = "";
}, "clear"), Ln = /* @__PURE__ */ w((t) => {
  h9 = p9(t).replace(/^\s+/g, "");
}, "setAccTitle"), Hn = /* @__PURE__ */ w(() => h9, "getAccTitle"), Wn = /* @__PURE__ */ w((t) => {
  d9 = p9(t).replace(/\n\s+/g, `
`);
}, "setAccDescription"), Yn = /* @__PURE__ */ w(() => d9, "getAccDescription"), ti = /* @__PURE__ */ w((t) => {
  f9 = p9(t);
}, "setDiagramTitle"), Mn = /* @__PURE__ */ w(() => f9, "getDiagramTitle"), PM = ae, Lfe = o9, Te = mr, t_ = JY, aX = Wd, g9 = /* @__PURE__ */ w((t) => pr(t, Te()), "sanitizeText"), sX = Q1, Rfe = /* @__PURE__ */ w(() => u9, "getCommonDb"), A2 = {}, L2 = /* @__PURE__ */ w((t, e, r) => {
  A2[t] && PM.warn(`Diagram with id ${t} already registered. Overwriting.`), A2[t] = e, r && jY(t, r), _fe(t, e.styles), e.injectUtils?.(
    PM,
    Lfe,
    Te,
    g9,
    sX,
    Rfe(),
    () => {
    }
  );
}, "registerDiagram"), r_ = /* @__PURE__ */ w((t) => {
  if (t in A2)
    return A2[t];
  throw new Ife(t);
}, "getDiagram"), Jf, Ife = (Jf = class extends Error {
  constructor(e) {
    super(`Diagram ${e} not found.`);
  }
}, w(Jf, "DiagramNotFoundError"), Jf);
function xy(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Mfe(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function m9(t) {
  let e, r, n;
  t.length !== 2 ? (e = xy, r = (o, l) => xy(t(o), l), n = (o, l) => t(o) - l) : (e = t === xy || t === Mfe ? t : Nfe, r = t, n = t);
  function i(o, l, u = 0, h = o.length) {
    if (u < h) {
      if (e(l, l) !== 0) return h;
      do {
        const f = u + h >>> 1;
        r(o[f], l) < 0 ? u = f + 1 : h = f;
      } while (u < h);
    }
    return u;
  }
  function a(o, l, u = 0, h = o.length) {
    if (u < h) {
      if (e(l, l) !== 0) return h;
      do {
        const f = u + h >>> 1;
        r(o[f], l) <= 0 ? u = f + 1 : h = f;
      } while (u < h);
    }
    return u;
  }
  function s(o, l, u = 0, h = o.length) {
    const f = i(o, l, u, h - 1);
    return f > u && n(o[f - 1], l) > -n(o[f], l) ? f - 1 : f;
  }
  return { left: i, center: s, right: a };
}
function Nfe() {
  return 0;
}
function Dfe(t) {
  return t === null ? NaN : +t;
}
const Ofe = m9(xy), Pfe = Ofe.right;
m9(Dfe).center;
class $M extends Map {
  constructor(e, r = Ffe) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null) for (const [n, i] of e) this.set(n, i);
  }
  get(e) {
    return super.get(BM(this, e));
  }
  has(e) {
    return super.has(BM(this, e));
  }
  set(e, r) {
    return super.set($fe(this, e), r);
  }
  delete(e) {
    return super.delete(Bfe(this, e));
  }
}
function BM({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : r;
}
function $fe({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : (t.set(n, r), r);
}
function Bfe({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) && (r = t.get(n), t.delete(n)), r;
}
function Ffe(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
const zfe = Math.sqrt(50), qfe = Math.sqrt(10), Gfe = Math.sqrt(2);
function R2(t, e, r) {
  const n = (e - t) / Math.max(0, r), i = Math.floor(Math.log10(n)), a = n / Math.pow(10, i), s = a >= zfe ? 10 : a >= qfe ? 5 : a >= Gfe ? 2 : 1;
  let o, l, u;
  return i < 0 ? (u = Math.pow(10, -i) / s, o = Math.round(t * u), l = Math.round(e * u), o / u < t && ++o, l / u > e && --l, u = -u) : (u = Math.pow(10, i) * s, o = Math.round(t / u), l = Math.round(e / u), o * u < t && ++o, l * u > e && --l), l < o && 0.5 <= r && r < 2 ? R2(t, e, r * 2) : [o, l, u];
}
function Ufe(t, e, r) {
  if (e = +e, t = +t, r = +r, !(r > 0)) return [];
  if (t === e) return [t];
  const n = e < t, [i, a, s] = n ? R2(e, t, r) : R2(t, e, r);
  if (!(a >= i)) return [];
  const o = a - i + 1, l = new Array(o);
  if (n)
    if (s < 0) for (let u = 0; u < o; ++u) l[u] = (a - u) / -s;
    else for (let u = 0; u < o; ++u) l[u] = (a - u) * s;
  else if (s < 0) for (let u = 0; u < o; ++u) l[u] = (i + u) / -s;
  else for (let u = 0; u < o; ++u) l[u] = (i + u) * s;
  return l;
}
function n_(t, e, r) {
  return e = +e, t = +t, r = +r, R2(t, e, r)[2];
}
function i_(t, e, r) {
  e = +e, t = +t, r = +r;
  const n = e < t, i = n ? n_(e, t, r) : n_(t, e, r);
  return (n ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function Vfe(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Hfe(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Wfe(t, e, r) {
  t = +t, e = +e, r = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +r;
  for (var n = -1, i = Math.max(0, Math.ceil((e - t) / r)) | 0, a = new Array(i); ++n < i; )
    a[n] = t + n * r;
  return a;
}
function Yfe(t) {
  return t;
}
var wy = 1, v5 = 2, a_ = 3, rv = 4, FM = 1e-6;
function Xfe(t) {
  return "translate(" + t + ",0)";
}
function jfe(t) {
  return "translate(0," + t + ")";
}
function Kfe(t) {
  return (e) => +t(e);
}
function Zfe(t, e) {
  return e = Math.max(0, t.bandwidth() - e * 2) / 2, t.round() && (e = Math.round(e)), (r) => +t(r) + e;
}
function Qfe() {
  return !this.__axis;
}
function oX(t, e) {
  var r = [], n = null, i = null, a = 6, s = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, u = t === wy || t === rv ? -1 : 1, h = t === rv || t === v5 ? "x" : "y", f = t === wy || t === a_ ? Xfe : jfe;
  function d(p) {
    var g = n ?? (e.ticks ? e.ticks.apply(e, r) : e.domain()), m = i ?? (e.tickFormat ? e.tickFormat.apply(e, r) : Yfe), v = Math.max(a, 0) + o, y = e.range(), b = +y[0] + l, x = +y[y.length - 1] + l, T = (e.bandwidth ? Zfe : Kfe)(e.copy(), l), E = p.selection ? p.selection() : p, A = E.selectAll(".domain").data([null]), S = E.selectAll(".tick").data(g, e).order(), k = S.exit(), _ = S.enter().append("g").attr("class", "tick"), R = S.select("line"), L = S.select("text");
    A = A.merge(A.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), S = S.merge(_), R = R.merge(_.append("line").attr("stroke", "currentColor").attr(h + "2", u * a)), L = L.merge(_.append("text").attr("fill", "currentColor").attr(h, u * v).attr("dy", t === wy ? "0em" : t === a_ ? "0.71em" : "0.32em")), p !== E && (A = A.transition(p), S = S.transition(p), R = R.transition(p), L = L.transition(p), k = k.transition(p).attr("opacity", FM).attr("transform", function(M) {
      return isFinite(M = T(M)) ? f(M + l) : this.getAttribute("transform");
    }), _.attr("opacity", FM).attr("transform", function(M) {
      var P = this.parentNode.__axis;
      return f((P && isFinite(P = P(M)) ? P : T(M)) + l);
    })), k.remove(), A.attr("d", t === rv || t === v5 ? s ? "M" + u * s + "," + b + "H" + l + "V" + x + "H" + u * s : "M" + l + "," + b + "V" + x : s ? "M" + b + "," + u * s + "V" + l + "H" + x + "V" + u * s : "M" + b + "," + l + "H" + x), S.attr("opacity", 1).attr("transform", function(M) {
      return f(T(M) + l);
    }), R.attr(h + "2", u * a), L.attr(h, u * v).text(m), E.filter(Qfe).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t === v5 ? "start" : t === rv ? "end" : "middle"), E.each(function() {
      this.__axis = T;
    });
  }
  return d.scale = function(p) {
    return arguments.length ? (e = p, d) : e;
  }, d.ticks = function() {
    return r = Array.from(arguments), d;
  }, d.tickArguments = function(p) {
    return arguments.length ? (r = p == null ? [] : Array.from(p), d) : r.slice();
  }, d.tickValues = function(p) {
    return arguments.length ? (n = p == null ? null : Array.from(p), d) : n && n.slice();
  }, d.tickFormat = function(p) {
    return arguments.length ? (i = p, d) : i;
  }, d.tickSize = function(p) {
    return arguments.length ? (a = s = +p, d) : a;
  }, d.tickSizeInner = function(p) {
    return arguments.length ? (a = +p, d) : a;
  }, d.tickSizeOuter = function(p) {
    return arguments.length ? (s = +p, d) : s;
  }, d.tickPadding = function(p) {
    return arguments.length ? (o = +p, d) : o;
  }, d.offset = function(p) {
    return arguments.length ? (l = +p, d) : l;
  }, d;
}
function Jfe(t) {
  return oX(wy, t);
}
function ede(t) {
  return oX(a_, t);
}
var tde = { value: () => {
} };
function lX() {
  for (var t = 0, e = arguments.length, r = {}, n; t < e; ++t) {
    if (!(n = arguments[t] + "") || n in r || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new Ty(r);
}
function Ty(t) {
  this._ = t;
}
function rde(t, e) {
  return t.trim().split(/^|\s+/).map(function(r) {
    var n = "", i = r.indexOf(".");
    if (i >= 0 && (n = r.slice(i + 1), r = r.slice(0, i)), r && !e.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
Ty.prototype = lX.prototype = {
  constructor: Ty,
  on: function(t, e) {
    var r = this._, n = rde(t + "", r), i, a = -1, s = n.length;
    if (arguments.length < 2) {
      for (; ++a < s; ) if ((i = (t = n[a]).type) && (i = nde(r[i], t.name))) return i;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++a < s; )
      if (i = (t = n[a]).type) r[i] = zM(r[i], t.name, e);
      else if (e == null) for (i in r) r[i] = zM(r[i], t.name, null);
    return this;
  },
  copy: function() {
    var t = {}, e = this._;
    for (var r in e) t[r] = e[r].slice();
    return new Ty(t);
  },
  call: function(t, e) {
    if ((i = arguments.length - 2) > 0) for (var r = new Array(i), n = 0, i, a; n < i; ++n) r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (a = this._[t], n = 0, i = a.length; n < i; ++n) a[n].value.apply(e, r);
  },
  apply: function(t, e, r) {
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (var n = this._[t], i = 0, a = n.length; i < a; ++i) n[i].value.apply(e, r);
  }
};
function nde(t, e) {
  for (var r = 0, n = t.length, i; r < n; ++r)
    if ((i = t[r]).name === e)
      return i.value;
}
function zM(t, e, r) {
  for (var n = 0, i = t.length; n < i; ++n)
    if (t[n].name === e) {
      t[n] = tde, t = t.slice(0, n).concat(t.slice(n + 1));
      break;
    }
  return r != null && t.push({ name: e, value: r }), t;
}
var s_ = "http://www.w3.org/1999/xhtml";
const qM = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: s_,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Fx(t) {
  var e = t += "", r = e.indexOf(":");
  return r >= 0 && (e = t.slice(0, r)) !== "xmlns" && (t = t.slice(r + 1)), qM.hasOwnProperty(e) ? { space: qM[e], local: t } : t;
}
function ide(t) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === s_ && e.documentElement.namespaceURI === s_ ? e.createElement(t) : e.createElementNS(r, t);
  };
}
function ade(t) {
  return function() {
    return this.ownerDocument.createElementNS(t.space, t.local);
  };
}
function cX(t) {
  var e = Fx(t);
  return (e.local ? ade : ide)(e);
}
function sde() {
}
function v9(t) {
  return t == null ? sde : function() {
    return this.querySelector(t);
  };
}
function ode(t) {
  typeof t != "function" && (t = v9(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var a = e[i], s = a.length, o = n[i] = new Array(s), l, u, h = 0; h < s; ++h)
      (l = a[h]) && (u = t.call(l, l.__data__, h, a)) && ("__data__" in l && (u.__data__ = l.__data__), o[h] = u);
  return new Ra(n, this._parents);
}
function lde(t) {
  return t == null ? [] : Array.isArray(t) ? t : Array.from(t);
}
function cde() {
  return [];
}
function uX(t) {
  return t == null ? cde : function() {
    return this.querySelectorAll(t);
  };
}
function ude(t) {
  return function() {
    return lde(t.apply(this, arguments));
  };
}
function hde(t) {
  typeof t == "function" ? t = ude(t) : t = uX(t);
  for (var e = this._groups, r = e.length, n = [], i = [], a = 0; a < r; ++a)
    for (var s = e[a], o = s.length, l, u = 0; u < o; ++u)
      (l = s[u]) && (n.push(t.call(l, l.__data__, u, s)), i.push(l));
  return new Ra(n, i);
}
function hX(t) {
  return function() {
    return this.matches(t);
  };
}
function fX(t) {
  return function(e) {
    return e.matches(t);
  };
}
var fde = Array.prototype.find;
function dde(t) {
  return function() {
    return fde.call(this.children, t);
  };
}
function pde() {
  return this.firstElementChild;
}
function gde(t) {
  return this.select(t == null ? pde : dde(typeof t == "function" ? t : fX(t)));
}
var mde = Array.prototype.filter;
function vde() {
  return Array.from(this.children);
}
function yde(t) {
  return function() {
    return mde.call(this.children, t);
  };
}
function bde(t) {
  return this.selectAll(t == null ? vde : yde(typeof t == "function" ? t : fX(t)));
}
function xde(t) {
  typeof t != "function" && (t = hX(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var a = e[i], s = a.length, o = n[i] = [], l, u = 0; u < s; ++u)
      (l = a[u]) && t.call(l, l.__data__, u, a) && o.push(l);
  return new Ra(n, this._parents);
}
function dX(t) {
  return new Array(t.length);
}
function wde() {
  return new Ra(this._enter || this._groups.map(dX), this._parents);
}
function I2(t, e) {
  this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = e;
}
I2.prototype = {
  constructor: I2,
  appendChild: function(t) {
    return this._parent.insertBefore(t, this._next);
  },
  insertBefore: function(t, e) {
    return this._parent.insertBefore(t, e);
  },
  querySelector: function(t) {
    return this._parent.querySelector(t);
  },
  querySelectorAll: function(t) {
    return this._parent.querySelectorAll(t);
  }
};
function Tde(t) {
  return function() {
    return t;
  };
}
function Ede(t, e, r, n, i, a) {
  for (var s = 0, o, l = e.length, u = a.length; s < u; ++s)
    (o = e[s]) ? (o.__data__ = a[s], n[s] = o) : r[s] = new I2(t, a[s]);
  for (; s < l; ++s)
    (o = e[s]) && (i[s] = o);
}
function Sde(t, e, r, n, i, a, s) {
  var o, l, u = /* @__PURE__ */ new Map(), h = e.length, f = a.length, d = new Array(h), p;
  for (o = 0; o < h; ++o)
    (l = e[o]) && (d[o] = p = s.call(l, l.__data__, o, e) + "", u.has(p) ? i[o] = l : u.set(p, l));
  for (o = 0; o < f; ++o)
    p = s.call(t, a[o], o, a) + "", (l = u.get(p)) ? (n[o] = l, l.__data__ = a[o], u.delete(p)) : r[o] = new I2(t, a[o]);
  for (o = 0; o < h; ++o)
    (l = e[o]) && u.get(d[o]) === l && (i[o] = l);
}
function kde(t) {
  return t.__data__;
}
function Cde(t, e) {
  if (!arguments.length) return Array.from(this, kde);
  var r = e ? Sde : Ede, n = this._parents, i = this._groups;
  typeof t != "function" && (t = Tde(t));
  for (var a = i.length, s = new Array(a), o = new Array(a), l = new Array(a), u = 0; u < a; ++u) {
    var h = n[u], f = i[u], d = f.length, p = _de(t.call(h, h && h.__data__, u, n)), g = p.length, m = o[u] = new Array(g), v = s[u] = new Array(g), y = l[u] = new Array(d);
    r(h, f, m, v, y, p, e);
    for (var b = 0, x = 0, T, E; b < g; ++b)
      if (T = m[b]) {
        for (b >= x && (x = b + 1); !(E = v[x]) && ++x < g; ) ;
        T._next = E || null;
      }
  }
  return s = new Ra(s, n), s._enter = o, s._exit = l, s;
}
function _de(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function Ade() {
  return new Ra(this._exit || this._groups.map(dX), this._parents);
}
function Lde(t, e, r) {
  var n = this.enter(), i = this, a = this.exit();
  return typeof t == "function" ? (n = t(n), n && (n = n.selection())) : n = n.append(t + ""), e != null && (i = e(i), i && (i = i.selection())), r == null ? a.remove() : r(a), n && i ? n.merge(i).order() : i;
}
function Rde(t) {
  for (var e = t.selection ? t.selection() : t, r = this._groups, n = e._groups, i = r.length, a = n.length, s = Math.min(i, a), o = new Array(i), l = 0; l < s; ++l)
    for (var u = r[l], h = n[l], f = u.length, d = o[l] = new Array(f), p, g = 0; g < f; ++g)
      (p = u[g] || h[g]) && (d[g] = p);
  for (; l < i; ++l)
    o[l] = r[l];
  return new Ra(o, this._parents);
}
function Ide() {
  for (var t = this._groups, e = -1, r = t.length; ++e < r; )
    for (var n = t[e], i = n.length - 1, a = n[i], s; --i >= 0; )
      (s = n[i]) && (a && s.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(s, a), a = s);
  return this;
}
function Mde(t) {
  t || (t = Nde);
  function e(f, d) {
    return f && d ? t(f.__data__, d.__data__) : !f - !d;
  }
  for (var r = this._groups, n = r.length, i = new Array(n), a = 0; a < n; ++a) {
    for (var s = r[a], o = s.length, l = i[a] = new Array(o), u, h = 0; h < o; ++h)
      (u = s[h]) && (l[h] = u);
    l.sort(e);
  }
  return new Ra(i, this._parents).order();
}
function Nde(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Dde() {
  var t = arguments[0];
  return arguments[0] = this, t.apply(null, arguments), this;
}
function Ode() {
  return Array.from(this);
}
function Pde() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], i = 0, a = n.length; i < a; ++i) {
      var s = n[i];
      if (s) return s;
    }
  return null;
}
function $de() {
  let t = 0;
  for (const e of this) ++t;
  return t;
}
function Bde() {
  return !this.node();
}
function Fde(t) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var i = e[r], a = 0, s = i.length, o; a < s; ++a)
      (o = i[a]) && t.call(o, o.__data__, a, i);
  return this;
}
function zde(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function qde(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function Gde(t, e) {
  return function() {
    this.setAttribute(t, e);
  };
}
function Ude(t, e) {
  return function() {
    this.setAttributeNS(t.space, t.local, e);
  };
}
function Vde(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t) : this.setAttribute(t, r);
  };
}
function Hde(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, r);
  };
}
function Wde(t, e) {
  var r = Fx(t);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? qde : zde : typeof e == "function" ? r.local ? Hde : Vde : r.local ? Ude : Gde)(r, e));
}
function pX(t) {
  return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
}
function Yde(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function Xde(t, e, r) {
  return function() {
    this.style.setProperty(t, e, r);
  };
}
function jde(t, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t) : this.style.setProperty(t, n, r);
  };
}
function Kde(t, e, r) {
  return arguments.length > 1 ? this.each((e == null ? Yde : typeof e == "function" ? jde : Xde)(t, e, r ?? "")) : Yd(this.node(), t);
}
function Yd(t, e) {
  return t.style.getPropertyValue(e) || pX(t).getComputedStyle(t, null).getPropertyValue(e);
}
function Zde(t) {
  return function() {
    delete this[t];
  };
}
function Qde(t, e) {
  return function() {
    this[t] = e;
  };
}
function Jde(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t] : this[t] = r;
  };
}
function e0e(t, e) {
  return arguments.length > 1 ? this.each((e == null ? Zde : typeof e == "function" ? Jde : Qde)(t, e)) : this.node()[t];
}
function gX(t) {
  return t.trim().split(/^|\s+/);
}
function y9(t) {
  return t.classList || new mX(t);
}
function mX(t) {
  this._node = t, this._names = gX(t.getAttribute("class") || "");
}
mX.prototype = {
  add: function(t) {
    var e = this._names.indexOf(t);
    e < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t) {
    var e = this._names.indexOf(t);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t) {
    return this._names.indexOf(t) >= 0;
  }
};
function vX(t, e) {
  for (var r = y9(t), n = -1, i = e.length; ++n < i; ) r.add(e[n]);
}
function yX(t, e) {
  for (var r = y9(t), n = -1, i = e.length; ++n < i; ) r.remove(e[n]);
}
function t0e(t) {
  return function() {
    vX(this, t);
  };
}
function r0e(t) {
  return function() {
    yX(this, t);
  };
}
function n0e(t, e) {
  return function() {
    (e.apply(this, arguments) ? vX : yX)(this, t);
  };
}
function i0e(t, e) {
  var r = gX(t + "");
  if (arguments.length < 2) {
    for (var n = y9(this.node()), i = -1, a = r.length; ++i < a; ) if (!n.contains(r[i])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? n0e : e ? t0e : r0e)(r, e));
}
function a0e() {
  this.textContent = "";
}
function s0e(t) {
  return function() {
    this.textContent = t;
  };
}
function o0e(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function l0e(t) {
  return arguments.length ? this.each(t == null ? a0e : (typeof t == "function" ? o0e : s0e)(t)) : this.node().textContent;
}
function c0e() {
  this.innerHTML = "";
}
function u0e(t) {
  return function() {
    this.innerHTML = t;
  };
}
function h0e(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function f0e(t) {
  return arguments.length ? this.each(t == null ? c0e : (typeof t == "function" ? h0e : u0e)(t)) : this.node().innerHTML;
}
function d0e() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function p0e() {
  return this.each(d0e);
}
function g0e() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function m0e() {
  return this.each(g0e);
}
function v0e(t) {
  var e = typeof t == "function" ? t : cX(t);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function y0e() {
  return null;
}
function b0e(t, e) {
  var r = typeof t == "function" ? t : cX(t), n = e == null ? y0e : typeof e == "function" ? e : v9(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function x0e() {
  var t = this.parentNode;
  t && t.removeChild(this);
}
function w0e() {
  return this.each(x0e);
}
function T0e() {
  var t = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function E0e() {
  var t = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function S0e(t) {
  return this.select(t ? E0e : T0e);
}
function k0e(t) {
  return arguments.length ? this.property("__data__", t) : this.node().__data__;
}
function C0e(t) {
  return function(e) {
    t.call(this, e, this.__data__);
  };
}
function _0e(t) {
  return t.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function A0e(t) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, i = e.length, a; r < i; ++r)
        a = e[r], (!t.type || a.type === t.type) && a.name === t.name ? this.removeEventListener(a.type, a.listener, a.options) : e[++n] = a;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function L0e(t, e, r) {
  return function() {
    var n = this.__on, i, a = C0e(e);
    if (n) {
      for (var s = 0, o = n.length; s < o; ++s)
        if ((i = n[s]).type === t.type && i.name === t.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = a, i.options = r), i.value = e;
          return;
        }
    }
    this.addEventListener(t.type, a, r), i = { type: t.type, name: t.name, value: e, listener: a, options: r }, n ? n.push(i) : this.__on = [i];
  };
}
function R0e(t, e, r) {
  var n = _0e(t + ""), i, a = n.length, s;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, u = o.length, h; l < u; ++l)
        for (i = 0, h = o[l]; i < a; ++i)
          if ((s = n[i]).type === h.type && s.name === h.name)
            return h.value;
    }
    return;
  }
  for (o = e ? L0e : A0e, i = 0; i < a; ++i) this.each(o(n[i], e, r));
  return this;
}
function bX(t, e, r) {
  var n = pX(t), i = n.CustomEvent;
  typeof i == "function" ? i = new i(e, r) : (i = n.document.createEvent("Event"), r ? (i.initEvent(e, r.bubbles, r.cancelable), i.detail = r.detail) : i.initEvent(e, !1, !1)), t.dispatchEvent(i);
}
function I0e(t, e) {
  return function() {
    return bX(this, t, e);
  };
}
function M0e(t, e) {
  return function() {
    return bX(this, t, e.apply(this, arguments));
  };
}
function N0e(t, e) {
  return this.each((typeof e == "function" ? M0e : I0e)(t, e));
}
function* D0e() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], i = 0, a = n.length, s; i < a; ++i)
      (s = n[i]) && (yield s);
}
var xX = [null];
function Ra(t, e) {
  this._groups = t, this._parents = e;
}
function J1() {
  return new Ra([[document.documentElement]], xX);
}
function O0e() {
  return this;
}
Ra.prototype = J1.prototype = {
  constructor: Ra,
  select: ode,
  selectAll: hde,
  selectChild: gde,
  selectChildren: bde,
  filter: xde,
  data: Cde,
  enter: wde,
  exit: Ade,
  join: Lde,
  merge: Rde,
  selection: O0e,
  order: Ide,
  sort: Mde,
  call: Dde,
  nodes: Ode,
  node: Pde,
  size: $de,
  empty: Bde,
  each: Fde,
  attr: Wde,
  style: Kde,
  property: e0e,
  classed: i0e,
  text: l0e,
  html: f0e,
  raise: p0e,
  lower: m0e,
  append: v0e,
  insert: b0e,
  remove: w0e,
  clone: S0e,
  datum: k0e,
  on: R0e,
  dispatch: N0e,
  [Symbol.iterator]: D0e
};
function Qe(t) {
  return typeof t == "string" ? new Ra([[document.querySelector(t)]], [document.documentElement]) : new Ra([[t]], xX);
}
function em(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function zx(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function gh() {
}
var Kg = 0.7, M2 = 1 / Kg, Rf = "\\s*([+-]?\\d+)\\s*", Zg = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", co = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", P0e = /^#([0-9a-f]{3,8})$/, $0e = new RegExp(`^rgb\\(${Rf},${Rf},${Rf}\\)$`), B0e = new RegExp(`^rgb\\(${co},${co},${co}\\)$`), F0e = new RegExp(`^rgba\\(${Rf},${Rf},${Rf},${Zg}\\)$`), z0e = new RegExp(`^rgba\\(${co},${co},${co},${Zg}\\)$`), q0e = new RegExp(`^hsl\\(${Zg},${co},${co}\\)$`), G0e = new RegExp(`^hsla\\(${Zg},${co},${co},${Zg}\\)$`), GM = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
em(gh, Uu, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: UM,
  // Deprecated! Use color.formatHex.
  formatHex: UM,
  formatHex8: U0e,
  formatHsl: V0e,
  formatRgb: VM,
  toString: VM
});
function UM() {
  return this.rgb().formatHex();
}
function U0e() {
  return this.rgb().formatHex8();
}
function V0e() {
  return TX(this).formatHsl();
}
function VM() {
  return this.rgb().formatRgb();
}
function Uu(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = P0e.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? HM(e) : r === 3 ? new ki(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? nv(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? nv(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = $0e.exec(t)) ? new ki(e[1], e[2], e[3], 1) : (e = B0e.exec(t)) ? new ki(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = F0e.exec(t)) ? nv(e[1], e[2], e[3], e[4]) : (e = z0e.exec(t)) ? nv(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = q0e.exec(t)) ? XM(e[1], e[2] / 100, e[3] / 100, 1) : (e = G0e.exec(t)) ? XM(e[1], e[2] / 100, e[3] / 100, e[4]) : GM.hasOwnProperty(t) ? HM(GM[t]) : t === "transparent" ? new ki(NaN, NaN, NaN, 0) : null;
}
function HM(t) {
  return new ki(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function nv(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new ki(t, e, r, n);
}
function wX(t) {
  return t instanceof gh || (t = Uu(t)), t ? (t = t.rgb(), new ki(t.r, t.g, t.b, t.opacity)) : new ki();
}
function o_(t, e, r, n) {
  return arguments.length === 1 ? wX(t) : new ki(t, e, r, n ?? 1);
}
function ki(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
em(ki, o_, zx(gh, {
  brighter(t) {
    return t = t == null ? M2 : Math.pow(M2, t), new ki(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Kg : Math.pow(Kg, t), new ki(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new ki($u(this.r), $u(this.g), $u(this.b), N2(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: WM,
  // Deprecated! Use color.formatHex.
  formatHex: WM,
  formatHex8: H0e,
  formatRgb: YM,
  toString: YM
}));
function WM() {
  return `#${Lu(this.r)}${Lu(this.g)}${Lu(this.b)}`;
}
function H0e() {
  return `#${Lu(this.r)}${Lu(this.g)}${Lu(this.b)}${Lu((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function YM() {
  const t = N2(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${$u(this.r)}, ${$u(this.g)}, ${$u(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function N2(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function $u(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function Lu(t) {
  return t = $u(t), (t < 16 ? "0" : "") + t.toString(16);
}
function XM(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new Ts(t, e, r, n);
}
function TX(t) {
  if (t instanceof Ts) return new Ts(t.h, t.s, t.l, t.opacity);
  if (t instanceof gh || (t = Uu(t)), !t) return new Ts();
  if (t instanceof Ts) return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, i = Math.min(e, r, n), a = Math.max(e, r, n), s = NaN, o = a - i, l = (a + i) / 2;
  return o ? (e === a ? s = (r - n) / o + (r < n) * 6 : r === a ? s = (n - e) / o + 2 : s = (e - r) / o + 4, o /= l < 0.5 ? a + i : 2 - a - i, s *= 60) : o = l > 0 && l < 1 ? 0 : s, new Ts(s, o, l, t.opacity);
}
function W0e(t, e, r, n) {
  return arguments.length === 1 ? TX(t) : new Ts(t, e, r, n ?? 1);
}
function Ts(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
em(Ts, W0e, zx(gh, {
  brighter(t) {
    return t = t == null ? M2 : Math.pow(M2, t), new Ts(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Kg : Math.pow(Kg, t), new Ts(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new ki(
      y5(t >= 240 ? t - 240 : t + 120, i, n),
      y5(t, i, n),
      y5(t < 120 ? t + 240 : t - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new Ts(jM(this.h), iv(this.s), iv(this.l), N2(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = N2(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${jM(this.h)}, ${iv(this.s) * 100}%, ${iv(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function jM(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function iv(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function y5(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const Y0e = Math.PI / 180, X0e = 180 / Math.PI, D2 = 18, EX = 0.96422, SX = 1, kX = 0.82521, CX = 4 / 29, If = 6 / 29, _X = 3 * If * If, j0e = If * If * If;
function AX(t) {
  if (t instanceof uo) return new uo(t.l, t.a, t.b, t.opacity);
  if (t instanceof Zo) return LX(t);
  t instanceof ki || (t = wX(t));
  var e = T5(t.r), r = T5(t.g), n = T5(t.b), i = b5((0.2225045 * e + 0.7168786 * r + 0.0606169 * n) / SX), a, s;
  return e === r && r === n ? a = s = i : (a = b5((0.4360747 * e + 0.3850649 * r + 0.1430804 * n) / EX), s = b5((0.0139322 * e + 0.0971045 * r + 0.7141733 * n) / kX)), new uo(116 * i - 16, 500 * (a - i), 200 * (i - s), t.opacity);
}
function K0e(t, e, r, n) {
  return arguments.length === 1 ? AX(t) : new uo(t, e, r, n ?? 1);
}
function uo(t, e, r, n) {
  this.l = +t, this.a = +e, this.b = +r, this.opacity = +n;
}
em(uo, K0e, zx(gh, {
  brighter(t) {
    return new uo(this.l + D2 * (t ?? 1), this.a, this.b, this.opacity);
  },
  darker(t) {
    return new uo(this.l - D2 * (t ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var t = (this.l + 16) / 116, e = isNaN(this.a) ? t : t + this.a / 500, r = isNaN(this.b) ? t : t - this.b / 200;
    return e = EX * x5(e), t = SX * x5(t), r = kX * x5(r), new ki(
      w5(3.1338561 * e - 1.6168667 * t - 0.4906146 * r),
      w5(-0.9787684 * e + 1.9161415 * t + 0.033454 * r),
      w5(0.0719453 * e - 0.2289914 * t + 1.4052427 * r),
      this.opacity
    );
  }
}));
function b5(t) {
  return t > j0e ? Math.pow(t, 1 / 3) : t / _X + CX;
}
function x5(t) {
  return t > If ? t * t * t : _X * (t - CX);
}
function w5(t) {
  return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function T5(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function Z0e(t) {
  if (t instanceof Zo) return new Zo(t.h, t.c, t.l, t.opacity);
  if (t instanceof uo || (t = AX(t)), t.a === 0 && t.b === 0) return new Zo(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var e = Math.atan2(t.b, t.a) * X0e;
  return new Zo(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function l_(t, e, r, n) {
  return arguments.length === 1 ? Z0e(t) : new Zo(t, e, r, n ?? 1);
}
function Zo(t, e, r, n) {
  this.h = +t, this.c = +e, this.l = +r, this.opacity = +n;
}
function LX(t) {
  if (isNaN(t.h)) return new uo(t.l, 0, 0, t.opacity);
  var e = t.h * Y0e;
  return new uo(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
}
em(Zo, l_, zx(gh, {
  brighter(t) {
    return new Zo(this.h, this.c, this.l + D2 * (t ?? 1), this.opacity);
  },
  darker(t) {
    return new Zo(this.h, this.c, this.l - D2 * (t ?? 1), this.opacity);
  },
  rgb() {
    return LX(this).rgb();
  }
}));
const qx = (t) => () => t;
function RX(t, e) {
  return function(r) {
    return t + r * e;
  };
}
function Q0e(t, e, r) {
  return t = Math.pow(t, r), e = Math.pow(e, r) - t, r = 1 / r, function(n) {
    return Math.pow(t + n * e, r);
  };
}
function J0e(t, e) {
  var r = e - t;
  return r ? RX(t, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : qx(isNaN(t) ? e : t);
}
function epe(t) {
  return (t = +t) == 1 ? Pg : function(e, r) {
    return r - e ? Q0e(e, r, t) : qx(isNaN(e) ? r : e);
  };
}
function Pg(t, e) {
  var r = e - t;
  return r ? RX(t, r) : qx(isNaN(t) ? e : t);
}
const O2 = (function t(e) {
  var r = epe(e);
  function n(i, a) {
    var s = r((i = o_(i)).r, (a = o_(a)).r), o = r(i.g, a.g), l = r(i.b, a.b), u = Pg(i.opacity, a.opacity);
    return function(h) {
      return i.r = s(h), i.g = o(h), i.b = l(h), i.opacity = u(h), i + "";
    };
  }
  return n.gamma = t, n;
})(1);
function tpe(t, e) {
  e || (e = []);
  var r = t ? Math.min(e.length, t.length) : 0, n = e.slice(), i;
  return function(a) {
    for (i = 0; i < r; ++i) n[i] = t[i] * (1 - a) + e[i] * a;
    return n;
  };
}
function rpe(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function npe(t, e) {
  var r = e ? e.length : 0, n = t ? Math.min(r, t.length) : 0, i = new Array(n), a = new Array(r), s;
  for (s = 0; s < n; ++s) i[s] = b9(t[s], e[s]);
  for (; s < r; ++s) a[s] = e[s];
  return function(o) {
    for (s = 0; s < n; ++s) a[s] = i[s](o);
    return a;
  };
}
function ipe(t, e) {
  var r = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(n) {
    return r.setTime(t * (1 - n) + e * n), r;
  };
}
function bs(t, e) {
  return t = +t, e = +e, function(r) {
    return t * (1 - r) + e * r;
  };
}
function ape(t, e) {
  var r = {}, n = {}, i;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (i in e)
    i in t ? r[i] = b9(t[i], e[i]) : n[i] = e[i];
  return function(a) {
    for (i in r) n[i] = r[i](a);
    return n;
  };
}
var c_ = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, E5 = new RegExp(c_.source, "g");
function spe(t) {
  return function() {
    return t;
  };
}
function ope(t) {
  return function(e) {
    return t(e) + "";
  };
}
function IX(t, e) {
  var r = c_.lastIndex = E5.lastIndex = 0, n, i, a, s = -1, o = [], l = [];
  for (t = t + "", e = e + ""; (n = c_.exec(t)) && (i = E5.exec(e)); )
    (a = i.index) > r && (a = e.slice(r, a), o[s] ? o[s] += a : o[++s] = a), (n = n[0]) === (i = i[0]) ? o[s] ? o[s] += i : o[++s] = i : (o[++s] = null, l.push({ i: s, x: bs(n, i) })), r = E5.lastIndex;
  return r < e.length && (a = e.slice(r), o[s] ? o[s] += a : o[++s] = a), o.length < 2 ? l[0] ? ope(l[0].x) : spe(e) : (e = l.length, function(u) {
    for (var h = 0, f; h < e; ++h) o[(f = l[h]).i] = f.x(u);
    return o.join("");
  });
}
function b9(t, e) {
  var r = typeof e, n;
  return e == null || r === "boolean" ? qx(e) : (r === "number" ? bs : r === "string" ? (n = Uu(e)) ? (e = n, O2) : IX : e instanceof Uu ? O2 : e instanceof Date ? ipe : rpe(e) ? tpe : Array.isArray(e) ? npe : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? ape : bs)(t, e);
}
function lpe(t, e) {
  return t = +t, e = +e, function(r) {
    return Math.round(t * (1 - r) + e * r);
  };
}
var KM = 180 / Math.PI, u_ = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function MX(t, e, r, n, i, a) {
  var s, o, l;
  return (s = Math.sqrt(t * t + e * e)) && (t /= s, e /= s), (l = t * r + e * n) && (r -= t * l, n -= e * l), (o = Math.sqrt(r * r + n * n)) && (r /= o, n /= o, l /= o), t * n < e * r && (t = -t, e = -e, l = -l, s = -s), {
    translateX: i,
    translateY: a,
    rotate: Math.atan2(e, t) * KM,
    skewX: Math.atan(l) * KM,
    scaleX: s,
    scaleY: o
  };
}
var av;
function cpe(t) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t + "");
  return e.isIdentity ? u_ : MX(e.a, e.b, e.c, e.d, e.e, e.f);
}
function upe(t) {
  return t == null || (av || (av = document.createElementNS("http://www.w3.org/2000/svg", "g")), av.setAttribute("transform", t), !(t = av.transform.baseVal.consolidate())) ? u_ : (t = t.matrix, MX(t.a, t.b, t.c, t.d, t.e, t.f));
}
function NX(t, e, r, n) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function a(u, h, f, d, p, g) {
    if (u !== f || h !== d) {
      var m = p.push("translate(", null, e, null, r);
      g.push({ i: m - 4, x: bs(u, f) }, { i: m - 2, x: bs(h, d) });
    } else (f || d) && p.push("translate(" + f + e + d + r);
  }
  function s(u, h, f, d) {
    u !== h ? (u - h > 180 ? h += 360 : h - u > 180 && (u += 360), d.push({ i: f.push(i(f) + "rotate(", null, n) - 2, x: bs(u, h) })) : h && f.push(i(f) + "rotate(" + h + n);
  }
  function o(u, h, f, d) {
    u !== h ? d.push({ i: f.push(i(f) + "skewX(", null, n) - 2, x: bs(u, h) }) : h && f.push(i(f) + "skewX(" + h + n);
  }
  function l(u, h, f, d, p, g) {
    if (u !== f || h !== d) {
      var m = p.push(i(p) + "scale(", null, ",", null, ")");
      g.push({ i: m - 4, x: bs(u, f) }, { i: m - 2, x: bs(h, d) });
    } else (f !== 1 || d !== 1) && p.push(i(p) + "scale(" + f + "," + d + ")");
  }
  return function(u, h) {
    var f = [], d = [];
    return u = t(u), h = t(h), a(u.translateX, u.translateY, h.translateX, h.translateY, f, d), s(u.rotate, h.rotate, f, d), o(u.skewX, h.skewX, f, d), l(u.scaleX, u.scaleY, h.scaleX, h.scaleY, f, d), u = h = null, function(p) {
      for (var g = -1, m = d.length, v; ++g < m; ) f[(v = d[g]).i] = v.x(p);
      return f.join("");
    };
  };
}
var hpe = NX(cpe, "px, ", "px)", "deg)"), fpe = NX(upe, ", ", ")", ")");
function dpe(t) {
  return function(e, r) {
    var n = t((e = l_(e)).h, (r = l_(r)).h), i = Pg(e.c, r.c), a = Pg(e.l, r.l), s = Pg(e.opacity, r.opacity);
    return function(o) {
      return e.h = n(o), e.c = i(o), e.l = a(o), e.opacity = s(o), e + "";
    };
  };
}
const ppe = dpe(J0e);
var Xd = 0, Lp = 0, np = 0, DX = 1e3, P2, Rp, $2 = 0, Vu = 0, Gx = 0, Qg = typeof performance == "object" && performance.now ? performance : Date, OX = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
  setTimeout(t, 17);
};
function x9() {
  return Vu || (OX(gpe), Vu = Qg.now() + Gx);
}
function gpe() {
  Vu = 0;
}
function B2() {
  this._call = this._time = this._next = null;
}
B2.prototype = PX.prototype = {
  constructor: B2,
  restart: function(t, e, r) {
    if (typeof t != "function") throw new TypeError("callback is not a function");
    r = (r == null ? x9() : +r) + (e == null ? 0 : +e), !this._next && Rp !== this && (Rp ? Rp._next = this : P2 = this, Rp = this), this._call = t, this._time = r, h_();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, h_());
  }
};
function PX(t, e, r) {
  var n = new B2();
  return n.restart(t, e, r), n;
}
function mpe() {
  x9(), ++Xd;
  for (var t = P2, e; t; )
    (e = Vu - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
  --Xd;
}
function ZM() {
  Vu = ($2 = Qg.now()) + Gx, Xd = Lp = 0;
  try {
    mpe();
  } finally {
    Xd = 0, ype(), Vu = 0;
  }
}
function vpe() {
  var t = Qg.now(), e = t - $2;
  e > DX && (Gx -= e, $2 = t);
}
function ype() {
  for (var t, e = P2, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t = e, e = e._next) : (r = e._next, e._next = null, e = t ? t._next = r : P2 = r);
  Rp = t, h_(n);
}
function h_(t) {
  if (!Xd) {
    Lp && (Lp = clearTimeout(Lp));
    var e = t - Vu;
    e > 24 ? (t < 1 / 0 && (Lp = setTimeout(ZM, t - Qg.now() - Gx)), np && (np = clearInterval(np))) : (np || ($2 = Qg.now(), np = setInterval(vpe, DX)), Xd = 1, OX(ZM));
  }
}
function QM(t, e, r) {
  var n = new B2();
  return e = e == null ? 0 : +e, n.restart((i) => {
    n.stop(), t(i + e);
  }, e, r), n;
}
var bpe = lX("start", "end", "cancel", "interrupt"), xpe = [], $X = 0, JM = 1, f_ = 2, Ey = 3, eN = 4, d_ = 5, Sy = 6;
function Ux(t, e, r, n, i, a) {
  var s = t.__transition;
  if (!s) t.__transition = {};
  else if (r in s) return;
  wpe(t, r, {
    name: e,
    index: n,
    // For context during callback.
    group: i,
    // For context during callback.
    on: bpe,
    tween: xpe,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: $X
  });
}
function w9(t, e) {
  var r = Bs(t, e);
  if (r.state > $X) throw new Error("too late; already scheduled");
  return r;
}
function xo(t, e) {
  var r = Bs(t, e);
  if (r.state > Ey) throw new Error("too late; already running");
  return r;
}
function Bs(t, e) {
  var r = t.__transition;
  if (!r || !(r = r[e])) throw new Error("transition not found");
  return r;
}
function wpe(t, e, r) {
  var n = t.__transition, i;
  n[e] = r, r.timer = PX(a, 0, r.time);
  function a(u) {
    r.state = JM, r.timer.restart(s, r.delay, r.time), r.delay <= u && s(u - r.delay);
  }
  function s(u) {
    var h, f, d, p;
    if (r.state !== JM) return l();
    for (h in n)
      if (p = n[h], p.name === r.name) {
        if (p.state === Ey) return QM(s);
        p.state === eN ? (p.state = Sy, p.timer.stop(), p.on.call("interrupt", t, t.__data__, p.index, p.group), delete n[h]) : +h < e && (p.state = Sy, p.timer.stop(), p.on.call("cancel", t, t.__data__, p.index, p.group), delete n[h]);
      }
    if (QM(function() {
      r.state === Ey && (r.state = eN, r.timer.restart(o, r.delay, r.time), o(u));
    }), r.state = f_, r.on.call("start", t, t.__data__, r.index, r.group), r.state === f_) {
      for (r.state = Ey, i = new Array(d = r.tween.length), h = 0, f = -1; h < d; ++h)
        (p = r.tween[h].value.call(t, t.__data__, r.index, r.group)) && (i[++f] = p);
      i.length = f + 1;
    }
  }
  function o(u) {
    for (var h = u < r.duration ? r.ease.call(null, u / r.duration) : (r.timer.restart(l), r.state = d_, 1), f = -1, d = i.length; ++f < d; )
      i[f].call(t, h);
    r.state === d_ && (r.on.call("end", t, t.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = Sy, r.timer.stop(), delete n[e];
    for (var u in n) return;
    delete t.__transition;
  }
}
function Tpe(t, e) {
  var r = t.__transition, n, i, a = !0, s;
  if (r) {
    e = e == null ? null : e + "";
    for (s in r) {
      if ((n = r[s]).name !== e) {
        a = !1;
        continue;
      }
      i = n.state > f_ && n.state < d_, n.state = Sy, n.timer.stop(), n.on.call(i ? "interrupt" : "cancel", t, t.__data__, n.index, n.group), delete r[s];
    }
    a && delete t.__transition;
  }
}
function Epe(t) {
  return this.each(function() {
    Tpe(this, t);
  });
}
function Spe(t, e) {
  var r, n;
  return function() {
    var i = xo(this, t), a = i.tween;
    if (a !== r) {
      n = r = a;
      for (var s = 0, o = n.length; s < o; ++s)
        if (n[s].name === e) {
          n = n.slice(), n.splice(s, 1);
          break;
        }
    }
    i.tween = n;
  };
}
function kpe(t, e, r) {
  var n, i;
  if (typeof r != "function") throw new Error();
  return function() {
    var a = xo(this, t), s = a.tween;
    if (s !== n) {
      i = (n = s).slice();
      for (var o = { name: e, value: r }, l = 0, u = i.length; l < u; ++l)
        if (i[l].name === e) {
          i[l] = o;
          break;
        }
      l === u && i.push(o);
    }
    a.tween = i;
  };
}
function Cpe(t, e) {
  var r = this._id;
  if (t += "", arguments.length < 2) {
    for (var n = Bs(this.node(), r).tween, i = 0, a = n.length, s; i < a; ++i)
      if ((s = n[i]).name === t)
        return s.value;
    return null;
  }
  return this.each((e == null ? Spe : kpe)(r, t, e));
}
function T9(t, e, r) {
  var n = t._id;
  return t.each(function() {
    var i = xo(this, n);
    (i.value || (i.value = {}))[e] = r.apply(this, arguments);
  }), function(i) {
    return Bs(i, n).value[e];
  };
}
function BX(t, e) {
  var r;
  return (typeof e == "number" ? bs : e instanceof Uu ? O2 : (r = Uu(e)) ? (e = r, O2) : IX)(t, e);
}
function _pe(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function Ape(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function Lpe(t, e, r) {
  var n, i = r + "", a;
  return function() {
    var s = this.getAttribute(t);
    return s === i ? null : s === n ? a : a = e(n = s, r);
  };
}
function Rpe(t, e, r) {
  var n, i = r + "", a;
  return function() {
    var s = this.getAttributeNS(t.space, t.local);
    return s === i ? null : s === n ? a : a = e(n = s, r);
  };
}
function Ipe(t, e, r) {
  var n, i, a;
  return function() {
    var s, o = r(this), l;
    return o == null ? void this.removeAttribute(t) : (s = this.getAttribute(t), l = o + "", s === l ? null : s === n && l === i ? a : (i = l, a = e(n = s, o)));
  };
}
function Mpe(t, e, r) {
  var n, i, a;
  return function() {
    var s, o = r(this), l;
    return o == null ? void this.removeAttributeNS(t.space, t.local) : (s = this.getAttributeNS(t.space, t.local), l = o + "", s === l ? null : s === n && l === i ? a : (i = l, a = e(n = s, o)));
  };
}
function Npe(t, e) {
  var r = Fx(t), n = r === "transform" ? fpe : BX;
  return this.attrTween(t, typeof e == "function" ? (r.local ? Mpe : Ipe)(r, n, T9(this, "attr." + t, e)) : e == null ? (r.local ? Ape : _pe)(r) : (r.local ? Rpe : Lpe)(r, n, e));
}
function Dpe(t, e) {
  return function(r) {
    this.setAttribute(t, e.call(this, r));
  };
}
function Ope(t, e) {
  return function(r) {
    this.setAttributeNS(t.space, t.local, e.call(this, r));
  };
}
function Ppe(t, e) {
  var r, n;
  function i() {
    var a = e.apply(this, arguments);
    return a !== n && (r = (n = a) && Ope(t, a)), r;
  }
  return i._value = e, i;
}
function $pe(t, e) {
  var r, n;
  function i() {
    var a = e.apply(this, arguments);
    return a !== n && (r = (n = a) && Dpe(t, a)), r;
  }
  return i._value = e, i;
}
function Bpe(t, e) {
  var r = "attr." + t;
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  var n = Fx(t);
  return this.tween(r, (n.local ? Ppe : $pe)(n, e));
}
function Fpe(t, e) {
  return function() {
    w9(this, t).delay = +e.apply(this, arguments);
  };
}
function zpe(t, e) {
  return e = +e, function() {
    w9(this, t).delay = e;
  };
}
function qpe(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? Fpe : zpe)(e, t)) : Bs(this.node(), e).delay;
}
function Gpe(t, e) {
  return function() {
    xo(this, t).duration = +e.apply(this, arguments);
  };
}
function Upe(t, e) {
  return e = +e, function() {
    xo(this, t).duration = e;
  };
}
function Vpe(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? Gpe : Upe)(e, t)) : Bs(this.node(), e).duration;
}
function Hpe(t, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    xo(this, t).ease = e;
  };
}
function Wpe(t) {
  var e = this._id;
  return arguments.length ? this.each(Hpe(e, t)) : Bs(this.node(), e).ease;
}
function Ype(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function") throw new Error();
    xo(this, t).ease = r;
  };
}
function Xpe(t) {
  if (typeof t != "function") throw new Error();
  return this.each(Ype(this._id, t));
}
function jpe(t) {
  typeof t != "function" && (t = hX(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var a = e[i], s = a.length, o = n[i] = [], l, u = 0; u < s; ++u)
      (l = a[u]) && t.call(l, l.__data__, u, a) && o.push(l);
  return new hl(n, this._parents, this._name, this._id);
}
function Kpe(t) {
  if (t._id !== this._id) throw new Error();
  for (var e = this._groups, r = t._groups, n = e.length, i = r.length, a = Math.min(n, i), s = new Array(n), o = 0; o < a; ++o)
    for (var l = e[o], u = r[o], h = l.length, f = s[o] = new Array(h), d, p = 0; p < h; ++p)
      (d = l[p] || u[p]) && (f[p] = d);
  for (; o < n; ++o)
    s[o] = e[o];
  return new hl(s, this._parents, this._name, this._id);
}
function Zpe(t) {
  return (t + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function Qpe(t, e, r) {
  var n, i, a = Zpe(e) ? w9 : xo;
  return function() {
    var s = a(this, t), o = s.on;
    o !== n && (i = (n = o).copy()).on(e, r), s.on = i;
  };
}
function Jpe(t, e) {
  var r = this._id;
  return arguments.length < 2 ? Bs(this.node(), r).on.on(t) : this.each(Qpe(r, t, e));
}
function ege(t) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition) if (+r !== t) return;
    e && e.removeChild(this);
  };
}
function tge() {
  return this.on("end.remove", ege(this._id));
}
function rge(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = v9(t));
  for (var n = this._groups, i = n.length, a = new Array(i), s = 0; s < i; ++s)
    for (var o = n[s], l = o.length, u = a[s] = new Array(l), h, f, d = 0; d < l; ++d)
      (h = o[d]) && (f = t.call(h, h.__data__, d, o)) && ("__data__" in h && (f.__data__ = h.__data__), u[d] = f, Ux(u[d], e, r, d, u, Bs(h, r)));
  return new hl(a, this._parents, e, r);
}
function nge(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = uX(t));
  for (var n = this._groups, i = n.length, a = [], s = [], o = 0; o < i; ++o)
    for (var l = n[o], u = l.length, h, f = 0; f < u; ++f)
      if (h = l[f]) {
        for (var d = t.call(h, h.__data__, f, l), p, g = Bs(h, r), m = 0, v = d.length; m < v; ++m)
          (p = d[m]) && Ux(p, e, r, m, d, g);
        a.push(d), s.push(h);
      }
  return new hl(a, s, e, r);
}
var ige = J1.prototype.constructor;
function age() {
  return new ige(this._groups, this._parents);
}
function sge(t, e) {
  var r, n, i;
  return function() {
    var a = Yd(this, t), s = (this.style.removeProperty(t), Yd(this, t));
    return a === s ? null : a === r && s === n ? i : i = e(r = a, n = s);
  };
}
function FX(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function oge(t, e, r) {
  var n, i = r + "", a;
  return function() {
    var s = Yd(this, t);
    return s === i ? null : s === n ? a : a = e(n = s, r);
  };
}
function lge(t, e, r) {
  var n, i, a;
  return function() {
    var s = Yd(this, t), o = r(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(t), Yd(this, t))), s === l ? null : s === n && l === i ? a : (i = l, a = e(n = s, o));
  };
}
function cge(t, e) {
  var r, n, i, a = "style." + e, s = "end." + a, o;
  return function() {
    var l = xo(this, t), u = l.on, h = l.value[a] == null ? o || (o = FX(e)) : void 0;
    (u !== r || i !== h) && (n = (r = u).copy()).on(s, i = h), l.on = n;
  };
}
function uge(t, e, r) {
  var n = (t += "") == "transform" ? hpe : BX;
  return e == null ? this.styleTween(t, sge(t, n)).on("end.style." + t, FX(t)) : typeof e == "function" ? this.styleTween(t, lge(t, n, T9(this, "style." + t, e))).each(cge(this._id, t)) : this.styleTween(t, oge(t, n, e), r).on("end.style." + t, null);
}
function hge(t, e, r) {
  return function(n) {
    this.style.setProperty(t, e.call(this, n), r);
  };
}
function fge(t, e, r) {
  var n, i;
  function a() {
    var s = e.apply(this, arguments);
    return s !== i && (n = (i = s) && hge(t, s, r)), n;
  }
  return a._value = e, a;
}
function dge(t, e, r) {
  var n = "style." + (t += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, fge(t, e, r ?? ""));
}
function pge(t) {
  return function() {
    this.textContent = t;
  };
}
function gge(t) {
  return function() {
    var e = t(this);
    this.textContent = e ?? "";
  };
}
function mge(t) {
  return this.tween("text", typeof t == "function" ? gge(T9(this, "text", t)) : pge(t == null ? "" : t + ""));
}
function vge(t) {
  return function(e) {
    this.textContent = t.call(this, e);
  };
}
function yge(t) {
  var e, r;
  function n() {
    var i = t.apply(this, arguments);
    return i !== r && (e = (r = i) && vge(i)), e;
  }
  return n._value = t, n;
}
function bge(t) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t == null) return this.tween(e, null);
  if (typeof t != "function") throw new Error();
  return this.tween(e, yge(t));
}
function xge() {
  for (var t = this._name, e = this._id, r = zX(), n = this._groups, i = n.length, a = 0; a < i; ++a)
    for (var s = n[a], o = s.length, l, u = 0; u < o; ++u)
      if (l = s[u]) {
        var h = Bs(l, e);
        Ux(l, t, r, u, s, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new hl(n, this._parents, t, r);
}
function wge() {
  var t, e, r = this, n = r._id, i = r.size();
  return new Promise(function(a, s) {
    var o = { value: s }, l = { value: function() {
      --i === 0 && a();
    } };
    r.each(function() {
      var u = xo(this, n), h = u.on;
      h !== t && (e = (t = h).copy(), e._.cancel.push(o), e._.interrupt.push(o), e._.end.push(l)), u.on = e;
    }), i === 0 && a();
  });
}
var Tge = 0;
function hl(t, e, r, n) {
  this._groups = t, this._parents = e, this._name = r, this._id = n;
}
function zX() {
  return ++Tge;
}
var $o = J1.prototype;
hl.prototype = {
  constructor: hl,
  select: rge,
  selectAll: nge,
  selectChild: $o.selectChild,
  selectChildren: $o.selectChildren,
  filter: jpe,
  merge: Kpe,
  selection: age,
  transition: xge,
  call: $o.call,
  nodes: $o.nodes,
  node: $o.node,
  size: $o.size,
  empty: $o.empty,
  each: $o.each,
  on: Jpe,
  attr: Npe,
  attrTween: Bpe,
  style: uge,
  styleTween: dge,
  text: mge,
  textTween: bge,
  remove: tge,
  tween: Cpe,
  delay: qpe,
  duration: Vpe,
  ease: Wpe,
  easeVarying: Xpe,
  end: wge,
  [Symbol.iterator]: $o[Symbol.iterator]
};
function Ege(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var Sge = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Ege
};
function kge(t, e) {
  for (var r; !(r = t.__transition) || !(r = r[e]); )
    if (!(t = t.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function Cge(t) {
  var e, r;
  t instanceof hl ? (e = t._id, t = t._name) : (e = zX(), (r = Sge).time = x9(), t = t == null ? null : t + "");
  for (var n = this._groups, i = n.length, a = 0; a < i; ++a)
    for (var s = n[a], o = s.length, l, u = 0; u < o; ++u)
      (l = s[u]) && Ux(l, t, e, u, s, r || kge(l, e));
  return new hl(n, this._parents, t, e);
}
J1.prototype.interrupt = Epe;
J1.prototype.transition = Cge;
const p_ = Math.PI, g_ = 2 * p_, vu = 1e-6, _ge = g_ - vu;
function qX(t) {
  this._ += t[0];
  for (let e = 1, r = t.length; e < r; ++e)
    this._ += arguments[e] + t[e];
}
function Age(t) {
  let e = Math.floor(t);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t}`);
  if (e > 15) return qX;
  const r = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let i = 1, a = n.length; i < a; ++i)
      this._ += Math.round(arguments[i] * r) / r + n[i];
  };
}
let Lge = class {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? qX : Age(e);
  }
  moveTo(e, r) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, r) {
    this._append`L${this._x1 = +e},${this._y1 = +r}`;
  }
  quadraticCurveTo(e, r, n, i) {
    this._append`Q${+e},${+r},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(e, r, n, i, a, s) {
    this._append`C${+e},${+r},${+n},${+i},${this._x1 = +a},${this._y1 = +s}`;
  }
  arcTo(e, r, n, i, a) {
    if (e = +e, r = +r, n = +n, i = +i, a = +a, a < 0) throw new Error(`negative radius: ${a}`);
    let s = this._x1, o = this._y1, l = n - e, u = i - r, h = s - e, f = o - r, d = h * h + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = r}`;
    else if (d > vu) if (!(Math.abs(f * l - u * h) > vu) || !a)
      this._append`L${this._x1 = e},${this._y1 = r}`;
    else {
      let p = n - s, g = i - o, m = l * l + u * u, v = p * p + g * g, y = Math.sqrt(m), b = Math.sqrt(d), x = a * Math.tan((p_ - Math.acos((m + d - v) / (2 * y * b))) / 2), T = x / b, E = x / y;
      Math.abs(T - 1) > vu && this._append`L${e + T * h},${r + T * f}`, this._append`A${a},${a},0,0,${+(f * p > h * g)},${this._x1 = e + E * l},${this._y1 = r + E * u}`;
    }
  }
  arc(e, r, n, i, a, s) {
    if (e = +e, r = +r, n = +n, s = !!s, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(i), l = n * Math.sin(i), u = e + o, h = r + l, f = 1 ^ s, d = s ? i - a : a - i;
    this._x1 === null ? this._append`M${u},${h}` : (Math.abs(this._x1 - u) > vu || Math.abs(this._y1 - h) > vu) && this._append`L${u},${h}`, n && (d < 0 && (d = d % g_ + g_), d > _ge ? this._append`A${n},${n},0,1,${f},${e - o},${r - l}A${n},${n},0,1,${f},${this._x1 = u},${this._y1 = h}` : d > vu && this._append`A${n},${n},0,${+(d >= p_)},${f},${this._x1 = e + n * Math.cos(a)},${this._y1 = r + n * Math.sin(a)}`);
  }
  rect(e, r, n, i) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function Rge(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function F2(t, e) {
  if (!isFinite(t) || t === 0) return null;
  var r = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e"), n = t.slice(0, r);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +t.slice(r + 1)
  ];
}
function jd(t) {
  return t = F2(Math.abs(t)), t ? t[1] : NaN;
}
function Ige(t, e) {
  return function(r, n) {
    for (var i = r.length, a = [], s = 0, o = t[0], l = 0; i > 0 && o > 0 && (l + o + 1 > n && (o = Math.max(1, n - l)), a.push(r.substring(i -= o, i + o)), !((l += o + 1) > n)); )
      o = t[s = (s + 1) % t.length];
    return a.reverse().join(e);
  };
}
function Mge(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(r) {
      return t[+r];
    });
  };
}
var Nge = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function z2(t) {
  if (!(e = Nge.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new E9({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
z2.prototype = E9.prototype;
function E9(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
E9.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Dge(t) {
  e: for (var e = t.length, r = 1, n = -1, i; r < e; ++r)
    switch (t[r]) {
      case ".":
        n = i = r;
        break;
      case "0":
        n === 0 && (n = r), i = r;
        break;
      default:
        if (!+t[r]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? t.slice(0, n) + t.slice(i + 1) : t;
}
var q2;
function Oge(t, e) {
  var r = F2(t, e);
  if (!r) return q2 = void 0, t.toPrecision(e);
  var n = r[0], i = r[1], a = i - (q2 = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, s = n.length;
  return a === s ? n : a > s ? n + new Array(a - s + 1).join("0") : a > 0 ? n.slice(0, a) + "." + n.slice(a) : "0." + new Array(1 - a).join("0") + F2(t, Math.max(0, e + a - 1))[0];
}
function tN(t, e) {
  var r = F2(t, e);
  if (!r) return t + "";
  var n = r[0], i = r[1];
  return i < 0 ? "0." + new Array(-i).join("0") + n : n.length > i + 1 ? n.slice(0, i + 1) + "." + n.slice(i + 1) : n + new Array(i - n.length + 2).join("0");
}
const rN = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: Rge,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => tN(t * 100, e),
  r: tN,
  s: Oge,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function nN(t) {
  return t;
}
var iN = Array.prototype.map, aN = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Pge(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? nN : Ige(iN.call(t.grouping, Number), t.thousands + ""), r = t.currency === void 0 ? "" : t.currency[0] + "", n = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", a = t.numerals === void 0 ? nN : Mge(iN.call(t.numerals, String)), s = t.percent === void 0 ? "%" : t.percent + "", o = t.minus === void 0 ? "\u2212" : t.minus + "", l = t.nan === void 0 ? "NaN" : t.nan + "";
  function u(f, d) {
    f = z2(f);
    var p = f.fill, g = f.align, m = f.sign, v = f.symbol, y = f.zero, b = f.width, x = f.comma, T = f.precision, E = f.trim, A = f.type;
    A === "n" ? (x = !0, A = "g") : rN[A] || (T === void 0 && (T = 12), E = !0, A = "g"), (y || p === "0" && g === "=") && (y = !0, p = "0", g = "=");
    var S = (d && d.prefix !== void 0 ? d.prefix : "") + (v === "$" ? r : v === "#" && /[boxX]/.test(A) ? "0" + A.toLowerCase() : ""), k = (v === "$" ? n : /[%p]/.test(A) ? s : "") + (d && d.suffix !== void 0 ? d.suffix : ""), _ = rN[A], R = /[defgprs%]/.test(A);
    T = T === void 0 ? 6 : /[gprs]/.test(A) ? Math.max(1, Math.min(21, T)) : Math.max(0, Math.min(20, T));
    function L(M) {
      var P = S, C = k, I, N, O;
      if (A === "c")
        C = _(M) + C, M = "";
      else {
        M = +M;
        var D = M < 0 || 1 / M < 0;
        if (M = isNaN(M) ? l : _(Math.abs(M), T), E && (M = Dge(M)), D && +M == 0 && m !== "+" && (D = !1), P = (D ? m === "(" ? m : o : m === "-" || m === "(" ? "" : m) + P, C = (A === "s" && !isNaN(M) && q2 !== void 0 ? aN[8 + q2 / 3] : "") + C + (D && m === "(" ? ")" : ""), R) {
          for (I = -1, N = M.length; ++I < N; )
            if (O = M.charCodeAt(I), 48 > O || O > 57) {
              C = (O === 46 ? i + M.slice(I + 1) : M.slice(I)) + C, M = M.slice(0, I);
              break;
            }
        }
      }
      x && !y && (M = e(M, 1 / 0));
      var $ = P.length + M.length + C.length, z = $ < b ? new Array(b - $ + 1).join(p) : "";
      switch (x && y && (M = e(z + M, z.length ? b - C.length : 1 / 0), z = ""), g) {
        case "<":
          M = P + M + C + z;
          break;
        case "=":
          M = P + z + M + C;
          break;
        case "^":
          M = z.slice(0, $ = z.length >> 1) + P + M + C + z.slice($);
          break;
        default:
          M = z + P + M + C;
          break;
      }
      return a(M);
    }
    return L.toString = function() {
      return f + "";
    }, L;
  }
  function h(f, d) {
    var p = Math.max(-8, Math.min(8, Math.floor(jd(d) / 3))) * 3, g = Math.pow(10, -p), m = u((f = z2(f), f.type = "f", f), { suffix: aN[8 + p / 3] });
    return function(v) {
      return m(g * v);
    };
  }
  return {
    format: u,
    formatPrefix: h
  };
}
var sv, Tu, GX;
$ge({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function $ge(t) {
  return sv = Pge(t), Tu = sv.format, GX = sv.formatPrefix, sv;
}
function Bge(t) {
  return Math.max(0, -jd(Math.abs(t)));
}
function Fge(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(jd(e) / 3))) * 3 - jd(Math.abs(t)));
}
function zge(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, jd(e) - jd(t)) + 1;
}
function qge(t) {
  var e = 0, r = t.children, n = r && r.length;
  if (!n) e = 1;
  else for (; --n >= 0; ) e += r[n].value;
  t.value = e;
}
function Gge() {
  return this.eachAfter(qge);
}
function Uge(t, e) {
  let r = -1;
  for (const n of this)
    t.call(e, n, ++r, this);
  return this;
}
function Vge(t, e) {
  for (var r = this, n = [r], i, a, s = -1; r = n.pop(); )
    if (t.call(e, r, ++s, this), i = r.children)
      for (a = i.length - 1; a >= 0; --a)
        n.push(i[a]);
  return this;
}
function Hge(t, e) {
  for (var r = this, n = [r], i = [], a, s, o, l = -1; r = n.pop(); )
    if (i.push(r), a = r.children)
      for (s = 0, o = a.length; s < o; ++s)
        n.push(a[s]);
  for (; r = i.pop(); )
    t.call(e, r, ++l, this);
  return this;
}
function Wge(t, e) {
  let r = -1;
  for (const n of this)
    if (t.call(e, n, ++r, this))
      return n;
}
function Yge(t) {
  return this.eachAfter(function(e) {
    for (var r = +t(e.data) || 0, n = e.children, i = n && n.length; --i >= 0; ) r += n[i].value;
    e.value = r;
  });
}
function Xge(t) {
  return this.eachBefore(function(e) {
    e.children && e.children.sort(t);
  });
}
function jge(t) {
  for (var e = this, r = Kge(e, t), n = [e]; e !== r; )
    e = e.parent, n.push(e);
  for (var i = n.length; t !== r; )
    n.splice(i, 0, t), t = t.parent;
  return n;
}
function Kge(t, e) {
  if (t === e) return t;
  var r = t.ancestors(), n = e.ancestors(), i = null;
  for (t = r.pop(), e = n.pop(); t === e; )
    i = t, t = r.pop(), e = n.pop();
  return i;
}
function Zge() {
  for (var t = this, e = [t]; t = t.parent; )
    e.push(t);
  return e;
}
function Qge() {
  return Array.from(this);
}
function Jge() {
  var t = [];
  return this.eachBefore(function(e) {
    e.children || t.push(e);
  }), t;
}
function e1e() {
  var t = this, e = [];
  return t.each(function(r) {
    r !== t && e.push({ source: r.parent, target: r });
  }), e;
}
function* t1e() {
  var t = this, e, r = [t], n, i, a;
  do
    for (e = r.reverse(), r = []; t = e.pop(); )
      if (yield t, n = t.children)
        for (i = 0, a = n.length; i < a; ++i)
          r.push(n[i]);
  while (r.length);
}
function S9(t, e) {
  t instanceof Map ? (t = [void 0, t], e === void 0 && (e = i1e)) : e === void 0 && (e = n1e);
  for (var r = new G2(t), n, i = [r], a, s, o, l; n = i.pop(); )
    if ((s = e(n.data)) && (l = (s = Array.from(s)).length))
      for (n.children = s, o = l - 1; o >= 0; --o)
        i.push(a = s[o] = new G2(s[o])), a.parent = n, a.depth = n.depth + 1;
  return r.eachBefore(s1e);
}
function r1e() {
  return S9(this).eachBefore(a1e);
}
function n1e(t) {
  return t.children;
}
function i1e(t) {
  return Array.isArray(t) ? t[1] : null;
}
function a1e(t) {
  t.data.value !== void 0 && (t.value = t.data.value), t.data = t.data.data;
}
function s1e(t) {
  var e = 0;
  do
    t.height = e;
  while ((t = t.parent) && t.height < ++e);
}
function G2(t) {
  this.data = t, this.depth = this.height = 0, this.parent = null;
}
G2.prototype = S9.prototype = {
  constructor: G2,
  count: Gge,
  each: Uge,
  eachAfter: Hge,
  eachBefore: Vge,
  find: Wge,
  sum: Yge,
  sort: Xge,
  path: jge,
  ancestors: Zge,
  descendants: Qge,
  leaves: Jge,
  links: e1e,
  copy: r1e,
  [Symbol.iterator]: t1e
};
function o1e(t) {
  if (typeof t != "function") throw new Error();
  return t;
}
function ip() {
  return 0;
}
function ap(t) {
  return function() {
    return t;
  };
}
function l1e(t) {
  t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1);
}
function c1e(t, e, r, n, i) {
  for (var a = t.children, s, o = -1, l = a.length, u = t.value && (n - e) / t.value; ++o < l; )
    s = a[o], s.y0 = r, s.y1 = i, s.x0 = e, s.x1 = e += s.value * u;
}
function u1e(t, e, r, n, i) {
  for (var a = t.children, s, o = -1, l = a.length, u = t.value && (i - r) / t.value; ++o < l; )
    s = a[o], s.x0 = e, s.x1 = n, s.y0 = r, s.y1 = r += s.value * u;
}
var h1e = (1 + Math.sqrt(5)) / 2;
function f1e(t, e, r, n, i, a) {
  for (var s = [], o = e.children, l, u, h = 0, f = 0, d = o.length, p, g, m = e.value, v, y, b, x, T, E, A; h < d; ) {
    p = i - r, g = a - n;
    do
      v = o[f++].value;
    while (!v && f < d);
    for (y = b = v, E = Math.max(g / p, p / g) / (m * t), A = v * v * E, T = Math.max(b / A, A / y); f < d; ++f) {
      if (v += u = o[f].value, u < y && (y = u), u > b && (b = u), A = v * v * E, x = Math.max(b / A, A / y), x > T) {
        v -= u;
        break;
      }
      T = x;
    }
    s.push(l = { value: v, dice: p < g, children: o.slice(h, f) }), l.dice ? c1e(l, r, n, i, m ? n += g * v / m : a) : u1e(l, r, n, m ? r += p * v / m : i, a), m -= v, h = f;
  }
  return s;
}
const d1e = (function t(e) {
  function r(n, i, a, s, o) {
    f1e(e, n, i, a, s, o);
  }
  return r.ratio = function(n) {
    return t((n = +n) > 1 ? n : 1);
  }, r;
})(h1e);
function p1e() {
  var t = d1e, e = !1, r = 1, n = 1, i = [0], a = ip, s = ip, o = ip, l = ip, u = ip;
  function h(d) {
    return d.x0 = d.y0 = 0, d.x1 = r, d.y1 = n, d.eachBefore(f), i = [0], e && d.eachBefore(l1e), d;
  }
  function f(d) {
    var p = i[d.depth], g = d.x0 + p, m = d.y0 + p, v = d.x1 - p, y = d.y1 - p;
    v < g && (g = v = (g + v) / 2), y < m && (m = y = (m + y) / 2), d.x0 = g, d.y0 = m, d.x1 = v, d.y1 = y, d.children && (p = i[d.depth + 1] = a(d) / 2, g += u(d) - p, m += s(d) - p, v -= o(d) - p, y -= l(d) - p, v < g && (g = v = (g + v) / 2), y < m && (m = y = (m + y) / 2), t(d, g, m, v, y));
  }
  return h.round = function(d) {
    return arguments.length ? (e = !!d, h) : e;
  }, h.size = function(d) {
    return arguments.length ? (r = +d[0], n = +d[1], h) : [r, n];
  }, h.tile = function(d) {
    return arguments.length ? (t = o1e(d), h) : t;
  }, h.padding = function(d) {
    return arguments.length ? h.paddingInner(d).paddingOuter(d) : h.paddingInner();
  }, h.paddingInner = function(d) {
    return arguments.length ? (a = typeof d == "function" ? d : ap(+d), h) : a;
  }, h.paddingOuter = function(d) {
    return arguments.length ? h.paddingTop(d).paddingRight(d).paddingBottom(d).paddingLeft(d) : h.paddingTop();
  }, h.paddingTop = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : ap(+d), h) : s;
  }, h.paddingRight = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : ap(+d), h) : o;
  }, h.paddingBottom = function(d) {
    return arguments.length ? (l = typeof d == "function" ? d : ap(+d), h) : l;
  }, h.paddingLeft = function(d) {
    return arguments.length ? (u = typeof d == "function" ? d : ap(+d), h) : u;
  }, h;
}
function Vx(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
const sN = Symbol("implicit");
function Bu() {
  var t = new $M(), e = [], r = [], n = sN;
  function i(a) {
    let s = t.get(a);
    if (s === void 0) {
      if (n !== sN) return n;
      t.set(a, s = e.push(a) - 1);
    }
    return r[s % r.length];
  }
  return i.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [], t = new $M();
    for (const s of a)
      t.has(s) || t.set(s, e.push(s) - 1);
    return i;
  }, i.range = function(a) {
    return arguments.length ? (r = Array.from(a), i) : r.slice();
  }, i.unknown = function(a) {
    return arguments.length ? (n = a, i) : n;
  }, i.copy = function() {
    return Bu(e, r).unknown(n);
  }, Vx.apply(i, arguments), i;
}
function m_() {
  var t = Bu().unknown(void 0), e = t.domain, r = t.range, n = 0, i = 1, a, s, o = !1, l = 0, u = 0, h = 0.5;
  delete t.unknown;
  function f() {
    var d = e().length, p = i < n, g = p ? i : n, m = p ? n : i;
    a = (m - g) / Math.max(1, d - l + u * 2), o && (a = Math.floor(a)), g += (m - g - a * (d - l)) * h, s = a * (1 - l), o && (g = Math.round(g), s = Math.round(s));
    var v = Wfe(d).map(function(y) {
      return g + a * y;
    });
    return r(p ? v.reverse() : v);
  }
  return t.domain = function(d) {
    return arguments.length ? (e(d), f()) : e();
  }, t.range = function(d) {
    return arguments.length ? ([n, i] = d, n = +n, i = +i, f()) : [n, i];
  }, t.rangeRound = function(d) {
    return [n, i] = d, n = +n, i = +i, o = !0, f();
  }, t.bandwidth = function() {
    return s;
  }, t.step = function() {
    return a;
  }, t.round = function(d) {
    return arguments.length ? (o = !!d, f()) : o;
  }, t.padding = function(d) {
    return arguments.length ? (l = Math.min(1, u = +d), f()) : l;
  }, t.paddingInner = function(d) {
    return arguments.length ? (l = Math.min(1, d), f()) : l;
  }, t.paddingOuter = function(d) {
    return arguments.length ? (u = +d, f()) : u;
  }, t.align = function(d) {
    return arguments.length ? (h = Math.max(0, Math.min(1, d)), f()) : h;
  }, t.copy = function() {
    return m_(e(), [n, i]).round(o).paddingInner(l).paddingOuter(u).align(h);
  }, Vx.apply(f(), arguments);
}
function g1e(t) {
  return function() {
    return t;
  };
}
function m1e(t) {
  return +t;
}
var oN = [0, 1];
function xf(t) {
  return t;
}
function v_(t, e) {
  return (e -= t = +t) ? function(r) {
    return (r - t) / e;
  } : g1e(isNaN(e) ? NaN : 0.5);
}
function v1e(t, e) {
  var r;
  return t > e && (r = t, t = e, e = r), function(n) {
    return Math.max(t, Math.min(e, n));
  };
}
function y1e(t, e, r) {
  var n = t[0], i = t[1], a = e[0], s = e[1];
  return i < n ? (n = v_(i, n), a = r(s, a)) : (n = v_(n, i), a = r(a, s)), function(o) {
    return a(n(o));
  };
}
function b1e(t, e, r) {
  var n = Math.min(t.length, e.length) - 1, i = new Array(n), a = new Array(n), s = -1;
  for (t[n] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < n; )
    i[s] = v_(t[s], t[s + 1]), a[s] = r(e[s], e[s + 1]);
  return function(o) {
    var l = Pfe(t, o, 1, n) - 1;
    return a[l](i[l](o));
  };
}
function UX(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function x1e() {
  var t = oN, e = oN, r = b9, n, i, a, s = xf, o, l, u;
  function h() {
    var d = Math.min(t.length, e.length);
    return s !== xf && (s = v1e(t[0], t[d - 1])), o = d > 2 ? b1e : y1e, l = u = null, f;
  }
  function f(d) {
    return d == null || isNaN(d = +d) ? a : (l || (l = o(t.map(n), e, r)))(n(s(d)));
  }
  return f.invert = function(d) {
    return s(i((u || (u = o(e, t.map(n), bs)))(d)));
  }, f.domain = function(d) {
    return arguments.length ? (t = Array.from(d, m1e), h()) : t.slice();
  }, f.range = function(d) {
    return arguments.length ? (e = Array.from(d), h()) : e.slice();
  }, f.rangeRound = function(d) {
    return e = Array.from(d), r = lpe, h();
  }, f.clamp = function(d) {
    return arguments.length ? (s = d ? !0 : xf, h()) : s !== xf;
  }, f.interpolate = function(d) {
    return arguments.length ? (r = d, h()) : r;
  }, f.unknown = function(d) {
    return arguments.length ? (a = d, f) : a;
  }, function(d, p) {
    return n = d, i = p, h();
  };
}
function VX() {
  return x1e()(xf, xf);
}
function w1e(t, e, r, n) {
  var i = i_(t, e, r), a;
  switch (n = z2(n ?? ",f"), n.type) {
    case "s": {
      var s = Math.max(Math.abs(t), Math.abs(e));
      return n.precision == null && !isNaN(a = Fge(i, s)) && (n.precision = a), GX(n, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(a = zge(i, Math.max(Math.abs(t), Math.abs(e)))) && (n.precision = a - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(a = Bge(i)) && (n.precision = a - (n.type === "%") * 2);
      break;
    }
  }
  return Tu(n);
}
function T1e(t) {
  var e = t.domain;
  return t.ticks = function(r) {
    var n = e();
    return Ufe(n[0], n[n.length - 1], r ?? 10);
  }, t.tickFormat = function(r, n) {
    var i = e();
    return w1e(i[0], i[i.length - 1], r ?? 10, n);
  }, t.nice = function(r) {
    r == null && (r = 10);
    var n = e(), i = 0, a = n.length - 1, s = n[i], o = n[a], l, u, h = 10;
    for (o < s && (u = s, s = o, o = u, u = i, i = a, a = u); h-- > 0; ) {
      if (u = n_(s, o, r), u === l)
        return n[i] = s, n[a] = o, e(n);
      if (u > 0)
        s = Math.floor(s / u) * u, o = Math.ceil(o / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, o = Math.floor(o * u) / u;
      else
        break;
      l = u;
    }
    return t;
  }, t;
}
function Kd() {
  var t = VX();
  return t.copy = function() {
    return UX(t, Kd());
  }, Vx.apply(t, arguments), T1e(t);
}
function E1e(t, e) {
  t = t.slice();
  var r = 0, n = t.length - 1, i = t[r], a = t[n], s;
  return a < i && (s = r, r = n, n = s, s = i, i = a, a = s), t[r] = e.floor(i), t[n] = e.ceil(a), t;
}
const S5 = /* @__PURE__ */ new Date(), k5 = /* @__PURE__ */ new Date();
function Xn(t, e, r, n) {
  function i(a) {
    return t(a = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+a)), a;
  }
  return i.floor = (a) => (t(a = /* @__PURE__ */ new Date(+a)), a), i.ceil = (a) => (t(a = new Date(a - 1)), e(a, 1), t(a), a), i.round = (a) => {
    const s = i(a), o = i.ceil(a);
    return a - s < o - a ? s : o;
  }, i.offset = (a, s) => (e(a = /* @__PURE__ */ new Date(+a), s == null ? 1 : Math.floor(s)), a), i.range = (a, s, o) => {
    const l = [];
    if (a = i.ceil(a), o = o == null ? 1 : Math.floor(o), !(a < s) || !(o > 0)) return l;
    let u;
    do
      l.push(u = /* @__PURE__ */ new Date(+a)), e(a, o), t(a);
    while (u < a && a < s);
    return l;
  }, i.filter = (a) => Xn((s) => {
    if (s >= s) for (; t(s), !a(s); ) s.setTime(s - 1);
  }, (s, o) => {
    if (s >= s)
      if (o < 0) for (; ++o <= 0; )
        for (; e(s, -1), !a(s); )
          ;
      else for (; --o >= 0; )
        for (; e(s, 1), !a(s); )
          ;
  }), r && (i.count = (a, s) => (S5.setTime(+a), k5.setTime(+s), t(S5), t(k5), Math.floor(r(S5, k5))), i.every = (a) => (a = Math.floor(a), !isFinite(a) || !(a > 0) ? null : a > 1 ? i.filter(n ? (s) => n(s) % a === 0 : (s) => i.count(0, s) % a === 0) : i)), i;
}
const Zd = Xn(() => {
}, (t, e) => {
  t.setTime(+t + e);
}, (t, e) => e - t);
Zd.every = (t) => (t = Math.floor(t), !isFinite(t) || !(t > 0) ? null : t > 1 ? Xn((e) => {
  e.setTime(Math.floor(e / t) * t);
}, (e, r) => {
  e.setTime(+e + r * t);
}, (e, r) => (r - e) / t) : Zd);
Zd.range;
const Qo = 1e3, Ka = Qo * 60, Jo = Ka * 60, fl = Jo * 24, k9 = fl * 7, lN = fl * 30, C5 = fl * 365, Zl = Xn((t) => {
  t.setTime(t - t.getMilliseconds());
}, (t, e) => {
  t.setTime(+t + e * Qo);
}, (t, e) => (e - t) / Qo, (t) => t.getUTCSeconds());
Zl.range;
const Jg = Xn((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * Qo);
}, (t, e) => {
  t.setTime(+t + e * Ka);
}, (t, e) => (e - t) / Ka, (t) => t.getMinutes());
Jg.range;
const S1e = Xn((t) => {
  t.setUTCSeconds(0, 0);
}, (t, e) => {
  t.setTime(+t + e * Ka);
}, (t, e) => (e - t) / Ka, (t) => t.getUTCMinutes());
S1e.range;
const e1 = Xn((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * Qo - t.getMinutes() * Ka);
}, (t, e) => {
  t.setTime(+t + e * Jo);
}, (t, e) => (e - t) / Jo, (t) => t.getHours());
e1.range;
const k1e = Xn((t) => {
  t.setUTCMinutes(0, 0, 0);
}, (t, e) => {
  t.setTime(+t + e * Jo);
}, (t, e) => (e - t) / Jo, (t) => t.getUTCHours());
k1e.range;
const Hu = Xn(
  (t) => t.setHours(0, 0, 0, 0),
  (t, e) => t.setDate(t.getDate() + e),
  (t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * Ka) / fl,
  (t) => t.getDate() - 1
);
Hu.range;
const C9 = Xn((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / fl, (t) => t.getUTCDate() - 1);
C9.range;
const C1e = Xn((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / fl, (t) => Math.floor(t / fl));
C1e.range;
function mh(t) {
  return Xn((e) => {
    e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0);
  }, (e, r) => {
    e.setDate(e.getDate() + r * 7);
  }, (e, r) => (r - e - (r.getTimezoneOffset() - e.getTimezoneOffset()) * Ka) / k9);
}
const tm = mh(0), t1 = mh(1), HX = mh(2), WX = mh(3), Wu = mh(4), YX = mh(5), XX = mh(6);
tm.range;
t1.range;
HX.range;
WX.range;
Wu.range;
YX.range;
XX.range;
function vh(t) {
  return Xn((e) => {
    e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0);
  }, (e, r) => {
    e.setUTCDate(e.getUTCDate() + r * 7);
  }, (e, r) => (r - e) / k9);
}
const jX = vh(0), U2 = vh(1), _1e = vh(2), A1e = vh(3), Qd = vh(4), L1e = vh(5), R1e = vh(6);
jX.range;
U2.range;
_1e.range;
A1e.range;
Qd.range;
L1e.range;
R1e.range;
const r1 = Xn((t) => {
  t.setDate(1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setMonth(t.getMonth() + e);
}, (t, e) => e.getMonth() - t.getMonth() + (e.getFullYear() - t.getFullYear()) * 12, (t) => t.getMonth());
r1.range;
const I1e = Xn((t) => {
  t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCMonth(t.getUTCMonth() + e);
}, (t, e) => e.getUTCMonth() - t.getUTCMonth() + (e.getUTCFullYear() - t.getUTCFullYear()) * 12, (t) => t.getUTCMonth());
I1e.range;
const dl = Xn((t) => {
  t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setFullYear(t.getFullYear() + e);
}, (t, e) => e.getFullYear() - t.getFullYear(), (t) => t.getFullYear());
dl.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Xn((e) => {
  e.setFullYear(Math.floor(e.getFullYear() / t) * t), e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, r) => {
  e.setFullYear(e.getFullYear() + r * t);
});
dl.range;
const Yu = Xn((t) => {
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCFullYear(t.getUTCFullYear() + e);
}, (t, e) => e.getUTCFullYear() - t.getUTCFullYear(), (t) => t.getUTCFullYear());
Yu.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Xn((e) => {
  e.setUTCFullYear(Math.floor(e.getUTCFullYear() / t) * t), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, r) => {
  e.setUTCFullYear(e.getUTCFullYear() + r * t);
});
Yu.range;
function M1e(t, e, r, n, i, a) {
  const s = [
    [Zl, 1, Qo],
    [Zl, 5, 5 * Qo],
    [Zl, 15, 15 * Qo],
    [Zl, 30, 30 * Qo],
    [a, 1, Ka],
    [a, 5, 5 * Ka],
    [a, 15, 15 * Ka],
    [a, 30, 30 * Ka],
    [i, 1, Jo],
    [i, 3, 3 * Jo],
    [i, 6, 6 * Jo],
    [i, 12, 12 * Jo],
    [n, 1, fl],
    [n, 2, 2 * fl],
    [r, 1, k9],
    [e, 1, lN],
    [e, 3, 3 * lN],
    [t, 1, C5]
  ];
  function o(u, h, f) {
    const d = h < u;
    d && ([u, h] = [h, u]);
    const p = f && typeof f.range == "function" ? f : l(u, h, f), g = p ? p.range(u, +h + 1) : [];
    return d ? g.reverse() : g;
  }
  function l(u, h, f) {
    const d = Math.abs(h - u) / f, p = m9(([, , v]) => v).right(s, d);
    if (p === s.length) return t.every(i_(u / C5, h / C5, f));
    if (p === 0) return Zd.every(Math.max(i_(u, h, f), 1));
    const [g, m] = s[d / s[p - 1][2] < s[p][2] / d ? p - 1 : p];
    return g.every(m);
  }
  return [o, l];
}
const [N1e, D1e] = M1e(dl, r1, tm, Hu, e1, Jg);
function _5(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
    return e.setFullYear(t.y), e;
  }
  return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
}
function A5(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
    return e.setUTCFullYear(t.y), e;
  }
  return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
}
function sp(t, e, r) {
  return { y: t, m: e, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function O1e(t) {
  var e = t.dateTime, r = t.date, n = t.time, i = t.periods, a = t.days, s = t.shortDays, o = t.months, l = t.shortMonths, u = op(i), h = lp(i), f = op(a), d = lp(a), p = op(s), g = lp(s), m = op(o), v = lp(o), y = op(l), b = lp(l), x = {
    a: O,
    A: D,
    b: $,
    B: z,
    c: null,
    d: pN,
    e: pN,
    f: ime,
    g: pme,
    G: mme,
    H: tme,
    I: rme,
    j: nme,
    L: KX,
    m: ame,
    M: sme,
    p: B,
    q: G,
    Q: vN,
    s: yN,
    S: ome,
    u: lme,
    U: cme,
    V: ume,
    w: hme,
    W: fme,
    x: null,
    X: null,
    y: dme,
    Y: gme,
    Z: vme,
    "%": mN
  }, T = {
    a: W,
    A: V,
    b: U,
    B: Z,
    c: null,
    d: gN,
    e: gN,
    f: wme,
    g: Ime,
    G: Nme,
    H: yme,
    I: bme,
    j: xme,
    L: QX,
    m: Tme,
    M: Eme,
    p: K,
    q: ce,
    Q: vN,
    s: yN,
    S: Sme,
    u: kme,
    U: Cme,
    V: _me,
    w: Ame,
    W: Lme,
    x: null,
    X: null,
    y: Rme,
    Y: Mme,
    Z: Dme,
    "%": mN
  }, E = {
    a: R,
    A: L,
    b: M,
    B: P,
    c: C,
    d: fN,
    e: fN,
    f: Z1e,
    g: hN,
    G: uN,
    H: dN,
    I: dN,
    j: Y1e,
    L: K1e,
    m: W1e,
    M: X1e,
    p: _,
    q: H1e,
    Q: J1e,
    s: eme,
    S: j1e,
    u: z1e,
    U: q1e,
    V: G1e,
    w: F1e,
    W: U1e,
    x: I,
    X: N,
    y: hN,
    Y: uN,
    Z: V1e,
    "%": Q1e
  };
  x.x = A(r, x), x.X = A(n, x), x.c = A(e, x), T.x = A(r, T), T.X = A(n, T), T.c = A(e, T);
  function A(J, ee) {
    return function(j) {
      var X = [], re = -1, Q = 0, ue = J.length, ne, xe, Y;
      for (j instanceof Date || (j = /* @__PURE__ */ new Date(+j)); ++re < ue; )
        J.charCodeAt(re) === 37 && (X.push(J.slice(Q, re)), (xe = cN[ne = J.charAt(++re)]) != null ? ne = J.charAt(++re) : xe = ne === "e" ? " " : "0", (Y = ee[ne]) && (ne = Y(j, xe)), X.push(ne), Q = re + 1);
      return X.push(J.slice(Q, re)), X.join("");
    };
  }
  function S(J, ee) {
    return function(j) {
      var X = sp(1900, void 0, 1), re = k(X, J, j += "", 0), Q, ue;
      if (re != j.length) return null;
      if ("Q" in X) return new Date(X.Q);
      if ("s" in X) return new Date(X.s * 1e3 + ("L" in X ? X.L : 0));
      if (ee && !("Z" in X) && (X.Z = 0), "p" in X && (X.H = X.H % 12 + X.p * 12), X.m === void 0 && (X.m = "q" in X ? X.q : 0), "V" in X) {
        if (X.V < 1 || X.V > 53) return null;
        "w" in X || (X.w = 1), "Z" in X ? (Q = A5(sp(X.y, 0, 1)), ue = Q.getUTCDay(), Q = ue > 4 || ue === 0 ? U2.ceil(Q) : U2(Q), Q = C9.offset(Q, (X.V - 1) * 7), X.y = Q.getUTCFullYear(), X.m = Q.getUTCMonth(), X.d = Q.getUTCDate() + (X.w + 6) % 7) : (Q = _5(sp(X.y, 0, 1)), ue = Q.getDay(), Q = ue > 4 || ue === 0 ? t1.ceil(Q) : t1(Q), Q = Hu.offset(Q, (X.V - 1) * 7), X.y = Q.getFullYear(), X.m = Q.getMonth(), X.d = Q.getDate() + (X.w + 6) % 7);
      } else ("W" in X || "U" in X) && ("w" in X || (X.w = "u" in X ? X.u % 7 : "W" in X ? 1 : 0), ue = "Z" in X ? A5(sp(X.y, 0, 1)).getUTCDay() : _5(sp(X.y, 0, 1)).getDay(), X.m = 0, X.d = "W" in X ? (X.w + 6) % 7 + X.W * 7 - (ue + 5) % 7 : X.w + X.U * 7 - (ue + 6) % 7);
      return "Z" in X ? (X.H += X.Z / 100 | 0, X.M += X.Z % 100, A5(X)) : _5(X);
    };
  }
  function k(J, ee, j, X) {
    for (var re = 0, Q = ee.length, ue = j.length, ne, xe; re < Q; ) {
      if (X >= ue) return -1;
      if (ne = ee.charCodeAt(re++), ne === 37) {
        if (ne = ee.charAt(re++), xe = E[ne in cN ? ee.charAt(re++) : ne], !xe || (X = xe(J, j, X)) < 0) return -1;
      } else if (ne != j.charCodeAt(X++))
        return -1;
    }
    return X;
  }
  function _(J, ee, j) {
    var X = u.exec(ee.slice(j));
    return X ? (J.p = h.get(X[0].toLowerCase()), j + X[0].length) : -1;
  }
  function R(J, ee, j) {
    var X = p.exec(ee.slice(j));
    return X ? (J.w = g.get(X[0].toLowerCase()), j + X[0].length) : -1;
  }
  function L(J, ee, j) {
    var X = f.exec(ee.slice(j));
    return X ? (J.w = d.get(X[0].toLowerCase()), j + X[0].length) : -1;
  }
  function M(J, ee, j) {
    var X = y.exec(ee.slice(j));
    return X ? (J.m = b.get(X[0].toLowerCase()), j + X[0].length) : -1;
  }
  function P(J, ee, j) {
    var X = m.exec(ee.slice(j));
    return X ? (J.m = v.get(X[0].toLowerCase()), j + X[0].length) : -1;
  }
  function C(J, ee, j) {
    return k(J, e, ee, j);
  }
  function I(J, ee, j) {
    return k(J, r, ee, j);
  }
  function N(J, ee, j) {
    return k(J, n, ee, j);
  }
  function O(J) {
    return s[J.getDay()];
  }
  function D(J) {
    return a[J.getDay()];
  }
  function $(J) {
    return l[J.getMonth()];
  }
  function z(J) {
    return o[J.getMonth()];
  }
  function B(J) {
    return i[+(J.getHours() >= 12)];
  }
  function G(J) {
    return 1 + ~~(J.getMonth() / 3);
  }
  function W(J) {
    return s[J.getUTCDay()];
  }
  function V(J) {
    return a[J.getUTCDay()];
  }
  function U(J) {
    return l[J.getUTCMonth()];
  }
  function Z(J) {
    return o[J.getUTCMonth()];
  }
  function K(J) {
    return i[+(J.getUTCHours() >= 12)];
  }
  function ce(J) {
    return 1 + ~~(J.getUTCMonth() / 3);
  }
  return {
    format: function(J) {
      var ee = A(J += "", x);
      return ee.toString = function() {
        return J;
      }, ee;
    },
    parse: function(J) {
      var ee = S(J += "", !1);
      return ee.toString = function() {
        return J;
      }, ee;
    },
    utcFormat: function(J) {
      var ee = A(J += "", T);
      return ee.toString = function() {
        return J;
      }, ee;
    },
    utcParse: function(J) {
      var ee = S(J += "", !0);
      return ee.toString = function() {
        return J;
      }, ee;
    }
  };
}
var cN = { "-": "", _: " ", 0: "0" }, ri = /^\s*\d+/, P1e = /^%/, $1e = /[\\^$*+?|[\]().{}]/g;
function Sr(t, e, r) {
  var n = t < 0 ? "-" : "", i = (n ? -t : t) + "", a = i.length;
  return n + (a < r ? new Array(r - a + 1).join(e) + i : i);
}
function B1e(t) {
  return t.replace($1e, "\\$&");
}
function op(t) {
  return new RegExp("^(?:" + t.map(B1e).join("|") + ")", "i");
}
function lp(t) {
  return new Map(t.map((e, r) => [e.toLowerCase(), r]));
}
function F1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 1));
  return n ? (t.w = +n[0], r + n[0].length) : -1;
}
function z1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 1));
  return n ? (t.u = +n[0], r + n[0].length) : -1;
}
function q1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.U = +n[0], r + n[0].length) : -1;
}
function G1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.V = +n[0], r + n[0].length) : -1;
}
function U1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.W = +n[0], r + n[0].length) : -1;
}
function uN(t, e, r) {
  var n = ri.exec(e.slice(r, r + 4));
  return n ? (t.y = +n[0], r + n[0].length) : -1;
}
function hN(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), r + n[0].length) : -1;
}
function V1e(t, e, r) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(r, r + 6));
  return n ? (t.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), r + n[0].length) : -1;
}
function H1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 1));
  return n ? (t.q = n[0] * 3 - 3, r + n[0].length) : -1;
}
function W1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.m = n[0] - 1, r + n[0].length) : -1;
}
function fN(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.d = +n[0], r + n[0].length) : -1;
}
function Y1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 3));
  return n ? (t.m = 0, t.d = +n[0], r + n[0].length) : -1;
}
function dN(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.H = +n[0], r + n[0].length) : -1;
}
function X1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.M = +n[0], r + n[0].length) : -1;
}
function j1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 2));
  return n ? (t.S = +n[0], r + n[0].length) : -1;
}
function K1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 3));
  return n ? (t.L = +n[0], r + n[0].length) : -1;
}
function Z1e(t, e, r) {
  var n = ri.exec(e.slice(r, r + 6));
  return n ? (t.L = Math.floor(n[0] / 1e3), r + n[0].length) : -1;
}
function Q1e(t, e, r) {
  var n = P1e.exec(e.slice(r, r + 1));
  return n ? r + n[0].length : -1;
}
function J1e(t, e, r) {
  var n = ri.exec(e.slice(r));
  return n ? (t.Q = +n[0], r + n[0].length) : -1;
}
function eme(t, e, r) {
  var n = ri.exec(e.slice(r));
  return n ? (t.s = +n[0], r + n[0].length) : -1;
}
function pN(t, e) {
  return Sr(t.getDate(), e, 2);
}
function tme(t, e) {
  return Sr(t.getHours(), e, 2);
}
function rme(t, e) {
  return Sr(t.getHours() % 12 || 12, e, 2);
}
function nme(t, e) {
  return Sr(1 + Hu.count(dl(t), t), e, 3);
}
function KX(t, e) {
  return Sr(t.getMilliseconds(), e, 3);
}
function ime(t, e) {
  return KX(t, e) + "000";
}
function ame(t, e) {
  return Sr(t.getMonth() + 1, e, 2);
}
function sme(t, e) {
  return Sr(t.getMinutes(), e, 2);
}
function ome(t, e) {
  return Sr(t.getSeconds(), e, 2);
}
function lme(t) {
  var e = t.getDay();
  return e === 0 ? 7 : e;
}
function cme(t, e) {
  return Sr(tm.count(dl(t) - 1, t), e, 2);
}
function ZX(t) {
  var e = t.getDay();
  return e >= 4 || e === 0 ? Wu(t) : Wu.ceil(t);
}
function ume(t, e) {
  return t = ZX(t), Sr(Wu.count(dl(t), t) + (dl(t).getDay() === 4), e, 2);
}
function hme(t) {
  return t.getDay();
}
function fme(t, e) {
  return Sr(t1.count(dl(t) - 1, t), e, 2);
}
function dme(t, e) {
  return Sr(t.getFullYear() % 100, e, 2);
}
function pme(t, e) {
  return t = ZX(t), Sr(t.getFullYear() % 100, e, 2);
}
function gme(t, e) {
  return Sr(t.getFullYear() % 1e4, e, 4);
}
function mme(t, e) {
  var r = t.getDay();
  return t = r >= 4 || r === 0 ? Wu(t) : Wu.ceil(t), Sr(t.getFullYear() % 1e4, e, 4);
}
function vme(t) {
  var e = t.getTimezoneOffset();
  return (e > 0 ? "-" : (e *= -1, "+")) + Sr(e / 60 | 0, "0", 2) + Sr(e % 60, "0", 2);
}
function gN(t, e) {
  return Sr(t.getUTCDate(), e, 2);
}
function yme(t, e) {
  return Sr(t.getUTCHours(), e, 2);
}
function bme(t, e) {
  return Sr(t.getUTCHours() % 12 || 12, e, 2);
}
function xme(t, e) {
  return Sr(1 + C9.count(Yu(t), t), e, 3);
}
function QX(t, e) {
  return Sr(t.getUTCMilliseconds(), e, 3);
}
function wme(t, e) {
  return QX(t, e) + "000";
}
function Tme(t, e) {
  return Sr(t.getUTCMonth() + 1, e, 2);
}
function Eme(t, e) {
  return Sr(t.getUTCMinutes(), e, 2);
}
function Sme(t, e) {
  return Sr(t.getUTCSeconds(), e, 2);
}
function kme(t) {
  var e = t.getUTCDay();
  return e === 0 ? 7 : e;
}
function Cme(t, e) {
  return Sr(jX.count(Yu(t) - 1, t), e, 2);
}
function JX(t) {
  var e = t.getUTCDay();
  return e >= 4 || e === 0 ? Qd(t) : Qd.ceil(t);
}
function _me(t, e) {
  return t = JX(t), Sr(Qd.count(Yu(t), t) + (Yu(t).getUTCDay() === 4), e, 2);
}
function Ame(t) {
  return t.getUTCDay();
}
function Lme(t, e) {
  return Sr(U2.count(Yu(t) - 1, t), e, 2);
}
function Rme(t, e) {
  return Sr(t.getUTCFullYear() % 100, e, 2);
}
function Ime(t, e) {
  return t = JX(t), Sr(t.getUTCFullYear() % 100, e, 2);
}
function Mme(t, e) {
  return Sr(t.getUTCFullYear() % 1e4, e, 4);
}
function Nme(t, e) {
  var r = t.getUTCDay();
  return t = r >= 4 || r === 0 ? Qd(t) : Qd.ceil(t), Sr(t.getUTCFullYear() % 1e4, e, 4);
}
function Dme() {
  return "+0000";
}
function mN() {
  return "%";
}
function vN(t) {
  return +t;
}
function yN(t) {
  return Math.floor(+t / 1e3);
}
var Zh, V2;
Ome({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Ome(t) {
  return Zh = O1e(t), V2 = Zh.format, Zh.parse, Zh.utcFormat, Zh.utcParse, Zh;
}
function Pme(t) {
  return new Date(t);
}
function $me(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function ej(t, e, r, n, i, a, s, o, l, u) {
  var h = VX(), f = h.invert, d = h.domain, p = u(".%L"), g = u(":%S"), m = u("%I:%M"), v = u("%I %p"), y = u("%a %d"), b = u("%b %d"), x = u("%B"), T = u("%Y");
  function E(A) {
    return (l(A) < A ? p : o(A) < A ? g : s(A) < A ? m : a(A) < A ? v : n(A) < A ? i(A) < A ? y : b : r(A) < A ? x : T)(A);
  }
  return h.invert = function(A) {
    return new Date(f(A));
  }, h.domain = function(A) {
    return arguments.length ? d(Array.from(A, $me)) : d().map(Pme);
  }, h.ticks = function(A) {
    var S = d();
    return t(S[0], S[S.length - 1], A ?? 10);
  }, h.tickFormat = function(A, S) {
    return S == null ? E : u(S);
  }, h.nice = function(A) {
    var S = d();
    return (!A || typeof A.range != "function") && (A = e(S[0], S[S.length - 1], A ?? 10)), A ? d(E1e(S, A)) : h;
  }, h.copy = function() {
    return UX(h, ej(t, e, r, n, i, a, s, o, l, u));
  }, h;
}
function Bme() {
  return Vx.apply(ej(N1e, D1e, dl, r1, tm, Hu, e1, Jg, Zl, V2).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Fme(t) {
  for (var e = t.length / 6 | 0, r = new Array(e), n = 0; n < e; ) r[n] = "#" + t.slice(n * 6, ++n * 6);
  return r;
}
const zme = Fme("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
function yn(t) {
  return function() {
    return t;
  };
}
const bN = Math.abs, xi = Math.atan2, ou = Math.cos, qme = Math.max, L5 = Math.min, Us = Math.sin, wf = Math.sqrt, Ti = 1e-12, n1 = Math.PI, H2 = n1 / 2, ky = 2 * n1;
function Gme(t) {
  return t > 1 ? 0 : t < -1 ? n1 : Math.acos(t);
}
function xN(t) {
  return t >= 1 ? H2 : t <= -1 ? -H2 : Math.asin(t);
}
function tj(t) {
  let e = 3;
  return t.digits = function(r) {
    if (!arguments.length) return e;
    if (r == null)
      e = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      e = n;
    }
    return t;
  }, () => new Lge(e);
}
function Ume(t) {
  return t.innerRadius;
}
function Vme(t) {
  return t.outerRadius;
}
function Hme(t) {
  return t.startAngle;
}
function Wme(t) {
  return t.endAngle;
}
function Yme(t) {
  return t && t.padAngle;
}
function Xme(t, e, r, n, i, a, s, o) {
  var l = r - t, u = n - e, h = s - i, f = o - a, d = f * l - h * u;
  if (!(d * d < Ti))
    return d = (h * (e - a) - f * (t - i)) / d, [t + d * l, e + d * u];
}
function ov(t, e, r, n, i, a, s) {
  var o = t - r, l = e - n, u = (s ? a : -a) / wf(o * o + l * l), h = u * l, f = -u * o, d = t + h, p = e + f, g = r + h, m = n + f, v = (d + g) / 2, y = (p + m) / 2, b = g - d, x = m - p, T = b * b + x * x, E = i - a, A = d * m - g * p, S = (x < 0 ? -1 : 1) * wf(qme(0, E * E * T - A * A)), k = (A * x - b * S) / T, _ = (-A * b - x * S) / T, R = (A * x + b * S) / T, L = (-A * b + x * S) / T, M = k - v, P = _ - y, C = R - v, I = L - y;
  return M * M + P * P > C * C + I * I && (k = R, _ = L), {
    cx: k,
    cy: _,
    x01: -h,
    y01: -f,
    x11: k * (i / E - 1),
    y11: _ * (i / E - 1)
  };
}
function Jd() {
  var t = Ume, e = Vme, r = yn(0), n = null, i = Hme, a = Wme, s = Yme, o = null, l = tj(u);
  function u() {
    var h, f, d = +t.apply(this, arguments), p = +e.apply(this, arguments), g = i.apply(this, arguments) - H2, m = a.apply(this, arguments) - H2, v = bN(m - g), y = m > g;
    if (o || (o = h = l()), p < d && (f = p, p = d, d = f), !(p > Ti)) o.moveTo(0, 0);
    else if (v > ky - Ti)
      o.moveTo(p * ou(g), p * Us(g)), o.arc(0, 0, p, g, m, !y), d > Ti && (o.moveTo(d * ou(m), d * Us(m)), o.arc(0, 0, d, m, g, y));
    else {
      var b = g, x = m, T = g, E = m, A = v, S = v, k = s.apply(this, arguments) / 2, _ = k > Ti && (n ? +n.apply(this, arguments) : wf(d * d + p * p)), R = L5(bN(p - d) / 2, +r.apply(this, arguments)), L = R, M = R, P, C;
      if (_ > Ti) {
        var I = xN(_ / d * Us(k)), N = xN(_ / p * Us(k));
        (A -= I * 2) > Ti ? (I *= y ? 1 : -1, T += I, E -= I) : (A = 0, T = E = (g + m) / 2), (S -= N * 2) > Ti ? (N *= y ? 1 : -1, b += N, x -= N) : (S = 0, b = x = (g + m) / 2);
      }
      var O = p * ou(b), D = p * Us(b), $ = d * ou(E), z = d * Us(E);
      if (R > Ti) {
        var B = p * ou(x), G = p * Us(x), W = d * ou(T), V = d * Us(T), U;
        if (v < n1)
          if (U = Xme(O, D, W, V, B, G, $, z)) {
            var Z = O - U[0], K = D - U[1], ce = B - U[0], J = G - U[1], ee = 1 / Us(Gme((Z * ce + K * J) / (wf(Z * Z + K * K) * wf(ce * ce + J * J))) / 2), j = wf(U[0] * U[0] + U[1] * U[1]);
            L = L5(R, (d - j) / (ee - 1)), M = L5(R, (p - j) / (ee + 1));
          } else
            L = M = 0;
      }
      S > Ti ? M > Ti ? (P = ov(W, V, O, D, p, M, y), C = ov(B, G, $, z, p, M, y), o.moveTo(P.cx + P.x01, P.cy + P.y01), M < R ? o.arc(P.cx, P.cy, M, xi(P.y01, P.x01), xi(C.y01, C.x01), !y) : (o.arc(P.cx, P.cy, M, xi(P.y01, P.x01), xi(P.y11, P.x11), !y), o.arc(0, 0, p, xi(P.cy + P.y11, P.cx + P.x11), xi(C.cy + C.y11, C.cx + C.x11), !y), o.arc(C.cx, C.cy, M, xi(C.y11, C.x11), xi(C.y01, C.x01), !y))) : (o.moveTo(O, D), o.arc(0, 0, p, b, x, !y)) : o.moveTo(O, D), !(d > Ti) || !(A > Ti) ? o.lineTo($, z) : L > Ti ? (P = ov($, z, B, G, d, -L, y), C = ov(O, D, W, V, d, -L, y), o.lineTo(P.cx + P.x01, P.cy + P.y01), L < R ? o.arc(P.cx, P.cy, L, xi(P.y01, P.x01), xi(C.y01, C.x01), !y) : (o.arc(P.cx, P.cy, L, xi(P.y01, P.x01), xi(P.y11, P.x11), !y), o.arc(0, 0, d, xi(P.cy + P.y11, P.cx + P.x11), xi(C.cy + C.y11, C.cx + C.x11), y), o.arc(C.cx, C.cy, L, xi(C.y11, C.x11), xi(C.y01, C.x01), !y))) : o.arc(0, 0, d, E, T, y);
    }
    if (o.closePath(), h) return o = null, h + "" || null;
  }
  return u.centroid = function() {
    var h = (+t.apply(this, arguments) + +e.apply(this, arguments)) / 2, f = (+i.apply(this, arguments) + +a.apply(this, arguments)) / 2 - n1 / 2;
    return [ou(f) * h, Us(f) * h];
  }, u.innerRadius = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : yn(+h), u) : t;
  }, u.outerRadius = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : yn(+h), u) : e;
  }, u.cornerRadius = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : yn(+h), u) : r;
  }, u.padRadius = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : yn(+h), u) : n;
  }, u.startAngle = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : yn(+h), u) : i;
  }, u.endAngle = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : yn(+h), u) : a;
  }, u.padAngle = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : yn(+h), u) : s;
  }, u.context = function(h) {
    return arguments.length ? (o = h ?? null, u) : o;
  }, u;
}
function rj(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function nj(t) {
  this._context = t;
}
nj.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(t, e);
        break;
    }
  }
};
function W2(t) {
  return new nj(t);
}
function jme(t) {
  return t[0];
}
function Kme(t) {
  return t[1];
}
function i1(t, e) {
  var r = yn(!0), n = null, i = W2, a = null, s = tj(o);
  t = typeof t == "function" ? t : t === void 0 ? jme : yn(t), e = typeof e == "function" ? e : e === void 0 ? Kme : yn(e);
  function o(l) {
    var u, h = (l = rj(l)).length, f, d = !1, p;
    for (n == null && (a = i(p = s())), u = 0; u <= h; ++u)
      !(u < h && r(f = l[u], u, l)) === d && ((d = !d) ? a.lineStart() : a.lineEnd()), d && a.point(+t(f, u, l), +e(f, u, l));
    if (p) return a = null, p + "" || null;
  }
  return o.x = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : yn(+l), o) : t;
  }, o.y = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : yn(+l), o) : e;
  }, o.defined = function(l) {
    return arguments.length ? (r = typeof l == "function" ? l : yn(!!l), o) : r;
  }, o.curve = function(l) {
    return arguments.length ? (i = l, n != null && (a = i(n)), o) : i;
  }, o.context = function(l) {
    return arguments.length ? (l == null ? n = a = null : a = i(n = l), o) : n;
  }, o;
}
function Zme(t, e) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Qme(t) {
  return t;
}
function Jme() {
  var t = Qme, e = Zme, r = null, n = yn(0), i = yn(ky), a = yn(0);
  function s(o) {
    var l, u = (o = rj(o)).length, h, f, d = 0, p = new Array(u), g = new Array(u), m = +n.apply(this, arguments), v = Math.min(ky, Math.max(-ky, i.apply(this, arguments) - m)), y, b = Math.min(Math.abs(v) / u, a.apply(this, arguments)), x = b * (v < 0 ? -1 : 1), T;
    for (l = 0; l < u; ++l)
      (T = g[p[l] = l] = +t(o[l], l, o)) > 0 && (d += T);
    for (e != null ? p.sort(function(E, A) {
      return e(g[E], g[A]);
    }) : r != null && p.sort(function(E, A) {
      return r(o[E], o[A]);
    }), l = 0, f = d ? (v - u * x) / d : 0; l < u; ++l, m = y)
      h = p[l], T = g[h], y = m + (T > 0 ? T * f : 0) + x, g[h] = {
        data: o[h],
        index: l,
        value: T,
        startAngle: m,
        endAngle: y,
        padAngle: b
      };
    return g;
  }
  return s.value = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : yn(+o), s) : t;
  }, s.sortValues = function(o) {
    return arguments.length ? (e = o, r = null, s) : e;
  }, s.sort = function(o) {
    return arguments.length ? (r = o, e = null, s) : r;
  }, s.startAngle = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : yn(+o), s) : n;
  }, s.endAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : yn(+o), s) : i;
  }, s.padAngle = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : yn(+o), s) : a;
  }, s;
}
class ij {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
}
function aj(t) {
  return new ij(t, !0);
}
function sj(t) {
  return new ij(t, !1);
}
function uc() {
}
function Y2(t, e, r) {
  t._context.bezierCurveTo(
    (2 * t._x0 + t._x1) / 3,
    (2 * t._y0 + t._y1) / 3,
    (t._x0 + 2 * t._x1) / 3,
    (t._y0 + 2 * t._y1) / 3,
    (t._x0 + 4 * t._x1 + e) / 6,
    (t._y0 + 4 * t._y1 + r) / 6
  );
}
function Hx(t) {
  this._context = t;
}
Hx.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Y2(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        Y2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function Mf(t) {
  return new Hx(t);
}
function oj(t) {
  this._context = t;
}
oj.prototype = {
  areaStart: uc,
  areaEnd: uc,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = t, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = t, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        Y2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function eve(t) {
  return new oj(t);
}
function lj(t) {
  this._context = t;
}
lj.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + t) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Y2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function tve(t) {
  return new lj(t);
}
function cj(t, e) {
  this._basis = new Hx(t), this._beta = e;
}
cj.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length - 1;
    if (r > 0)
      for (var n = t[0], i = e[0], a = t[r] - n, s = e[r] - i, o = -1, l; ++o <= r; )
        l = o / r, this._basis.point(
          this._beta * t[o] + (1 - this._beta) * (n + l * a),
          this._beta * e[o] + (1 - this._beta) * (i + l * s)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
const rve = (function t(e) {
  function r(n) {
    return e === 1 ? new Hx(n) : new cj(n, e);
  }
  return r.beta = function(n) {
    return t(+n);
  }, r;
})(0.85);
function X2(t, e, r) {
  t._context.bezierCurveTo(
    t._x1 + t._k * (t._x2 - t._x0),
    t._y1 + t._k * (t._y2 - t._y0),
    t._x2 + t._k * (t._x1 - e),
    t._y2 + t._k * (t._y1 - r),
    t._x2,
    t._y2
  );
}
function _9(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
_9.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        X2(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2, this._x1 = t, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        X2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const uj = (function t(e) {
  function r(n) {
    return new _9(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
})(0);
function A9(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
A9.prototype = {
  areaStart: uc,
  areaEnd: uc,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        X2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const nve = (function t(e) {
  function r(n) {
    return new A9(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
})(0);
function L9(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
L9.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        X2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const ive = (function t(e) {
  function r(n) {
    return new L9(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
})(0);
function R9(t, e, r) {
  var n = t._x1, i = t._y1, a = t._x2, s = t._y2;
  if (t._l01_a > Ti) {
    var o = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a, l = 3 * t._l01_a * (t._l01_a + t._l12_a);
    n = (n * o - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / l, i = (i * o - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / l;
  }
  if (t._l23_a > Ti) {
    var u = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a, h = 3 * t._l23_a * (t._l23_a + t._l12_a);
    a = (a * u + t._x1 * t._l23_2a - e * t._l12_2a) / h, s = (s * u + t._y1 * t._l23_2a - r * t._l12_2a) / h;
  }
  t._context.bezierCurveTo(n, i, a, s, t._x2, t._y2);
}
function hj(t, e) {
  this._context = t, this._alpha = e;
}
hj.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        R9(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const fj = (function t(e) {
  function r(n) {
    return e ? new hj(n, e) : new _9(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
})(0.5);
function dj(t, e) {
  this._context = t, this._alpha = e;
}
dj.prototype = {
  areaStart: uc,
  areaEnd: uc,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        R9(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const ave = (function t(e) {
  function r(n) {
    return e ? new dj(n, e) : new A9(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
})(0.5);
function pj(t, e) {
  this._context = t, this._alpha = e;
}
pj.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        R9(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const sve = (function t(e) {
  function r(n) {
    return e ? new pj(n, e) : new L9(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
})(0.5);
function gj(t) {
  this._context = t;
}
gj.prototype = {
  areaStart: uc,
  areaEnd: uc,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(t, e) {
    t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e));
  }
};
function ove(t) {
  return new gj(t);
}
function wN(t) {
  return t < 0 ? -1 : 1;
}
function TN(t, e, r) {
  var n = t._x1 - t._x0, i = e - t._x1, a = (t._y1 - t._y0) / (n || i < 0 && -0), s = (r - t._y1) / (i || n < 0 && -0), o = (a * i + s * n) / (n + i);
  return (wN(a) + wN(s)) * Math.min(Math.abs(a), Math.abs(s), 0.5 * Math.abs(o)) || 0;
}
function EN(t, e) {
  var r = t._x1 - t._x0;
  return r ? (3 * (t._y1 - t._y0) / r - e) / 2 : e;
}
function R5(t, e, r) {
  var n = t._x0, i = t._y0, a = t._x1, s = t._y1, o = (a - n) / 3;
  t._context.bezierCurveTo(n + o, i + o * e, a - o, s - o * r, a, s);
}
function j2(t) {
  this._context = t;
}
j2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        R5(this, this._t0, EN(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    var r = NaN;
    if (t = +t, e = +e, !(t === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, R5(this, EN(this, r = TN(this, t, e)), r);
          break;
        default:
          R5(this, this._t0, r = TN(this, t, e));
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = r;
    }
  }
};
function mj(t) {
  this._context = new vj(t);
}
(mj.prototype = Object.create(j2.prototype)).point = function(t, e) {
  j2.prototype.point.call(this, e, t);
};
function vj(t) {
  this._context = t;
}
vj.prototype = {
  moveTo: function(t, e) {
    this._context.moveTo(e, t);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(t, e) {
    this._context.lineTo(e, t);
  },
  bezierCurveTo: function(t, e, r, n, i, a) {
    this._context.bezierCurveTo(e, t, n, r, a, i);
  }
};
function yj(t) {
  return new j2(t);
}
function bj(t) {
  return new mj(t);
}
function xj(t) {
  this._context = t;
}
xj.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length;
    if (r)
      if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), r === 2)
        this._context.lineTo(t[1], e[1]);
      else
        for (var n = SN(t), i = SN(e), a = 0, s = 1; s < r; ++a, ++s)
          this._context.bezierCurveTo(n[0][a], i[0][a], n[1][a], i[1][a], t[s], e[s]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
function SN(t) {
  var e, r = t.length - 1, n, i = new Array(r), a = new Array(r), s = new Array(r);
  for (i[0] = 0, a[0] = 2, s[0] = t[0] + 2 * t[1], e = 1; e < r - 1; ++e) i[e] = 1, a[e] = 4, s[e] = 4 * t[e] + 2 * t[e + 1];
  for (i[r - 1] = 2, a[r - 1] = 7, s[r - 1] = 8 * t[r - 1] + t[r], e = 1; e < r; ++e) n = i[e] / a[e - 1], a[e] -= n, s[e] -= n * s[e - 1];
  for (i[r - 1] = s[r - 1] / a[r - 1], e = r - 2; e >= 0; --e) i[e] = (s[e] - i[e + 1]) / a[e];
  for (a[r - 1] = (t[r] + i[r - 1]) / 2, e = 0; e < r - 1; ++e) a[e] = 2 * t[e + 1] - i[e + 1];
  return [i, a];
}
function wj(t) {
  return new xj(t);
}
function Wx(t, e) {
  this._context = t, this._t = e;
}
Wx.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(t, e);
        else {
          var r = this._x * (1 - this._t) + t * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, e);
        }
        break;
      }
    }
    this._x = t, this._y = e;
  }
};
function Tj(t) {
  return new Wx(t, 0.5);
}
function Ej(t) {
  return new Wx(t, 0);
}
function Sj(t) {
  return new Wx(t, 1);
}
function Ip(t, e, r) {
  this.k = t, this.x = e, this.y = r;
}
Ip.prototype = {
  constructor: Ip,
  scale: function(t) {
    return t === 1 ? this : new Ip(this.k * t, this.x, this.y);
  },
  translate: function(t, e) {
    return t === 0 & e === 0 ? this : new Ip(this.k, this.x + this.k * t, this.y + this.k * e);
  },
  apply: function(t) {
    return [t[0] * this.k + this.x, t[1] * this.k + this.y];
  },
  applyX: function(t) {
    return t * this.k + this.x;
  },
  applyY: function(t) {
    return t * this.k + this.y;
  },
  invert: function(t) {
    return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
  },
  invertX: function(t) {
    return (t - this.x) / this.k;
  },
  invertY: function(t) {
    return (t - this.y) / this.k;
  },
  rescaleX: function(t) {
    return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
  },
  rescaleY: function(t) {
    return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Ip.prototype;
var El = /* @__PURE__ */ w((t) => {
  const { securityLevel: e } = Te();
  let r = Qe("body");
  if (e === "sandbox") {
    const a = Qe(`#i${t}`).node()?.contentDocument ?? document;
    r = Qe(a.body);
  }
  return r.select(`#${t}`);
}, "selectSvgElement");
function I9(t) {
  return typeof t > "u" || t === null;
}
w(I9, "isNothing");
function kj(t) {
  return typeof t == "object" && t !== null;
}
w(kj, "isObject");
function Cj(t) {
  return Array.isArray(t) ? t : I9(t) ? [] : [t];
}
w(Cj, "toArray");
function _j(t, e) {
  var r, n, i, a;
  if (e)
    for (a = Object.keys(e), r = 0, n = a.length; r < n; r += 1)
      i = a[r], t[i] = e[i];
  return t;
}
w(_j, "extend");
function Aj(t, e) {
  var r = "", n;
  for (n = 0; n < e; n += 1)
    r += t;
  return r;
}
w(Aj, "repeat");
function Lj(t) {
  return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
w(Lj, "isNegativeZero");
var lve = I9, cve = kj, uve = Cj, hve = Aj, fve = Lj, dve = _j, qn = {
  isNothing: lve,
  isObject: cve,
  toArray: uve,
  repeat: hve,
  isNegativeZero: fve,
  extend: dve
};
function M9(t, e) {
  var r = "", n = t.reason || "(unknown reason)";
  return t.mark ? (t.mark.name && (r += 'in "' + t.mark.name + '" '), r += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (r += `

` + t.mark.snippet), n + " " + r) : n;
}
w(M9, "formatError");
function e0(t, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = M9(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
w(e0, "YAMLException$1");
e0.prototype = Object.create(Error.prototype);
e0.prototype.constructor = e0;
e0.prototype.toString = /* @__PURE__ */ w(function(e) {
  return this.name + ": " + M9(this, e);
}, "toString");
var oa = e0;
function Cy(t, e, r, n, i) {
  var a = "", s = "", o = Math.floor(i / 2) - 1;
  return n - e > o && (a = " ... ", e = n - o + a.length), r - n > o && (s = " ...", r = n + o - s.length), {
    str: a + t.slice(e, r).replace(/\t/g, "\u2192") + s,
    pos: n - e + a.length
    // relative position
  };
}
w(Cy, "getLine");
function _y(t, e) {
  return qn.repeat(" ", e - t.length) + t;
}
w(_y, "padStart");
function Rj(t, e) {
  if (e = Object.create(e || null), !t.buffer) return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], a, s = -1; a = r.exec(t.buffer); )
    i.push(a.index), n.push(a.index + a[0].length), t.position <= a.index && s < 0 && (s = n.length - 2);
  s < 0 && (s = n.length - 1);
  var o = "", l, u, h = Math.min(t.line + e.linesAfter, i.length).toString().length, f = e.maxLength - (e.indent + h + 3);
  for (l = 1; l <= e.linesBefore && !(s - l < 0); l++)
    u = Cy(
      t.buffer,
      n[s - l],
      i[s - l],
      t.position - (n[s] - n[s - l]),
      f
    ), o = qn.repeat(" ", e.indent) + _y((t.line - l + 1).toString(), h) + " | " + u.str + `
` + o;
  for (u = Cy(t.buffer, n[s], i[s], t.position, f), o += qn.repeat(" ", e.indent) + _y((t.line + 1).toString(), h) + " | " + u.str + `
`, o += qn.repeat("-", e.indent + h + 3 + u.pos) + `^
`, l = 1; l <= e.linesAfter && !(s + l >= i.length); l++)
    u = Cy(
      t.buffer,
      n[s + l],
      i[s + l],
      t.position - (n[s] - n[s + l]),
      f
    ), o += qn.repeat(" ", e.indent) + _y((t.line + l + 1).toString(), h) + " | " + u.str + `
`;
  return o.replace(/\n$/, "");
}
w(Rj, "makeSnippet");
var pve = Rj, gve = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], mve = [
  "scalar",
  "sequence",
  "mapping"
];
function Ij(t) {
  var e = {};
  return t !== null && Object.keys(t).forEach(function(r) {
    t[r].forEach(function(n) {
      e[String(n)] = r;
    });
  }), e;
}
w(Ij, "compileStyleAliases");
function Mj(t, e) {
  if (e = e || {}, Object.keys(e).forEach(function(r) {
    if (gve.indexOf(r) === -1)
      throw new oa('Unknown option "' + r + '" is met in definition of "' + t + '" YAML type.');
  }), this.options = e, this.tag = t, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return !0;
  }, this.construct = e.construct || function(r) {
    return r;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || !1, this.styleAliases = Ij(e.styleAliases || null), mve.indexOf(this.kind) === -1)
    throw new oa('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
}
w(Mj, "Type$1");
var _i = Mj;
function y_(t, e) {
  var r = [];
  return t[e].forEach(function(n) {
    var i = r.length;
    r.forEach(function(a, s) {
      a.tag === n.tag && a.kind === n.kind && a.multi === n.multi && (i = s);
    }), r[i] = n;
  }), r;
}
w(y_, "compileList");
function Nj() {
  var t = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, r;
  function n(i) {
    i.multi ? (t.multi[i.kind].push(i), t.multi.fallback.push(i)) : t[i.kind][i.tag] = t.fallback[i.tag] = i;
  }
  for (w(n, "collectType"), e = 0, r = arguments.length; e < r; e += 1)
    arguments[e].forEach(n);
  return t;
}
w(Nj, "compileMap");
function K2(t) {
  return this.extend(t);
}
w(K2, "Schema$1");
K2.prototype.extend = /* @__PURE__ */ w(function(e) {
  var r = [], n = [];
  if (e instanceof _i)
    n.push(e);
  else if (Array.isArray(e))
    n = n.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (r = r.concat(e.implicit)), e.explicit && (n = n.concat(e.explicit));
  else
    throw new oa("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(a) {
    if (!(a instanceof _i))
      throw new oa("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (a.loadKind && a.loadKind !== "scalar")
      throw new oa("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (a.multi)
      throw new oa("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), n.forEach(function(a) {
    if (!(a instanceof _i))
      throw new oa("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(K2.prototype);
  return i.implicit = (this.implicit || []).concat(r), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = y_(i, "implicit"), i.compiledExplicit = y_(i, "explicit"), i.compiledTypeMap = Nj(i.compiledImplicit, i.compiledExplicit), i;
}, "extend");
var vve = K2, yve = new _i("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: /* @__PURE__ */ w(function(t) {
    return t !== null ? t : "";
  }, "construct")
}), bve = new _i("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: /* @__PURE__ */ w(function(t) {
    return t !== null ? t : [];
  }, "construct")
}), xve = new _i("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: /* @__PURE__ */ w(function(t) {
    return t !== null ? t : {};
  }, "construct")
}), wve = new vve({
  explicit: [
    yve,
    bve,
    xve
  ]
});
function Dj(t) {
  if (t === null) return !0;
  var e = t.length;
  return e === 1 && t === "~" || e === 4 && (t === "null" || t === "Null" || t === "NULL");
}
w(Dj, "resolveYamlNull");
function Oj() {
  return null;
}
w(Oj, "constructYamlNull");
function Pj(t) {
  return t === null;
}
w(Pj, "isNull");
var Tve = new _i("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: Dj,
  construct: Oj,
  predicate: Pj,
  represent: {
    canonical: /* @__PURE__ */ w(function() {
      return "~";
    }, "canonical"),
    lowercase: /* @__PURE__ */ w(function() {
      return "null";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ w(function() {
      return "NULL";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ w(function() {
      return "Null";
    }, "camelcase"),
    empty: /* @__PURE__ */ w(function() {
      return "";
    }, "empty")
  },
  defaultStyle: "lowercase"
});
function $j(t) {
  if (t === null) return !1;
  var e = t.length;
  return e === 4 && (t === "true" || t === "True" || t === "TRUE") || e === 5 && (t === "false" || t === "False" || t === "FALSE");
}
w($j, "resolveYamlBoolean");
function Bj(t) {
  return t === "true" || t === "True" || t === "TRUE";
}
w(Bj, "constructYamlBoolean");
function Fj(t) {
  return Object.prototype.toString.call(t) === "[object Boolean]";
}
w(Fj, "isBoolean");
var Eve = new _i("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: $j,
  construct: Bj,
  predicate: Fj,
  represent: {
    lowercase: /* @__PURE__ */ w(function(t) {
      return t ? "true" : "false";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ w(function(t) {
      return t ? "TRUE" : "FALSE";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ w(function(t) {
      return t ? "True" : "False";
    }, "camelcase")
  },
  defaultStyle: "lowercase"
});
function zj(t) {
  return 48 <= t && t <= 57 || 65 <= t && t <= 70 || 97 <= t && t <= 102;
}
w(zj, "isHexCode");
function qj(t) {
  return 48 <= t && t <= 55;
}
w(qj, "isOctCode");
function Gj(t) {
  return 48 <= t && t <= 57;
}
w(Gj, "isDecCode");
function Uj(t) {
  if (t === null) return !1;
  var e = t.length, r = 0, n = !1, i;
  if (!e) return !1;
  if (i = t[r], (i === "-" || i === "+") && (i = t[++r]), i === "0") {
    if (r + 1 === e) return !0;
    if (i = t[++r], i === "b") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (i !== "0" && i !== "1") return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (!zj(t.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (!qj(t.charCodeAt(r))) return !1;
          n = !0;
        }
      return n && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; r < e; r++)
    if (i = t[r], i !== "_") {
      if (!Gj(t.charCodeAt(r)))
        return !1;
      n = !0;
    }
  return !(!n || i === "_");
}
w(Uj, "resolveYamlInteger");
function Vj(t) {
  var e = t, r = 1, n;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (r = -1), e = e.slice(1), n = e[0]), e === "0") return 0;
  if (n === "0") {
    if (e[1] === "b") return r * parseInt(e.slice(2), 2);
    if (e[1] === "x") return r * parseInt(e.slice(2), 16);
    if (e[1] === "o") return r * parseInt(e.slice(2), 8);
  }
  return r * parseInt(e, 10);
}
w(Vj, "constructYamlInteger");
function Hj(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !qn.isNegativeZero(t);
}
w(Hj, "isInteger");
var Sve = new _i("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: Uj,
  construct: Vj,
  predicate: Hj,
  represent: {
    binary: /* @__PURE__ */ w(function(t) {
      return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
    }, "binary"),
    octal: /* @__PURE__ */ w(function(t) {
      return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
    }, "octal"),
    decimal: /* @__PURE__ */ w(function(t) {
      return t.toString(10);
    }, "decimal"),
    /* eslint-disable max-len */
    hexadecimal: /* @__PURE__ */ w(function(t) {
      return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
    }, "hexadecimal")
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), kve = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function Wj(t) {
  return !(t === null || !kve.test(t) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t[t.length - 1] === "_");
}
w(Wj, "resolveYamlFloat");
function Yj(t) {
  var e, r;
  return e = t.replace(/_/g, "").toLowerCase(), r = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : r * parseFloat(e, 10);
}
w(Yj, "constructYamlFloat");
var Cve = /^[-+]?[0-9]+e/;
function Xj(t, e) {
  var r;
  if (isNaN(t))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (qn.isNegativeZero(t))
    return "-0.0";
  return r = t.toString(10), Cve.test(r) ? r.replace("e", ".e") : r;
}
w(Xj, "representYamlFloat");
function jj(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || qn.isNegativeZero(t));
}
w(jj, "isFloat");
var _ve = new _i("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: Wj,
  construct: Yj,
  predicate: jj,
  represent: Xj,
  defaultStyle: "lowercase"
}), Kj = wve.extend({
  implicit: [
    Tve,
    Eve,
    Sve,
    _ve
  ]
}), Ave = Kj, Zj = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Qj = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function Jj(t) {
  return t === null ? !1 : Zj.exec(t) !== null || Qj.exec(t) !== null;
}
w(Jj, "resolveYamlTimestamp");
function eK(t) {
  var e, r, n, i, a, s, o, l = 0, u = null, h, f, d;
  if (e = Zj.exec(t), e === null && (e = Qj.exec(t)), e === null) throw new Error("Date resolve error");
  if (r = +e[1], n = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(r, n, i));
  if (a = +e[4], s = +e[5], o = +e[6], e[7]) {
    for (l = e[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return e[9] && (h = +e[10], f = +(e[11] || 0), u = (h * 60 + f) * 6e4, e[9] === "-" && (u = -u)), d = new Date(Date.UTC(r, n, i, a, s, o, l)), u && d.setTime(d.getTime() - u), d;
}
w(eK, "constructYamlTimestamp");
function tK(t) {
  return t.toISOString();
}
w(tK, "representYamlTimestamp");
var Lve = new _i("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: Jj,
  construct: eK,
  instanceOf: Date,
  represent: tK
});
function rK(t) {
  return t === "<<" || t === null;
}
w(rK, "resolveYamlMerge");
var Rve = new _i("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: rK
}), N9 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function nK(t) {
  if (t === null) return !1;
  var e, r, n = 0, i = t.length, a = N9;
  for (r = 0; r < i; r++)
    if (e = a.indexOf(t.charAt(r)), !(e > 64)) {
      if (e < 0) return !1;
      n += 6;
    }
  return n % 8 === 0;
}
w(nK, "resolveYamlBinary");
function iK(t) {
  var e, r, n = t.replace(/[\r\n=]/g, ""), i = n.length, a = N9, s = 0, o = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)), s = s << 6 | a.indexOf(n.charAt(e));
  return r = i % 4 * 6, r === 0 ? (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)) : r === 18 ? (o.push(s >> 10 & 255), o.push(s >> 2 & 255)) : r === 12 && o.push(s >> 4 & 255), new Uint8Array(o);
}
w(iK, "constructYamlBinary");
function aK(t) {
  var e = "", r = 0, n, i, a = t.length, s = N9;
  for (n = 0; n < a; n++)
    n % 3 === 0 && n && (e += s[r >> 18 & 63], e += s[r >> 12 & 63], e += s[r >> 6 & 63], e += s[r & 63]), r = (r << 8) + t[n];
  return i = a % 3, i === 0 ? (e += s[r >> 18 & 63], e += s[r >> 12 & 63], e += s[r >> 6 & 63], e += s[r & 63]) : i === 2 ? (e += s[r >> 10 & 63], e += s[r >> 4 & 63], e += s[r << 2 & 63], e += s[64]) : i === 1 && (e += s[r >> 2 & 63], e += s[r << 4 & 63], e += s[64], e += s[64]), e;
}
w(aK, "representYamlBinary");
function sK(t) {
  return Object.prototype.toString.call(t) === "[object Uint8Array]";
}
w(sK, "isBinary");
var Ive = new _i("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: nK,
  construct: iK,
  predicate: sK,
  represent: aK
}), Mve = Object.prototype.hasOwnProperty, Nve = Object.prototype.toString;
function oK(t) {
  if (t === null) return !0;
  var e = [], r, n, i, a, s, o = t;
  for (r = 0, n = o.length; r < n; r += 1) {
    if (i = o[r], s = !1, Nve.call(i) !== "[object Object]") return !1;
    for (a in i)
      if (Mve.call(i, a))
        if (!s) s = !0;
        else return !1;
    if (!s) return !1;
    if (e.indexOf(a) === -1) e.push(a);
    else return !1;
  }
  return !0;
}
w(oK, "resolveYamlOmap");
function lK(t) {
  return t !== null ? t : [];
}
w(lK, "constructYamlOmap");
var Dve = new _i("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: oK,
  construct: lK
}), Ove = Object.prototype.toString;
function cK(t) {
  if (t === null) return !0;
  var e, r, n, i, a, s = t;
  for (a = new Array(s.length), e = 0, r = s.length; e < r; e += 1) {
    if (n = s[e], Ove.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return !1;
    a[e] = [i[0], n[i[0]]];
  }
  return !0;
}
w(cK, "resolveYamlPairs");
function uK(t) {
  if (t === null) return [];
  var e, r, n, i, a, s = t;
  for (a = new Array(s.length), e = 0, r = s.length; e < r; e += 1)
    n = s[e], i = Object.keys(n), a[e] = [i[0], n[i[0]]];
  return a;
}
w(uK, "constructYamlPairs");
var Pve = new _i("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: cK,
  construct: uK
}), $ve = Object.prototype.hasOwnProperty;
function hK(t) {
  if (t === null) return !0;
  var e, r = t;
  for (e in r)
    if ($ve.call(r, e) && r[e] !== null)
      return !1;
  return !0;
}
w(hK, "resolveYamlSet");
function fK(t) {
  return t !== null ? t : {};
}
w(fK, "constructYamlSet");
var Bve = new _i("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: hK,
  construct: fK
}), dK = Ave.extend({
  implicit: [
    Lve,
    Rve
  ],
  explicit: [
    Ive,
    Dve,
    Pve,
    Bve
  ]
}), hc = Object.prototype.hasOwnProperty, Z2 = 1, pK = 2, gK = 3, Q2 = 4, I5 = 1, Fve = 2, kN = 3, zve = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, qve = /[\x85\u2028\u2029]/, Gve = /[,\[\]\{\}]/, mK = /^(?:!|!!|![a-z\-]+!)$/i, vK = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function b_(t) {
  return Object.prototype.toString.call(t);
}
w(b_, "_class");
function Ss(t) {
  return t === 10 || t === 13;
}
w(Ss, "is_EOL");
function sc(t) {
  return t === 9 || t === 32;
}
w(sc, "is_WHITE_SPACE");
function qi(t) {
  return t === 9 || t === 32 || t === 10 || t === 13;
}
w(qi, "is_WS_OR_EOL");
function Ru(t) {
  return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
w(Ru, "is_FLOW_INDICATOR");
function yK(t) {
  var e;
  return 48 <= t && t <= 57 ? t - 48 : (e = t | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
w(yK, "fromHexCode");
function bK(t) {
  return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
w(bK, "escapedHexLen");
function xK(t) {
  return 48 <= t && t <= 57 ? t - 48 : -1;
}
w(xK, "fromDecimalCode");
function x_(t) {
  return t === 48 ? "\0" : t === 97 ? "\x07" : t === 98 ? "\b" : t === 116 || t === 9 ? "	" : t === 110 ? `
` : t === 118 ? "\v" : t === 102 ? "\f" : t === 114 ? "\r" : t === 101 ? "\x1B" : t === 32 ? " " : t === 34 ? '"' : t === 47 ? "/" : t === 92 ? "\\" : t === 78 ? "\x85" : t === 95 ? "\xA0" : t === 76 ? "\u2028" : t === 80 ? "\u2029" : "";
}
w(x_, "simpleEscapeSequence");
function wK(t) {
  return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode(
    (t - 65536 >> 10) + 55296,
    (t - 65536 & 1023) + 56320
  );
}
w(wK, "charFromCodepoint");
var TK = new Array(256), EK = new Array(256);
for (lu = 0; lu < 256; lu++)
  TK[lu] = x_(lu) ? 1 : 0, EK[lu] = x_(lu);
var lu;
function SK(t, e) {
  this.input = t, this.filename = e.filename || null, this.schema = e.schema || dK, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
w(SK, "State$1");
function D9(t, e) {
  var r = {
    name: t.filename,
    buffer: t.input.slice(0, -1),
    // omit trailing \0
    position: t.position,
    line: t.line,
    column: t.position - t.lineStart
  };
  return r.snippet = pve(r), new oa(e, r);
}
w(D9, "generateError");
function Ot(t, e) {
  throw D9(t, e);
}
w(Ot, "throwError");
function a1(t, e) {
  t.onWarning && t.onWarning.call(null, D9(t, e));
}
w(a1, "throwWarning");
var CN = {
  YAML: /* @__PURE__ */ w(function(e, r, n) {
    var i, a, s;
    e.version !== null && Ot(e, "duplication of %YAML directive"), n.length !== 1 && Ot(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && Ot(e, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), s = parseInt(i[2], 10), a !== 1 && Ot(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = s < 2, s !== 1 && s !== 2 && a1(e, "unsupported YAML version of the document");
  }, "handleYamlDirective"),
  TAG: /* @__PURE__ */ w(function(e, r, n) {
    var i, a;
    n.length !== 2 && Ot(e, "TAG directive accepts exactly two arguments"), i = n[0], a = n[1], mK.test(i) || Ot(e, "ill-formed tag handle (first argument) of the TAG directive"), hc.call(e.tagMap, i) && Ot(e, 'there is a previously declared suffix for "' + i + '" tag handle'), vK.test(a) || Ot(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      a = decodeURIComponent(a);
    } catch {
      Ot(e, "tag prefix is malformed: " + a);
    }
    e.tagMap[i] = a;
  }, "handleTagDirective")
};
function al(t, e, r, n) {
  var i, a, s, o;
  if (e < r) {
    if (o = t.input.slice(e, r), n)
      for (i = 0, a = o.length; i < a; i += 1)
        s = o.charCodeAt(i), s === 9 || 32 <= s && s <= 1114111 || Ot(t, "expected valid JSON character");
    else zve.test(o) && Ot(t, "the stream contains non-printable characters");
    t.result += o;
  }
}
w(al, "captureSegment");
function w_(t, e, r, n) {
  var i, a, s, o;
  for (qn.isObject(r) || Ot(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), s = 0, o = i.length; s < o; s += 1)
    a = i[s], hc.call(e, a) || (e[a] = r[a], n[a] = !0);
}
w(w_, "mergeMappings");
function Iu(t, e, r, n, i, a, s, o, l) {
  var u, h;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, h = i.length; u < h; u += 1)
      Array.isArray(i[u]) && Ot(t, "nested arrays are not supported inside keys"), typeof i == "object" && b_(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (typeof i == "object" && b_(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(a))
      for (u = 0, h = a.length; u < h; u += 1)
        w_(t, e, a[u], r);
    else
      w_(t, e, a, r);
  else
    !t.json && !hc.call(r, i) && hc.call(e, i) && (t.line = s || t.line, t.lineStart = o || t.lineStart, t.position = l || t.position, Ot(t, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: a
    }) : e[i] = a, delete r[i];
  return e;
}
w(Iu, "storeMappingPair");
function Yx(t) {
  var e;
  e = t.input.charCodeAt(t.position), e === 10 ? t.position++ : e === 13 ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++) : Ot(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1;
}
w(Yx, "readLineBreak");
function xn(t, e, r) {
  for (var n = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
    for (; sc(i); )
      i === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), i = t.input.charCodeAt(++t.position);
    if (e && i === 35)
      do
        i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (Ss(i))
      for (Yx(t), i = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; i === 32; )
        t.lineIndent++, i = t.input.charCodeAt(++t.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && t.lineIndent < r && a1(t, "deficient indentation"), n;
}
w(xn, "skipSeparationSpace");
function rm(t) {
  var e = t.position, r;
  return r = t.input.charCodeAt(e), !!((r === 45 || r === 46) && r === t.input.charCodeAt(e + 1) && r === t.input.charCodeAt(e + 2) && (e += 3, r = t.input.charCodeAt(e), r === 0 || qi(r)));
}
w(rm, "testDocumentSeparator");
function Xx(t, e) {
  e === 1 ? t.result += " " : e > 1 && (t.result += qn.repeat(`
`, e - 1));
}
w(Xx, "writeFoldedLines");
function kK(t, e, r) {
  var n, i, a, s, o, l, u, h, f = t.kind, d = t.result, p;
  if (p = t.input.charCodeAt(t.position), qi(p) || Ru(p) || p === 35 || p === 38 || p === 42 || p === 33 || p === 124 || p === 62 || p === 39 || p === 34 || p === 37 || p === 64 || p === 96 || (p === 63 || p === 45) && (i = t.input.charCodeAt(t.position + 1), qi(i) || r && Ru(i)))
    return !1;
  for (t.kind = "scalar", t.result = "", a = s = t.position, o = !1; p !== 0; ) {
    if (p === 58) {
      if (i = t.input.charCodeAt(t.position + 1), qi(i) || r && Ru(i))
        break;
    } else if (p === 35) {
      if (n = t.input.charCodeAt(t.position - 1), qi(n))
        break;
    } else {
      if (t.position === t.lineStart && rm(t) || r && Ru(p))
        break;
      if (Ss(p))
        if (l = t.line, u = t.lineStart, h = t.lineIndent, xn(t, !1, -1), t.lineIndent >= e) {
          o = !0, p = t.input.charCodeAt(t.position);
          continue;
        } else {
          t.position = s, t.line = l, t.lineStart = u, t.lineIndent = h;
          break;
        }
    }
    o && (al(t, a, s, !1), Xx(t, t.line - l), a = s = t.position, o = !1), sc(p) || (s = t.position + 1), p = t.input.charCodeAt(++t.position);
  }
  return al(t, a, s, !1), t.result ? !0 : (t.kind = f, t.result = d, !1);
}
w(kK, "readPlainScalar");
function CK(t, e) {
  var r, n, i;
  if (r = t.input.charCodeAt(t.position), r !== 39)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, n = i = t.position; (r = t.input.charCodeAt(t.position)) !== 0; )
    if (r === 39)
      if (al(t, n, t.position, !0), r = t.input.charCodeAt(++t.position), r === 39)
        n = t.position, t.position++, i = t.position;
      else
        return !0;
    else Ss(r) ? (al(t, n, i, !0), Xx(t, xn(t, !1, e)), n = i = t.position) : t.position === t.lineStart && rm(t) ? Ot(t, "unexpected end of the document within a single quoted scalar") : (t.position++, i = t.position);
  Ot(t, "unexpected end of the stream within a single quoted scalar");
}
w(CK, "readSingleQuotedScalar");
function _K(t, e) {
  var r, n, i, a, s, o;
  if (o = t.input.charCodeAt(t.position), o !== 34)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, r = n = t.position; (o = t.input.charCodeAt(t.position)) !== 0; ) {
    if (o === 34)
      return al(t, r, t.position, !0), t.position++, !0;
    if (o === 92) {
      if (al(t, r, t.position, !0), o = t.input.charCodeAt(++t.position), Ss(o))
        xn(t, !1, e);
      else if (o < 256 && TK[o])
        t.result += EK[o], t.position++;
      else if ((s = bK(o)) > 0) {
        for (i = s, a = 0; i > 0; i--)
          o = t.input.charCodeAt(++t.position), (s = yK(o)) >= 0 ? a = (a << 4) + s : Ot(t, "expected hexadecimal character");
        t.result += wK(a), t.position++;
      } else
        Ot(t, "unknown escape sequence");
      r = n = t.position;
    } else Ss(o) ? (al(t, r, n, !0), Xx(t, xn(t, !1, e)), r = n = t.position) : t.position === t.lineStart && rm(t) ? Ot(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position);
  }
  Ot(t, "unexpected end of the stream within a double quoted scalar");
}
w(_K, "readDoubleQuotedScalar");
function AK(t, e) {
  var r = !0, n, i, a, s = t.tag, o, l = t.anchor, u, h, f, d, p, g = /* @__PURE__ */ Object.create(null), m, v, y, b;
  if (b = t.input.charCodeAt(t.position), b === 91)
    h = 93, p = !1, o = [];
  else if (b === 123)
    h = 125, p = !0, o = {};
  else
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = o), b = t.input.charCodeAt(++t.position); b !== 0; ) {
    if (xn(t, !0, e), b = t.input.charCodeAt(t.position), b === h)
      return t.position++, t.tag = s, t.anchor = l, t.kind = p ? "mapping" : "sequence", t.result = o, !0;
    r ? b === 44 && Ot(t, "expected the node content, but found ','") : Ot(t, "missed comma between flow collection entries"), v = m = y = null, f = d = !1, b === 63 && (u = t.input.charCodeAt(t.position + 1), qi(u) && (f = d = !0, t.position++, xn(t, !0, e))), n = t.line, i = t.lineStart, a = t.position, Xu(t, e, Z2, !1, !0), v = t.tag, m = t.result, xn(t, !0, e), b = t.input.charCodeAt(t.position), (d || t.line === n) && b === 58 && (f = !0, b = t.input.charCodeAt(++t.position), xn(t, !0, e), Xu(t, e, Z2, !1, !0), y = t.result), p ? Iu(t, o, g, v, m, y, n, i, a) : f ? o.push(Iu(t, null, g, v, m, y, n, i, a)) : o.push(m), xn(t, !0, e), b = t.input.charCodeAt(t.position), b === 44 ? (r = !0, b = t.input.charCodeAt(++t.position)) : r = !1;
  }
  Ot(t, "unexpected end of the stream within a flow collection");
}
w(AK, "readFlowCollection");
function LK(t, e) {
  var r, n, i = I5, a = !1, s = !1, o = e, l = 0, u = !1, h, f;
  if (f = t.input.charCodeAt(t.position), f === 124)
    n = !1;
  else if (f === 62)
    n = !0;
  else
    return !1;
  for (t.kind = "scalar", t.result = ""; f !== 0; )
    if (f = t.input.charCodeAt(++t.position), f === 43 || f === 45)
      I5 === i ? i = f === 43 ? kN : Fve : Ot(t, "repeat of a chomping mode identifier");
    else if ((h = xK(f)) >= 0)
      h === 0 ? Ot(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : s ? Ot(t, "repeat of an indentation width identifier") : (o = e + h - 1, s = !0);
    else
      break;
  if (sc(f)) {
    do
      f = t.input.charCodeAt(++t.position);
    while (sc(f));
    if (f === 35)
      do
        f = t.input.charCodeAt(++t.position);
      while (!Ss(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (Yx(t), t.lineIndent = 0, f = t.input.charCodeAt(t.position); (!s || t.lineIndent < o) && f === 32; )
      t.lineIndent++, f = t.input.charCodeAt(++t.position);
    if (!s && t.lineIndent > o && (o = t.lineIndent), Ss(f)) {
      l++;
      continue;
    }
    if (t.lineIndent < o) {
      i === kN ? t.result += qn.repeat(`
`, a ? 1 + l : l) : i === I5 && a && (t.result += `
`);
      break;
    }
    for (n ? sc(f) ? (u = !0, t.result += qn.repeat(`
`, a ? 1 + l : l)) : u ? (u = !1, t.result += qn.repeat(`
`, l + 1)) : l === 0 ? a && (t.result += " ") : t.result += qn.repeat(`
`, l) : t.result += qn.repeat(`
`, a ? 1 + l : l), a = !0, s = !0, l = 0, r = t.position; !Ss(f) && f !== 0; )
      f = t.input.charCodeAt(++t.position);
    al(t, r, t.position, !1);
  }
  return !0;
}
w(LK, "readBlockScalar");
function T_(t, e) {
  var r, n = t.tag, i = t.anchor, a = [], s, o = !1, l;
  if (t.firstTabInLine !== -1) return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = a), l = t.input.charCodeAt(t.position); l !== 0 && (t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Ot(t, "tab characters must not be used in indentation")), !(l !== 45 || (s = t.input.charCodeAt(t.position + 1), !qi(s)))); ) {
    if (o = !0, t.position++, xn(t, !0, -1) && t.lineIndent <= e) {
      a.push(null), l = t.input.charCodeAt(t.position);
      continue;
    }
    if (r = t.line, Xu(t, e, gK, !1, !0), a.push(t.result), xn(t, !0, -1), l = t.input.charCodeAt(t.position), (t.line === r || t.lineIndent > e) && l !== 0)
      Ot(t, "bad indentation of a sequence entry");
    else if (t.lineIndent < e)
      break;
  }
  return o ? (t.tag = n, t.anchor = i, t.kind = "sequence", t.result = a, !0) : !1;
}
w(T_, "readBlockSequence");
function RK(t, e, r) {
  var n, i, a, s, o, l, u = t.tag, h = t.anchor, f = {}, d = /* @__PURE__ */ Object.create(null), p = null, g = null, m = null, v = !1, y = !1, b;
  if (t.firstTabInLine !== -1) return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = f), b = t.input.charCodeAt(t.position); b !== 0; ) {
    if (!v && t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Ot(t, "tab characters must not be used in indentation")), n = t.input.charCodeAt(t.position + 1), a = t.line, (b === 63 || b === 58) && qi(n))
      b === 63 ? (v && (Iu(t, f, d, p, g, null, s, o, l), p = g = m = null), y = !0, v = !0, i = !0) : v ? (v = !1, i = !0) : Ot(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, b = n;
    else {
      if (s = t.line, o = t.lineStart, l = t.position, !Xu(t, r, pK, !1, !0))
        break;
      if (t.line === a) {
        for (b = t.input.charCodeAt(t.position); sc(b); )
          b = t.input.charCodeAt(++t.position);
        if (b === 58)
          b = t.input.charCodeAt(++t.position), qi(b) || Ot(t, "a whitespace character is expected after the key-value separator within a block mapping"), v && (Iu(t, f, d, p, g, null, s, o, l), p = g = m = null), y = !0, v = !1, i = !1, p = t.tag, g = t.result;
        else if (y)
          Ot(t, "can not read an implicit mapping pair; a colon is missed");
        else
          return t.tag = u, t.anchor = h, !0;
      } else if (y)
        Ot(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t.tag = u, t.anchor = h, !0;
    }
    if ((t.line === a || t.lineIndent > e) && (v && (s = t.line, o = t.lineStart, l = t.position), Xu(t, e, Q2, !0, i) && (v ? g = t.result : m = t.result), v || (Iu(t, f, d, p, g, m, s, o, l), p = g = m = null), xn(t, !0, -1), b = t.input.charCodeAt(t.position)), (t.line === a || t.lineIndent > e) && b !== 0)
      Ot(t, "bad indentation of a mapping entry");
    else if (t.lineIndent < e)
      break;
  }
  return v && Iu(t, f, d, p, g, null, s, o, l), y && (t.tag = u, t.anchor = h, t.kind = "mapping", t.result = f), y;
}
w(RK, "readBlockMapping");
function IK(t) {
  var e, r = !1, n = !1, i, a, s;
  if (s = t.input.charCodeAt(t.position), s !== 33) return !1;
  if (t.tag !== null && Ot(t, "duplication of a tag property"), s = t.input.charCodeAt(++t.position), s === 60 ? (r = !0, s = t.input.charCodeAt(++t.position)) : s === 33 ? (n = !0, i = "!!", s = t.input.charCodeAt(++t.position)) : i = "!", e = t.position, r) {
    do
      s = t.input.charCodeAt(++t.position);
    while (s !== 0 && s !== 62);
    t.position < t.length ? (a = t.input.slice(e, t.position), s = t.input.charCodeAt(++t.position)) : Ot(t, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !qi(s); )
      s === 33 && (n ? Ot(t, "tag suffix cannot contain exclamation marks") : (i = t.input.slice(e - 1, t.position + 1), mK.test(i) || Ot(t, "named tag handle cannot contain such characters"), n = !0, e = t.position + 1)), s = t.input.charCodeAt(++t.position);
    a = t.input.slice(e, t.position), Gve.test(a) && Ot(t, "tag suffix cannot contain flow indicator characters");
  }
  a && !vK.test(a) && Ot(t, "tag name cannot contain such characters: " + a);
  try {
    a = decodeURIComponent(a);
  } catch {
    Ot(t, "tag name is malformed: " + a);
  }
  return r ? t.tag = a : hc.call(t.tagMap, i) ? t.tag = t.tagMap[i] + a : i === "!" ? t.tag = "!" + a : i === "!!" ? t.tag = "tag:yaml.org,2002:" + a : Ot(t, 'undeclared tag handle "' + i + '"'), !0;
}
w(IK, "readTagProperty");
function MK(t) {
  var e, r;
  if (r = t.input.charCodeAt(t.position), r !== 38) return !1;
  for (t.anchor !== null && Ot(t, "duplication of an anchor property"), r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !qi(r) && !Ru(r); )
    r = t.input.charCodeAt(++t.position);
  return t.position === e && Ot(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), !0;
}
w(MK, "readAnchorProperty");
function NK(t) {
  var e, r, n;
  if (n = t.input.charCodeAt(t.position), n !== 42) return !1;
  for (n = t.input.charCodeAt(++t.position), e = t.position; n !== 0 && !qi(n) && !Ru(n); )
    n = t.input.charCodeAt(++t.position);
  return t.position === e && Ot(t, "name of an alias node must contain at least one character"), r = t.input.slice(e, t.position), hc.call(t.anchorMap, r) || Ot(t, 'unidentified alias "' + r + '"'), t.result = t.anchorMap[r], xn(t, !0, -1), !0;
}
w(NK, "readAlias");
function Xu(t, e, r, n, i) {
  var a, s, o, l = 1, u = !1, h = !1, f, d, p, g, m, v;
  if (t.listener !== null && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, a = s = o = Q2 === r || gK === r, n && xn(t, !0, -1) && (u = !0, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)), l === 1)
    for (; IK(t) || MK(t); )
      xn(t, !0, -1) ? (u = !0, o = a, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)) : o = !1;
  if (o && (o = u || i), (l === 1 || Q2 === r) && (Z2 === r || pK === r ? m = e : m = e + 1, v = t.position - t.lineStart, l === 1 ? o && (T_(t, v) || RK(t, v, m)) || AK(t, m) ? h = !0 : (s && LK(t, m) || CK(t, m) || _K(t, m) ? h = !0 : NK(t) ? (h = !0, (t.tag !== null || t.anchor !== null) && Ot(t, "alias node should not have any properties")) : kK(t, m, Z2 === r) && (h = !0, t.tag === null && (t.tag = "?")), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : l === 0 && (h = o && T_(t, v))), t.tag === null)
    t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
  else if (t.tag === "?") {
    for (t.result !== null && t.kind !== "scalar" && Ot(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), f = 0, d = t.implicitTypes.length; f < d; f += 1)
      if (g = t.implicitTypes[f], g.resolve(t.result)) {
        t.result = g.construct(t.result), t.tag = g.tag, t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
  } else if (t.tag !== "!") {
    if (hc.call(t.typeMap[t.kind || "fallback"], t.tag))
      g = t.typeMap[t.kind || "fallback"][t.tag];
    else
      for (g = null, p = t.typeMap.multi[t.kind || "fallback"], f = 0, d = p.length; f < d; f += 1)
        if (t.tag.slice(0, p[f].tag.length) === p[f].tag) {
          g = p[f];
          break;
        }
    g || Ot(t, "unknown tag !<" + t.tag + ">"), t.result !== null && g.kind !== t.kind && Ot(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + g.kind + '", not "' + t.kind + '"'), g.resolve(t.result, t.tag) ? (t.result = g.construct(t.result, t.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : Ot(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
  }
  return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || h;
}
w(Xu, "composeNode");
function DK(t) {
  var e = t.position, r, n, i, a = !1, s;
  for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = /* @__PURE__ */ Object.create(null), t.anchorMap = /* @__PURE__ */ Object.create(null); (s = t.input.charCodeAt(t.position)) !== 0 && (xn(t, !0, -1), s = t.input.charCodeAt(t.position), !(t.lineIndent > 0 || s !== 37)); ) {
    for (a = !0, s = t.input.charCodeAt(++t.position), r = t.position; s !== 0 && !qi(s); )
      s = t.input.charCodeAt(++t.position);
    for (n = t.input.slice(r, t.position), i = [], n.length < 1 && Ot(t, "directive name must not be less than one character in length"); s !== 0; ) {
      for (; sc(s); )
        s = t.input.charCodeAt(++t.position);
      if (s === 35) {
        do
          s = t.input.charCodeAt(++t.position);
        while (s !== 0 && !Ss(s));
        break;
      }
      if (Ss(s)) break;
      for (r = t.position; s !== 0 && !qi(s); )
        s = t.input.charCodeAt(++t.position);
      i.push(t.input.slice(r, t.position));
    }
    s !== 0 && Yx(t), hc.call(CN, n) ? CN[n](t, n, i) : a1(t, 'unknown document directive "' + n + '"');
  }
  if (xn(t, !0, -1), t.lineIndent === 0 && t.input.charCodeAt(t.position) === 45 && t.input.charCodeAt(t.position + 1) === 45 && t.input.charCodeAt(t.position + 2) === 45 ? (t.position += 3, xn(t, !0, -1)) : a && Ot(t, "directives end mark is expected"), Xu(t, t.lineIndent - 1, Q2, !1, !0), xn(t, !0, -1), t.checkLineBreaks && qve.test(t.input.slice(e, t.position)) && a1(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && rm(t)) {
    t.input.charCodeAt(t.position) === 46 && (t.position += 3, xn(t, !0, -1));
    return;
  }
  if (t.position < t.length - 1)
    Ot(t, "end of the stream or a document separator is expected");
  else
    return;
}
w(DK, "readDocument");
function O9(t, e) {
  t = String(t), e = e || {}, t.length !== 0 && (t.charCodeAt(t.length - 1) !== 10 && t.charCodeAt(t.length - 1) !== 13 && (t += `
`), t.charCodeAt(0) === 65279 && (t = t.slice(1)));
  var r = new SK(t, e), n = t.indexOf("\0");
  for (n !== -1 && (r.position = n, Ot(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    DK(r);
  return r.documents;
}
w(O9, "loadDocuments");
function Uve(t, e, r) {
  e !== null && typeof e == "object" && typeof r > "u" && (r = e, e = null);
  var n = O9(t, r);
  if (typeof e != "function")
    return n;
  for (var i = 0, a = n.length; i < a; i += 1)
    e(n[i]);
}
w(Uve, "loadAll$1");
function OK(t, e) {
  var r = O9(t, e);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new oa("expected a single document in the stream, but found more");
  }
}
w(OK, "load$1");
var Vve = OK, Hve = {
  load: Vve
}, PK = Object.prototype.toString, $K = Object.prototype.hasOwnProperty, P9 = 65279, Wve = 9, s1 = 10, Yve = 13, Xve = 32, jve = 33, Kve = 34, E_ = 35, Zve = 37, Qve = 38, Jve = 39, eye = 42, BK = 44, tye = 45, J2 = 58, rye = 61, nye = 62, iye = 63, aye = 64, FK = 91, zK = 93, sye = 96, qK = 123, oye = 124, GK = 125, Mi = {};
Mi[0] = "\\0";
Mi[7] = "\\a";
Mi[8] = "\\b";
Mi[9] = "\\t";
Mi[10] = "\\n";
Mi[11] = "\\v";
Mi[12] = "\\f";
Mi[13] = "\\r";
Mi[27] = "\\e";
Mi[34] = '\\"';
Mi[92] = "\\\\";
Mi[133] = "\\N";
Mi[160] = "\\_";
Mi[8232] = "\\L";
Mi[8233] = "\\P";
var lye = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], cye = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function UK(t, e) {
  var r, n, i, a, s, o, l;
  if (e === null) return {};
  for (r = {}, n = Object.keys(e), i = 0, a = n.length; i < a; i += 1)
    s = n[i], o = String(e[s]), s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)), l = t.compiledTypeMap.fallback[s], l && $K.call(l.styleAliases, o) && (o = l.styleAliases[o]), r[s] = o;
  return r;
}
w(UK, "compileStyleMap");
function VK(t) {
  var e, r, n;
  if (e = t.toString(16).toUpperCase(), t <= 255)
    r = "x", n = 2;
  else if (t <= 65535)
    r = "u", n = 4;
  else if (t <= 4294967295)
    r = "U", n = 8;
  else
    throw new oa("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + qn.repeat("0", n - e.length) + e;
}
w(VK, "encodeHex");
var uye = 1, o1 = 2;
function HK(t) {
  this.schema = t.schema || dK, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || !1, this.skipInvalid = t.skipInvalid || !1, this.flowLevel = qn.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = UK(this.schema, t.styles || null), this.sortKeys = t.sortKeys || !1, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || !1, this.noCompatMode = t.noCompatMode || !1, this.condenseFlow = t.condenseFlow || !1, this.quotingType = t.quotingType === '"' ? o1 : uye, this.forceQuotes = t.forceQuotes || !1, this.replacer = typeof t.replacer == "function" ? t.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
w(HK, "State");
function S_(t, e) {
  for (var r = qn.repeat(" ", e), n = 0, i = -1, a = "", s, o = t.length; n < o; )
    i = t.indexOf(`
`, n), i === -1 ? (s = t.slice(n), n = o) : (s = t.slice(n, i + 1), n = i + 1), s.length && s !== `
` && (a += r), a += s;
  return a;
}
w(S_, "indentString");
function eb(t, e) {
  return `
` + qn.repeat(" ", t.indent * e);
}
w(eb, "generateNextLine");
function WK(t, e) {
  var r, n, i;
  for (r = 0, n = t.implicitTypes.length; r < n; r += 1)
    if (i = t.implicitTypes[r], i.resolve(e))
      return !0;
  return !1;
}
w(WK, "testImplicitResolving");
function l1(t) {
  return t === Xve || t === Wve;
}
w(l1, "isWhitespace");
function t0(t) {
  return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && t !== 8232 && t !== 8233 || 57344 <= t && t <= 65533 && t !== P9 || 65536 <= t && t <= 1114111;
}
w(t0, "isPrintable");
function k_(t) {
  return t0(t) && t !== P9 && t !== Yve && t !== s1;
}
w(k_, "isNsCharOrWhitespace");
function C_(t, e, r) {
  var n = k_(t), i = n && !l1(t);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      n
    ) : n && t !== BK && t !== FK && t !== zK && t !== qK && t !== GK) && t !== E_ && !(e === J2 && !i) || k_(e) && !l1(e) && t === E_ || e === J2 && i
  );
}
w(C_, "isPlainSafe");
function YK(t) {
  return t0(t) && t !== P9 && !l1(t) && t !== tye && t !== iye && t !== J2 && t !== BK && t !== FK && t !== zK && t !== qK && t !== GK && t !== E_ && t !== Qve && t !== eye && t !== jve && t !== oye && t !== rye && t !== nye && t !== Jve && t !== Kve && t !== Zve && t !== aye && t !== sye;
}
w(YK, "isPlainSafeFirst");
function XK(t) {
  return !l1(t) && t !== J2;
}
w(XK, "isPlainSafeLast");
function Tf(t, e) {
  var r = t.charCodeAt(e), n;
  return r >= 55296 && r <= 56319 && e + 1 < t.length && (n = t.charCodeAt(e + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
}
w(Tf, "codePointAt");
function $9(t) {
  var e = /^\n* /;
  return e.test(t);
}
w($9, "needIndentIndicator");
var jK = 1, __ = 2, KK = 3, ZK = 4, df = 5;
function QK(t, e, r, n, i, a, s, o) {
  var l, u = 0, h = null, f = !1, d = !1, p = n !== -1, g = -1, m = YK(Tf(t, 0)) && XK(Tf(t, t.length - 1));
  if (e || s)
    for (l = 0; l < t.length; u >= 65536 ? l += 2 : l++) {
      if (u = Tf(t, l), !t0(u))
        return df;
      m = m && C_(u, h, o), h = u;
    }
  else {
    for (l = 0; l < t.length; u >= 65536 ? l += 2 : l++) {
      if (u = Tf(t, l), u === s1)
        f = !0, p && (d = d || // Foldable line = too long, and not more-indented.
        l - g - 1 > n && t[g + 1] !== " ", g = l);
      else if (!t0(u))
        return df;
      m = m && C_(u, h, o), h = u;
    }
    d = d || p && l - g - 1 > n && t[g + 1] !== " ";
  }
  return !f && !d ? m && !s && !i(t) ? jK : a === o1 ? df : __ : r > 9 && $9(t) ? df : s ? a === o1 ? df : __ : d ? ZK : KK;
}
w(QK, "chooseScalarStyle");
function JK(t, e, r, n, i) {
  t.dump = (function() {
    if (e.length === 0)
      return t.quotingType === o1 ? '""' : "''";
    if (!t.noCompatMode && (lye.indexOf(e) !== -1 || cye.test(e)))
      return t.quotingType === o1 ? '"' + e + '"' : "'" + e + "'";
    var a = t.indent * Math.max(1, r), s = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - a), o = n || t.flowLevel > -1 && r >= t.flowLevel;
    function l(u) {
      return WK(t, u);
    }
    switch (w(l, "testAmbiguity"), QK(
      e,
      o,
      t.indent,
      s,
      l,
      t.quotingType,
      t.forceQuotes && !n,
      i
    )) {
      case jK:
        return e;
      case __:
        return "'" + e.replace(/'/g, "''") + "'";
      case KK:
        return "|" + A_(e, t.indent) + L_(S_(e, a));
      case ZK:
        return ">" + A_(e, t.indent) + L_(S_(eZ(e, s), a));
      case df:
        return '"' + tZ(e) + '"';
      default:
        throw new oa("impossible error: invalid scalar style");
    }
  })();
}
w(JK, "writeScalar");
function A_(t, e) {
  var r = $9(t) ? String(e) : "", n = t[t.length - 1] === `
`, i = n && (t[t.length - 2] === `
` || t === `
`), a = i ? "+" : n ? "" : "-";
  return r + a + `
`;
}
w(A_, "blockHeader");
function L_(t) {
  return t[t.length - 1] === `
` ? t.slice(0, -1) : t;
}
w(L_, "dropEndingNewline");
function eZ(t, e) {
  for (var r = /(\n+)([^\n]*)/g, n = (function() {
    var u = t.indexOf(`
`);
    return u = u !== -1 ? u : t.length, r.lastIndex = u, R_(t.slice(0, u), e);
  })(), i = t[0] === `
` || t[0] === " ", a, s; s = r.exec(t); ) {
    var o = s[1], l = s[2];
    a = l[0] === " ", n += o + (!i && !a && l !== "" ? `
` : "") + R_(l, e), i = a;
  }
  return n;
}
w(eZ, "foldString");
function R_(t, e) {
  if (t === "" || t[0] === " ") return t;
  for (var r = / [^ ]/g, n, i = 0, a, s = 0, o = 0, l = ""; n = r.exec(t); )
    o = n.index, o - i > e && (a = s > i ? s : o, l += `
` + t.slice(i, a), i = a + 1), s = o;
  return l += `
`, t.length - i > e && s > i ? l += t.slice(i, s) + `
` + t.slice(s + 1) : l += t.slice(i), l.slice(1);
}
w(R_, "foldLine");
function tZ(t) {
  for (var e = "", r = 0, n, i = 0; i < t.length; r >= 65536 ? i += 2 : i++)
    r = Tf(t, i), n = Mi[r], !n && t0(r) ? (e += t[i], r >= 65536 && (e += t[i + 1])) : e += n || VK(r);
  return e;
}
w(tZ, "escapeString");
function rZ(t, e, r) {
  var n = "", i = t.tag, a, s, o;
  for (a = 0, s = r.length; a < s; a += 1)
    o = r[a], t.replacer && (o = t.replacer.call(r, String(a), o)), (po(t, e, o, !1, !1) || typeof o > "u" && po(t, e, null, !1, !1)) && (n !== "" && (n += "," + (t.condenseFlow ? "" : " ")), n += t.dump);
  t.tag = i, t.dump = "[" + n + "]";
}
w(rZ, "writeFlowSequence");
function I_(t, e, r, n) {
  var i = "", a = t.tag, s, o, l;
  for (s = 0, o = r.length; s < o; s += 1)
    l = r[s], t.replacer && (l = t.replacer.call(r, String(s), l)), (po(t, e + 1, l, !0, !0, !1, !0) || typeof l > "u" && po(t, e + 1, null, !0, !0, !1, !0)) && ((!n || i !== "") && (i += eb(t, e)), t.dump && s1 === t.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t.dump);
  t.tag = a, t.dump = i || "[]";
}
w(I_, "writeBlockSequence");
function nZ(t, e, r) {
  var n = "", i = t.tag, a = Object.keys(r), s, o, l, u, h;
  for (s = 0, o = a.length; s < o; s += 1)
    h = "", n !== "" && (h += ", "), t.condenseFlow && (h += '"'), l = a[s], u = r[l], t.replacer && (u = t.replacer.call(r, l, u)), po(t, e, l, !1, !1) && (t.dump.length > 1024 && (h += "? "), h += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), po(t, e, u, !1, !1) && (h += t.dump, n += h));
  t.tag = i, t.dump = "{" + n + "}";
}
w(nZ, "writeFlowMapping");
function iZ(t, e, r, n) {
  var i = "", a = t.tag, s = Object.keys(r), o, l, u, h, f, d;
  if (t.sortKeys === !0)
    s.sort();
  else if (typeof t.sortKeys == "function")
    s.sort(t.sortKeys);
  else if (t.sortKeys)
    throw new oa("sortKeys must be a boolean or a function");
  for (o = 0, l = s.length; o < l; o += 1)
    d = "", (!n || i !== "") && (d += eb(t, e)), u = s[o], h = r[u], t.replacer && (h = t.replacer.call(r, u, h)), po(t, e + 1, u, !0, !0, !0) && (f = t.tag !== null && t.tag !== "?" || t.dump && t.dump.length > 1024, f && (t.dump && s1 === t.dump.charCodeAt(0) ? d += "?" : d += "? "), d += t.dump, f && (d += eb(t, e)), po(t, e + 1, h, !0, f) && (t.dump && s1 === t.dump.charCodeAt(0) ? d += ":" : d += ": ", d += t.dump, i += d));
  t.tag = a, t.dump = i || "{}";
}
w(iZ, "writeBlockMapping");
function M_(t, e, r) {
  var n, i, a, s, o, l;
  for (i = r ? t.explicitTypes : t.implicitTypes, a = 0, s = i.length; a < s; a += 1)
    if (o = i[a], (o.instanceOf || o.predicate) && (!o.instanceOf || typeof e == "object" && e instanceof o.instanceOf) && (!o.predicate || o.predicate(e))) {
      if (r ? o.multi && o.representName ? t.tag = o.representName(e) : t.tag = o.tag : t.tag = "?", o.represent) {
        if (l = t.styleMap[o.tag] || o.defaultStyle, PK.call(o.represent) === "[object Function]")
          n = o.represent(e, l);
        else if ($K.call(o.represent, l))
          n = o.represent[l](e, l);
        else
          throw new oa("!<" + o.tag + '> tag resolver accepts not "' + l + '" style');
        t.dump = n;
      }
      return !0;
    }
  return !1;
}
w(M_, "detectType");
function po(t, e, r, n, i, a, s) {
  t.tag = null, t.dump = r, M_(t, r, !1) || M_(t, r, !0);
  var o = PK.call(t.dump), l = n, u;
  n && (n = t.flowLevel < 0 || t.flowLevel > e);
  var h = o === "[object Object]" || o === "[object Array]", f, d;
  if (h && (f = t.duplicates.indexOf(r), d = f !== -1), (t.tag !== null && t.tag !== "?" || d || t.indent !== 2 && e > 0) && (i = !1), d && t.usedDuplicates[f])
    t.dump = "*ref_" + f;
  else {
    if (h && d && !t.usedDuplicates[f] && (t.usedDuplicates[f] = !0), o === "[object Object]")
      n && Object.keys(t.dump).length !== 0 ? (iZ(t, e, t.dump, i), d && (t.dump = "&ref_" + f + t.dump)) : (nZ(t, e, t.dump), d && (t.dump = "&ref_" + f + " " + t.dump));
    else if (o === "[object Array]")
      n && t.dump.length !== 0 ? (t.noArrayIndent && !s && e > 0 ? I_(t, e - 1, t.dump, i) : I_(t, e, t.dump, i), d && (t.dump = "&ref_" + f + t.dump)) : (rZ(t, e, t.dump), d && (t.dump = "&ref_" + f + " " + t.dump));
    else if (o === "[object String]")
      t.tag !== "?" && JK(t, t.dump, e, a, l);
    else {
      if (o === "[object Undefined]")
        return !1;
      if (t.skipInvalid) return !1;
      throw new oa("unacceptable kind of an object to dump " + o);
    }
    t.tag !== null && t.tag !== "?" && (u = encodeURI(
      t.tag[0] === "!" ? t.tag.slice(1) : t.tag
    ).replace(/!/g, "%21"), t.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", t.dump = u + " " + t.dump);
  }
  return !0;
}
w(po, "writeNode");
function aZ(t, e) {
  var r = [], n = [], i, a;
  for (tb(t, r, n), i = 0, a = n.length; i < a; i += 1)
    e.duplicates.push(r[n[i]]);
  e.usedDuplicates = new Array(a);
}
w(aZ, "getDuplicateReferences");
function tb(t, e, r) {
  var n, i, a;
  if (t !== null && typeof t == "object")
    if (i = e.indexOf(t), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (e.push(t), Array.isArray(t))
      for (i = 0, a = t.length; i < a; i += 1)
        tb(t[i], e, r);
    else
      for (n = Object.keys(t), i = 0, a = n.length; i < a; i += 1)
        tb(t[n[i]], e, r);
}
w(tb, "inspectNode");
function hye(t, e) {
  e = e || {};
  var r = new HK(e);
  r.noRefs || aZ(t, r);
  var n = t;
  return r.replacer && (n = r.replacer.call({ "": n }, "", n)), po(r, 0, n, !0, !0) ? r.dump + `
` : "";
}
w(hye, "dump$1");
function fye(t, e) {
  return function() {
    throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
w(fye, "renamed");
var jx = Kj, Kx = Hve.load;
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
var Ei = {
  aggregation: 17.25,
  extension: 17.25,
  composition: 17.25,
  dependency: 6,
  lollipop: 13.5,
  arrow_point: 4
  //arrow_cross: 24,
}, _N = {
  arrow_point: 9,
  arrow_cross: 12.5,
  arrow_circle: 12.5
};
function Mp(t, e) {
  if (t === void 0 || e === void 0)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  t = Zr(t), e = Zr(e);
  const [r, n] = [t.x, t.y], [i, a] = [e.x, e.y], s = i - r, o = a - n;
  return { angle: Math.atan(o / s), deltaX: s, deltaY: o };
}
w(Mp, "calculateDeltaAndAngle");
var Zr = /* @__PURE__ */ w((t) => Array.isArray(t) ? { x: t[0], y: t[1] } : t, "pointTransformer"), sZ = /* @__PURE__ */ w((t) => ({
  x: /* @__PURE__ */ w(function(e, r, n) {
    let i = 0;
    const a = Zr(n[0]).x < Zr(n[n.length - 1]).x ? "left" : "right";
    if (r === 0 && Object.hasOwn(Ei, t.arrowTypeStart)) {
      const { angle: p, deltaX: g } = Mp(n[0], n[1]);
      i = Ei[t.arrowTypeStart] * Math.cos(p) * (g >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(Ei, t.arrowTypeEnd)) {
      const { angle: p, deltaX: g } = Mp(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = Ei[t.arrowTypeEnd] * Math.cos(p) * (g >= 0 ? 1 : -1);
    }
    const s = Math.abs(
      Zr(e).x - Zr(n[n.length - 1]).x
    ), o = Math.abs(
      Zr(e).y - Zr(n[n.length - 1]).y
    ), l = Math.abs(Zr(e).x - Zr(n[0]).x), u = Math.abs(Zr(e).y - Zr(n[0]).y), h = Ei[t.arrowTypeStart], f = Ei[t.arrowTypeEnd], d = 1;
    if (s < f && s > 0 && o < f) {
      let p = f + d - s;
      p *= a === "right" ? -1 : 1, i -= p;
    }
    if (l < h && l > 0 && u < h) {
      let p = h + d - l;
      p *= a === "right" ? -1 : 1, i += p;
    }
    return Zr(e).x + i;
  }, "x"),
  y: /* @__PURE__ */ w(function(e, r, n) {
    let i = 0;
    const a = Zr(n[0]).y < Zr(n[n.length - 1]).y ? "down" : "up";
    if (r === 0 && Object.hasOwn(Ei, t.arrowTypeStart)) {
      const { angle: p, deltaY: g } = Mp(n[0], n[1]);
      i = Ei[t.arrowTypeStart] * Math.abs(Math.sin(p)) * (g >= 0 ? 1 : -1);
    } else if (r === n.length - 1 && Object.hasOwn(Ei, t.arrowTypeEnd)) {
      const { angle: p, deltaY: g } = Mp(
        n[n.length - 1],
        n[n.length - 2]
      );
      i = Ei[t.arrowTypeEnd] * Math.abs(Math.sin(p)) * (g >= 0 ? 1 : -1);
    }
    const s = Math.abs(
      Zr(e).y - Zr(n[n.length - 1]).y
    ), o = Math.abs(
      Zr(e).x - Zr(n[n.length - 1]).x
    ), l = Math.abs(Zr(e).y - Zr(n[0]).y), u = Math.abs(Zr(e).x - Zr(n[0]).x), h = Ei[t.arrowTypeStart], f = Ei[t.arrowTypeEnd], d = 1;
    if (s < f && s > 0 && o < f) {
      let p = f + d - s;
      p *= a === "up" ? -1 : 1, i -= p;
    }
    if (l < h && l > 0 && u < h) {
      let p = h + d - l;
      p *= a === "up" ? -1 : 1, i += p;
    }
    return Zr(e).y + i;
  }, "y")
}), "getLineFunctionsWithOffset"), nm = /* @__PURE__ */ w(({
  flowchart: t
}) => {
  const e = t?.subGraphTitleMargin?.top ?? 0, r = t?.subGraphTitleMargin?.bottom ?? 0, n = e + r;
  return {
    subGraphTitleTopMargin: e,
    subGraphTitleBottomMargin: r,
    subGraphTitleTotalMargin: n
  };
}, "getSubGraphTitleMargins"), dye = /* @__PURE__ */ w((t) => {
  const { handDrawnSeed: e } = Te();
  return {
    fill: t,
    hachureAngle: 120,
    // angle of hachure,
    hachureGap: 4,
    fillWeight: 2,
    roughness: 0.7,
    stroke: t,
    seed: e
  };
}, "solidStateFill"), _0 = /* @__PURE__ */ w((t) => {
  const e = pye([
    ...t.cssCompiledStyles || [],
    ...t.cssStyles || [],
    ...t.labelStyle || []
  ]);
  return { stylesMap: e, stylesArray: [...e] };
}, "compileStyles"), pye = /* @__PURE__ */ w((t) => {
  const e = /* @__PURE__ */ new Map();
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.set(n.trim(), i?.trim());
  }), e;
}, "styles2Map"), B9 = /* @__PURE__ */ w((t) => t === "color" || t === "font-size" || t === "font-family" || t === "font-weight" || t === "font-style" || t === "text-decoration" || t === "text-align" || t === "text-transform" || t === "line-height" || t === "letter-spacing" || t === "word-spacing" || t === "text-shadow" || t === "text-overflow" || t === "white-space" || t === "word-wrap" || t === "word-break" || t === "overflow-wrap" || t === "hyphens", "isLabelStyle"), kt = /* @__PURE__ */ w((t) => {
  const { stylesArray: e } = _0(t), r = [], n = [], i = [], a = [];
  return e.forEach((s) => {
    const o = s[0];
    B9(o) ? r.push(s.join(":") + " !important") : (n.push(s.join(":") + " !important"), o.includes("stroke") && i.push(s.join(":") + " !important"), o === "fill" && a.push(s.join(":") + " !important"));
  }), {
    labelStyles: r.join(";"),
    nodeStyles: n.join(";"),
    stylesArray: e,
    borderStyles: i,
    backgroundStyles: a
  };
}, "styles2String"), Rt = /* @__PURE__ */ w((t, e) => {
  const { themeVariables: r, handDrawnSeed: n } = Te(), { nodeBorder: i, mainBkg: a } = r, { stylesMap: s } = _0(t);
  return Object.assign(
    {
      roughness: 0.7,
      fill: s.get("fill") || a,
      fillStyle: "hachure",
      // solid fill
      fillWeight: 4,
      hachureGap: 5.2,
      stroke: s.get("stroke") || i,
      seed: n,
      strokeWidth: s.get("stroke-width")?.replace("px", "") || 1.3,
      fillLineDash: [0, 0],
      strokeLineDash: gye(s.get("stroke-dasharray"))
    },
    e
  );
}, "userNodeOverrides"), gye = /* @__PURE__ */ w((t) => {
  if (!t)
    return [0, 0];
  const e = t.trim().split(/\s+/).map(Number);
  if (e.length === 1) {
    const i = isNaN(e[0]) ? 0 : e[0];
    return [i, i];
  }
  const r = isNaN(e[0]) ? 0 : e[0], n = isNaN(e[1]) ? 0 : e[1];
  return [r, n];
}, "getStrokeDashArray"), lv = {}, On = {}, AN;
function mye() {
  return AN || (AN = 1, Object.defineProperty(On, "__esModule", { value: !0 }), On.BLANK_URL = On.relativeFirstCharacters = On.whitespaceEscapeCharsRegex = On.urlSchemeRegex = On.ctrlCharactersRegex = On.htmlCtrlEntityRegex = On.htmlEntitiesRegex = On.invalidProtocolRegex = void 0, On.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im, On.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g, On.htmlCtrlEntityRegex = /&(newline|tab);/gi, On.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, On.urlSchemeRegex = /^.+(:|&colon;)/gim, On.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g, On.relativeFirstCharacters = [".", "/"], On.BLANK_URL = "about:blank"), On;
}
var LN;
function vye() {
  if (LN) return lv;
  LN = 1, Object.defineProperty(lv, "__esModule", { value: !0 }), lv.sanitizeUrl = a;
  var t = mye();
  function e(s) {
    return t.relativeFirstCharacters.indexOf(s[0]) > -1;
  }
  function r(s) {
    var o = s.replace(t.ctrlCharactersRegex, "");
    return o.replace(t.htmlEntitiesRegex, function(l, u) {
      return String.fromCharCode(u);
    });
  }
  function n(s) {
    return URL.canParse(s);
  }
  function i(s) {
    try {
      return decodeURIComponent(s);
    } catch {
      return s;
    }
  }
  function a(s) {
    if (!s)
      return t.BLANK_URL;
    var o, l = i(s.trim());
    do
      l = r(l).replace(t.htmlCtrlEntityRegex, "").replace(t.ctrlCharactersRegex, "").replace(t.whitespaceEscapeCharsRegex, "").trim(), l = i(l), o = l.match(t.ctrlCharactersRegex) || l.match(t.htmlEntitiesRegex) || l.match(t.htmlCtrlEntityRegex) || l.match(t.whitespaceEscapeCharsRegex);
    while (o && o.length > 0);
    var u = l;
    if (!u)
      return t.BLANK_URL;
    if (e(u))
      return u;
    var h = u.trimStart(), f = h.match(t.urlSchemeRegex);
    if (!f)
      return u;
    var d = f[0].toLowerCase().trim();
    if (t.invalidProtocolRegex.test(d))
      return t.BLANK_URL;
    var p = h.replace(/\\/g, "/");
    if (d === "mailto:" || d.includes("://"))
      return p;
    if (d === "http:" || d === "https:") {
      if (!n(p))
        return t.BLANK_URL;
      var g = new URL(p);
      return g.protocol = g.protocol.toLowerCase(), g.hostname = g.hostname.toLowerCase(), g.toString();
    }
    return p;
  }
  return lv;
}
var yh = vye(), oZ = typeof global == "object" && global && global.Object === Object && global, yye = typeof self == "object" && self && self.Object === Object && self, wo = oZ || yye || Function("return this")(), ns = wo.Symbol, lZ = Object.prototype, bye = lZ.hasOwnProperty, xye = lZ.toString, cp = ns ? ns.toStringTag : void 0;
function wye(t) {
  var e = bye.call(t, cp), r = t[cp];
  try {
    t[cp] = void 0;
    var n = !0;
  } catch {
  }
  var i = xye.call(t);
  return n && (e ? t[cp] = r : delete t[cp]), i;
}
var Tye = Object.prototype, Eye = Tye.toString;
function Sye(t) {
  return Eye.call(t);
}
var kye = "[object Null]", Cye = "[object Undefined]", RN = ns ? ns.toStringTag : void 0;
function bh(t) {
  return t == null ? t === void 0 ? Cye : kye : RN && RN in Object(t) ? wye(t) : Sye(t);
}
function Ia(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var _ye = "[object AsyncFunction]", Aye = "[object Function]", Lye = "[object GeneratorFunction]", Rye = "[object Proxy]";
function c1(t) {
  if (!Ia(t))
    return !1;
  var e = bh(t);
  return e == Aye || e == Lye || e == _ye || e == Rye;
}
var M5 = wo["__core-js_shared__"], IN = (function() {
  var t = /[^.]+$/.exec(M5 && M5.keys && M5.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
})();
function Iye(t) {
  return !!IN && IN in t;
}
var Mye = Function.prototype, Nye = Mye.toString;
function xh(t) {
  if (t != null) {
    try {
      return Nye.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var Dye = /[\\^$.*+?()[\]{}|]/g, Oye = /^\[object .+?Constructor\]$/, Pye = Function.prototype, $ye = Object.prototype, Bye = Pye.toString, Fye = $ye.hasOwnProperty, zye = RegExp(
  "^" + Bye.call(Fye).replace(Dye, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function qye(t) {
  if (!Ia(t) || Iye(t))
    return !1;
  var e = c1(t) ? zye : Oye;
  return e.test(xh(t));
}
function Gye(t, e) {
  return t?.[e];
}
function wh(t, e) {
  var r = Gye(t, e);
  return qye(r) ? r : void 0;
}
var u1 = wh(Object, "create");
function Uye() {
  this.__data__ = u1 ? u1(null) : {}, this.size = 0;
}
function Vye(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var Hye = "__lodash_hash_undefined__", Wye = Object.prototype, Yye = Wye.hasOwnProperty;
function Xye(t) {
  var e = this.__data__;
  if (u1) {
    var r = e[t];
    return r === Hye ? void 0 : r;
  }
  return Yye.call(e, t) ? e[t] : void 0;
}
var jye = Object.prototype, Kye = jye.hasOwnProperty;
function Zye(t) {
  var e = this.__data__;
  return u1 ? e[t] !== void 0 : Kye.call(e, t);
}
var Qye = "__lodash_hash_undefined__";
function Jye(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = u1 && e === void 0 ? Qye : e, this;
}
function ju(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
ju.prototype.clear = Uye;
ju.prototype.delete = Vye;
ju.prototype.get = Xye;
ju.prototype.has = Zye;
ju.prototype.set = Jye;
function e2e() {
  this.__data__ = [], this.size = 0;
}
function A0(t, e) {
  return t === e || t !== t && e !== e;
}
function Zx(t, e) {
  for (var r = t.length; r--; )
    if (A0(t[r][0], e))
      return r;
  return -1;
}
var t2e = Array.prototype, r2e = t2e.splice;
function n2e(t) {
  var e = this.__data__, r = Zx(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : r2e.call(e, r, 1), --this.size, !0;
}
function i2e(t) {
  var e = this.__data__, r = Zx(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function a2e(t) {
  return Zx(this.__data__, t) > -1;
}
function s2e(t, e) {
  var r = this.__data__, n = Zx(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
function Sl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Sl.prototype.clear = e2e;
Sl.prototype.delete = n2e;
Sl.prototype.get = i2e;
Sl.prototype.has = a2e;
Sl.prototype.set = s2e;
var h1 = wh(wo, "Map");
function o2e() {
  this.size = 0, this.__data__ = {
    hash: new ju(),
    map: new (h1 || Sl)(),
    string: new ju()
  };
}
function l2e(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function Qx(t, e) {
  var r = t.__data__;
  return l2e(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function c2e(t) {
  var e = Qx(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function u2e(t) {
  return Qx(this, t).get(t);
}
function h2e(t) {
  return Qx(this, t).has(t);
}
function f2e(t, e) {
  var r = Qx(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
function kl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
kl.prototype.clear = o2e;
kl.prototype.delete = c2e;
kl.prototype.get = u2e;
kl.prototype.has = h2e;
kl.prototype.set = f2e;
var d2e = "Expected a function";
function L0(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(d2e);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = t.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (L0.Cache || kl)(), r;
}
L0.Cache = kl;
function p2e() {
  this.__data__ = new Sl(), this.size = 0;
}
function g2e(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function m2e(t) {
  return this.__data__.get(t);
}
function v2e(t) {
  return this.__data__.has(t);
}
var y2e = 200;
function b2e(t, e) {
  var r = this.__data__;
  if (r instanceof Sl) {
    var n = r.__data__;
    if (!h1 || n.length < y2e - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new kl(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
function ks(t) {
  var e = this.__data__ = new Sl(t);
  this.size = e.size;
}
ks.prototype.clear = p2e;
ks.prototype.delete = g2e;
ks.prototype.get = m2e;
ks.prototype.has = v2e;
ks.prototype.set = b2e;
var rb = (function() {
  try {
    var t = wh(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
})();
function Jx(t, e, r) {
  e == "__proto__" && rb ? rb(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
function N_(t, e, r) {
  (r !== void 0 && !A0(t[e], r) || r === void 0 && !(e in t)) && Jx(t, e, r);
}
function x2e(t) {
  return function(e, r, n) {
    for (var i = -1, a = Object(e), s = n(e), o = s.length; o--; ) {
      var l = s[++i];
      if (r(a[l], l, a) === !1)
        break;
    }
    return e;
  };
}
var F9 = x2e(), cZ = typeof exports == "object" && exports && !exports.nodeType && exports, MN = cZ && typeof module == "object" && module && !module.nodeType && module, w2e = MN && MN.exports === cZ, NN = w2e ? wo.Buffer : void 0, DN = NN ? NN.allocUnsafe : void 0;
function uZ(t, e) {
  if (e)
    return t.slice();
  var r = t.length, n = DN ? DN(r) : new t.constructor(r);
  return t.copy(n), n;
}
var nb = wo.Uint8Array;
function z9(t) {
  var e = new t.constructor(t.byteLength);
  return new nb(e).set(new nb(t)), e;
}
function hZ(t, e) {
  var r = e ? z9(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
function fZ(t, e) {
  var r = -1, n = t.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t[r];
  return e;
}
var ON = Object.create, T2e = /* @__PURE__ */ (function() {
  function t() {
  }
  return function(e) {
    if (!Ia(e))
      return {};
    if (ON)
      return ON(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
})();
function dZ(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var q9 = dZ(Object.getPrototypeOf, Object), E2e = Object.prototype;
function e4(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || E2e;
  return t === r;
}
function pZ(t) {
  return typeof t.constructor == "function" && !e4(t) ? T2e(q9(t)) : {};
}
function go(t) {
  return t != null && typeof t == "object";
}
var S2e = "[object Arguments]";
function PN(t) {
  return go(t) && bh(t) == S2e;
}
var gZ = Object.prototype, k2e = gZ.hasOwnProperty, C2e = gZ.propertyIsEnumerable, r0 = PN(/* @__PURE__ */ (function() {
  return arguments;
})()) ? PN : function(t) {
  return go(t) && k2e.call(t, "callee") && !C2e.call(t, "callee");
}, Rn = Array.isArray, _2e = 9007199254740991;
function G9(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= _2e;
}
function $c(t) {
  return t != null && G9(t.length) && !c1(t);
}
function mZ(t) {
  return go(t) && $c(t);
}
function A2e() {
  return !1;
}
var vZ = typeof exports == "object" && exports && !exports.nodeType && exports, $N = vZ && typeof module == "object" && module && !module.nodeType && module, L2e = $N && $N.exports === vZ, BN = L2e ? wo.Buffer : void 0, R2e = BN ? BN.isBuffer : void 0, n0 = R2e || A2e, I2e = "[object Object]", M2e = Function.prototype, N2e = Object.prototype, yZ = M2e.toString, D2e = N2e.hasOwnProperty, O2e = yZ.call(Object);
function P2e(t) {
  if (!go(t) || bh(t) != I2e)
    return !1;
  var e = q9(t);
  if (e === null)
    return !0;
  var r = D2e.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && yZ.call(r) == O2e;
}
var $2e = "[object Arguments]", B2e = "[object Array]", F2e = "[object Boolean]", z2e = "[object Date]", q2e = "[object Error]", G2e = "[object Function]", U2e = "[object Map]", V2e = "[object Number]", H2e = "[object Object]", W2e = "[object RegExp]", Y2e = "[object Set]", X2e = "[object String]", j2e = "[object WeakMap]", K2e = "[object ArrayBuffer]", Z2e = "[object DataView]", Q2e = "[object Float32Array]", J2e = "[object Float64Array]", ebe = "[object Int8Array]", tbe = "[object Int16Array]", rbe = "[object Int32Array]", nbe = "[object Uint8Array]", ibe = "[object Uint8ClampedArray]", abe = "[object Uint16Array]", sbe = "[object Uint32Array]", Hr = {};
Hr[Q2e] = Hr[J2e] = Hr[ebe] = Hr[tbe] = Hr[rbe] = Hr[nbe] = Hr[ibe] = Hr[abe] = Hr[sbe] = !0;
Hr[$2e] = Hr[B2e] = Hr[K2e] = Hr[F2e] = Hr[Z2e] = Hr[z2e] = Hr[q2e] = Hr[G2e] = Hr[U2e] = Hr[V2e] = Hr[H2e] = Hr[W2e] = Hr[Y2e] = Hr[X2e] = Hr[j2e] = !1;
function obe(t) {
  return go(t) && G9(t.length) && !!Hr[bh(t)];
}
function t4(t) {
  return function(e) {
    return t(e);
  };
}
var bZ = typeof exports == "object" && exports && !exports.nodeType && exports, $g = bZ && typeof module == "object" && module && !module.nodeType && module, lbe = $g && $g.exports === bZ, N5 = lbe && oZ.process, i0 = (function() {
  try {
    var t = $g && $g.require && $g.require("util").types;
    return t || N5 && N5.binding && N5.binding("util");
  } catch {
  }
})(), FN = i0 && i0.isTypedArray, r4 = FN ? t4(FN) : obe;
function D_(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
var cbe = Object.prototype, ube = cbe.hasOwnProperty;
function n4(t, e, r) {
  var n = t[e];
  (!(ube.call(t, e) && A0(n, r)) || r === void 0 && !(e in t)) && Jx(t, e, r);
}
function im(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, s = e.length; ++a < s; ) {
    var o = e[a], l = void 0;
    l === void 0 && (l = t[o]), i ? Jx(r, o, l) : n4(r, o, l);
  }
  return r;
}
function hbe(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var fbe = 9007199254740991, dbe = /^(?:0|[1-9]\d*)$/;
function i4(t, e) {
  var r = typeof t;
  return e = e ?? fbe, !!e && (r == "number" || r != "symbol" && dbe.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
var pbe = Object.prototype, gbe = pbe.hasOwnProperty;
function xZ(t, e) {
  var r = Rn(t), n = !r && r0(t), i = !r && !n && n0(t), a = !r && !n && !i && r4(t), s = r || n || i || a, o = s ? hbe(t.length, String) : [], l = o.length;
  for (var u in t)
    (e || gbe.call(t, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    i4(u, l))) && o.push(u);
  return o;
}
function mbe(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var vbe = Object.prototype, ybe = vbe.hasOwnProperty;
function bbe(t) {
  if (!Ia(t))
    return mbe(t);
  var e = e4(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !ybe.call(t, n)) || r.push(n);
  return r;
}
function Th(t) {
  return $c(t) ? xZ(t, !0) : bbe(t);
}
function xbe(t) {
  return im(t, Th(t));
}
function wbe(t, e, r, n, i, a, s) {
  var o = D_(t, r), l = D_(e, r), u = s.get(l);
  if (u) {
    N_(t, r, u);
    return;
  }
  var h = a ? a(o, l, r + "", t, e, s) : void 0, f = h === void 0;
  if (f) {
    var d = Rn(l), p = !d && n0(l), g = !d && !p && r4(l);
    h = l, d || p || g ? Rn(o) ? h = o : mZ(o) ? h = fZ(o) : p ? (f = !1, h = uZ(l, !0)) : g ? (f = !1, h = hZ(l, !0)) : h = [] : P2e(l) || r0(l) ? (h = o, r0(o) ? h = xbe(o) : (!Ia(o) || c1(o)) && (h = pZ(l))) : f = !1;
  }
  f && (s.set(l, h), i(h, l, n, a, s), s.delete(l)), N_(t, r, h);
}
function wZ(t, e, r, n, i) {
  t !== e && F9(e, function(a, s) {
    if (i || (i = new ks()), Ia(a))
      wbe(t, e, s, r, wZ, n, i);
    else {
      var o = n ? n(D_(t, s), a, s + "", t, e, i) : void 0;
      o === void 0 && (o = a), N_(t, s, o);
    }
  }, Th);
}
function Eh(t) {
  return t;
}
function Tbe(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
var zN = Math.max;
function TZ(t, e, r) {
  return e = zN(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, a = zN(n.length - e, 0), s = Array(a); ++i < a; )
      s[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(s), Tbe(t, this, o);
  };
}
function Ef(t) {
  return function() {
    return t;
  };
}
var Ebe = rb ? function(t, e) {
  return rb(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Ef(e),
    writable: !0
  });
} : Eh, Sbe = 800, kbe = 16, Cbe = Date.now;
function _be(t) {
  var e = 0, r = 0;
  return function() {
    var n = Cbe(), i = kbe - (n - r);
    if (r = n, i > 0) {
      if (++e >= Sbe)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
var EZ = _be(Ebe);
function a4(t, e) {
  return EZ(TZ(t, e, Eh), t + "");
}
function f1(t, e, r) {
  if (!Ia(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? $c(r) && i4(e, r.length) : n == "string" && e in r) ? A0(r[e], t) : !1;
}
function Abe(t) {
  return a4(function(e, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && f1(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t(e, o, n, a);
    }
    return e;
  });
}
var ib = Abe(function(t, e, r) {
  wZ(t, e, r);
}), SZ = "\u200B", Lbe = {
  curveBasis: Mf,
  curveBasisClosed: eve,
  curveBasisOpen: tve,
  curveBumpX: aj,
  curveBumpY: sj,
  curveBundle: rve,
  curveCardinalClosed: nve,
  curveCardinalOpen: ive,
  curveCardinal: uj,
  curveCatmullRomClosed: ave,
  curveCatmullRomOpen: sve,
  curveCatmullRom: fj,
  curveLinear: W2,
  curveLinearClosed: ove,
  curveMonotoneX: yj,
  curveMonotoneY: bj,
  curveNatural: wj,
  curveStep: Tj,
  curveStepAfter: Sj,
  curveStepBefore: Ej
}, Rbe = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, Ibe = /* @__PURE__ */ w(function(t, e) {
  const r = kZ(t, /(?:init\b)|(?:initialize\b)/);
  let n = {};
  if (Array.isArray(r)) {
    const s = r.map((o) => o.args);
    k2(s), n = bn(n, [...s]);
  } else
    n = r.args;
  if (!n)
    return;
  let i = c9(t, e);
  const a = "config";
  return n[a] !== void 0 && (i === "flowchart-v2" && (i = "flowchart"), n[i] = n[a], delete n[a]), n;
}, "detectInit"), kZ = /* @__PURE__ */ w(function(t, e = null) {
  try {
    const r = new RegExp(
      `[%]{2}(?![{]${Rbe.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    t = t.trim().replace(r, "").replace(/'/gm, '"'), ae.debug(
      `Detecting diagram directive${e !== null ? " type:" + e : ""} based on the text:${t}`
    );
    let n;
    const i = [];
    for (; (n = Dg.exec(t)) !== null; )
      if (n.index === Dg.lastIndex && Dg.lastIndex++, n && !e || e && n[1]?.match(e) || e && n[2]?.match(e)) {
        const a = n[1] ? n[1] : n[2], s = n[3] ? n[3].trim() : n[4] ? JSON.parse(n[4].trim()) : null;
        i.push({ type: a, args: s });
      }
    return i.length === 0 ? { type: t, args: null } : i.length === 1 ? i[0] : i;
  } catch (r) {
    return ae.error(
      `ERROR: ${r.message} - Unable to parse directive type: '${e}' based on the text: '${t}'`
    ), { type: void 0, args: null };
  }
}, "detectDirective"), Mbe = /* @__PURE__ */ w(function(t) {
  return t.replace(Dg, "");
}, "removeDirectives"), Nbe = /* @__PURE__ */ w(function(t, e) {
  for (const [r, n] of e.entries())
    if (n.match(t))
      return r;
  return -1;
}, "isSubstringInArray");
function U9(t, e) {
  if (!t)
    return e;
  const r = `curve${t.charAt(0).toUpperCase() + t.slice(1)}`;
  return Lbe[r] ?? e;
}
w(U9, "interpolateToCurve");
function CZ(t, e) {
  const r = t.trim();
  if (r)
    return e.securityLevel !== "loose" ? yh.sanitizeUrl(r) : r;
}
w(CZ, "formatUrl");
var Dbe = /* @__PURE__ */ w((t, ...e) => {
  const r = t.split("."), n = r.length - 1, i = r[n];
  let a = window;
  for (let s = 0; s < n; s++)
    if (a = a[r[s]], !a) {
      ae.error(`Function name: ${t} not found in window`);
      return;
    }
  a[i](...e);
}, "runFunc");
function V9(t, e) {
  return !t || !e ? 0 : Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
w(V9, "distance");
function _Z(t) {
  let e, r = 0;
  t.forEach((i) => {
    r += V9(i, e), e = i;
  });
  const n = r / 2;
  return H9(t, n);
}
w(_Z, "traverseEdge");
function AZ(t) {
  return t.length === 1 ? t[0] : _Z(t);
}
w(AZ, "calcLabelPosition");
var qN = /* @__PURE__ */ w((t, e = 2) => {
  const r = Math.pow(10, e);
  return Math.round(t * r) / r;
}, "roundNumber"), H9 = /* @__PURE__ */ w((t, e) => {
  let r, n = e;
  for (const i of t) {
    if (r) {
      const a = V9(i, r);
      if (a === 0)
        return r;
      if (a < n)
        n -= a;
      else {
        const s = n / a;
        if (s <= 0)
          return r;
        if (s >= 1)
          return { x: i.x, y: i.y };
        if (s > 0 && s < 1)
          return {
            x: qN((1 - s) * r.x + s * i.x, 5),
            y: qN((1 - s) * r.y + s * i.y, 5)
          };
      }
    }
    r = i;
  }
  throw new Error("Could not find a suitable point for the given distance");
}, "calculatePoint"), Obe = /* @__PURE__ */ w((t, e, r) => {
  ae.info(`our points ${JSON.stringify(e)}`), e[0] !== r && (e = e.reverse());
  const i = H9(e, 25), a = t ? 10 : 5, s = Math.atan2(e[0].y - i.y, e[0].x - i.x), o = { x: 0, y: 0 };
  return o.x = Math.sin(s) * a + (e[0].x + i.x) / 2, o.y = -Math.cos(s) * a + (e[0].y + i.y) / 2, o;
}, "calcCardinalityPosition");
function LZ(t, e, r) {
  const n = structuredClone(r);
  ae.info("our points", n), e !== "start_left" && e !== "start_right" && n.reverse();
  const i = 25 + t, a = H9(n, i), s = 10 + t * 0.5, o = Math.atan2(n[0].y - a.y, n[0].x - a.x), l = { x: 0, y: 0 };
  return e === "start_left" ? (l.x = Math.sin(o + Math.PI) * s + (n[0].x + a.x) / 2, l.y = -Math.cos(o + Math.PI) * s + (n[0].y + a.y) / 2) : e === "end_right" ? (l.x = Math.sin(o - Math.PI) * s + (n[0].x + a.x) / 2 - 5, l.y = -Math.cos(o - Math.PI) * s + (n[0].y + a.y) / 2 - 5) : e === "end_left" ? (l.x = Math.sin(o) * s + (n[0].x + a.x) / 2 - 5, l.y = -Math.cos(o) * s + (n[0].y + a.y) / 2 - 5) : (l.x = Math.sin(o) * s + (n[0].x + a.x) / 2, l.y = -Math.cos(o) * s + (n[0].y + a.y) / 2), l;
}
w(LZ, "calcTerminalLabelPosition");
function W9(t) {
  let e = "", r = "";
  for (const n of t)
    n !== void 0 && (n.startsWith("color:") || n.startsWith("text-align:") ? r = r + n + ";" : e = e + n + ";");
  return { style: e, labelStyle: r };
}
w(W9, "getStylesFromArray");
var GN = 0, RZ = /* @__PURE__ */ w(() => (GN++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + GN), "generateId");
function IZ(t) {
  let e = "";
  const r = "0123456789abcdef", n = r.length;
  for (let i = 0; i < t; i++)
    e += r.charAt(Math.floor(Math.random() * n));
  return e;
}
w(IZ, "makeRandomHex");
var MZ = /* @__PURE__ */ w((t) => IZ(t.length), "random"), Pbe = /* @__PURE__ */ w(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0,
    text: ""
  };
}, "getTextObj"), $be = /* @__PURE__ */ w(function(t, e) {
  const r = e.text.replace(at.lineBreakRegex, " "), [, n] = Sh(e.fontSize), i = t.append("text");
  i.attr("x", e.x), i.attr("y", e.y), i.style("text-anchor", e.anchor), i.style("font-family", e.fontFamily), i.style("font-size", n), i.style("font-weight", e.fontWeight), i.attr("fill", e.fill), e.class !== void 0 && i.attr("class", e.class);
  const a = i.append("tspan");
  return a.attr("x", e.x + e.textMargin * 2), a.attr("fill", e.fill), a.text(r), i;
}, "drawSimpleText"), NZ = L0(
  (t, e, r) => {
    if (!t || (r = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      r
    ), at.lineBreakRegex.test(t)))
      return t;
    const n = t.split(" ").filter(Boolean), i = [];
    let a = "";
    return n.forEach((s, o) => {
      const l = Vi(`${s} `, r), u = Vi(a, r);
      if (l > e) {
        const { hyphenatedStrings: d, remainingWord: p } = Bbe(s, e, "-", r);
        i.push(a, ...d), a = p;
      } else u + l >= e ? (i.push(a), a = s) : a = [a, s].filter(Boolean).join(" ");
      o + 1 === n.length && i.push(a);
    }), i.filter((s) => s !== "").join(r.joinWith);
  },
  (t, e, r) => `${t}${e}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`
), Bbe = L0(
  (t, e, r = "-", n) => {
    n = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      n
    );
    const i = [...t], a = [];
    let s = "";
    return i.forEach((o, l) => {
      const u = `${s}${o}`;
      if (Vi(u, n) >= e) {
        const f = l + 1, d = i.length === f, p = `${u}${r}`;
        a.push(d ? u : p), s = "";
      } else
        s = u;
    }), { hyphenatedStrings: a, remainingWord: s };
  },
  (t, e, r = "-", n) => `${t}${e}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`
);
function ab(t, e) {
  return Y9(t, e).height;
}
w(ab, "calculateTextHeight");
function Vi(t, e) {
  return Y9(t, e).width;
}
w(Vi, "calculateTextWidth");
var Y9 = L0(
  (t, e) => {
    const { fontSize: r = 12, fontFamily: n = "Arial", fontWeight: i = 400 } = e;
    if (!t)
      return { width: 0, height: 0 };
    const [, a] = Sh(r), s = ["sans-serif", n], o = t.split(at.lineBreakRegex), l = [], u = Qe("body");
    if (!u.remove)
      return { width: 0, height: 0, lineHeight: 0 };
    const h = u.append("svg");
    for (const d of s) {
      let p = 0;
      const g = { width: 0, height: 0, lineHeight: 0 };
      for (const m of o) {
        const v = Pbe();
        v.text = m || SZ;
        const y = $be(h, v).style("font-size", a).style("font-weight", i).style("font-family", d), b = (y._groups || y)[0][0].getBBox();
        if (b.width === 0 && b.height === 0)
          throw new Error("svg element not in render tree");
        g.width = Math.round(Math.max(g.width, b.width)), p = Math.round(b.height), g.height += p, g.lineHeight = Math.round(Math.max(g.lineHeight, p));
      }
      l.push(g);
    }
    h.remove();
    const f = isNaN(l[1].height) || isNaN(l[1].width) || isNaN(l[1].lineHeight) || l[0].height > l[1].height && l[0].width > l[1].width && l[0].lineHeight > l[1].lineHeight ? 0 : 1;
    return l[f];
  },
  (t, e) => `${t}${e.fontSize}${e.fontWeight}${e.fontFamily}`
), ed, Fbe = (ed = class {
  constructor(e = !1, r) {
    this.count = 0, this.count = r ? r.length : 0, this.next = e ? () => this.count++ : () => Date.now();
  }
}, w(ed, "InitIDGenerator"), ed), cv, zbe = /* @__PURE__ */ w(function(t) {
  return cv = cv || document.createElement("div"), t = escape(t).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), cv.innerHTML = t, unescape(cv.textContent);
}, "entityDecode");
function X9(t) {
  return "str" in t;
}
w(X9, "isDetailedError");
var qbe = /* @__PURE__ */ w((t, e, r, n) => {
  if (!n)
    return;
  const i = t.node()?.getBBox();
  i && t.append("text").text(n).attr("text-anchor", "middle").attr("x", i.x + i.width / 2).attr("y", -r).attr("class", e);
}, "insertTitle"), Sh = /* @__PURE__ */ w((t) => {
  if (typeof t == "number")
    return [t, t + "px"];
  const e = parseInt(t ?? "", 10);
  return Number.isNaN(e) ? [void 0, void 0] : t === String(e) ? [e, t + "px"] : [e, t];
}, "parseFontSize");
function Xi(t, e) {
  return ib({}, t, e);
}
w(Xi, "cleanAndMerge");
var Jt = {
  assignWithDepth: bn,
  wrapLabel: NZ,
  calculateTextHeight: ab,
  calculateTextWidth: Vi,
  calculateTextDimensions: Y9,
  cleanAndMerge: Xi,
  detectInit: Ibe,
  detectDirective: kZ,
  isSubstringInArray: Nbe,
  interpolateToCurve: U9,
  calcLabelPosition: AZ,
  calcCardinalityPosition: Obe,
  calcTerminalLabelPosition: LZ,
  formatUrl: CZ,
  getStylesFromArray: W9,
  generateId: RZ,
  random: MZ,
  runFunc: Dbe,
  entityDecode: zbe,
  insertTitle: qbe,
  isLabelCoordinateInPath: DZ,
  parseFontSize: Sh,
  InitIDGenerator: Fbe
}, Gbe = /* @__PURE__ */ w(function(t) {
  let e = t;
  return e = e.replace(/style.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/classDef.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/#\w+;/g, function(r) {
    const n = r.substring(1, r.length - 1);
    return /^\+?\d+$/.test(n) ? "\uFB02\xB0\xB0" + n + "\xB6\xDF" : "\uFB02\xB0" + n + "\xB6\xDF";
  }), e;
}, "encodeEntities"), mo = /* @__PURE__ */ w(function(t) {
  return t.replace(//g, "&#").replace(//g, "&").replace(//g, ";");
}, "decodeEntities"), Nf = /* @__PURE__ */ w((t, e, {
  counter: r = 0,
  prefix: n,
  suffix: i
}, a) => a || `${n ? `${n}_` : ""}${t}_${e}_${r}${i ? `_${i}` : ""}`, "getEdgeId");
function Ai(t) {
  return t ?? null;
}
w(Ai, "handleUndefinedAttr");
function DZ(t, e) {
  const r = Math.round(t.x), n = Math.round(t.y), i = e.replace(
    /(\d+\.\d+)/g,
    (a) => Math.round(parseFloat(a)).toString()
  );
  return i.includes(r.toString()) || i.includes(n.toString());
}
w(DZ, "isLabelCoordinateInPath");
const Ube = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16
}), sb = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), OZ = Object.freeze({
  ...Ube,
  ...sb
}), Vbe = Object.freeze({
  ...OZ,
  body: "",
  hidden: !1
}), Hbe = Object.freeze({
  width: null,
  height: null
}), Wbe = Object.freeze({
  ...Hbe,
  ...sb
}), Ybe = (t, e, r, n = "") => {
  const i = t.split(":");
  if (t.slice(0, 1) === "@") {
    if (i.length < 2 || i.length > 3) return null;
    n = i.shift().slice(1);
  }
  if (i.length > 3 || !i.length) return null;
  if (i.length > 1) {
    const o = i.pop(), l = i.pop(), u = {
      provider: i.length > 0 ? i[0] : n,
      prefix: l,
      name: o
    };
    return D5(u) ? u : null;
  }
  const a = i[0], s = a.split("-");
  if (s.length > 1) {
    const o = {
      provider: n,
      prefix: s.shift(),
      name: s.join("-")
    };
    return D5(o) ? o : null;
  }
  if (r && n === "") {
    const o = {
      provider: n,
      prefix: "",
      name: a
    };
    return D5(o, r) ? o : null;
  }
  return null;
}, D5 = (t, e) => t ? !!((e && t.prefix === "" || t.prefix) && t.name) : !1;
function Xbe(t, e) {
  const r = {};
  !t.hFlip != !e.hFlip && (r.hFlip = !0), !t.vFlip != !e.vFlip && (r.vFlip = !0);
  const n = ((t.rotate || 0) + (e.rotate || 0)) % 4;
  return n && (r.rotate = n), r;
}
function UN(t, e) {
  const r = Xbe(t, e);
  for (const n in Vbe) n in sb ? n in t && !(n in r) && (r[n] = sb[n]) : n in e ? r[n] = e[n] : n in t && (r[n] = t[n]);
  return r;
}
function jbe(t, e) {
  const r = t.icons, n = t.aliases || /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function a(s) {
    if (r[s]) return i[s] = [];
    if (!(s in i)) {
      i[s] = null;
      const o = n[s] && n[s].parent, l = o && a(o);
      l && (i[s] = [o].concat(l));
    }
    return i[s];
  }
  return (e || Object.keys(r).concat(Object.keys(n))).forEach(a), i;
}
function VN(t, e, r) {
  const n = t.icons, i = t.aliases || /* @__PURE__ */ Object.create(null);
  let a = {};
  function s(o) {
    a = UN(n[o] || i[o], a);
  }
  return s(e), r.forEach(s), UN(t, a);
}
function Kbe(t, e) {
  if (t.icons[e]) return VN(t, e, []);
  const r = jbe(t, [e])[e];
  return r ? VN(t, e, r) : null;
}
const Zbe = /(-?[0-9.]*[0-9]+[0-9.]*)/g, Qbe = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function HN(t, e, r) {
  if (e === 1) return t;
  if (r = r || 100, typeof t == "number") return Math.ceil(t * e * r) / r;
  if (typeof t != "string") return t;
  const n = t.split(Zbe);
  if (n === null || !n.length) return t;
  const i = [];
  let a = n.shift(), s = Qbe.test(a);
  for (; ; ) {
    if (s) {
      const o = parseFloat(a);
      isNaN(o) ? i.push(a) : i.push(Math.ceil(o * e * r) / r);
    } else i.push(a);
    if (a = n.shift(), a === void 0) return i.join("");
    s = !s;
  }
}
function Jbe(t, e = "defs") {
  let r = "";
  const n = t.indexOf("<" + e);
  for (; n >= 0; ) {
    const i = t.indexOf(">", n), a = t.indexOf("</" + e);
    if (i === -1 || a === -1) break;
    const s = t.indexOf(">", a);
    if (s === -1) break;
    r += t.slice(i + 1, a).trim(), t = t.slice(0, n).trim() + t.slice(s + 1);
  }
  return {
    defs: r,
    content: t
  };
}
function exe(t, e) {
  return t ? "<defs>" + t + "</defs>" + e : e;
}
function txe(t, e, r) {
  const n = Jbe(t);
  return exe(n.defs, e + n.content + r);
}
const rxe = (t) => t === "unset" || t === "undefined" || t === "none";
function nxe(t, e) {
  const r = {
    ...OZ,
    ...t
  }, n = {
    ...Wbe,
    ...e
  }, i = {
    left: r.left,
    top: r.top,
    width: r.width,
    height: r.height
  };
  let a = r.body;
  [r, n].forEach((m) => {
    const v = [], y = m.hFlip, b = m.vFlip;
    let x = m.rotate;
    y ? b ? x += 2 : (v.push("translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"), v.push("scale(-1 1)"), i.top = i.left = 0) : b && (v.push("translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"), v.push("scale(1 -1)"), i.top = i.left = 0);
    let T;
    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {
      case 1:
        T = i.height / 2 + i.top, v.unshift("rotate(90 " + T.toString() + " " + T.toString() + ")");
        break;
      case 2:
        v.unshift("rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")");
        break;
      case 3:
        T = i.width / 2 + i.left, v.unshift("rotate(-90 " + T.toString() + " " + T.toString() + ")");
        break;
    }
    x % 2 === 1 && (i.left !== i.top && (T = i.left, i.left = i.top, i.top = T), i.width !== i.height && (T = i.width, i.width = i.height, i.height = T)), v.length && (a = txe(a, '<g transform="' + v.join(" ") + '">', "</g>"));
  });
  const s = n.width, o = n.height, l = i.width, u = i.height;
  let h, f;
  s === null ? (f = o === null ? "1em" : o === "auto" ? u : o, h = HN(f, l / u)) : (h = s === "auto" ? l : s, f = o === null ? HN(h, u / l) : o === "auto" ? u : o);
  const d = {}, p = (m, v) => {
    rxe(v) || (d[m] = v.toString());
  };
  p("width", h), p("height", f);
  const g = [
    i.left,
    i.top,
    l,
    u
  ];
  return d.viewBox = g.join(" "), {
    attributes: d,
    viewBox: g,
    body: a
  };
}
const ixe = /\sid="(\S+)"/g, WN = /* @__PURE__ */ new Map();
function axe(t) {
  t = t.replace(/[0-9]+$/, "") || "a";
  const e = WN.get(t) || 0;
  return WN.set(t, e + 1), e ? `${t}${e}` : t;
}
function sxe(t) {
  const e = [];
  let r;
  for (; r = ixe.exec(t); ) e.push(r[1]);
  if (!e.length) return t;
  const n = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return e.forEach((i) => {
    const a = axe(i), s = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(new RegExp('([#;"])(' + s + ')([")]|\\.[a-z])', "g"), "$1" + a + n + "$3");
  }), t = t.replace(new RegExp(n, "g"), ""), t;
}
function oxe(t, e) {
  let r = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in e) r += " " + n + '="' + e[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + t + "</svg>";
}
function j9() {
  return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
}
var kh = j9();
function PZ(t) {
  kh = t;
}
var Bg = { exec: () => null };
function kr(t, e = "") {
  let r = typeof t == "string" ? t : t.source, n = { replace: (i, a) => {
    let s = typeof a == "string" ? a : a.source;
    return s = s.replace(Gi.caret, "$1"), r = r.replace(i, s), n;
  }, getRegex: () => new RegExp(r, e) };
  return n;
}
var lxe = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return !1;
  }
})(), Gi = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`), htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i") }, cxe = /^(?:[ \t]*(?:\n|$))+/, uxe = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, hxe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, am = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, fxe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, K9 = /(?:[*+-]|\d{1,9}[.)])/, $Z = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, BZ = kr($Z).replace(/bull/g, K9).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), dxe = kr($Z).replace(/bull/g, K9).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), Z9 = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, pxe = /^[^\n]+/, Q9 = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, gxe = kr(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q9).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), mxe = kr(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, K9).getRegex(), s4 = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", J9 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, vxe = kr("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", J9).replace("tag", s4).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), FZ = kr(Z9).replace("hr", am).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", s4).getRegex(), yxe = kr(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", FZ).getRegex(), eL = { blockquote: yxe, code: uxe, def: gxe, fences: hxe, heading: fxe, hr: am, html: vxe, lheading: BZ, list: mxe, newline: cxe, paragraph: FZ, table: Bg, text: pxe }, YN = kr("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", am).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", s4).getRegex(), bxe = { ...eL, lheading: dxe, table: YN, paragraph: kr(Z9).replace("hr", am).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", YN).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", s4).getRegex() }, xxe = { ...eL, html: kr(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", J9).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: Bg, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: kr(Z9).replace("hr", am).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", BZ).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, wxe = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Txe = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, zZ = /^( {2,}|\\)\n(?!\s*$)/, Exe = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, o4 = /[\p{P}\p{S}]/u, tL = /[\s\p{P}\p{S}]/u, qZ = /[^\s\p{P}\p{S}]/u, Sxe = kr(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, tL).getRegex(), GZ = /(?!~)[\p{P}\p{S}]/u, kxe = /(?!~)[\s\p{P}\p{S}]/u, Cxe = /(?:[^\s\p{P}\p{S}]|~)/u, _xe = kr(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", lxe ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), UZ = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, Axe = kr(UZ, "u").replace(/punct/g, o4).getRegex(), Lxe = kr(UZ, "u").replace(/punct/g, GZ).getRegex(), VZ = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Rxe = kr(VZ, "gu").replace(/notPunctSpace/g, qZ).replace(/punctSpace/g, tL).replace(/punct/g, o4).getRegex(), Ixe = kr(VZ, "gu").replace(/notPunctSpace/g, Cxe).replace(/punctSpace/g, kxe).replace(/punct/g, GZ).getRegex(), Mxe = kr("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, qZ).replace(/punctSpace/g, tL).replace(/punct/g, o4).getRegex(), Nxe = kr(/\\(punct)/, "gu").replace(/punct/g, o4).getRegex(), Dxe = kr(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Oxe = kr(J9).replace("(?:-->|$)", "-->").getRegex(), Pxe = kr("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Oxe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), ob = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, $xe = kr(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", ob).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), HZ = kr(/^!?\[(label)\]\[(ref)\]/).replace("label", ob).replace("ref", Q9).getRegex(), WZ = kr(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q9).getRegex(), Bxe = kr("reflink|nolink(?!\\()", "g").replace("reflink", HZ).replace("nolink", WZ).getRegex(), XN = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, rL = { _backpedal: Bg, anyPunctuation: Nxe, autolink: Dxe, blockSkip: _xe, br: zZ, code: Txe, del: Bg, emStrongLDelim: Axe, emStrongRDelimAst: Rxe, emStrongRDelimUnd: Mxe, escape: wxe, link: $xe, nolink: WZ, punctuation: Sxe, reflink: HZ, reflinkSearch: Bxe, tag: Pxe, text: Exe, url: Bg }, Fxe = { ...rL, link: kr(/^!?\[(label)\]\((.*?)\)/).replace("label", ob).getRegex(), reflink: kr(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", ob).getRegex() }, O_ = { ...rL, emStrongRDelimAst: Ixe, emStrongLDelim: Lxe, url: kr(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", XN).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: kr(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", XN).getRegex() }, zxe = { ...O_, br: kr(zZ).replace("{2,}", "*").getRegex(), text: kr(O_.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, uv = { normal: eL, gfm: bxe, pedantic: xxe }, up = { normal: rL, gfm: O_, breaks: zxe, pedantic: Fxe }, qxe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, jN = (t) => qxe[t];
function Ys(t, e) {
  if (e) {
    if (Gi.escapeTest.test(t)) return t.replace(Gi.escapeReplace, jN);
  } else if (Gi.escapeTestNoEncode.test(t)) return t.replace(Gi.escapeReplaceNoEncode, jN);
  return t;
}
function KN(t) {
  try {
    t = encodeURI(t).replace(Gi.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function ZN(t, e) {
  let r = t.replace(Gi.findPipe, (a, s, o) => {
    let l = !1, u = s;
    for (; --u >= 0 && o[u] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), n = r.split(Gi.splitPipe), i = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; i < n.length; i++) n[i] = n[i].trim().replace(Gi.slashPipe, "|");
  return n;
}
function hp(t, e, r) {
  let n = t.length;
  if (n === 0) return "";
  let i = 0;
  for (; i < n && t.charAt(n - i - 1) === e; )
    i++;
  return t.slice(0, n - i);
}
function Gxe(t, e) {
  if (t.indexOf(e[1]) === -1) return -1;
  let r = 0;
  for (let n = 0; n < t.length; n++) if (t[n] === "\\") n++;
  else if (t[n] === e[0]) r++;
  else if (t[n] === e[1] && (r--, r < 0)) return n;
  return r > 0 ? -2 : -1;
}
function QN(t, e, r, n, i) {
  let a = e.href, s = e.title || null, o = t[1].replace(i.other.outputLinkReplace, "$1");
  n.state.inLink = !0;
  let l = { type: t[0].charAt(0) === "!" ? "image" : "link", raw: r, href: a, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = !1, l;
}
function Uxe(t, e, r) {
  let n = t.match(r.other.indentCodeCompensation);
  if (n === null) return e;
  let i = n[1];
  return e.split(`
`).map((a) => {
    let s = a.match(r.other.beginningSpace);
    if (s === null) return a;
    let [o] = s;
    return o.length >= i.length ? a.slice(i.length) : a;
  }).join(`
`);
}
var lb = class {
  options;
  rules;
  lexer;
  constructor(e) {
    this.options = e || kh;
  }
  space(e) {
    let r = this.rules.block.newline.exec(e);
    if (r && r[0].length > 0) return { type: "space", raw: r[0] };
  }
  code(e) {
    let r = this.rules.block.code.exec(e);
    if (r) {
      let n = r[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: r[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : hp(n, `
`) };
    }
  }
  fences(e) {
    let r = this.rules.block.fences.exec(e);
    if (r) {
      let n = r[0], i = Uxe(n, r[3] || "", this.rules);
      return { type: "code", raw: n, lang: r[2] ? r[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : r[2], text: i };
    }
  }
  heading(e) {
    let r = this.rules.block.heading.exec(e);
    if (r) {
      let n = r[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let i = hp(n, "#");
        (this.options.pedantic || !i || this.rules.other.endingSpaceChar.test(i)) && (n = i.trim());
      }
      return { type: "heading", raw: r[0], depth: r[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let r = this.rules.block.hr.exec(e);
    if (r) return { type: "hr", raw: hp(r[0], `
`) };
  }
  blockquote(e) {
    let r = this.rules.block.blockquote.exec(e);
    if (r) {
      let n = hp(r[0], `
`).split(`
`), i = "", a = "", s = [];
      for (; n.length > 0; ) {
        let o = !1, l = [], u;
        for (u = 0; u < n.length; u++) if (this.rules.other.blockquoteStart.test(n[u])) l.push(n[u]), o = !0;
        else if (!o) l.push(n[u]);
        else break;
        n = n.slice(u);
        let h = l.join(`
`), f = h.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        i = i ? `${i}
${h}` : h, a = a ? `${a}
${f}` : f;
        let d = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(f, s, !0), this.lexer.state.top = d, n.length === 0) break;
        let p = s.at(-1);
        if (p?.type === "code") break;
        if (p?.type === "blockquote") {
          let g = p, m = g.raw + `
` + n.join(`
`), v = this.blockquote(m);
          s[s.length - 1] = v, i = i.substring(0, i.length - g.raw.length) + v.raw, a = a.substring(0, a.length - g.text.length) + v.text;
          break;
        } else if (p?.type === "list") {
          let g = p, m = g.raw + `
` + n.join(`
`), v = this.list(m);
          s[s.length - 1] = v, i = i.substring(0, i.length - p.raw.length) + v.raw, a = a.substring(0, a.length - g.raw.length) + v.raw, n = m.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: i, tokens: s, text: a };
    }
  }
  list(e) {
    let r = this.rules.block.list.exec(e);
    if (r) {
      let n = r[1].trim(), i = n.length > 1, a = { type: "list", raw: "", ordered: i, start: i ? +n.slice(0, -1) : "", loose: !1, items: [] };
      n = i ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = i ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = !1;
      for (; e; ) {
        let u = !1, h = "", f = "";
        if (!(r = s.exec(e)) || this.rules.block.hr.test(e)) break;
        h = r[0], e = e.substring(h.length);
        let d = r[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (b) => " ".repeat(3 * b.length)), p = e.split(`
`, 1)[0], g = !d.trim(), m = 0;
        if (this.options.pedantic ? (m = 2, f = d.trimStart()) : g ? m = r[1].length + 1 : (m = r[2].search(this.rules.other.nonSpaceChar), m = m > 4 ? 1 : m, f = d.slice(m), m += r[1].length), g && this.rules.other.blankLine.test(p) && (h += p + `
`, e = e.substring(p.length + 1), u = !0), !u) {
          let b = this.rules.other.nextBulletRegex(m), x = this.rules.other.hrRegex(m), T = this.rules.other.fencesBeginRegex(m), E = this.rules.other.headingBeginRegex(m), A = this.rules.other.htmlBeginRegex(m);
          for (; e; ) {
            let S = e.split(`
`, 1)[0], k;
            if (p = S, this.options.pedantic ? (p = p.replace(this.rules.other.listReplaceNesting, "  "), k = p) : k = p.replace(this.rules.other.tabCharGlobal, "    "), T.test(p) || E.test(p) || A.test(p) || b.test(p) || x.test(p)) break;
            if (k.search(this.rules.other.nonSpaceChar) >= m || !p.trim()) f += `
` + k.slice(m);
            else {
              if (g || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || T.test(d) || E.test(d) || x.test(d)) break;
              f += `
` + p;
            }
            !g && !p.trim() && (g = !0), h += S + `
`, e = e.substring(S.length + 1), d = k.slice(m);
          }
        }
        a.loose || (o ? a.loose = !0 : this.rules.other.doubleBlankLine.test(h) && (o = !0));
        let v = null, y;
        this.options.gfm && (v = this.rules.other.listIsTask.exec(f), v && (y = v[0] !== "[ ] ", f = f.replace(this.rules.other.listReplaceTask, ""))), a.items.push({ type: "list_item", raw: h, task: !!v, checked: y, loose: !1, text: f, tokens: [] }), a.raw += h;
      }
      let l = a.items.at(-1);
      if (l) l.raw = l.raw.trimEnd(), l.text = l.text.trimEnd();
      else return;
      a.raw = a.raw.trimEnd();
      for (let u = 0; u < a.items.length; u++) if (this.lexer.state.top = !1, a.items[u].tokens = this.lexer.blockTokens(a.items[u].text, []), !a.loose) {
        let h = a.items[u].tokens.filter((d) => d.type === "space"), f = h.length > 0 && h.some((d) => this.rules.other.anyLine.test(d.raw));
        a.loose = f;
      }
      if (a.loose) for (let u = 0; u < a.items.length; u++) a.items[u].loose = !0;
      return a;
    }
  }
  html(e) {
    let r = this.rules.block.html.exec(e);
    if (r) return { type: "html", block: !0, raw: r[0], pre: r[1] === "pre" || r[1] === "script" || r[1] === "style", text: r[0] };
  }
  def(e) {
    let r = this.rules.block.def.exec(e);
    if (r) {
      let n = r[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), i = r[2] ? r[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", a = r[3] ? r[3].substring(1, r[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : r[3];
      return { type: "def", tag: n, raw: r[0], href: i, title: a };
    }
  }
  table(e) {
    let r = this.rules.block.table.exec(e);
    if (!r || !this.rules.other.tableDelimiter.test(r[2])) return;
    let n = ZN(r[1]), i = r[2].replace(this.rules.other.tableAlignChars, "").split("|"), a = r[3]?.trim() ? r[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: r[0], header: [], align: [], rows: [] };
    if (n.length === i.length) {
      for (let o of i) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < n.length; o++) s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: !0, align: s.align[o] });
      for (let o of a) s.rows.push(ZN(o, s.header.length).map((l, u) => ({ text: l, tokens: this.lexer.inline(l), header: !1, align: s.align[u] })));
      return s;
    }
  }
  lheading(e) {
    let r = this.rules.block.lheading.exec(e);
    if (r) return { type: "heading", raw: r[0], depth: r[2].charAt(0) === "=" ? 1 : 2, text: r[1], tokens: this.lexer.inline(r[1]) };
  }
  paragraph(e) {
    let r = this.rules.block.paragraph.exec(e);
    if (r) {
      let n = r[1].charAt(r[1].length - 1) === `
` ? r[1].slice(0, -1) : r[1];
      return { type: "paragraph", raw: r[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let r = this.rules.block.text.exec(e);
    if (r) return { type: "text", raw: r[0], text: r[0], tokens: this.lexer.inline(r[0]) };
  }
  escape(e) {
    let r = this.rules.inline.escape.exec(e);
    if (r) return { type: "escape", raw: r[0], text: r[1] };
  }
  tag(e) {
    let r = this.rules.inline.tag.exec(e);
    if (r) return !this.lexer.state.inLink && this.rules.other.startATag.test(r[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(r[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(r[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(r[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: r[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: r[0] };
  }
  link(e) {
    let r = this.rules.inline.link.exec(e);
    if (r) {
      let n = r[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = hp(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = Gxe(r[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let o = (r[0].indexOf("!") === 0 ? 5 : 4) + r[1].length + s;
          r[2] = r[2].substring(0, s), r[0] = r[0].substring(0, o).trim(), r[3] = "";
        }
      }
      let i = r[2], a = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(i);
        s && (i = s[1], a = s[3]);
      } else a = r[3] ? r[3].slice(1, -1) : "";
      return i = i.trim(), this.rules.other.startAngleBracket.test(i) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? i = i.slice(1) : i = i.slice(1, -1)), QN(r, { href: i && i.replace(this.rules.inline.anyPunctuation, "$1"), title: a && a.replace(this.rules.inline.anyPunctuation, "$1") }, r[0], this.lexer, this.rules);
    }
  }
  reflink(e, r) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let i = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), a = r[i.toLowerCase()];
      if (!a) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return QN(n, a, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, r, n = "") {
    let i = this.rules.inline.emStrongLDelim.exec(e);
    if (!(!i || i[3] && n.match(this.rules.other.unicodeAlphaNumeric)) && (!(i[1] || i[2]) || !n || this.rules.inline.punctuation.exec(n))) {
      let a = [...i[0]].length - 1, s, o, l = a, u = 0, h = i[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (h.lastIndex = 0, r = r.slice(-1 * e.length + a); (i = h.exec(r)) != null; ) {
        if (s = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !s) continue;
        if (o = [...s].length, i[3] || i[4]) {
          l += o;
          continue;
        } else if ((i[5] || i[6]) && a % 3 && !((a + o) % 3)) {
          u += o;
          continue;
        }
        if (l -= o, l > 0) continue;
        o = Math.min(o, o + l + u);
        let f = [...i[0]][0].length, d = e.slice(0, a + i.index + f + o);
        if (Math.min(a, o) % 2) {
          let g = d.slice(1, -1);
          return { type: "em", raw: d, text: g, tokens: this.lexer.inlineTokens(g) };
        }
        let p = d.slice(2, -2);
        return { type: "strong", raw: d, text: p, tokens: this.lexer.inlineTokens(p) };
      }
    }
  }
  codespan(e) {
    let r = this.rules.inline.code.exec(e);
    if (r) {
      let n = r[2].replace(this.rules.other.newLineCharGlobal, " "), i = this.rules.other.nonSpaceChar.test(n), a = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return i && a && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: r[0], text: n };
    }
  }
  br(e) {
    let r = this.rules.inline.br.exec(e);
    if (r) return { type: "br", raw: r[0] };
  }
  del(e) {
    let r = this.rules.inline.del.exec(e);
    if (r) return { type: "del", raw: r[0], text: r[2], tokens: this.lexer.inlineTokens(r[2]) };
  }
  autolink(e) {
    let r = this.rules.inline.autolink.exec(e);
    if (r) {
      let n, i;
      return r[2] === "@" ? (n = r[1], i = "mailto:" + n) : (n = r[1], i = n), { type: "link", raw: r[0], text: n, href: i, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let r;
    if (r = this.rules.inline.url.exec(e)) {
      let n, i;
      if (r[2] === "@") n = r[0], i = "mailto:" + n;
      else {
        let a;
        do
          a = r[0], r[0] = this.rules.inline._backpedal.exec(r[0])?.[0] ?? "";
        while (a !== r[0]);
        n = r[0], r[1] === "www." ? i = "http://" + r[0] : i = r[0];
      }
      return { type: "link", raw: r[0], text: n, href: i, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let r = this.rules.inline.text.exec(e);
    if (r) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: r[0], text: r[0], escaped: n };
    }
  }
}, xs = class P_ {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || kh, this.options.tokenizer = this.options.tokenizer || new lb(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    let r = { other: Gi, block: uv.normal, inline: up.normal };
    this.options.pedantic ? (r.block = uv.pedantic, r.inline = up.pedantic) : this.options.gfm && (r.block = uv.gfm, this.options.breaks ? r.inline = up.breaks : r.inline = up.gfm), this.tokenizer.rules = r;
  }
  static get rules() {
    return { block: uv, inline: up };
  }
  static lex(e, r) {
    return new P_(r).lex(e);
  }
  static lexInline(e, r) {
    return new P_(r).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Gi.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      let n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = !1) {
    for (this.options.pedantic && (e = e.replace(Gi.tabCharGlobal, "    ").replace(Gi.spaceLine, "")); e; ) {
      let i;
      if (this.options.extensions?.block?.some((s) => (i = s.call({ lexer: this }, e, r)) ? (e = e.substring(i.raw.length), r.push(i), !0) : !1)) continue;
      if (i = this.tokenizer.space(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        i.raw.length === 1 && s !== void 0 ? s.raw += `
` : r.push(i);
        continue;
      }
      if (i = this.tokenizer.code(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (i = this.tokenizer.fences(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.heading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.hr(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.blockquote(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.list(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.html(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.def(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = { href: i.href, title: i.title }, r.push(i));
        continue;
      }
      if (i = this.tokenizer.table(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      if (i = this.tokenizer.lheading(e)) {
        e = e.substring(i.raw.length), r.push(i);
        continue;
      }
      let a = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, o = e.slice(1), l;
        this.options.extensions.startBlock.forEach((u) => {
          l = u.call({ lexer: this }, o), typeof l == "number" && l >= 0 && (s = Math.min(s, l));
        }), s < 1 / 0 && s >= 0 && (a = e.substring(0, s + 1));
      }
      if (this.state.top && (i = this.tokenizer.paragraph(a))) {
        let s = r.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i), n = a.length !== e.length, e = e.substring(i.raw.length);
        continue;
      }
      if (i = this.tokenizer.text(e)) {
        e = e.substring(i.raw.length);
        let s = r.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + i.raw, s.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : r.push(i);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = !0, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  inlineTokens(e, r = []) {
    let n = e, i = null;
    if (this.tokens.links) {
      let l = Object.keys(this.tokens.links);
      if (l.length > 0) for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) l.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, i.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let a;
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) a = i[2] ? i[2].length : 0, n = n.slice(0, i.index + a) + "[" + "a".repeat(i[0].length - a - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let s = !1, o = "";
    for (; e; ) {
      s || (o = ""), s = !1;
      let l;
      if (this.options.extensions?.inline?.some((h) => (l = h.call({ lexer: this }, e, r)) ? (e = e.substring(l.raw.length), r.push(l), !0) : !1)) continue;
      if (l = this.tokenizer.escape(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.tag(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.link(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(l.raw.length);
        let h = r.at(-1);
        l.type === "text" && h?.type === "text" ? (h.raw += l.raw, h.text += l.text) : r.push(l);
        continue;
      }
      if (l = this.tokenizer.emStrong(e, n, o)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.codespan(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.br(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.del(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (l = this.tokenizer.autolink(e)) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      if (!this.state.inLink && (l = this.tokenizer.url(e))) {
        e = e.substring(l.raw.length), r.push(l);
        continue;
      }
      let u = e;
      if (this.options.extensions?.startInline) {
        let h = 1 / 0, f = e.slice(1), d;
        this.options.extensions.startInline.forEach((p) => {
          d = p.call({ lexer: this }, f), typeof d == "number" && d >= 0 && (h = Math.min(h, d));
        }), h < 1 / 0 && h >= 0 && (u = e.substring(0, h + 1));
      }
      if (l = this.tokenizer.inlineText(u)) {
        e = e.substring(l.raw.length), l.raw.slice(-1) !== "_" && (o = l.raw.slice(-1)), s = !0;
        let h = r.at(-1);
        h?.type === "text" ? (h.raw += l.raw, h.text += l.text) : r.push(l);
        continue;
      }
      if (e) {
        let h = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(h);
          break;
        } else throw new Error(h);
      }
    }
    return r;
  }
}, cb = class {
  options;
  parser;
  constructor(e) {
    this.options = e || kh;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: r, escaped: n }) {
    let i = (r || "").match(Gi.notSpaceStart)?.[0], a = e.replace(Gi.endingNewline, "") + `
`;
    return i ? '<pre><code class="language-' + Ys(i) + '">' + (n ? a : Ys(a, !0)) + `</code></pre>
` : "<pre><code>" + (n ? a : Ys(a, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: r }) {
    return `<h${r}>${this.parser.parseInline(e)}</h${r}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let r = e.ordered, n = e.start, i = "";
    for (let o = 0; o < e.items.length; o++) {
      let l = e.items[o];
      i += this.listitem(l);
    }
    let a = r ? "ol" : "ul", s = r && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + a + s + `>
` + i + "</" + a + `>
`;
  }
  listitem(e) {
    let r = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + Ys(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: !0 }) : r += n + " ";
    }
    return r += this.parser.parse(e.tokens, !!e.loose), `<li>${r}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let r = "", n = "";
    for (let a = 0; a < e.header.length; a++) n += this.tablecell(e.header[a]);
    r += this.tablerow({ text: n });
    let i = "";
    for (let a = 0; a < e.rows.length; a++) {
      let s = e.rows[a];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      i += this.tablerow({ text: n });
    }
    return i && (i = `<tbody>${i}</tbody>`), `<table>
<thead>
` + r + `</thead>
` + i + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let r = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + r + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${Ys(e, !0)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: r, tokens: n }) {
    let i = this.parser.parseInline(n), a = KN(e);
    if (a === null) return i;
    e = a;
    let s = '<a href="' + e + '"';
    return r && (s += ' title="' + Ys(r) + '"'), s += ">" + i + "</a>", s;
  }
  image({ href: e, title: r, text: n, tokens: i }) {
    i && (n = this.parser.parseInline(i, this.parser.textRenderer));
    let a = KN(e);
    if (a === null) return Ys(n);
    e = a;
    let s = `<img src="${e}" alt="${n}"`;
    return r && (s += ` title="${Ys(r)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : Ys(e.text);
  }
}, nL = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
}, ws = class $_ {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || kh, this.options.renderer = this.options.renderer || new cb(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new nL();
  }
  static parse(e, r) {
    return new $_(r).parse(e);
  }
  static parseInline(e, r) {
    return new $_(r).parseInline(e);
  }
  parse(e, r = !0) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let a = e[i];
      if (this.options.extensions?.renderers?.[a.type]) {
        let o = a, l = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (l !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(o.type)) {
          n += l || "";
          continue;
        }
      }
      let s = a;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, l = this.renderer.text(o);
          for (; i + 1 < e.length && e[i + 1].type === "text"; ) o = e[++i], l += `
` + this.renderer.text(o);
          r ? n += this.renderer.paragraph({ type: "paragraph", raw: l, text: l, tokens: [{ type: "text", raw: l, text: l, escaped: !0 }] }) : n += l;
          continue;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, r = this.renderer) {
    let n = "";
    for (let i = 0; i < e.length; i++) {
      let a = e[i];
      if (this.options.extensions?.renderers?.[a.type]) {
        let o = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (o !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(a.type)) {
          n += o || "";
          continue;
        }
      }
      let s = a;
      switch (s.type) {
        case "escape": {
          n += r.text(s);
          break;
        }
        case "html": {
          n += r.html(s);
          break;
        }
        case "link": {
          n += r.link(s);
          break;
        }
        case "image": {
          n += r.image(s);
          break;
        }
        case "strong": {
          n += r.strong(s);
          break;
        }
        case "em": {
          n += r.em(s);
          break;
        }
        case "codespan": {
          n += r.codespan(s);
          break;
        }
        case "br": {
          n += r.br(s);
          break;
        }
        case "del": {
          n += r.del(s);
          break;
        }
        case "text": {
          n += r.text(s);
          break;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
}, Np = class {
  options;
  block;
  constructor(e) {
    this.options = e || kh;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? xs.lex : xs.lexInline;
  }
  provideParser() {
    return this.block ? ws.parse : ws.parseInline;
  }
}, Vxe = class {
  defaults = j9();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = ws;
  Renderer = cb;
  TextRenderer = nL;
  Lexer = xs;
  Tokenizer = lb;
  Hooks = Np;
  constructor(...e) {
    this.use(...e);
  }
  walkTokens(e, r) {
    let n = [];
    for (let i of e) switch (n = n.concat(r.call(this, i)), i.type) {
      case "table": {
        let a = i;
        for (let s of a.header) n = n.concat(this.walkTokens(s.tokens, r));
        for (let s of a.rows) for (let o of s) n = n.concat(this.walkTokens(o.tokens, r));
        break;
      }
      case "list": {
        let a = i;
        n = n.concat(this.walkTokens(a.items, r));
        break;
      }
      default: {
        let a = i;
        this.defaults.extensions?.childTokens?.[a.type] ? this.defaults.extensions.childTokens[a.type].forEach((s) => {
          let o = a[s].flat(1 / 0);
          n = n.concat(this.walkTokens(o, r));
        }) : a.tokens && (n = n.concat(this.walkTokens(a.tokens, r)));
      }
    }
    return n;
  }
  use(...e) {
    let r = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let i = { ...n };
      if (i.async = this.defaults.async || i.async || !1, n.extensions && (n.extensions.forEach((a) => {
        if (!a.name) throw new Error("extension name required");
        if ("renderer" in a) {
          let s = r.renderers[a.name];
          s ? r.renderers[a.name] = function(...o) {
            let l = a.renderer.apply(this, o);
            return l === !1 && (l = s.apply(this, o)), l;
          } : r.renderers[a.name] = a.renderer;
        }
        if ("tokenizer" in a) {
          if (!a.level || a.level !== "block" && a.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = r[a.level];
          s ? s.unshift(a.tokenizer) : r[a.level] = [a.tokenizer], a.start && (a.level === "block" ? r.startBlock ? r.startBlock.push(a.start) : r.startBlock = [a.start] : a.level === "inline" && (r.startInline ? r.startInline.push(a.start) : r.startInline = [a.start]));
        }
        "childTokens" in a && a.childTokens && (r.childTokens[a.name] = a.childTokens);
      }), i.extensions = r), n.renderer) {
        let a = this.defaults.renderer || new cb(this.defaults);
        for (let s in n.renderer) {
          if (!(s in a)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, l = n.renderer[o], u = a[o];
          a[o] = (...h) => {
            let f = l.apply(a, h);
            return f === !1 && (f = u.apply(a, h)), f || "";
          };
        }
        i.renderer = a;
      }
      if (n.tokenizer) {
        let a = this.defaults.tokenizer || new lb(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in a)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, l = n.tokenizer[o], u = a[o];
          a[o] = (...h) => {
            let f = l.apply(a, h);
            return f === !1 && (f = u.apply(a, h)), f;
          };
        }
        i.tokenizer = a;
      }
      if (n.hooks) {
        let a = this.defaults.hooks || new Np();
        for (let s in n.hooks) {
          if (!(s in a)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, l = n.hooks[o], u = a[o];
          Np.passThroughHooks.has(s) ? a[o] = (h) => {
            if (this.defaults.async && Np.passThroughHooksRespectAsync.has(s)) return (async () => {
              let d = await l.call(a, h);
              return u.call(a, d);
            })();
            let f = l.call(a, h);
            return u.call(a, f);
          } : a[o] = (...h) => {
            if (this.defaults.async) return (async () => {
              let d = await l.apply(a, h);
              return d === !1 && (d = await u.apply(a, h)), d;
            })();
            let f = l.apply(a, h);
            return f === !1 && (f = u.apply(a, h)), f;
          };
        }
        i.hooks = a;
      }
      if (n.walkTokens) {
        let a = this.defaults.walkTokens, s = n.walkTokens;
        i.walkTokens = function(o) {
          let l = [];
          return l.push(s.call(this, o)), a && (l = l.concat(a.call(this, o))), l;
        };
      }
      this.defaults = { ...this.defaults, ...i };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, r) {
    return xs.lex(e, r ?? this.defaults);
  }
  parser(e, r) {
    return ws.parse(e, r ?? this.defaults);
  }
  parseMarkdown(e) {
    return (r, n) => {
      let i = { ...n }, a = { ...this.defaults, ...i }, s = this.onError(!!a.silent, !!a.async);
      if (this.defaults.async === !0 && i.async === !1) return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof r > "u" || r === null) return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof r != "string") return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
      if (a.hooks && (a.hooks.options = a, a.hooks.block = e), a.async) return (async () => {
        let o = a.hooks ? await a.hooks.preprocess(r) : r, l = await (a.hooks ? await a.hooks.provideLexer() : e ? xs.lex : xs.lexInline)(o, a), u = a.hooks ? await a.hooks.processAllTokens(l) : l;
        a.walkTokens && await Promise.all(this.walkTokens(u, a.walkTokens));
        let h = await (a.hooks ? await a.hooks.provideParser() : e ? ws.parse : ws.parseInline)(u, a);
        return a.hooks ? await a.hooks.postprocess(h) : h;
      })().catch(s);
      try {
        a.hooks && (r = a.hooks.preprocess(r));
        let o = (a.hooks ? a.hooks.provideLexer() : e ? xs.lex : xs.lexInline)(r, a);
        a.hooks && (o = a.hooks.processAllTokens(o)), a.walkTokens && this.walkTokens(o, a.walkTokens);
        let l = (a.hooks ? a.hooks.provideParser() : e ? ws.parse : ws.parseInline)(o, a);
        return a.hooks && (l = a.hooks.postprocess(l)), l;
      } catch (o) {
        return s(o);
      }
    };
  }
  onError(e, r) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let i = "<p>An error occurred:</p><pre>" + Ys(n.message + "", !0) + "</pre>";
        return r ? Promise.resolve(i) : i;
      }
      if (r) return Promise.reject(n);
      throw n;
    };
  }
}, Ku = new Vxe();
function Lr(t, e) {
  return Ku.parse(t, e);
}
Lr.options = Lr.setOptions = function(t) {
  return Ku.setOptions(t), Lr.defaults = Ku.defaults, PZ(Lr.defaults), Lr;
};
Lr.getDefaults = j9;
Lr.defaults = kh;
Lr.use = function(...t) {
  return Ku.use(...t), Lr.defaults = Ku.defaults, PZ(Lr.defaults), Lr;
};
Lr.walkTokens = function(t, e) {
  return Ku.walkTokens(t, e);
};
Lr.parseInline = Ku.parseInline;
Lr.Parser = ws;
Lr.parser = ws.parse;
Lr.Renderer = cb;
Lr.TextRenderer = nL;
Lr.Lexer = xs;
Lr.lexer = xs.lex;
Lr.Tokenizer = lb;
Lr.Hooks = Np;
Lr.parse = Lr;
Lr.options;
Lr.setOptions;
Lr.use;
Lr.walkTokens;
Lr.parseInline;
ws.parse;
xs.lex;
function YZ(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = Array.from(typeof t == "string" ? [t] : t);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i = n.reduce(function(o, l) {
    var u = l.match(/\n([\t ]+|(?!\s).)/g);
    return u ? o.concat(u.map(function(h) {
      var f, d;
      return (d = (f = h.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && d !== void 0 ? d : 0;
    })) : o;
  }, []);
  if (i.length) {
    var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
    n = n.map(function(o) {
      return o.replace(a, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var s = n[0];
  return e.forEach(function(o, l) {
    var u = s.match(/(?:^|\n)( *)$/), h = u ? u[1] : "", f = o;
    typeof o == "string" && o.includes(`
`) && (f = String(o).split(`
`).map(function(d, p) {
      return p === 0 ? d : "" + h + d;
    }).join(`
`)), s += f + n[l + 1];
  }), s;
}
var XZ = {
  body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
  height: 80,
  width: 80
}, B_ = /* @__PURE__ */ new Map(), jZ = /* @__PURE__ */ new Map(), KZ = /* @__PURE__ */ w((t) => {
  for (const e of t) {
    if (!e.name)
      throw new Error(
        'Invalid icon loader. Must have a "name" property with non-empty string value.'
      );
    if (ae.debug("Registering icon pack:", e.name), "loader" in e)
      jZ.set(e.name, e.loader);
    else if ("icons" in e)
      B_.set(e.name, e.icons);
    else
      throw ae.error("Invalid icon loader:", e), new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
  }
}, "registerIconPacks"), ZZ = /* @__PURE__ */ w(async (t, e) => {
  const r = Ybe(t, !0, e !== void 0);
  if (!r)
    throw new Error(`Invalid icon name: ${t}`);
  const n = r.prefix || e;
  if (!n)
    throw new Error(`Icon name must contain a prefix: ${t}`);
  let i = B_.get(n);
  if (!i) {
    const s = jZ.get(n);
    if (!s)
      throw new Error(`Icon set not found: ${r.prefix}`);
    try {
      i = { ...await s(), prefix: n }, B_.set(n, i);
    } catch (o) {
      throw ae.error(o), new Error(`Failed to load icon set: ${r.prefix}`);
    }
  }
  const a = Kbe(i, r.name);
  if (!a)
    throw new Error(`Icon not found: ${t}`);
  return a;
}, "getRegisteredIconData"), Hxe = /* @__PURE__ */ w(async (t) => {
  try {
    return await ZZ(t), !0;
  } catch {
    return !1;
  }
}, "isIconAvailable"), fc = /* @__PURE__ */ w(async (t, e, r) => {
  let n;
  try {
    n = await ZZ(t, e?.fallbackPrefix);
  } catch (s) {
    ae.error(s), n = XZ;
  }
  const i = nxe(n, e), a = oxe(sxe(i.body), {
    ...i.attributes,
    ...r
  });
  return pr(a, mr());
}, "getIconSVG");
function QZ(t, { markdownAutoWrap: e }) {
  const n = t.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`), i = YZ(n);
  return e === !1 ? i.replace(/ /g, "&nbsp;") : i;
}
w(QZ, "preprocessMarkdown");
function JZ(t, e = {}) {
  const r = QZ(t, e), n = Lr.lexer(r), i = [[]];
  let a = 0;
  function s(o, l = "normal") {
    o.type === "text" ? o.text.split(`
`).forEach((h, f) => {
      f !== 0 && (a++, i.push([])), h.split(" ").forEach((d) => {
        d = d.replace(/&#39;/g, "'"), d && i[a].push({ content: d, type: l });
      });
    }) : o.type === "strong" || o.type === "em" ? o.tokens.forEach((u) => {
      s(u, o.type);
    }) : o.type === "html" && i[a].push({ content: o.text, type: "normal" });
  }
  return w(s, "processNode"), n.forEach((o) => {
    o.type === "paragraph" ? o.tokens?.forEach((l) => {
      s(l);
    }) : o.type === "html" ? i[a].push({ content: o.text, type: "normal" }) : i[a].push({ content: o.raw, type: "normal" });
  }), i;
}
w(JZ, "markdownToLines");
function eQ(t, { markdownAutoWrap: e } = {}) {
  const r = Lr.lexer(t);
  function n(i) {
    return i.type === "text" ? e === !1 ? i.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : i.text.replace(/\n */g, "<br/>") : i.type === "strong" ? `<strong>${i.tokens?.map(n).join("")}</strong>` : i.type === "em" ? `<em>${i.tokens?.map(n).join("")}</em>` : i.type === "paragraph" ? `<p>${i.tokens?.map(n).join("")}</p>` : i.type === "space" ? "" : i.type === "html" ? `${i.text}` : i.type === "escape" ? i.text : (ae.warn(`Unsupported markdown: ${i.type}`), i.raw);
  }
  return w(n, "output"), r.map(n).join("");
}
w(eQ, "markdownToHTML");
function tQ(t) {
  return Intl.Segmenter ? [...new Intl.Segmenter().segment(t)].map((e) => e.segment) : [...t];
}
w(tQ, "splitTextToChars");
function rQ(t, e) {
  const r = tQ(e.content);
  return iL(t, [], r, e.type);
}
w(rQ, "splitWordToFitWidth");
function iL(t, e, r, n) {
  if (r.length === 0)
    return [
      { content: e.join(""), type: n },
      { content: "", type: n }
    ];
  const [i, ...a] = r, s = [...e, i];
  return t([{ content: s.join(""), type: n }]) ? iL(t, s, a, n) : (e.length === 0 && i && (e.push(i), r.shift()), [
    { content: e.join(""), type: n },
    { content: r.join(""), type: n }
  ]);
}
w(iL, "splitWordToFitWidthRecursion");
function nQ(t, e) {
  if (t.some(({ content: r }) => r.includes(`
`)))
    throw new Error("splitLineToFitWidth does not support newlines in the line");
  return ub(t, e);
}
w(nQ, "splitLineToFitWidth");
function ub(t, e, r = [], n = []) {
  if (t.length === 0)
    return n.length > 0 && r.push(n), r.length > 0 ? r : [];
  let i = "";
  t[0].content === " " && (i = " ", t.shift());
  const a = t.shift() ?? { content: " ", type: "normal" }, s = [...n];
  if (i !== "" && s.push({ content: i, type: "normal" }), s.push(a), e(s))
    return ub(t, e, r, s);
  if (n.length > 0)
    r.push(n), t.unshift(a);
  else if (a.content) {
    const [o, l] = rQ(e, a);
    r.push([o]), l.content && t.unshift(l);
  }
  return ub(t, e, r);
}
w(ub, "splitLineToFitWidthRecursion");
function F_(t, e) {
  e && t.attr("style", e);
}
w(F_, "applyStyle");
async function iQ(t, e, r, n, i = !1, a = mr()) {
  const s = t.append("foreignObject");
  s.attr("width", `${10 * r}px`), s.attr("height", `${10 * r}px`);
  const o = s.append("xhtml:div"), l = dn(e.label) ? await Z1(e.label.replace(at.lineBreakRegex, `
`), a) : pr(e.label, a), u = e.isNode ? "nodeLabel" : "edgeLabel", h = o.append("span");
  h.html(l), F_(h, e.labelStyle), h.attr("class", `${u} ${n}`), F_(o, e.labelStyle), o.style("display", "table-cell"), o.style("white-space", "nowrap"), o.style("line-height", "1.5"), o.style("max-width", r + "px"), o.style("text-align", "center"), o.attr("xmlns", "http://www.w3.org/1999/xhtml"), i && o.attr("class", "labelBkg");
  let f = o.node().getBoundingClientRect();
  return f.width === r && (o.style("display", "table"), o.style("white-space", "break-spaces"), o.style("width", r + "px"), f = o.node().getBoundingClientRect()), s.node();
}
w(iQ, "addHtmlSpan");
function l4(t, e, r) {
  return t.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", e * r - 0.1 + "em").attr("dy", r + "em");
}
w(l4, "createTspan");
function aQ(t, e, r) {
  const n = t.append("text"), i = l4(n, 1, e);
  c4(i, r);
  const a = i.node().getComputedTextLength();
  return n.remove(), a;
}
w(aQ, "computeWidthOfText");
function sQ(t, e, r) {
  const n = t.append("text"), i = l4(n, 1, e);
  c4(i, [{ content: r, type: "normal" }]);
  const a = i.node()?.getBoundingClientRect();
  return a && n.remove(), a;
}
w(sQ, "computeDimensionOfText");
function oQ(t, e, r, n = !1) {
  const a = e.append("g"), s = a.insert("rect").attr("class", "background").attr("style", "stroke: none"), o = a.append("text").attr("y", "-10.1");
  let l = 0;
  for (const u of r) {
    const h = /* @__PURE__ */ w((d) => aQ(a, 1.1, d) <= t, "checkWidth"), f = h(u) ? [u] : nQ(u, h);
    for (const d of f) {
      const p = l4(o, l, 1.1);
      c4(p, d), l++;
    }
  }
  if (n) {
    const u = o.node().getBBox(), h = 2;
    return s.attr("x", u.x - h).attr("y", u.y - h).attr("width", u.width + 2 * h).attr("height", u.height + 2 * h), a.node();
  } else
    return o.node();
}
w(oQ, "createFormattedText");
function c4(t, e) {
  t.text(""), e.forEach((r, n) => {
    const i = t.append("tspan").attr("font-style", r.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", r.type === "strong" ? "bold" : "normal");
    n === 0 ? i.text(r.content) : i.text(" " + r.content);
  });
}
w(c4, "updateTextContentAndStyles");
async function aL(t, e = {}) {
  const r = [];
  t.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (i, a, s) => (r.push(
    (async () => {
      const o = `${a}:${s}`;
      return await Hxe(o) ? await fc(o, void 0, { class: "label-icon" }) : `<i class='${pr(i, e).replace(":", " ")}'></i>`;
    })()
  ), i));
  const n = await Promise.all(r);
  return t.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => n.shift() ?? "");
}
w(aL, "replaceIconSubstring");
var Na = /* @__PURE__ */ w(async (t, e = "", {
  style: r = "",
  isTitle: n = !1,
  classes: i = "",
  useHtmlLabels: a = !0,
  isNode: s = !0,
  width: o = 200,
  addSvgBackground: l = !1
} = {}, u) => {
  if (ae.debug(
    "XYZ createText",
    e,
    r,
    n,
    i,
    a,
    s,
    "addSvgBackground: ",
    l
  ), a) {
    const h = eQ(e, u), f = await aL(mo(h), u), d = e.replace(/\\\\/g, "\\"), p = {
      isNode: s,
      label: dn(e) ? d : f,
      labelStyle: r.replace("fill:", "color:")
    };
    return await iQ(t, p, o, i, l, u);
  } else {
    const h = e.replace(/<br\s*\/?>/g, "<br/>"), f = JZ(h.replace("<br>", "<br/>"), u), d = oQ(
      o,
      t,
      f,
      e ? l : !1
    );
    if (s) {
      /stroke:/.exec(r) && (r = r.replace("stroke:", "lineColor:"));
      const p = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      Qe(d).attr("style", p);
    } else {
      const p = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
      Qe(d).select("rect").attr("style", p.replace(/background:/g, "fill:"));
      const g = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      Qe(d).select("text").attr("style", g);
    }
    return d;
  }
}, "createText");
function O5(t, e, r) {
  if (t && t.length) {
    const [n, i] = e, a = Math.PI / 180 * r, s = Math.cos(a), o = Math.sin(a);
    for (const l of t) {
      const [u, h] = l;
      l[0] = (u - n) * s - (h - i) * o + n, l[1] = (u - n) * o + (h - i) * s + i;
    }
  }
}
function Wxe(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
function Yxe(t, e, r, n = 1) {
  const i = r, a = Math.max(e, 0.1), s = t[0] && t[0][0] && typeof t[0][0] == "number" ? [t] : t, o = [0, 0];
  if (i) for (const u of s) O5(u, o, i);
  const l = (function(u, h, f) {
    const d = [];
    for (const b of u) {
      const x = [...b];
      Wxe(x[0], x[x.length - 1]) || x.push([x[0][0], x[0][1]]), x.length > 2 && d.push(x);
    }
    const p = [];
    h = Math.max(h, 0.1);
    const g = [];
    for (const b of d) for (let x = 0; x < b.length - 1; x++) {
      const T = b[x], E = b[x + 1];
      if (T[1] !== E[1]) {
        const A = Math.min(T[1], E[1]);
        g.push({ ymin: A, ymax: Math.max(T[1], E[1]), x: A === T[1] ? T[0] : E[0], islope: (E[0] - T[0]) / (E[1] - T[1]) });
      }
    }
    if (g.sort(((b, x) => b.ymin < x.ymin ? -1 : b.ymin > x.ymin ? 1 : b.x < x.x ? -1 : b.x > x.x ? 1 : b.ymax === x.ymax ? 0 : (b.ymax - x.ymax) / Math.abs(b.ymax - x.ymax))), !g.length) return p;
    let m = [], v = g[0].ymin, y = 0;
    for (; m.length || g.length; ) {
      if (g.length) {
        let b = -1;
        for (let x = 0; x < g.length && !(g[x].ymin > v); x++) b = x;
        g.splice(0, b + 1).forEach(((x) => {
          m.push({ s: v, edge: x });
        }));
      }
      if (m = m.filter(((b) => !(b.edge.ymax <= v))), m.sort(((b, x) => b.edge.x === x.edge.x ? 0 : (b.edge.x - x.edge.x) / Math.abs(b.edge.x - x.edge.x))), (f !== 1 || y % h == 0) && m.length > 1) for (let b = 0; b < m.length; b += 2) {
        const x = b + 1;
        if (x >= m.length) break;
        const T = m[b].edge, E = m[x].edge;
        p.push([[Math.round(T.x), v], [Math.round(E.x), v]]);
      }
      v += f, m.forEach(((b) => {
        b.edge.x = b.edge.x + f * b.edge.islope;
      })), y++;
    }
    return p;
  })(s, a, n);
  if (i) {
    for (const u of s) O5(u, o, -i);
    (function(u, h, f) {
      const d = [];
      u.forEach(((p) => d.push(...p))), O5(d, h, f);
    })(l, o, -i);
  }
  return l;
}
function sm(t, e) {
  var r;
  const n = e.hachureAngle + 90;
  let i = e.hachureGap;
  i < 0 && (i = 4 * e.strokeWidth), i = Math.round(Math.max(i, 0.1));
  let a = 1;
  return e.roughness >= 1 && (((r = e.randomizer) === null || r === void 0 ? void 0 : r.next()) || Math.random()) > 0.7 && (a = i), Yxe(t, i, n, a || 1);
}
class sL {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    return this._fillPolygons(e, r);
  }
  _fillPolygons(e, r) {
    const n = sm(e, r);
    return { type: "fillSketch", ops: this.renderLines(n, r) };
  }
  renderLines(e, r) {
    const n = [];
    for (const i of e) n.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], r));
    return n;
  }
}
function u4(t) {
  const e = t[0], r = t[1];
  return Math.sqrt(Math.pow(e[0] - r[0], 2) + Math.pow(e[1] - r[1], 2));
}
class Xxe extends sL {
  fillPolygons(e, r) {
    let n = r.hachureGap;
    n < 0 && (n = 4 * r.strokeWidth), n = Math.max(n, 0.1);
    const i = sm(e, Object.assign({}, r, { hachureGap: n })), a = Math.PI / 180 * r.hachureAngle, s = [], o = 0.5 * n * Math.cos(a), l = 0.5 * n * Math.sin(a);
    for (const [u, h] of i) u4([u, h]) && s.push([[u[0] - o, u[1] + l], [...h]], [[u[0] + o, u[1] - l], [...h]]);
    return { type: "fillSketch", ops: this.renderLines(s, r) };
  }
}
class jxe extends sL {
  fillPolygons(e, r) {
    const n = this._fillPolygons(e, r), i = Object.assign({}, r, { hachureAngle: r.hachureAngle + 90 }), a = this._fillPolygons(e, i);
    return n.ops = n.ops.concat(a.ops), n;
  }
}
let Kxe = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = sm(e, r = Object.assign({}, r, { hachureAngle: 0 }));
    return this.dotsOnLines(n, r);
  }
  dotsOnLines(e, r) {
    const n = [];
    let i = r.hachureGap;
    i < 0 && (i = 4 * r.strokeWidth), i = Math.max(i, 0.1);
    let a = r.fillWeight;
    a < 0 && (a = r.strokeWidth / 2);
    const s = i / 4;
    for (const o of e) {
      const l = u4(o), u = l / i, h = Math.ceil(u) - 1, f = l - h * i, d = (o[0][0] + o[1][0]) / 2 - i / 4, p = Math.min(o[0][1], o[1][1]);
      for (let g = 0; g < h; g++) {
        const m = p + f + g * i, v = d - s + 2 * Math.random() * s, y = m - s + 2 * Math.random() * s, b = this.helper.ellipse(v, y, a, a, r);
        n.push(...b.ops);
      }
    }
    return { type: "fillSketch", ops: n };
  }
}, Zxe = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = sm(e, r);
    return { type: "fillSketch", ops: this.dashedLine(n, r) };
  }
  dashedLine(e, r) {
    const n = r.dashOffset < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashOffset, i = r.dashGap < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashGap, a = [];
    return e.forEach(((s) => {
      const o = u4(s), l = Math.floor(o / (n + i)), u = (o + i - l * (n + i)) / 2;
      let h = s[0], f = s[1];
      h[0] > f[0] && (h = s[1], f = s[0]);
      const d = Math.atan((f[1] - h[1]) / (f[0] - h[0]));
      for (let p = 0; p < l; p++) {
        const g = p * (n + i), m = g + n, v = [h[0] + g * Math.cos(d) + u * Math.cos(d), h[1] + g * Math.sin(d) + u * Math.sin(d)], y = [h[0] + m * Math.cos(d) + u * Math.cos(d), h[1] + m * Math.sin(d) + u * Math.sin(d)];
        a.push(...this.helper.doubleLineOps(v[0], v[1], y[0], y[1], r));
      }
    })), a;
  }
};
class Qxe {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap, i = r.zigzagOffset < 0 ? n : r.zigzagOffset, a = sm(e, r = Object.assign({}, r, { hachureGap: n + i }));
    return { type: "fillSketch", ops: this.zigzagLines(a, i, r) };
  }
  zigzagLines(e, r, n) {
    const i = [];
    return e.forEach(((a) => {
      const s = u4(a), o = Math.round(s / (2 * r));
      let l = a[0], u = a[1];
      l[0] > u[0] && (l = a[1], u = a[0]);
      const h = Math.atan((u[1] - l[1]) / (u[0] - l[0]));
      for (let f = 0; f < o; f++) {
        const d = 2 * f * r, p = 2 * (f + 1) * r, g = Math.sqrt(2 * Math.pow(r, 2)), m = [l[0] + d * Math.cos(h), l[1] + d * Math.sin(h)], v = [l[0] + p * Math.cos(h), l[1] + p * Math.sin(h)], y = [m[0] + g * Math.cos(h + Math.PI / 4), m[1] + g * Math.sin(h + Math.PI / 4)];
        i.push(...this.helper.doubleLineOps(m[0], m[1], y[0], y[1], n), ...this.helper.doubleLineOps(y[0], y[1], v[0], v[1], n));
      }
    })), i;
  }
}
const ra = {};
let Jxe = class {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
const e4e = 0, P5 = 1, JN = 2, hv = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function $5(t, e) {
  return t.type === e;
}
function oL(t) {
  const e = [], r = (function(s) {
    const o = new Array();
    for (; s !== ""; ) if (s.match(/^([ \t\r\n,]+)/)) s = s.substr(RegExp.$1.length);
    else if (s.match(/^([aAcChHlLmMqQsStTvVzZ])/)) o[o.length] = { type: e4e, text: RegExp.$1 }, s = s.substr(RegExp.$1.length);
    else {
      if (!s.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
      o[o.length] = { type: P5, text: `${parseFloat(RegExp.$1)}` }, s = s.substr(RegExp.$1.length);
    }
    return o[o.length] = { type: JN, text: "" }, o;
  })(t);
  let n = "BOD", i = 0, a = r[i];
  for (; !$5(a, JN); ) {
    let s = 0;
    const o = [];
    if (n === "BOD") {
      if (a.text !== "M" && a.text !== "m") return oL("M0,0" + t);
      i++, s = hv[a.text], n = a.text;
    } else $5(a, P5) ? s = hv[n] : (i++, s = hv[a.text], n = a.text);
    if (!(i + s < r.length)) throw new Error("Path data ended short");
    for (let l = i; l < i + s; l++) {
      const u = r[l];
      if (!$5(u, P5)) throw new Error("Param not a number: " + n + "," + u.text);
      o[o.length] = +u.text;
    }
    if (typeof hv[n] != "number") throw new Error("Bad segment: " + n);
    {
      const l = { key: n, data: o };
      e.push(l), i += s, a = r[i], n === "M" && (n = "L"), n === "m" && (n = "l");
    }
  }
  return e;
}
function lQ(t) {
  let e = 0, r = 0, n = 0, i = 0;
  const a = [];
  for (const { key: s, data: o } of t) switch (s) {
    case "M":
      a.push({ key: "M", data: [...o] }), [e, r] = o, [n, i] = o;
      break;
    case "m":
      e += o[0], r += o[1], a.push({ key: "M", data: [e, r] }), n = e, i = r;
      break;
    case "L":
      a.push({ key: "L", data: [...o] }), [e, r] = o;
      break;
    case "l":
      e += o[0], r += o[1], a.push({ key: "L", data: [e, r] });
      break;
    case "C":
      a.push({ key: "C", data: [...o] }), e = o[4], r = o[5];
      break;
    case "c": {
      const l = o.map(((u, h) => h % 2 ? u + r : u + e));
      a.push({ key: "C", data: l }), e = l[4], r = l[5];
      break;
    }
    case "Q":
      a.push({ key: "Q", data: [...o] }), e = o[2], r = o[3];
      break;
    case "q": {
      const l = o.map(((u, h) => h % 2 ? u + r : u + e));
      a.push({ key: "Q", data: l }), e = l[2], r = l[3];
      break;
    }
    case "A":
      a.push({ key: "A", data: [...o] }), e = o[5], r = o[6];
      break;
    case "a":
      e += o[5], r += o[6], a.push({ key: "A", data: [o[0], o[1], o[2], o[3], o[4], e, r] });
      break;
    case "H":
      a.push({ key: "H", data: [...o] }), e = o[0];
      break;
    case "h":
      e += o[0], a.push({ key: "H", data: [e] });
      break;
    case "V":
      a.push({ key: "V", data: [...o] }), r = o[0];
      break;
    case "v":
      r += o[0], a.push({ key: "V", data: [r] });
      break;
    case "S":
      a.push({ key: "S", data: [...o] }), e = o[2], r = o[3];
      break;
    case "s": {
      const l = o.map(((u, h) => h % 2 ? u + r : u + e));
      a.push({ key: "S", data: l }), e = l[2], r = l[3];
      break;
    }
    case "T":
      a.push({ key: "T", data: [...o] }), e = o[0], r = o[1];
      break;
    case "t":
      e += o[0], r += o[1], a.push({ key: "T", data: [e, r] });
      break;
    case "Z":
    case "z":
      a.push({ key: "Z", data: [] }), e = n, r = i;
  }
  return a;
}
function cQ(t) {
  const e = [];
  let r = "", n = 0, i = 0, a = 0, s = 0, o = 0, l = 0;
  for (const { key: u, data: h } of t) {
    switch (u) {
      case "M":
        e.push({ key: "M", data: [...h] }), [n, i] = h, [a, s] = h;
        break;
      case "C":
        e.push({ key: "C", data: [...h] }), n = h[4], i = h[5], o = h[2], l = h[3];
        break;
      case "L":
        e.push({ key: "L", data: [...h] }), [n, i] = h;
        break;
      case "H":
        n = h[0], e.push({ key: "L", data: [n, i] });
        break;
      case "V":
        i = h[0], e.push({ key: "L", data: [n, i] });
        break;
      case "S": {
        let f = 0, d = 0;
        r === "C" || r === "S" ? (f = n + (n - o), d = i + (i - l)) : (f = n, d = i), e.push({ key: "C", data: [f, d, ...h] }), o = h[0], l = h[1], n = h[2], i = h[3];
        break;
      }
      case "T": {
        const [f, d] = h;
        let p = 0, g = 0;
        r === "Q" || r === "T" ? (p = n + (n - o), g = i + (i - l)) : (p = n, g = i);
        const m = n + 2 * (p - n) / 3, v = i + 2 * (g - i) / 3, y = f + 2 * (p - f) / 3, b = d + 2 * (g - d) / 3;
        e.push({ key: "C", data: [m, v, y, b, f, d] }), o = p, l = g, n = f, i = d;
        break;
      }
      case "Q": {
        const [f, d, p, g] = h, m = n + 2 * (f - n) / 3, v = i + 2 * (d - i) / 3, y = p + 2 * (f - p) / 3, b = g + 2 * (d - g) / 3;
        e.push({ key: "C", data: [m, v, y, b, p, g] }), o = f, l = d, n = p, i = g;
        break;
      }
      case "A": {
        const f = Math.abs(h[0]), d = Math.abs(h[1]), p = h[2], g = h[3], m = h[4], v = h[5], y = h[6];
        f === 0 || d === 0 ? (e.push({ key: "C", data: [n, i, v, y, v, y] }), n = v, i = y) : (n !== v || i !== y) && (uQ(n, i, v, y, f, d, p, g, m).forEach((function(b) {
          e.push({ key: "C", data: b });
        })), n = v, i = y);
        break;
      }
      case "Z":
        e.push({ key: "Z", data: [] }), n = a, i = s;
    }
    r = u;
  }
  return e;
}
function fp(t, e, r) {
  return [t * Math.cos(r) - e * Math.sin(r), t * Math.sin(r) + e * Math.cos(r)];
}
function uQ(t, e, r, n, i, a, s, o, l, u) {
  const h = (f = s, Math.PI * f / 180);
  var f;
  let d = [], p = 0, g = 0, m = 0, v = 0;
  if (u) [p, g, m, v] = u;
  else {
    [t, e] = fp(t, e, -h), [r, n] = fp(r, n, -h);
    const P = (t - r) / 2, C = (e - n) / 2;
    let I = P * P / (i * i) + C * C / (a * a);
    I > 1 && (I = Math.sqrt(I), i *= I, a *= I);
    const N = i * i, O = a * a, D = N * O - N * C * C - O * P * P, $ = N * C * C + O * P * P, z = (o === l ? -1 : 1) * Math.sqrt(Math.abs(D / $));
    m = z * i * C / a + (t + r) / 2, v = z * -a * P / i + (e + n) / 2, p = Math.asin(parseFloat(((e - v) / a).toFixed(9))), g = Math.asin(parseFloat(((n - v) / a).toFixed(9))), t < m && (p = Math.PI - p), r < m && (g = Math.PI - g), p < 0 && (p = 2 * Math.PI + p), g < 0 && (g = 2 * Math.PI + g), l && p > g && (p -= 2 * Math.PI), !l && g > p && (g -= 2 * Math.PI);
  }
  let y = g - p;
  if (Math.abs(y) > 120 * Math.PI / 180) {
    const P = g, C = r, I = n;
    g = l && g > p ? p + 120 * Math.PI / 180 * 1 : p + 120 * Math.PI / 180 * -1, d = uQ(r = m + i * Math.cos(g), n = v + a * Math.sin(g), C, I, i, a, s, 0, l, [g, P, m, v]);
  }
  y = g - p;
  const b = Math.cos(p), x = Math.sin(p), T = Math.cos(g), E = Math.sin(g), A = Math.tan(y / 4), S = 4 / 3 * i * A, k = 4 / 3 * a * A, _ = [t, e], R = [t + S * x, e - k * b], L = [r + S * E, n - k * T], M = [r, n];
  if (R[0] = 2 * _[0] - R[0], R[1] = 2 * _[1] - R[1], u) return [R, L, M].concat(d);
  {
    d = [R, L, M].concat(d);
    const P = [];
    for (let C = 0; C < d.length; C += 3) {
      const I = fp(d[C][0], d[C][1], h), N = fp(d[C + 1][0], d[C + 1][1], h), O = fp(d[C + 2][0], d[C + 2][1], h);
      P.push([I[0], I[1], N[0], N[1], O[0], O[1]]);
    }
    return P;
  }
}
const t4e = { randOffset: function(t, e) {
  return Yt(t, e);
}, randOffsetWithRange: function(t, e, r) {
  return hb(t, e, r);
}, ellipse: function(t, e, r, n, i) {
  const a = fQ(r, n, i);
  return z_(t, e, i, a).opset;
}, doubleLineOps: function(t, e, r, n, i) {
  return dc(t, e, r, n, i, !0);
} };
function hQ(t, e, r, n, i) {
  return { type: "path", ops: dc(t, e, r, n, i) };
}
function Ay(t, e, r) {
  const n = (t || []).length;
  if (n > 2) {
    const i = [];
    for (let a = 0; a < n - 1; a++) i.push(...dc(t[a][0], t[a][1], t[a + 1][0], t[a + 1][1], r));
    return e && i.push(...dc(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], r)), { type: "path", ops: i };
  }
  return n === 2 ? hQ(t[0][0], t[0][1], t[1][0], t[1][1], r) : { type: "path", ops: [] };
}
function r4e(t, e, r, n, i) {
  return (function(a, s) {
    return Ay(a, !0, s);
  })([[t, e], [t + r, e], [t + r, e + n], [t, e + n]], i);
}
function eD(t, e) {
  if (t.length) {
    const r = typeof t[0][0] == "number" ? [t] : t, n = fv(r[0], 1 * (1 + 0.2 * e.roughness), e), i = e.disableMultiStroke ? [] : fv(r[0], 1.5 * (1 + 0.22 * e.roughness), nD(e));
    for (let a = 1; a < r.length; a++) {
      const s = r[a];
      if (s.length) {
        const o = fv(s, 1 * (1 + 0.2 * e.roughness), e), l = e.disableMultiStroke ? [] : fv(s, 1.5 * (1 + 0.22 * e.roughness), nD(e));
        for (const u of o) u.op !== "move" && n.push(u);
        for (const u of l) u.op !== "move" && i.push(u);
      }
    }
    return { type: "path", ops: n.concat(i) };
  }
  return { type: "path", ops: [] };
}
function fQ(t, e, r) {
  const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2)), i = Math.ceil(Math.max(r.curveStepCount, r.curveStepCount / Math.sqrt(200) * n)), a = 2 * Math.PI / i;
  let s = Math.abs(t / 2), o = Math.abs(e / 2);
  const l = 1 - r.curveFitting;
  return s += Yt(s * l, r), o += Yt(o * l, r), { increment: a, rx: s, ry: o };
}
function z_(t, e, r, n) {
  const [i, a] = iD(n.increment, t, e, n.rx, n.ry, 1, n.increment * hb(0.1, hb(0.4, 1, r), r), r);
  let s = fb(i, null, r);
  if (!r.disableMultiStroke && r.roughness !== 0) {
    const [o] = iD(n.increment, t, e, n.rx, n.ry, 1.5, 0, r), l = fb(o, null, r);
    s = s.concat(l);
  }
  return { estimatedPoints: a, opset: { type: "path", ops: s } };
}
function tD(t, e, r, n, i, a, s, o, l) {
  const u = t, h = e;
  let f = Math.abs(r / 2), d = Math.abs(n / 2);
  f += Yt(0.01 * f, l), d += Yt(0.01 * d, l);
  let p = i, g = a;
  for (; p < 0; ) p += 2 * Math.PI, g += 2 * Math.PI;
  g - p > 2 * Math.PI && (p = 0, g = 2 * Math.PI);
  const m = 2 * Math.PI / l.curveStepCount, v = Math.min(m / 2, (g - p) / 2), y = aD(v, u, h, f, d, p, g, 1, l);
  if (!l.disableMultiStroke) {
    const b = aD(v, u, h, f, d, p, g, 1.5, l);
    y.push(...b);
  }
  return s && (o ? y.push(...dc(u, h, u + f * Math.cos(p), h + d * Math.sin(p), l), ...dc(u, h, u + f * Math.cos(g), h + d * Math.sin(g), l)) : y.push({ op: "lineTo", data: [u, h] }, { op: "lineTo", data: [u + f * Math.cos(p), h + d * Math.sin(p)] })), { type: "path", ops: y };
}
function rD(t, e) {
  const r = cQ(lQ(oL(t))), n = [];
  let i = [0, 0], a = [0, 0];
  for (const { key: s, data: o } of r) switch (s) {
    case "M":
      a = [o[0], o[1]], i = [o[0], o[1]];
      break;
    case "L":
      n.push(...dc(a[0], a[1], o[0], o[1], e)), a = [o[0], o[1]];
      break;
    case "C": {
      const [l, u, h, f, d, p] = o;
      n.push(...n4e(l, u, h, f, d, p, a, e)), a = [d, p];
      break;
    }
    case "Z":
      n.push(...dc(a[0], a[1], i[0], i[1], e)), a = [i[0], i[1]];
  }
  return { type: "path", ops: n };
}
function B5(t, e) {
  const r = [];
  for (const n of t) if (n.length) {
    const i = e.maxRandomnessOffset || 0, a = n.length;
    if (a > 2) {
      r.push({ op: "move", data: [n[0][0] + Yt(i, e), n[0][1] + Yt(i, e)] });
      for (let s = 1; s < a; s++) r.push({ op: "lineTo", data: [n[s][0] + Yt(i, e), n[s][1] + Yt(i, e)] });
    }
  }
  return { type: "fillPath", ops: r };
}
function Qh(t, e) {
  return (function(r, n) {
    let i = r.fillStyle || "hachure";
    if (!ra[i]) switch (i) {
      case "zigzag":
        ra[i] || (ra[i] = new Xxe(n));
        break;
      case "cross-hatch":
        ra[i] || (ra[i] = new jxe(n));
        break;
      case "dots":
        ra[i] || (ra[i] = new Kxe(n));
        break;
      case "dashed":
        ra[i] || (ra[i] = new Zxe(n));
        break;
      case "zigzag-line":
        ra[i] || (ra[i] = new Qxe(n));
        break;
      default:
        i = "hachure", ra[i] || (ra[i] = new sL(n));
    }
    return ra[i];
  })(e, t4e).fillPolygons(t, e);
}
function nD(t) {
  const e = Object.assign({}, t);
  return e.randomizer = void 0, t.seed && (e.seed = t.seed + 1), e;
}
function dQ(t) {
  return t.randomizer || (t.randomizer = new Jxe(t.seed || 0)), t.randomizer.next();
}
function hb(t, e, r, n = 1) {
  return r.roughness * n * (dQ(r) * (e - t) + t);
}
function Yt(t, e, r = 1) {
  return hb(-t, t, e, r);
}
function dc(t, e, r, n, i, a = !1) {
  const s = a ? i.disableMultiStrokeFill : i.disableMultiStroke, o = q_(t, e, r, n, i, !0, !1);
  if (s) return o;
  const l = q_(t, e, r, n, i, !0, !0);
  return o.concat(l);
}
function q_(t, e, r, n, i, a, s) {
  const o = Math.pow(t - r, 2) + Math.pow(e - n, 2), l = Math.sqrt(o);
  let u = 1;
  u = l < 200 ? 1 : l > 500 ? 0.4 : -16668e-7 * l + 1.233334;
  let h = i.maxRandomnessOffset || 0;
  h * h * 100 > o && (h = l / 10);
  const f = h / 2, d = 0.2 + 0.2 * dQ(i);
  let p = i.bowing * i.maxRandomnessOffset * (n - e) / 200, g = i.bowing * i.maxRandomnessOffset * (t - r) / 200;
  p = Yt(p, i, u), g = Yt(g, i, u);
  const m = [], v = () => Yt(f, i, u), y = () => Yt(h, i, u), b = i.preserveVertices;
  return s ? m.push({ op: "move", data: [t + (b ? 0 : v()), e + (b ? 0 : v())] }) : m.push({ op: "move", data: [t + (b ? 0 : Yt(h, i, u)), e + (b ? 0 : Yt(h, i, u))] }), s ? m.push({ op: "bcurveTo", data: [p + t + (r - t) * d + v(), g + e + (n - e) * d + v(), p + t + 2 * (r - t) * d + v(), g + e + 2 * (n - e) * d + v(), r + (b ? 0 : v()), n + (b ? 0 : v())] }) : m.push({ op: "bcurveTo", data: [p + t + (r - t) * d + y(), g + e + (n - e) * d + y(), p + t + 2 * (r - t) * d + y(), g + e + 2 * (n - e) * d + y(), r + (b ? 0 : y()), n + (b ? 0 : y())] }), m;
}
function fv(t, e, r) {
  if (!t.length) return [];
  const n = [];
  n.push([t[0][0] + Yt(e, r), t[0][1] + Yt(e, r)]), n.push([t[0][0] + Yt(e, r), t[0][1] + Yt(e, r)]);
  for (let i = 1; i < t.length; i++) n.push([t[i][0] + Yt(e, r), t[i][1] + Yt(e, r)]), i === t.length - 1 && n.push([t[i][0] + Yt(e, r), t[i][1] + Yt(e, r)]);
  return fb(n, null, r);
}
function fb(t, e, r) {
  const n = t.length, i = [];
  if (n > 3) {
    const a = [], s = 1 - r.curveTightness;
    i.push({ op: "move", data: [t[1][0], t[1][1]] });
    for (let o = 1; o + 2 < n; o++) {
      const l = t[o];
      a[0] = [l[0], l[1]], a[1] = [l[0] + (s * t[o + 1][0] - s * t[o - 1][0]) / 6, l[1] + (s * t[o + 1][1] - s * t[o - 1][1]) / 6], a[2] = [t[o + 1][0] + (s * t[o][0] - s * t[o + 2][0]) / 6, t[o + 1][1] + (s * t[o][1] - s * t[o + 2][1]) / 6], a[3] = [t[o + 1][0], t[o + 1][1]], i.push({ op: "bcurveTo", data: [a[1][0], a[1][1], a[2][0], a[2][1], a[3][0], a[3][1]] });
    }
  } else n === 3 ? (i.push({ op: "move", data: [t[1][0], t[1][1]] }), i.push({ op: "bcurveTo", data: [t[1][0], t[1][1], t[2][0], t[2][1], t[2][0], t[2][1]] })) : n === 2 && i.push(...q_(t[0][0], t[0][1], t[1][0], t[1][1], r, !0, !0));
  return i;
}
function iD(t, e, r, n, i, a, s, o) {
  const l = [], u = [];
  if (o.roughness === 0) {
    t /= 4, u.push([e + n * Math.cos(-t), r + i * Math.sin(-t)]);
    for (let h = 0; h <= 2 * Math.PI; h += t) {
      const f = [e + n * Math.cos(h), r + i * Math.sin(h)];
      l.push(f), u.push(f);
    }
    u.push([e + n * Math.cos(0), r + i * Math.sin(0)]), u.push([e + n * Math.cos(t), r + i * Math.sin(t)]);
  } else {
    const h = Yt(0.5, o) - Math.PI / 2;
    u.push([Yt(a, o) + e + 0.9 * n * Math.cos(h - t), Yt(a, o) + r + 0.9 * i * Math.sin(h - t)]);
    const f = 2 * Math.PI + h - 0.01;
    for (let d = h; d < f; d += t) {
      const p = [Yt(a, o) + e + n * Math.cos(d), Yt(a, o) + r + i * Math.sin(d)];
      l.push(p), u.push(p);
    }
    u.push([Yt(a, o) + e + n * Math.cos(h + 2 * Math.PI + 0.5 * s), Yt(a, o) + r + i * Math.sin(h + 2 * Math.PI + 0.5 * s)]), u.push([Yt(a, o) + e + 0.98 * n * Math.cos(h + s), Yt(a, o) + r + 0.98 * i * Math.sin(h + s)]), u.push([Yt(a, o) + e + 0.9 * n * Math.cos(h + 0.5 * s), Yt(a, o) + r + 0.9 * i * Math.sin(h + 0.5 * s)]);
  }
  return [u, l];
}
function aD(t, e, r, n, i, a, s, o, l) {
  const u = a + Yt(0.1, l), h = [];
  h.push([Yt(o, l) + e + 0.9 * n * Math.cos(u - t), Yt(o, l) + r + 0.9 * i * Math.sin(u - t)]);
  for (let f = u; f <= s; f += t) h.push([Yt(o, l) + e + n * Math.cos(f), Yt(o, l) + r + i * Math.sin(f)]);
  return h.push([e + n * Math.cos(s), r + i * Math.sin(s)]), h.push([e + n * Math.cos(s), r + i * Math.sin(s)]), fb(h, null, l);
}
function n4e(t, e, r, n, i, a, s, o) {
  const l = [], u = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];
  let h = [0, 0];
  const f = o.disableMultiStroke ? 1 : 2, d = o.preserveVertices;
  for (let p = 0; p < f; p++) p === 0 ? l.push({ op: "move", data: [s[0], s[1]] }) : l.push({ op: "move", data: [s[0] + (d ? 0 : Yt(u[0], o)), s[1] + (d ? 0 : Yt(u[0], o))] }), h = d ? [i, a] : [i + Yt(u[p], o), a + Yt(u[p], o)], l.push({ op: "bcurveTo", data: [t + Yt(u[p], o), e + Yt(u[p], o), r + Yt(u[p], o), n + Yt(u[p], o), h[0], h[1]] });
  return l;
}
function dp(t) {
  return [...t];
}
function sD(t, e = 0) {
  const r = t.length;
  if (r < 3) throw new Error("A curve must have at least three points.");
  const n = [];
  if (r === 3) n.push(dp(t[0]), dp(t[1]), dp(t[2]), dp(t[2]));
  else {
    const i = [];
    i.push(t[0], t[0]);
    for (let o = 1; o < t.length; o++) i.push(t[o]), o === t.length - 1 && i.push(t[o]);
    const a = [], s = 1 - e;
    n.push(dp(i[0]));
    for (let o = 1; o + 2 < i.length; o++) {
      const l = i[o];
      a[0] = [l[0], l[1]], a[1] = [l[0] + (s * i[o + 1][0] - s * i[o - 1][0]) / 6, l[1] + (s * i[o + 1][1] - s * i[o - 1][1]) / 6], a[2] = [i[o + 1][0] + (s * i[o][0] - s * i[o + 2][0]) / 6, i[o + 1][1] + (s * i[o][1] - s * i[o + 2][1]) / 6], a[3] = [i[o + 1][0], i[o + 1][1]], n.push(a[1], a[2], a[3]);
    }
  }
  return n;
}
function Ly(t, e) {
  return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
}
function i4e(t, e, r) {
  const n = Ly(e, r);
  if (n === 0) return Ly(t, e);
  let i = ((t[0] - e[0]) * (r[0] - e[0]) + (t[1] - e[1]) * (r[1] - e[1])) / n;
  return i = Math.max(0, Math.min(1, i)), Ly(t, yu(e, r, i));
}
function yu(t, e, r) {
  return [t[0] + (e[0] - t[0]) * r, t[1] + (e[1] - t[1]) * r];
}
function G_(t, e, r, n) {
  const i = n || [];
  if ((function(o, l) {
    const u = o[l + 0], h = o[l + 1], f = o[l + 2], d = o[l + 3];
    let p = 3 * h[0] - 2 * u[0] - d[0];
    p *= p;
    let g = 3 * h[1] - 2 * u[1] - d[1];
    g *= g;
    let m = 3 * f[0] - 2 * d[0] - u[0];
    m *= m;
    let v = 3 * f[1] - 2 * d[1] - u[1];
    return v *= v, p < m && (p = m), g < v && (g = v), p + g;
  })(t, e) < r) {
    const o = t[e + 0];
    i.length ? (a = i[i.length - 1], s = o, Math.sqrt(Ly(a, s)) > 1 && i.push(o)) : i.push(o), i.push(t[e + 3]);
  } else {
    const l = t[e + 0], u = t[e + 1], h = t[e + 2], f = t[e + 3], d = yu(l, u, 0.5), p = yu(u, h, 0.5), g = yu(h, f, 0.5), m = yu(d, p, 0.5), v = yu(p, g, 0.5), y = yu(m, v, 0.5);
    G_([l, d, m, y], 0, r, i), G_([y, v, g, f], 0, r, i);
  }
  var a, s;
  return i;
}
function a4e(t, e) {
  return db(t, 0, t.length, e);
}
function db(t, e, r, n, i) {
  const a = i || [], s = t[e], o = t[r - 1];
  let l = 0, u = 1;
  for (let h = e + 1; h < r - 1; ++h) {
    const f = i4e(t[h], s, o);
    f > l && (l = f, u = h);
  }
  return Math.sqrt(l) > n ? (db(t, e, u + 1, n, a), db(t, u, r, n, a)) : (a.length || a.push(s), a.push(o)), a;
}
function F5(t, e = 0.15, r) {
  const n = [], i = (t.length - 1) / 3;
  for (let a = 0; a < i; a++)
    G_(t, 3 * a, e, n);
  return r && r > 0 ? db(n, 0, n.length, r) : n;
}
const wa = "none";
class pb {
  constructor(e) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: !1, disableMultiStrokeFill: !1, preserveVertices: !1, fillShapeRoughnessGain: 0.8 }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, r, n) {
    return { shape: e, sets: r || [], options: n || this.defaultOptions };
  }
  line(e, r, n, i, a) {
    const s = this._o(a);
    return this._d("line", [hQ(e, r, n, i, s)], s);
  }
  rectangle(e, r, n, i, a) {
    const s = this._o(a), o = [], l = r4e(e, r, n, i, s);
    if (s.fill) {
      const u = [[e, r], [e + n, r], [e + n, r + i], [e, r + i]];
      s.fillStyle === "solid" ? o.push(B5([u], s)) : o.push(Qh([u], s));
    }
    return s.stroke !== wa && o.push(l), this._d("rectangle", o, s);
  }
  ellipse(e, r, n, i, a) {
    const s = this._o(a), o = [], l = fQ(n, i, s), u = z_(e, r, s, l);
    if (s.fill) if (s.fillStyle === "solid") {
      const h = z_(e, r, s, l).opset;
      h.type = "fillPath", o.push(h);
    } else o.push(Qh([u.estimatedPoints], s));
    return s.stroke !== wa && o.push(u.opset), this._d("ellipse", o, s);
  }
  circle(e, r, n, i) {
    const a = this.ellipse(e, r, n, n, i);
    return a.shape = "circle", a;
  }
  linearPath(e, r) {
    const n = this._o(r);
    return this._d("linearPath", [Ay(e, !1, n)], n);
  }
  arc(e, r, n, i, a, s, o = !1, l) {
    const u = this._o(l), h = [], f = tD(e, r, n, i, a, s, o, !0, u);
    if (o && u.fill) if (u.fillStyle === "solid") {
      const d = Object.assign({}, u);
      d.disableMultiStroke = !0;
      const p = tD(e, r, n, i, a, s, !0, !1, d);
      p.type = "fillPath", h.push(p);
    } else h.push((function(d, p, g, m, v, y, b) {
      const x = d, T = p;
      let E = Math.abs(g / 2), A = Math.abs(m / 2);
      E += Yt(0.01 * E, b), A += Yt(0.01 * A, b);
      let S = v, k = y;
      for (; S < 0; ) S += 2 * Math.PI, k += 2 * Math.PI;
      k - S > 2 * Math.PI && (S = 0, k = 2 * Math.PI);
      const _ = (k - S) / b.curveStepCount, R = [];
      for (let L = S; L <= k; L += _) R.push([x + E * Math.cos(L), T + A * Math.sin(L)]);
      return R.push([x + E * Math.cos(k), T + A * Math.sin(k)]), R.push([x, T]), Qh([R], b);
    })(e, r, n, i, a, s, u));
    return u.stroke !== wa && h.push(f), this._d("arc", h, u);
  }
  curve(e, r) {
    const n = this._o(r), i = [], a = eD(e, n);
    if (n.fill && n.fill !== wa) if (n.fillStyle === "solid") {
      const s = eD(e, Object.assign(Object.assign({}, n), { disableMultiStroke: !0, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(s.ops) });
    } else {
      const s = [], o = e;
      if (o.length) {
        const l = typeof o[0][0] == "number" ? [o] : o;
        for (const u of l) u.length < 3 ? s.push(...u) : u.length === 3 ? s.push(...F5(sD([u[0], u[0], u[1], u[2]]), 10, (1 + n.roughness) / 2)) : s.push(...F5(sD(u), 10, (1 + n.roughness) / 2));
      }
      s.length && i.push(Qh([s], n));
    }
    return n.stroke !== wa && i.push(a), this._d("curve", i, n);
  }
  polygon(e, r) {
    const n = this._o(r), i = [], a = Ay(e, !0, n);
    return n.fill && (n.fillStyle === "solid" ? i.push(B5([e], n)) : i.push(Qh([e], n))), n.stroke !== wa && i.push(a), this._d("polygon", i, n);
  }
  path(e, r) {
    const n = this._o(r), i = [];
    if (!e) return this._d("path", i, n);
    e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const a = n.fill && n.fill !== "transparent" && n.fill !== wa, s = n.stroke !== wa, o = !!(n.simplification && n.simplification < 1), l = (function(h, f, d) {
      const p = cQ(lQ(oL(h))), g = [];
      let m = [], v = [0, 0], y = [];
      const b = () => {
        y.length >= 4 && m.push(...F5(y, f)), y = [];
      }, x = () => {
        b(), m.length && (g.push(m), m = []);
      };
      for (const { key: E, data: A } of p) switch (E) {
        case "M":
          x(), v = [A[0], A[1]], m.push(v);
          break;
        case "L":
          b(), m.push([A[0], A[1]]);
          break;
        case "C":
          if (!y.length) {
            const S = m.length ? m[m.length - 1] : v;
            y.push([S[0], S[1]]);
          }
          y.push([A[0], A[1]]), y.push([A[2], A[3]]), y.push([A[4], A[5]]);
          break;
        case "Z":
          b(), m.push([v[0], v[1]]);
      }
      if (x(), !d) return g;
      const T = [];
      for (const E of g) {
        const A = a4e(E, d);
        A.length && T.push(A);
      }
      return T;
    })(e, 1, o ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2), u = rD(e, n);
    if (a) if (n.fillStyle === "solid") if (l.length === 1) {
      const h = rD(e, Object.assign(Object.assign({}, n), { disableMultiStroke: !0, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      i.push({ type: "fillPath", ops: this._mergedShape(h.ops) });
    } else i.push(B5(l, n));
    else i.push(Qh(l, n));
    return s && (o ? l.forEach(((h) => {
      i.push(Ay(h, !1, n));
    })) : i.push(u)), this._d("path", i, n);
  }
  opsToPath(e, r) {
    let n = "";
    for (const i of e.ops) {
      const a = typeof r == "number" && r >= 0 ? i.data.map(((s) => +s.toFixed(r))) : i.data;
      switch (i.op) {
        case "move":
          n += `M${a[0]} ${a[1]} `;
          break;
        case "bcurveTo":
          n += `C${a[0]} ${a[1]}, ${a[2]} ${a[3]}, ${a[4]} ${a[5]} `;
          break;
        case "lineTo":
          n += `L${a[0]} ${a[1]} `;
      }
    }
    return n.trim();
  }
  toPaths(e) {
    const r = e.sets || [], n = e.options || this.defaultOptions, i = [];
    for (const a of r) {
      let s = null;
      switch (a.type) {
        case "path":
          s = { d: this.opsToPath(a), stroke: n.stroke, strokeWidth: n.strokeWidth, fill: wa };
          break;
        case "fillPath":
          s = { d: this.opsToPath(a), stroke: wa, strokeWidth: 0, fill: n.fill || wa };
          break;
        case "fillSketch":
          s = this.fillSketch(a, n);
      }
      s && i.push(s);
    }
    return i;
  }
  fillSketch(e, r) {
    let n = r.fillWeight;
    return n < 0 && (n = r.strokeWidth / 2), { d: this.opsToPath(e), stroke: r.fill || wa, strokeWidth: n, fill: wa };
  }
  _mergedShape(e) {
    return e.filter(((r, n) => n === 0 || r.op !== "move"));
  }
}
class s4e {
  constructor(e, r) {
    this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new pb(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.ctx, a = e.options.fixedDecimalPlaceDigits;
    for (const s of r) switch (s.type) {
      case "path":
        i.save(), i.strokeStyle = n.stroke === "none" ? "transparent" : n.stroke, i.lineWidth = n.strokeWidth, n.strokeLineDash && i.setLineDash(n.strokeLineDash), n.strokeLineDashOffset && (i.lineDashOffset = n.strokeLineDashOffset), this._drawToContext(i, s, a), i.restore();
        break;
      case "fillPath": {
        i.save(), i.fillStyle = n.fill || "";
        const o = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
        this._drawToContext(i, s, a, o), i.restore();
        break;
      }
      case "fillSketch":
        this.fillSketch(i, s, n);
    }
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2), e.save(), n.fillLineDash && e.setLineDash(n.fillLineDash), n.fillLineDashOffset && (e.lineDashOffset = n.fillLineDashOffset), e.strokeStyle = n.fill || "", e.lineWidth = i, this._drawToContext(e, r, n.fixedDecimalPlaceDigits), e.restore();
  }
  _drawToContext(e, r, n, i = "nonzero") {
    e.beginPath();
    for (const a of r.ops) {
      const s = typeof n == "number" && n >= 0 ? a.data.map(((o) => +o.toFixed(n))) : a.data;
      switch (a.op) {
        case "move":
          e.moveTo(s[0], s[1]);
          break;
        case "bcurveTo":
          e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
          break;
        case "lineTo":
          e.lineTo(s[0], s[1]);
      }
    }
    r.type === "fillPath" ? e.fill(i) : e.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(e, r, n, i, a) {
    const s = this.gen.line(e, r, n, i, a);
    return this.draw(s), s;
  }
  rectangle(e, r, n, i, a) {
    const s = this.gen.rectangle(e, r, n, i, a);
    return this.draw(s), s;
  }
  ellipse(e, r, n, i, a) {
    const s = this.gen.ellipse(e, r, n, i, a);
    return this.draw(s), s;
  }
  circle(e, r, n, i) {
    const a = this.gen.circle(e, r, n, i);
    return this.draw(a), a;
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n), n;
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n), n;
  }
  arc(e, r, n, i, a, s, o = !1, l) {
    const u = this.gen.arc(e, r, n, i, a, s, o, l);
    return this.draw(u), u;
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n), n;
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n), n;
  }
}
const dv = "http://www.w3.org/2000/svg";
class o4e {
  constructor(e, r) {
    this.svg = e, this.gen = new pb(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), i = this.svg.ownerDocument || window.document, a = i.createElementNS(dv, "g"), s = e.options.fixedDecimalPlaceDigits;
    for (const o of r) {
      let l = null;
      switch (o.type) {
        case "path":
          l = i.createElementNS(dv, "path"), l.setAttribute("d", this.opsToPath(o, s)), l.setAttribute("stroke", n.stroke), l.setAttribute("stroke-width", n.strokeWidth + ""), l.setAttribute("fill", "none"), n.strokeLineDash && l.setAttribute("stroke-dasharray", n.strokeLineDash.join(" ").trim()), n.strokeLineDashOffset && l.setAttribute("stroke-dashoffset", `${n.strokeLineDashOffset}`);
          break;
        case "fillPath":
          l = i.createElementNS(dv, "path"), l.setAttribute("d", this.opsToPath(o, s)), l.setAttribute("stroke", "none"), l.setAttribute("stroke-width", "0"), l.setAttribute("fill", n.fill || ""), e.shape !== "curve" && e.shape !== "polygon" || l.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          l = this.fillSketch(i, o, n);
      }
      l && a.appendChild(l);
    }
    return a;
  }
  fillSketch(e, r, n) {
    let i = n.fillWeight;
    i < 0 && (i = n.strokeWidth / 2);
    const a = e.createElementNS(dv, "path");
    return a.setAttribute("d", this.opsToPath(r, n.fixedDecimalPlaceDigits)), a.setAttribute("stroke", n.fill || ""), a.setAttribute("stroke-width", i + ""), a.setAttribute("fill", "none"), n.fillLineDash && a.setAttribute("stroke-dasharray", n.fillLineDash.join(" ").trim()), n.fillLineDashOffset && a.setAttribute("stroke-dashoffset", `${n.fillLineDashOffset}`), a;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, r) {
    return this.gen.opsToPath(e, r);
  }
  line(e, r, n, i, a) {
    const s = this.gen.line(e, r, n, i, a);
    return this.draw(s);
  }
  rectangle(e, r, n, i, a) {
    const s = this.gen.rectangle(e, r, n, i, a);
    return this.draw(s);
  }
  ellipse(e, r, n, i, a) {
    const s = this.gen.ellipse(e, r, n, i, a);
    return this.draw(s);
  }
  circle(e, r, n, i) {
    const a = this.gen.circle(e, r, n, i);
    return this.draw(a);
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n);
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n);
  }
  arc(e, r, n, i, a, s, o = !1, l) {
    const u = this.gen.arc(e, r, n, i, a, s, o, l);
    return this.draw(u);
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n);
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n);
  }
}
var Lt = { canvas: (t, e) => new s4e(t, e), svg: (t, e) => new o4e(t, e), generator: (t) => new pb(t), newSeed: () => pb.newSeed() }, Ht = /* @__PURE__ */ w(async (t, e, r) => {
  let n;
  const i = e.useHtmlLabels || Nr(Te()?.htmlLabels);
  r ? n = r : n = "node default";
  const a = t.insert("g").attr("class", n).attr("id", e.domId || e.id), s = a.insert("g").attr("class", "label").attr("style", Ai(e.labelStyle));
  let o;
  e.label === void 0 ? o = "" : o = typeof e.label == "string" ? e.label : e.label[0];
  const l = await Na(s, pr(mo(o), Te()), {
    useHtmlLabels: i,
    width: e.width || Te().flowchart?.wrappingWidth,
    // @ts-expect-error -- This is currently not used. Should this be `classes` instead?
    cssClasses: "markdown-node-label",
    style: e.labelStyle,
    addSvgBackground: !!e.icon || !!e.img
  });
  let u = l.getBBox();
  const h = (e?.padding ?? 0) / 2;
  if (i) {
    const f = l.children[0], d = Qe(l), p = f.getElementsByTagName("img");
    if (p) {
      const g = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...p].map(
          (m) => new Promise((v) => {
            function y() {
              if (m.style.display = "flex", m.style.flexDirection = "column", g) {
                const b = Te().fontSize ? Te().fontSize : window.getComputedStyle(document.body).fontSize, x = 5, [T = fr.fontSize] = Sh(b), E = T * x + "px";
                m.style.minWidth = E, m.style.maxWidth = E;
              } else
                m.style.width = "100%";
              v(m);
            }
            w(y, "setupImage"), setTimeout(() => {
              m.complete && y();
            }), m.addEventListener("error", y), m.addEventListener("load", y);
          })
        )
      );
    }
    u = f.getBoundingClientRect(), d.attr("width", u.width), d.attr("height", u.height);
  }
  return i ? s.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")") : s.attr("transform", "translate(0, " + -u.height / 2 + ")"), e.centerLabel && s.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"), s.insert("rect", ":first-child"), { shapeSvg: a, bbox: u, halfPadding: h, label: s };
}, "labelHelper"), z5 = /* @__PURE__ */ w(async (t, e, r) => {
  const n = r.useHtmlLabels || Nr(Te()?.flowchart?.htmlLabels), i = t.insert("g").attr("class", "label").attr("style", r.labelStyle || ""), a = await Na(i, pr(mo(e), Te()), {
    useHtmlLabels: n,
    width: r.width || Te()?.flowchart?.wrappingWidth,
    style: r.labelStyle,
    addSvgBackground: !!r.icon || !!r.img
  });
  let s = a.getBBox();
  const o = r.padding / 2;
  if (Nr(Te()?.flowchart?.htmlLabels)) {
    const l = a.children[0], u = Qe(a);
    s = l.getBoundingClientRect(), u.attr("width", s.width), u.attr("height", s.height);
  }
  return n ? i.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")") : i.attr("transform", "translate(0, " + -s.height / 2 + ")"), r.centerLabel && i.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), i.insert("rect", ":first-child"), { shapeSvg: t, bbox: s, halfPadding: o, label: i };
}, "insertLabel"), It = /* @__PURE__ */ w((t, e) => {
  const r = e.node().getBBox();
  t.width = r.width, t.height = r.height;
}, "updateNodeBounds"), zt = /* @__PURE__ */ w((t, e) => (t.look === "handDrawn" ? "rough-node" : "node") + " " + t.cssClasses + " " + (e || ""), "getNodeClasses");
function or(t) {
  const e = t.map((r, n) => `${n === 0 ? "M" : "L"}${r.x},${r.y}`);
  return e.push("Z"), e.join(" ");
}
w(or, "createPathFromPoints");
function pc(t, e, r, n, i, a) {
  const s = [], l = r - t, u = n - e, h = l / a, f = 2 * Math.PI / h, d = e + u / 2;
  for (let p = 0; p <= 50; p++) {
    const g = p / 50, m = t + g * l, v = d + i * Math.sin(f * (m - t));
    s.push({ x: m, y: v });
  }
  return s;
}
w(pc, "generateFullSineWavePoints");
function d1(t, e, r, n, i, a) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let f = 0; f < n; f++) {
    const d = o + f * h, p = t + r * Math.cos(d), g = e + r * Math.sin(d);
    s.push({ x: -p, y: -g });
  }
  return s;
}
w(d1, "generateCirclePoints");
var l4e = /* @__PURE__ */ w((t, e) => {
  var r = t.x, n = t.y, i = e.x - r, a = e.y - n, s = t.width / 2, o = t.height / 2, l, u;
  return Math.abs(a) * s > Math.abs(i) * o ? (a < 0 && (o = -o), l = a === 0 ? 0 : o * i / a, u = o) : (i < 0 && (s = -s), l = s, u = i === 0 ? 0 : s * a / i), { x: r + l, y: n + u };
}, "intersectRect"), R0 = l4e;
function pQ(t, e) {
  e && t.attr("style", e);
}
w(pQ, "applyStyle");
async function gQ(t) {
  const e = Qe(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), r = e.append("xhtml:div"), n = Te();
  let i = t.label;
  t.label && dn(t.label) && (i = await Z1(t.label.replace(at.lineBreakRegex, `
`), n));
  const s = '<span class="' + (t.isNode ? "nodeLabel" : "edgeLabel") + '" ' + (t.labelStyle ? 'style="' + t.labelStyle + '"' : "") + // codeql [js/html-constructed-from-input] : false positive
  ">" + i + "</span>";
  return r.html(pr(s, n)), pQ(r, t.labelStyle), r.style("display", "inline-block"), r.style("padding-right", "1px"), r.style("white-space", "nowrap"), r.attr("xmlns", "http://www.w3.org/1999/xhtml"), e.node();
}
w(gQ, "addHtmlLabel");
var c4e = /* @__PURE__ */ w(async (t, e, r, n) => {
  let i = t || "";
  if (typeof i == "object" && (i = i[0]), Nr(Te().flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), ae.info("vertexText" + i);
    const a = {
      isNode: n,
      label: mo(i).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (o) => `<i class='${o.replace(":", " ")}'></i>`
      ),
      labelStyle: e && e.replace("fill:", "color:")
    };
    return await gQ(a);
  } else {
    const a = document.createElementNS("http://www.w3.org/2000/svg", "text");
    a.setAttribute("style", e.replace("color:", "fill:"));
    let s = [];
    typeof i == "string" ? s = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? s = i : s = [];
    for (const o of s) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), l.setAttribute("dy", "1em"), l.setAttribute("x", "0"), r ? l.setAttribute("class", "title-row") : l.setAttribute("class", "row"), l.textContent = o.trim(), a.appendChild(l);
    }
    return a;
  }
}, "createLabel"), Mu = c4e, Bc = /* @__PURE__ */ w((t, e, r, n, i) => [
  "M",
  t + i,
  e,
  // Move to the first point
  "H",
  t + r - i,
  // Draw horizontal line to the beginning of the right corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t + r,
  e + i,
  // Draw arc to the right top corner
  "V",
  e + n - i,
  // Draw vertical line down to the beginning of the right bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t + r - i,
  e + n,
  // Draw arc to the right bottom corner
  "H",
  t + i,
  // Draw horizontal line to the beginning of the left bottom corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t,
  e + n - i,
  // Draw arc to the left bottom corner
  "V",
  e + i,
  // Draw vertical line up to the beginning of the left top corner
  "A",
  i,
  i,
  0,
  0,
  1,
  t + i,
  e,
  // Draw arc to the left top corner
  "Z"
  // Close the path
].join(" "), "createRoundedRectPathD"), mQ = /* @__PURE__ */ w(async (t, e) => {
  ae.info("Creating subgraph rect for ", e.id, e);
  const r = Te(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: a, clusterBorder: s } = n, { labelStyles: o, nodeStyles: l, borderStyles: u, backgroundStyles: h } = kt(e), f = t.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), d = Nr(r.flowchart.htmlLabels), p = f.insert("g").attr("class", "cluster-label "), g = await Na(p, e.label, {
    style: e.labelStyle,
    useHtmlLabels: d,
    isNode: !0
  });
  let m = g.getBBox();
  if (Nr(r.flowchart.htmlLabels)) {
    const S = g.children[0], k = Qe(g);
    m = S.getBoundingClientRect(), k.attr("width", m.width), k.attr("height", m.height);
  }
  const v = e.width <= m.width + e.padding ? m.width + e.padding : e.width;
  e.width <= m.width + e.padding ? e.diff = (v - e.width) / 2 - e.padding : e.diff = -e.padding;
  const y = e.height, b = e.x - v / 2, x = e.y - y / 2;
  ae.trace("Data ", e, JSON.stringify(e));
  let T;
  if (e.look === "handDrawn") {
    const S = Lt.svg(f), k = Rt(e, {
      roughness: 0.7,
      fill: a,
      // fill: 'red',
      stroke: s,
      fillWeight: 3,
      seed: i
    }), _ = S.path(Bc(b, x, v, y, 0), k);
    T = f.insert(() => (ae.debug("Rough node insert CXC", _), _), ":first-child"), T.select("path:nth-child(2)").attr("style", u.join(";")), T.select("path").attr("style", h.join(";").replace("fill", "stroke"));
  } else
    T = f.insert("rect", ":first-child"), T.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", b).attr("y", x).attr("width", v).attr("height", y);
  const { subGraphTitleTopMargin: E } = nm(r);
  if (p.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - m.width / 2}, ${e.y - e.height / 2 + E})`
  ), o) {
    const S = p.select("span");
    S && S.attr("style", o);
  }
  const A = T.node().getBBox();
  return e.offsetX = 0, e.width = A.width, e.height = A.height, e.offsetY = m.height - e.padding / 2, e.intersect = function(S) {
    return R0(e, S);
  }, { cluster: f, labelBBox: m };
}, "rect"), u4e = /* @__PURE__ */ w((t, e) => {
  const r = t.insert("g").attr("class", "note-cluster").attr("id", e.id), n = r.insert("rect", ":first-child"), i = 0 * e.padding, a = i / 2;
  n.attr("rx", e.rx).attr("ry", e.ry).attr("x", e.x - e.width / 2 - a).attr("y", e.y - e.height / 2 - a).attr("width", e.width + i).attr("height", e.height + i).attr("fill", "none");
  const s = n.node().getBBox();
  return e.width = s.width, e.height = s.height, e.intersect = function(o) {
    return R0(e, o);
  }, { cluster: r, labelBBox: { width: 0, height: 0 } };
}, "noteGroup"), h4e = /* @__PURE__ */ w(async (t, e) => {
  const r = Te(), { themeVariables: n, handDrawnSeed: i } = r, { altBackground: a, compositeBackground: s, compositeTitleBackground: o, nodeBorder: l } = n, u = t.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-id", e.id).attr("data-look", e.look), h = u.insert("g", ":first-child"), f = u.insert("g").attr("class", "cluster-label");
  let d = u.append("rect");
  const p = f.node().appendChild(await Mu(e.label, e.labelStyle, void 0, !0));
  let g = p.getBBox();
  if (Nr(r.flowchart.htmlLabels)) {
    const _ = p.children[0], R = Qe(p);
    g = _.getBoundingClientRect(), R.attr("width", g.width), R.attr("height", g.height);
  }
  const m = 0 * e.padding, v = m / 2, y = (e.width <= g.width + e.padding ? g.width + e.padding : e.width) + m;
  e.width <= g.width + e.padding ? e.diff = (y - e.width) / 2 - e.padding : e.diff = -e.padding;
  const b = e.height + m, x = e.height + m - g.height - 6, T = e.x - y / 2, E = e.y - b / 2;
  e.width = y;
  const A = e.y - e.height / 2 - v + g.height + 2;
  let S;
  if (e.look === "handDrawn") {
    const _ = e.cssClasses.includes("statediagram-cluster-alt"), R = Lt.svg(u), L = e.rx || e.ry ? R.path(Bc(T, E, y, b, 10), {
      roughness: 0.7,
      fill: o,
      fillStyle: "solid",
      stroke: l,
      seed: i
    }) : R.rectangle(T, E, y, b, { seed: i });
    S = u.insert(() => L, ":first-child");
    const M = R.rectangle(T, A, y, x, {
      fill: _ ? a : s,
      fillStyle: _ ? "hachure" : "solid",
      stroke: l,
      seed: i
    });
    S = u.insert(() => L, ":first-child"), d = u.insert(() => M);
  } else
    S = h.insert("rect", ":first-child"), S.attr("class", "outer").attr("x", T).attr("y", E).attr("width", y).attr("height", b).attr("data-look", e.look), d.attr("class", "inner").attr("x", T).attr("y", A).attr("width", y).attr("height", x);
  f.attr(
    "transform",
    `translate(${e.x - g.width / 2}, ${E + 1 - (Nr(r.flowchart.htmlLabels) ? 0 : 3)})`
  );
  const k = S.node().getBBox();
  return e.height = k.height, e.offsetX = 0, e.offsetY = g.height - e.padding / 2, e.labelBBox = g, e.intersect = function(_) {
    return R0(e, _);
  }, { cluster: u, labelBBox: g };
}, "roundedWithTitle"), f4e = /* @__PURE__ */ w(async (t, e) => {
  ae.info("Creating subgraph rect for ", e.id, e);
  const r = Te(), { themeVariables: n, handDrawnSeed: i } = r, { clusterBkg: a, clusterBorder: s } = n, { labelStyles: o, nodeStyles: l, borderStyles: u, backgroundStyles: h } = kt(e), f = t.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), d = Nr(r.flowchart.htmlLabels), p = f.insert("g").attr("class", "cluster-label "), g = await Na(p, e.label, {
    style: e.labelStyle,
    useHtmlLabels: d,
    isNode: !0,
    width: e.width
  });
  let m = g.getBBox();
  if (Nr(r.flowchart.htmlLabels)) {
    const S = g.children[0], k = Qe(g);
    m = S.getBoundingClientRect(), k.attr("width", m.width), k.attr("height", m.height);
  }
  const v = e.width <= m.width + e.padding ? m.width + e.padding : e.width;
  e.width <= m.width + e.padding ? e.diff = (v - e.width) / 2 - e.padding : e.diff = -e.padding;
  const y = e.height, b = e.x - v / 2, x = e.y - y / 2;
  ae.trace("Data ", e, JSON.stringify(e));
  let T;
  if (e.look === "handDrawn") {
    const S = Lt.svg(f), k = Rt(e, {
      roughness: 0.7,
      fill: a,
      // fill: 'red',
      stroke: s,
      fillWeight: 4,
      seed: i
    }), _ = S.path(Bc(b, x, v, y, e.rx), k);
    T = f.insert(() => (ae.debug("Rough node insert CXC", _), _), ":first-child"), T.select("path:nth-child(2)").attr("style", u.join(";")), T.select("path").attr("style", h.join(";").replace("fill", "stroke"));
  } else
    T = f.insert("rect", ":first-child"), T.attr("style", l).attr("rx", e.rx).attr("ry", e.ry).attr("x", b).attr("y", x).attr("width", v).attr("height", y);
  const { subGraphTitleTopMargin: E } = nm(r);
  if (p.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${e.x - m.width / 2}, ${e.y - e.height / 2 + E})`
  ), o) {
    const S = p.select("span");
    S && S.attr("style", o);
  }
  const A = T.node().getBBox();
  return e.offsetX = 0, e.width = A.width, e.height = A.height, e.offsetY = m.height - e.padding / 2, e.intersect = function(S) {
    return R0(e, S);
  }, { cluster: f, labelBBox: m };
}, "kanbanSection"), d4e = /* @__PURE__ */ w((t, e) => {
  const r = Te(), { themeVariables: n, handDrawnSeed: i } = r, { nodeBorder: a } = n, s = t.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-look", e.look), o = s.insert("g", ":first-child"), l = 0 * e.padding, u = e.width + l;
  e.diff = -e.padding;
  const h = e.height + l, f = e.x - u / 2, d = e.y - h / 2;
  e.width = u;
  let p;
  if (e.look === "handDrawn") {
    const v = Lt.svg(s).rectangle(f, d, u, h, {
      fill: "lightgrey",
      roughness: 0.5,
      strokeLineDash: [5],
      stroke: a,
      seed: i
    });
    p = s.insert(() => v, ":first-child");
  } else
    p = o.insert("rect", ":first-child"), p.attr("class", "divider").attr("x", f).attr("y", d).attr("width", u).attr("height", h).attr("data-look", e.look);
  const g = p.node().getBBox();
  return e.height = g.height, e.offsetX = 0, e.offsetY = 0, e.intersect = function(m) {
    return R0(e, m);
  }, { cluster: s, labelBBox: {} };
}, "divider"), p4e = mQ, g4e = {
  rect: mQ,
  squareRect: p4e,
  roundedWithTitle: h4e,
  noteGroup: u4e,
  divider: d4e,
  kanbanSection: f4e
}, vQ = /* @__PURE__ */ new Map(), lL = /* @__PURE__ */ w(async (t, e) => {
  const r = e.shape || "rect", n = await g4e[r](t, e);
  return vQ.set(e.id, n), n;
}, "insertCluster"), m4e = /* @__PURE__ */ w(() => {
  vQ = /* @__PURE__ */ new Map();
}, "clear");
function yQ(t, e) {
  return t.intersect(e);
}
w(yQ, "intersectNode");
var v4e = yQ;
function bQ(t, e, r, n) {
  var i = t.x, a = t.y, s = i - n.x, o = a - n.y, l = Math.sqrt(e * e * o * o + r * r * s * s), u = Math.abs(e * r * s / l);
  n.x < i && (u = -u);
  var h = Math.abs(e * r * o / l);
  return n.y < a && (h = -h), { x: i + u, y: a + h };
}
w(bQ, "intersectEllipse");
var xQ = bQ;
function wQ(t, e, r) {
  return xQ(t, e, e, r);
}
w(wQ, "intersectCircle");
var y4e = wQ;
function TQ(t, e, r, n) {
  {
    const i = e.y - t.y, a = t.x - e.x, s = e.x * t.y - t.x * e.y, o = i * r.x + a * r.y + s, l = i * n.x + a * n.y + s, u = 1e-6;
    if (o !== 0 && l !== 0 && U_(o, l))
      return;
    const h = n.y - r.y, f = r.x - n.x, d = n.x * r.y - r.x * n.y, p = h * t.x + f * t.y + d, g = h * e.x + f * e.y + d;
    if (Math.abs(p) < u && Math.abs(g) < u && U_(p, g))
      return;
    const m = i * f - h * a;
    if (m === 0)
      return;
    const v = Math.abs(m / 2);
    let y = a * d - f * s;
    const b = y < 0 ? (y - v) / m : (y + v) / m;
    y = h * s - i * d;
    const x = y < 0 ? (y - v) / m : (y + v) / m;
    return { x: b, y: x };
  }
}
w(TQ, "intersectLine");
function U_(t, e) {
  return t * e > 0;
}
w(U_, "sameSign");
var b4e = TQ;
function EQ(t, e, r) {
  let n = t.x, i = t.y, a = [], s = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof e.forEach == "function" ? e.forEach(function(h) {
    s = Math.min(s, h.x), o = Math.min(o, h.y);
  }) : (s = Math.min(s, e.x), o = Math.min(o, e.y));
  let l = n - t.width / 2 - s, u = i - t.height / 2 - o;
  for (let h = 0; h < e.length; h++) {
    let f = e[h], d = e[h < e.length - 1 ? h + 1 : 0], p = b4e(
      t,
      r,
      { x: l + f.x, y: u + f.y },
      { x: l + d.x, y: u + d.y }
    );
    p && a.push(p);
  }
  return a.length ? (a.length > 1 && a.sort(function(h, f) {
    let d = h.x - r.x, p = h.y - r.y, g = Math.sqrt(d * d + p * p), m = f.x - r.x, v = f.y - r.y, y = Math.sqrt(m * m + v * v);
    return g < y ? -1 : g === y ? 0 : 1;
  }), a[0]) : t;
}
w(EQ, "intersectPolygon");
var x4e = EQ, St = {
  node: v4e,
  circle: y4e,
  ellipse: xQ,
  polygon: x4e,
  rect: R0
};
function SQ(t, e) {
  const { labelStyles: r } = kt(e);
  e.labelStyle = r;
  const n = zt(e);
  let i = n;
  n || (i = "anchor");
  const a = t.insert("g").attr("class", i).attr("id", e.domId || e.id), s = 1, { cssStyles: o } = e, l = Lt.svg(a), u = Rt(e, { fill: "black", stroke: "none", fillStyle: "solid" });
  e.look !== "handDrawn" && (u.roughness = 0);
  const h = l.circle(0, 0, s * 2, u), f = a.insert(() => h, ":first-child");
  return f.attr("class", "anchor").attr("style", Ai(o)), It(e, f), e.intersect = function(d) {
    return ae.info("Circle intersect", e, s, d), St.circle(e, s, d);
  }, a;
}
w(SQ, "anchor");
function V_(t, e, r, n, i, a, s) {
  const l = (t + r) / 2, u = (e + n) / 2, h = Math.atan2(n - e, r - t), f = (r - t) / 2, d = (n - e) / 2, p = f / i, g = d / a, m = Math.sqrt(p ** 2 + g ** 2);
  if (m > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const v = Math.sqrt(1 - m ** 2), y = l + v * a * Math.sin(h) * (s ? -1 : 1), b = u - v * i * Math.cos(h) * (s ? -1 : 1), x = Math.atan2((e - b) / a, (t - y) / i);
  let E = Math.atan2((n - b) / a, (r - y) / i) - x;
  s && E < 0 && (E += 2 * Math.PI), !s && E > 0 && (E -= 2 * Math.PI);
  const A = [];
  for (let S = 0; S < 20; S++) {
    const k = S / 19, _ = x + k * E, R = y + i * Math.cos(_), L = b + a * Math.sin(_);
    A.push({ x: R, y: L });
  }
  return A;
}
w(V_, "generateArcPoints");
async function kQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = a.width + e.padding + 20, o = a.height + e.padding, l = o / 2, u = l / (2.5 + o / 50), { cssStyles: h } = e, f = [
    { x: s / 2, y: -o / 2 },
    { x: -s / 2, y: -o / 2 },
    ...V_(-s / 2, -o / 2, -s / 2, o / 2, u, l, !1),
    { x: s / 2, y: o / 2 },
    ...V_(s / 2, o / 2, s / 2, -o / 2, u, l, !0)
  ], d = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = or(f), m = d.path(g, p), v = i.insert(() => m, ":first-child");
  return v.attr("class", "basic label-container"), h && e.look !== "handDrawn" && v.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && v.selectAll("path").attr("style", n), v.attr("transform", `translate(${u / 2}, 0)`), It(e, v), e.intersect = function(y) {
    return St.polygon(e, f, y);
  }, i;
}
w(kQ, "bowTieRect");
function Fc(t, e, r, n) {
  return t.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
w(Fc, "insertPolygonShape");
async function CQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = a.height + e.padding, o = 12, l = a.width + e.padding + o, u = 0, h = l, f = -s, d = 0, p = [
    { x: u + o, y: f },
    { x: h, y: f },
    { x: h, y: d },
    { x: u, y: d },
    { x: u, y: f + o },
    { x: u + o, y: f }
  ];
  let g;
  const { cssStyles: m } = e;
  if (e.look === "handDrawn") {
    const v = Lt.svg(i), y = Rt(e, {}), b = or(p), x = v.path(b, y);
    g = i.insert(() => x, ":first-child").attr("transform", `translate(${-l / 2}, ${s / 2})`), m && g.attr("style", m);
  } else
    g = Fc(i, l, s, p);
  return n && g.attr("style", n), It(e, g), e.intersect = function(v) {
    return St.polygon(e, p, v);
  }, i;
}
w(CQ, "card");
function _Q(t, e) {
  const { nodeStyles: r } = kt(e);
  e.label = "";
  const n = t.insert("g").attr("class", zt(e)).attr("id", e.domId ?? e.id), { cssStyles: i } = e, a = Math.max(28, e.width ?? 0), s = [
    { x: 0, y: a / 2 },
    { x: a / 2, y: 0 },
    { x: 0, y: -a / 2 },
    { x: -a / 2, y: 0 }
  ], o = Lt.svg(n), l = Rt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const u = or(s), h = o.path(u, l), f = n.insert(() => h, ":first-child");
  return i && e.look !== "handDrawn" && f.selectAll("path").attr("style", i), r && e.look !== "handDrawn" && f.selectAll("path").attr("style", r), e.width = 28, e.height = 28, e.intersect = function(d) {
    return St.polygon(e, s, d);
  }, n;
}
w(_Q, "choice");
async function cL(t, e, r) {
  const { labelStyles: n, nodeStyles: i } = kt(e);
  e.labelStyle = n;
  const { shapeSvg: a, bbox: s, halfPadding: o } = await Ht(t, e, zt(e)), l = r?.padding ?? o, u = s.width / 2 + l;
  let h;
  const { cssStyles: f } = e;
  if (e.look === "handDrawn") {
    const d = Lt.svg(a), p = Rt(e, {}), g = d.circle(0, 0, u * 2, p);
    h = a.insert(() => g, ":first-child"), h.attr("class", "basic label-container").attr("style", Ai(f));
  } else
    h = a.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", i).attr("r", u).attr("cx", 0).attr("cy", 0);
  return It(e, h), e.calcIntersect = function(d, p) {
    const g = d.width / 2;
    return St.circle(d, g, p);
  }, e.intersect = function(d) {
    return ae.info("Circle intersect", e, u, d), St.circle(e, u, d);
  }, a;
}
w(cL, "circle");
function AQ(t) {
  const e = Math.cos(Math.PI / 4), r = Math.sin(Math.PI / 4), n = t * 2, i = { x: n / 2 * e, y: n / 2 * r }, a = { x: -(n / 2) * e, y: n / 2 * r }, s = { x: -(n / 2) * e, y: -(n / 2) * r }, o = { x: n / 2 * e, y: -(n / 2) * r };
  return `M ${a.x},${a.y} L ${o.x},${o.y}
                   M ${i.x},${i.y} L ${s.x},${s.y}`;
}
w(AQ, "createLine");
function LQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r, e.label = "";
  const i = t.insert("g").attr("class", zt(e)).attr("id", e.domId ?? e.id), a = Math.max(30, e?.width ?? 0), { cssStyles: s } = e, o = Lt.svg(i), l = Rt(e, {});
  e.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const u = o.circle(0, 0, a * 2, l), h = AQ(a), f = o.path(h, l), d = i.insert(() => u, ":first-child");
  return d.insert(() => f), s && e.look !== "handDrawn" && d.selectAll("path").attr("style", s), n && e.look !== "handDrawn" && d.selectAll("path").attr("style", n), It(e, d), e.intersect = function(p) {
    return ae.info("crossedCircle intersect", e, { radius: a, point: p }), St.circle(e, a, p);
  }, i;
}
w(LQ, "crossedCircle");
function Go(t, e, r, n = 100, i = 0, a = 180) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let f = 0; f < n; f++) {
    const d = o + f * h, p = t + r * Math.cos(d), g = e + r * Math.sin(d);
    s.push({ x: -p, y: -g });
  }
  return s;
}
w(Go, "generateCirclePoints");
async function RQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = a.width + (e.padding ?? 0), l = a.height + (e.padding ?? 0), u = Math.max(5, l * 0.1), { cssStyles: h } = e, f = [
    ...Go(o / 2, -l / 2, u, 30, -90, 0),
    { x: -o / 2 - u, y: u },
    ...Go(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...Go(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: -l / 2 },
    ...Go(o / 2, l / 2, u, 20, 0, 90)
  ], d = [
    { x: o / 2, y: -l / 2 - u },
    { x: -o / 2, y: -l / 2 - u },
    ...Go(o / 2, -l / 2, u, 20, -90, 0),
    { x: -o / 2 - u, y: -u },
    ...Go(o / 2 + o * 0.1, -u, u, 20, -180, -270),
    ...Go(o / 2 + o * 0.1, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: l / 2 },
    ...Go(o / 2, l / 2, u, 20, 0, 90),
    { x: -o / 2, y: l / 2 + u },
    { x: o / 2, y: l / 2 + u }
  ], p = Lt.svg(i), g = Rt(e, { fill: "none" });
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const v = or(f).replace("Z", ""), y = p.path(v, g), b = or(d), x = p.path(b, { ...g }), T = i.insert("g", ":first-child");
  return T.insert(() => x, ":first-child").attr("stroke-opacity", 0), T.insert(() => y, ":first-child"), T.attr("class", "text"), h && e.look !== "handDrawn" && T.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && T.selectAll("path").attr("style", n), T.attr("transform", `translate(${u}, 0)`), s.attr(
    "transform",
    `translate(${-o / 2 + u - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, T), e.intersect = function(E) {
    return St.polygon(e, d, E);
  }, i;
}
w(RQ, "curlyBraceLeft");
function Uo(t, e, r, n = 100, i = 0, a = 180) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let f = 0; f < n; f++) {
    const d = o + f * h, p = t + r * Math.cos(d), g = e + r * Math.sin(d);
    s.push({ x: p, y: g });
  }
  return s;
}
w(Uo, "generateCirclePoints");
async function IQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = a.width + (e.padding ?? 0), l = a.height + (e.padding ?? 0), u = Math.max(5, l * 0.1), { cssStyles: h } = e, f = [
    ...Uo(o / 2, -l / 2, u, 20, -90, 0),
    { x: o / 2 + u, y: -u },
    ...Uo(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...Uo(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: o / 2 + u, y: l / 2 },
    ...Uo(o / 2, l / 2, u, 20, 0, 90)
  ], d = [
    { x: -o / 2, y: -l / 2 - u },
    { x: o / 2, y: -l / 2 - u },
    ...Uo(o / 2, -l / 2, u, 20, -90, 0),
    { x: o / 2 + u, y: -u },
    ...Uo(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...Uo(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: o / 2 + u, y: l / 2 },
    ...Uo(o / 2, l / 2, u, 20, 0, 90),
    { x: o / 2, y: l / 2 + u },
    { x: -o / 2, y: l / 2 + u }
  ], p = Lt.svg(i), g = Rt(e, { fill: "none" });
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const v = or(f).replace("Z", ""), y = p.path(v, g), b = or(d), x = p.path(b, { ...g }), T = i.insert("g", ":first-child");
  return T.insert(() => x, ":first-child").attr("stroke-opacity", 0), T.insert(() => y, ":first-child"), T.attr("class", "text"), h && e.look !== "handDrawn" && T.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && T.selectAll("path").attr("style", n), T.attr("transform", `translate(${-u}, 0)`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, T), e.intersect = function(E) {
    return St.polygon(e, d, E);
  }, i;
}
w(IQ, "curlyBraceRight");
function si(t, e, r, n = 100, i = 0, a = 180) {
  const s = [], o = i * Math.PI / 180, h = (a * Math.PI / 180 - o) / (n - 1);
  for (let f = 0; f < n; f++) {
    const d = o + f * h, p = t + r * Math.cos(d), g = e + r * Math.sin(d);
    s.push({ x: -p, y: -g });
  }
  return s;
}
w(si, "generateCirclePoints");
async function MQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = a.width + (e.padding ?? 0), l = a.height + (e.padding ?? 0), u = Math.max(5, l * 0.1), { cssStyles: h } = e, f = [
    ...si(o / 2, -l / 2, u, 30, -90, 0),
    { x: -o / 2 - u, y: u },
    ...si(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...si(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: -l / 2 },
    ...si(o / 2, l / 2, u, 20, 0, 90)
  ], d = [
    ...si(-o / 2 + u + u / 2, -l / 2, u, 20, -90, -180),
    { x: o / 2 - u / 2, y: u },
    ...si(-o / 2 - u / 2, -u, u, 20, 0, 90),
    ...si(-o / 2 - u / 2, u, u, 20, -90, 0),
    { x: o / 2 - u / 2, y: -u },
    ...si(-o / 2 + u + u / 2, l / 2, u, 30, -180, -270)
  ], p = [
    { x: o / 2, y: -l / 2 - u },
    { x: -o / 2, y: -l / 2 - u },
    ...si(o / 2, -l / 2, u, 20, -90, 0),
    { x: -o / 2 - u, y: -u },
    ...si(o / 2 + u * 2, -u, u, 20, -180, -270),
    ...si(o / 2 + u * 2, u, u, 20, -90, -180),
    { x: -o / 2 - u, y: l / 2 },
    ...si(o / 2, l / 2, u, 20, 0, 90),
    { x: -o / 2, y: l / 2 + u },
    { x: o / 2 - u - u / 2, y: l / 2 + u },
    ...si(-o / 2 + u + u / 2, -l / 2, u, 20, -90, -180),
    { x: o / 2 - u / 2, y: u },
    ...si(-o / 2 - u / 2, -u, u, 20, 0, 90),
    ...si(-o / 2 - u / 2, u, u, 20, -90, 0),
    { x: o / 2 - u / 2, y: -u },
    ...si(-o / 2 + u + u / 2, l / 2, u, 30, -180, -270)
  ], g = Lt.svg(i), m = Rt(e, { fill: "none" });
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const y = or(f).replace("Z", ""), b = g.path(y, m), T = or(d).replace("Z", ""), E = g.path(T, m), A = or(p), S = g.path(A, { ...m }), k = i.insert("g", ":first-child");
  return k.insert(() => S, ":first-child").attr("stroke-opacity", 0), k.insert(() => b, ":first-child"), k.insert(() => E, ":first-child"), k.attr("class", "text"), h && e.look !== "handDrawn" && k.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), k.attr("transform", `translate(${u - u / 4}, 0)`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, k), e.intersect = function(_) {
    return St.polygon(e, p, _);
  }, i;
}
w(MQ, "curlyBraces");
async function NQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = 80, o = 20, l = Math.max(s, (a.width + (e.padding ?? 0) * 2) * 1.25, e?.width ?? 0), u = Math.max(o, a.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = u / 2, { cssStyles: f } = e, d = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = l, m = u, v = g - h, y = m / 4, b = [
    { x: v, y: 0 },
    { x: y, y: 0 },
    { x: 0, y: m / 2 },
    { x: y, y: m },
    { x: v, y: m },
    ...d1(-v, -m / 2, h, 50, 270, 90)
  ], x = or(b), T = d.path(x, p), E = i.insert(() => T, ":first-child");
  return E.attr("class", "basic label-container"), f && e.look !== "handDrawn" && E.selectChildren("path").attr("style", f), n && e.look !== "handDrawn" && E.selectChildren("path").attr("style", n), E.attr("transform", `translate(${-l / 2}, ${-u / 2})`), It(e, E), e.intersect = function(A) {
    return St.polygon(e, b, A);
  }, i;
}
w(NQ, "curvedTrapezoid");
var w4e = /* @__PURE__ */ w((t, e, r, n, i, a) => [
  `M${t},${e + a}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createCylinderPathD"), T4e = /* @__PURE__ */ w((t, e, r, n, i, a) => [
  `M${t},${e + a}`,
  `M${t + r},${e + a}`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`
].join(" "), "createOuterCylinderPathD"), E4e = /* @__PURE__ */ w((t, e, r, n, i, a) => [`M${t - r / 2},${-n / 2}`, `a${i},${a} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function DQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + e.padding, e.width ?? 0), l = o / 2, u = l / (2.5 + o / 50), h = Math.max(a.height + u + e.padding, e.height ?? 0);
  let f;
  const { cssStyles: d } = e;
  if (e.look === "handDrawn") {
    const p = Lt.svg(i), g = T4e(0, 0, o, h, l, u), m = E4e(0, u, o, h, l, u), v = p.path(g, Rt(e, {})), y = p.path(m, Rt(e, { fill: "none" }));
    f = i.insert(() => y, ":first-child"), f = i.insert(() => v, ":first-child"), f.attr("class", "basic label-container"), d && f.attr("style", d);
  } else {
    const p = w4e(0, 0, o, h, l, u);
    f = i.insert("path", ":first-child").attr("d", p).attr("class", "basic label-container").attr("style", Ai(d)).attr("style", n);
  }
  return f.attr("label-offset-y", u), f.attr("transform", `translate(${-o / 2}, ${-(h / 2 + u)})`), It(e, f), s.attr(
    "transform",
    `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + (e.padding ?? 0) / 1.5 - (a.y - (a.top ?? 0))})`
  ), e.intersect = function(p) {
    const g = St.rect(e, p), m = g.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(m) < (e.width ?? 0) / 2 || Math.abs(m) == (e.width ?? 0) / 2 && Math.abs(g.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - u)) {
      let v = u * u * (1 - m * m / (l * l));
      v > 0 && (v = Math.sqrt(v)), v = u - v, p.y - (e.y ?? 0) > 0 && (v = -v), g.y += v;
    }
    return g;
  }, i;
}
w(DQ, "cylinder");
async function OQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = a.width + e.padding, l = a.height + e.padding, u = l * 0.2, h = -o / 2, f = -l / 2 - u / 2, { cssStyles: d } = e, p = Lt.svg(i), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = [
    { x: h, y: f + u },
    { x: -h, y: f + u },
    { x: -h, y: -f },
    { x: h, y: -f },
    { x: h, y: f },
    { x: -h, y: f },
    { x: -h, y: f + u }
  ], v = p.polygon(
    m.map((b) => [b.x, b.y]),
    g
  ), y = i.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), d && e.look !== "handDrawn" && y.selectAll("path").attr("style", d), n && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${h + (e.padding ?? 0) / 2 - (a.x - (a.left ?? 0))}, ${f + u + (e.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, y), e.intersect = function(b) {
    return St.rect(e, b);
  }, i;
}
w(OQ, "dividedRectangle");
async function PQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s } = await Ht(t, e, zt(e)), l = a.width / 2 + s + 5, u = a.width / 2 + s;
  let h;
  const { cssStyles: f } = e;
  if (e.look === "handDrawn") {
    const d = Lt.svg(i), p = Rt(e, { roughness: 0.2, strokeWidth: 2.5 }), g = Rt(e, { roughness: 0.2, strokeWidth: 1.5 }), m = d.circle(0, 0, l * 2, p), v = d.circle(0, 0, u * 2, g);
    h = i.insert("g", ":first-child"), h.attr("class", Ai(e.cssClasses)).attr("style", Ai(f)), h.node()?.appendChild(m), h.node()?.appendChild(v);
  } else {
    h = i.insert("g", ":first-child");
    const d = h.insert("circle", ":first-child"), p = h.insert("circle");
    h.attr("class", "basic label-container").attr("style", n), d.attr("class", "outer-circle").attr("style", n).attr("r", l).attr("cx", 0).attr("cy", 0), p.attr("class", "inner-circle").attr("style", n).attr("r", u).attr("cx", 0).attr("cy", 0);
  }
  return It(e, h), e.intersect = function(d) {
    return ae.info("DoubleCircle intersect", e, l, d), St.circle(e, l, d);
  }, i;
}
w(PQ, "doublecircle");
function $Q(t, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = kt(e);
  e.label = "", e.labelStyle = n;
  const a = t.insert("g").attr("class", zt(e)).attr("id", e.domId ?? e.id), s = 7, { cssStyles: o } = e, l = Lt.svg(a), { nodeBorder: u } = r, h = Rt(e, { fillStyle: "solid" });
  e.look !== "handDrawn" && (h.roughness = 0);
  const f = l.circle(0, 0, s * 2, h), d = a.insert(() => f, ":first-child");
  return d.selectAll("path").attr("style", `fill: ${u} !important;`), o && o.length > 0 && e.look !== "handDrawn" && d.selectAll("path").attr("style", o), i && e.look !== "handDrawn" && d.selectAll("path").attr("style", i), It(e, d), e.intersect = function(p) {
    return ae.info("filledCircle intersect", e, { radius: s, point: p }), St.circle(e, s, p);
  }, a;
}
w($Q, "filledCircle");
async function BQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = a.width + (e.padding ?? 0), l = o + a.height, u = o + a.height, h = [
    { x: 0, y: -l },
    { x: u, y: -l },
    { x: u / 2, y: 0 }
  ], { cssStyles: f } = e, d = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = or(h), m = d.path(g, p), v = i.insert(() => m, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`);
  return f && e.look !== "handDrawn" && v.selectChildren("path").attr("style", f), n && e.look !== "handDrawn" && v.selectChildren("path").attr("style", n), e.width = o, e.height = l, It(e, v), s.attr(
    "transform",
    `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-l / 2 + (e.padding ?? 0) / 2 + (a.y - (a.top ?? 0))})`
  ), e.intersect = function(y) {
    return ae.info("Triangle intersect", e, h, y), St.polygon(e, h, y);
  }, i;
}
w(BQ, "flippedTriangle");
function FQ(t, e, { dir: r, config: { state: n, themeVariables: i } }) {
  const { nodeStyles: a } = kt(e);
  e.label = "";
  const s = t.insert("g").attr("class", zt(e)).attr("id", e.domId ?? e.id), { cssStyles: o } = e;
  let l = Math.max(70, e?.width ?? 0), u = Math.max(10, e?.height ?? 0);
  r === "LR" && (l = Math.max(10, e?.width ?? 0), u = Math.max(70, e?.height ?? 0));
  const h = -1 * l / 2, f = -1 * u / 2, d = Lt.svg(s), p = Rt(e, {
    stroke: i.lineColor,
    fill: i.lineColor
  });
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = d.rectangle(h, f, l, u, p), m = s.insert(() => g, ":first-child");
  o && e.look !== "handDrawn" && m.selectAll("path").attr("style", o), a && e.look !== "handDrawn" && m.selectAll("path").attr("style", a), It(e, m);
  const v = n?.padding ?? 0;
  return e.width && e.height && (e.width += v / 2 || 0, e.height += v / 2 || 0), e.intersect = function(y) {
    return St.rect(e, y);
  }, s;
}
w(FQ, "forkJoin");
async function zQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const i = 80, a = 50, { shapeSvg: s, bbox: o } = await Ht(t, e, zt(e)), l = Math.max(i, o.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(a, o.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = u / 2, { cssStyles: f } = e, d = Lt.svg(s), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = [
    { x: -l / 2, y: -u / 2 },
    { x: l / 2 - h, y: -u / 2 },
    ...d1(-l / 2 + h, 0, h, 50, 90, 270),
    { x: l / 2 - h, y: u / 2 },
    { x: -l / 2, y: u / 2 }
  ], m = or(g), v = d.path(m, p), y = s.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), f && e.look !== "handDrawn" && y.selectChildren("path").attr("style", f), n && e.look !== "handDrawn" && y.selectChildren("path").attr("style", n), It(e, y), e.intersect = function(b) {
    return ae.info("Pill intersect", e, { radius: h, point: b }), St.polygon(e, g, b);
  }, s;
}
w(zQ, "halfRoundedRectangle");
async function qQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = a.height + (e.padding ?? 0), o = a.width + (e.padding ?? 0) * 2.5, { cssStyles: l } = e, u = Lt.svg(i), h = Rt(e, {});
  e.look !== "handDrawn" && (h.roughness = 0, h.fillStyle = "solid");
  let f = o / 2;
  const d = f / 6;
  f = f + d;
  const p = s / 2, g = p / 2, m = f - g, v = [
    { x: -m, y: -p },
    { x: 0, y: -p },
    { x: m, y: -p },
    { x: f, y: 0 },
    { x: m, y: p },
    { x: 0, y: p },
    { x: -m, y: p },
    { x: -f, y: 0 }
  ], y = or(v), b = u.path(y, h), x = i.insert(() => b, ":first-child");
  return x.attr("class", "basic label-container"), l && e.look !== "handDrawn" && x.selectChildren("path").attr("style", l), n && e.look !== "handDrawn" && x.selectChildren("path").attr("style", n), e.width = o, e.height = s, It(e, x), e.intersect = function(T) {
    return St.polygon(e, v, T);
  }, i;
}
w(qQ, "hexagon");
async function GQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.label = "", e.labelStyle = r;
  const { shapeSvg: i } = await Ht(t, e, zt(e)), a = Math.max(30, e?.width ?? 0), s = Math.max(30, e?.height ?? 0), { cssStyles: o } = e, l = Lt.svg(i), u = Rt(e, {});
  e.look !== "handDrawn" && (u.roughness = 0, u.fillStyle = "solid");
  const h = [
    { x: 0, y: 0 },
    { x: a, y: 0 },
    { x: 0, y: s },
    { x: a, y: s }
  ], f = or(h), d = l.path(f, u), p = i.insert(() => d, ":first-child");
  return p.attr("class", "basic label-container"), o && e.look !== "handDrawn" && p.selectChildren("path").attr("style", o), n && e.look !== "handDrawn" && p.selectChildren("path").attr("style", n), p.attr("transform", `translate(${-a / 2}, ${-s / 2})`), It(e, p), e.intersect = function(g) {
    return ae.info("Pill intersect", e, { points: h }), St.polygon(e, h, g);
  }, i;
}
w(GQ, "hourglass");
async function UQ(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = kt(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, label: f } = await Ht(t, e, "icon-shape default"), d = e.pos === "t", p = o, g = o, { nodeBorder: m } = r, { stylesMap: v } = _0(e), y = -g / 2, b = -p / 2, x = e.label ? 8 : 0, T = Lt.svg(u), E = Rt(e, { stroke: "none", fill: "none" });
  e.look !== "handDrawn" && (E.roughness = 0, E.fillStyle = "solid");
  const A = T.rectangle(y, b, g, p, E), S = Math.max(g, h.width), k = p + h.height + x, _ = T.rectangle(-S / 2, -k / 2, S, k, {
    ...E,
    fill: "transparent",
    stroke: "none"
  }), R = u.insert(() => A, ":first-child"), L = u.insert(() => _);
  if (e.icon) {
    const M = u.append("g");
    M.html(
      `<g>${await fc(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const P = M.node().getBBox(), C = P.width, I = P.height, N = P.x, O = P.y;
    M.attr(
      "transform",
      `translate(${-C / 2 - N},${d ? h.height / 2 + x / 2 - I / 2 - O : -h.height / 2 - x / 2 - I / 2 - O})`
    ), M.attr("style", `color: ${v.get("stroke") ?? m};`);
  }
  return f.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${d ? -k / 2 : k / 2 - h.height})`
  ), R.attr(
    "transform",
    `translate(0,${d ? h.height / 2 + x / 2 : -h.height / 2 - x / 2})`
  ), It(e, L), e.intersect = function(M) {
    if (ae.info("iconSquare intersect", e, M), !e.label)
      return St.rect(e, M);
    const P = e.x ?? 0, C = e.y ?? 0, I = e.height ?? 0;
    let N = [];
    return d ? N = [
      { x: P - h.width / 2, y: C - I / 2 },
      { x: P + h.width / 2, y: C - I / 2 },
      { x: P + h.width / 2, y: C - I / 2 + h.height + x },
      { x: P + g / 2, y: C - I / 2 + h.height + x },
      { x: P + g / 2, y: C + I / 2 },
      { x: P - g / 2, y: C + I / 2 },
      { x: P - g / 2, y: C - I / 2 + h.height + x },
      { x: P - h.width / 2, y: C - I / 2 + h.height + x }
    ] : N = [
      { x: P - g / 2, y: C - I / 2 },
      { x: P + g / 2, y: C - I / 2 },
      { x: P + g / 2, y: C - I / 2 + p },
      { x: P + h.width / 2, y: C - I / 2 + p },
      { x: P + h.width / 2 / 2, y: C + I / 2 },
      { x: P - h.width / 2, y: C + I / 2 },
      { x: P - h.width / 2, y: C - I / 2 + p },
      { x: P - g / 2, y: C - I / 2 + p }
    ], St.polygon(e, N, M);
  }, u;
}
w(UQ, "icon");
async function VQ(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = kt(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, label: f } = await Ht(t, e, "icon-shape default"), d = 20, p = e.label ? 8 : 0, g = e.pos === "t", { nodeBorder: m, mainBkg: v } = r, { stylesMap: y } = _0(e), b = Lt.svg(u), x = Rt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const T = y.get("fill");
  x.stroke = T ?? v;
  const E = u.append("g");
  e.icon && E.html(
    `<g>${await fc(e.icon, {
      height: o,
      width: o,
      fallbackPrefix: ""
    })}</g>`
  );
  const A = E.node().getBBox(), S = A.width, k = A.height, _ = A.x, R = A.y, L = Math.max(S, k) * Math.SQRT2 + d * 2, M = b.circle(0, 0, L, x), P = Math.max(L, h.width), C = L + h.height + p, I = b.rectangle(-P / 2, -C / 2, P, C, {
    ...x,
    fill: "transparent",
    stroke: "none"
  }), N = u.insert(() => M, ":first-child"), O = u.insert(() => I);
  return E.attr(
    "transform",
    `translate(${-S / 2 - _},${g ? h.height / 2 + p / 2 - k / 2 - R : -h.height / 2 - p / 2 - k / 2 - R})`
  ), E.attr("style", `color: ${y.get("stroke") ?? m};`), f.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${g ? -C / 2 : C / 2 - h.height})`
  ), N.attr(
    "transform",
    `translate(0,${g ? h.height / 2 + p / 2 : -h.height / 2 - p / 2})`
  ), It(e, O), e.intersect = function(D) {
    return ae.info("iconSquare intersect", e, D), St.rect(e, D);
  }, u;
}
w(VQ, "iconCircle");
async function HQ(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = kt(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, halfPadding: f, label: d } = await Ht(
    t,
    e,
    "icon-shape default"
  ), p = e.pos === "t", g = o + f * 2, m = o + f * 2, { nodeBorder: v, mainBkg: y } = r, { stylesMap: b } = _0(e), x = -m / 2, T = -g / 2, E = e.label ? 8 : 0, A = Lt.svg(u), S = Rt(e, {});
  e.look !== "handDrawn" && (S.roughness = 0, S.fillStyle = "solid");
  const k = b.get("fill");
  S.stroke = k ?? y;
  const _ = A.path(Bc(x, T, m, g, 5), S), R = Math.max(m, h.width), L = g + h.height + E, M = A.rectangle(-R / 2, -L / 2, R, L, {
    ...S,
    fill: "transparent",
    stroke: "none"
  }), P = u.insert(() => _, ":first-child").attr("class", "icon-shape2"), C = u.insert(() => M);
  if (e.icon) {
    const I = u.append("g");
    I.html(
      `<g>${await fc(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const N = I.node().getBBox(), O = N.width, D = N.height, $ = N.x, z = N.y;
    I.attr(
      "transform",
      `translate(${-O / 2 - $},${p ? h.height / 2 + E / 2 - D / 2 - z : -h.height / 2 - E / 2 - D / 2 - z})`
    ), I.attr("style", `color: ${b.get("stroke") ?? v};`);
  }
  return d.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${p ? -L / 2 : L / 2 - h.height})`
  ), P.attr(
    "transform",
    `translate(0,${p ? h.height / 2 + E / 2 : -h.height / 2 - E / 2})`
  ), It(e, C), e.intersect = function(I) {
    if (ae.info("iconSquare intersect", e, I), !e.label)
      return St.rect(e, I);
    const N = e.x ?? 0, O = e.y ?? 0, D = e.height ?? 0;
    let $ = [];
    return p ? $ = [
      { x: N - h.width / 2, y: O - D / 2 },
      { x: N + h.width / 2, y: O - D / 2 },
      { x: N + h.width / 2, y: O - D / 2 + h.height + E },
      { x: N + m / 2, y: O - D / 2 + h.height + E },
      { x: N + m / 2, y: O + D / 2 },
      { x: N - m / 2, y: O + D / 2 },
      { x: N - m / 2, y: O - D / 2 + h.height + E },
      { x: N - h.width / 2, y: O - D / 2 + h.height + E }
    ] : $ = [
      { x: N - m / 2, y: O - D / 2 },
      { x: N + m / 2, y: O - D / 2 },
      { x: N + m / 2, y: O - D / 2 + g },
      { x: N + h.width / 2, y: O - D / 2 + g },
      { x: N + h.width / 2 / 2, y: O + D / 2 },
      { x: N - h.width / 2, y: O + D / 2 },
      { x: N - h.width / 2, y: O - D / 2 + g },
      { x: N - m / 2, y: O - D / 2 + g }
    ], St.polygon(e, $, I);
  }, u;
}
w(HQ, "iconRounded");
async function WQ(t, e, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = kt(e);
  e.labelStyle = i;
  const a = e.assetHeight ?? 48, s = e.assetWidth ?? 48, o = Math.max(a, s), l = n?.wrappingWidth;
  e.width = Math.max(o, l ?? 0);
  const { shapeSvg: u, bbox: h, halfPadding: f, label: d } = await Ht(
    t,
    e,
    "icon-shape default"
  ), p = e.pos === "t", g = o + f * 2, m = o + f * 2, { nodeBorder: v, mainBkg: y } = r, { stylesMap: b } = _0(e), x = -m / 2, T = -g / 2, E = e.label ? 8 : 0, A = Lt.svg(u), S = Rt(e, {});
  e.look !== "handDrawn" && (S.roughness = 0, S.fillStyle = "solid");
  const k = b.get("fill");
  S.stroke = k ?? y;
  const _ = A.path(Bc(x, T, m, g, 0.1), S), R = Math.max(m, h.width), L = g + h.height + E, M = A.rectangle(-R / 2, -L / 2, R, L, {
    ...S,
    fill: "transparent",
    stroke: "none"
  }), P = u.insert(() => _, ":first-child"), C = u.insert(() => M);
  if (e.icon) {
    const I = u.append("g");
    I.html(
      `<g>${await fc(e.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const N = I.node().getBBox(), O = N.width, D = N.height, $ = N.x, z = N.y;
    I.attr(
      "transform",
      `translate(${-O / 2 - $},${p ? h.height / 2 + E / 2 - D / 2 - z : -h.height / 2 - E / 2 - D / 2 - z})`
    ), I.attr("style", `color: ${b.get("stroke") ?? v};`);
  }
  return d.attr(
    "transform",
    `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${p ? -L / 2 : L / 2 - h.height})`
  ), P.attr(
    "transform",
    `translate(0,${p ? h.height / 2 + E / 2 : -h.height / 2 - E / 2})`
  ), It(e, C), e.intersect = function(I) {
    if (ae.info("iconSquare intersect", e, I), !e.label)
      return St.rect(e, I);
    const N = e.x ?? 0, O = e.y ?? 0, D = e.height ?? 0;
    let $ = [];
    return p ? $ = [
      { x: N - h.width / 2, y: O - D / 2 },
      { x: N + h.width / 2, y: O - D / 2 },
      { x: N + h.width / 2, y: O - D / 2 + h.height + E },
      { x: N + m / 2, y: O - D / 2 + h.height + E },
      { x: N + m / 2, y: O + D / 2 },
      { x: N - m / 2, y: O + D / 2 },
      { x: N - m / 2, y: O - D / 2 + h.height + E },
      { x: N - h.width / 2, y: O - D / 2 + h.height + E }
    ] : $ = [
      { x: N - m / 2, y: O - D / 2 },
      { x: N + m / 2, y: O - D / 2 },
      { x: N + m / 2, y: O - D / 2 + g },
      { x: N + h.width / 2, y: O - D / 2 + g },
      { x: N + h.width / 2 / 2, y: O + D / 2 },
      { x: N - h.width / 2, y: O + D / 2 },
      { x: N - h.width / 2, y: O - D / 2 + g },
      { x: N - m / 2, y: O - D / 2 + g }
    ], St.polygon(e, $, I);
  }, u;
}
w(WQ, "iconSquare");
async function YQ(t, e, { config: { flowchart: r } }) {
  const n = new Image();
  n.src = e?.img ?? "", await n.decode();
  const i = Number(n.naturalWidth.toString().replace("px", "")), a = Number(n.naturalHeight.toString().replace("px", ""));
  e.imageAspectRatio = i / a;
  const { labelStyles: s } = kt(e);
  e.labelStyle = s;
  const o = r?.wrappingWidth;
  e.defaultWidth = r?.wrappingWidth;
  const l = Math.max(
    e.label ? o ?? 0 : 0,
    e?.assetWidth ?? i
  ), u = e.constraint === "on" && e?.assetHeight ? e.assetHeight * e.imageAspectRatio : l, h = e.constraint === "on" ? u / e.imageAspectRatio : e?.assetHeight ?? a;
  e.width = Math.max(u, o ?? 0);
  const { shapeSvg: f, bbox: d, label: p } = await Ht(t, e, "image-shape default"), g = e.pos === "t", m = -u / 2, v = -h / 2, y = e.label ? 8 : 0, b = Lt.svg(f), x = Rt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const T = b.rectangle(m, v, u, h, x), E = Math.max(u, d.width), A = h + d.height + y, S = b.rectangle(-E / 2, -A / 2, E, A, {
    ...x,
    fill: "none",
    stroke: "none"
  }), k = f.insert(() => T, ":first-child"), _ = f.insert(() => S);
  if (e.img) {
    const R = f.append("image");
    R.attr("href", e.img), R.attr("width", u), R.attr("height", h), R.attr("preserveAspectRatio", "none"), R.attr(
      "transform",
      `translate(${-u / 2},${g ? A / 2 - h : -A / 2})`
    );
  }
  return p.attr(
    "transform",
    `translate(${-d.width / 2 - (d.x - (d.left ?? 0))},${g ? -h / 2 - d.height / 2 - y / 2 : h / 2 - d.height / 2 + y / 2})`
  ), k.attr(
    "transform",
    `translate(0,${g ? d.height / 2 + y / 2 : -d.height / 2 - y / 2})`
  ), It(e, _), e.intersect = function(R) {
    if (ae.info("iconSquare intersect", e, R), !e.label)
      return St.rect(e, R);
    const L = e.x ?? 0, M = e.y ?? 0, P = e.height ?? 0;
    let C = [];
    return g ? C = [
      { x: L - d.width / 2, y: M - P / 2 },
      { x: L + d.width / 2, y: M - P / 2 },
      { x: L + d.width / 2, y: M - P / 2 + d.height + y },
      { x: L + u / 2, y: M - P / 2 + d.height + y },
      { x: L + u / 2, y: M + P / 2 },
      { x: L - u / 2, y: M + P / 2 },
      { x: L - u / 2, y: M - P / 2 + d.height + y },
      { x: L - d.width / 2, y: M - P / 2 + d.height + y }
    ] : C = [
      { x: L - u / 2, y: M - P / 2 },
      { x: L + u / 2, y: M - P / 2 },
      { x: L + u / 2, y: M - P / 2 + h },
      { x: L + d.width / 2, y: M - P / 2 + h },
      { x: L + d.width / 2 / 2, y: M + P / 2 },
      { x: L - d.width / 2, y: M + P / 2 },
      { x: L - d.width / 2, y: M - P / 2 + h },
      { x: L - u / 2, y: M - P / 2 + h }
    ], St.polygon(e, C, R);
  }, f;
}
w(YQ, "imageSquare");
async function XQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), l = [
    { x: 0, y: 0 },
    { x: s, y: 0 },
    { x: s + 3 * o / 6, y: -o },
    { x: -3 * o / 6, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const f = Lt.svg(i), d = Rt(e, {}), p = or(l), g = f.path(p, d);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = Fc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, It(e, u), e.intersect = function(f) {
    return St.polygon(e, l, f);
  }, i;
}
w(XQ, "inv_trapezoid");
async function h4(t, e, r) {
  const { labelStyles: n, nodeStyles: i } = kt(e);
  e.labelStyle = n;
  const { shapeSvg: a, bbox: s } = await Ht(t, e, zt(e)), o = Math.max(s.width + r.labelPaddingX * 2, e?.width || 0), l = Math.max(s.height + r.labelPaddingY * 2, e?.height || 0), u = -o / 2, h = -l / 2;
  let f, { rx: d, ry: p } = e;
  const { cssStyles: g } = e;
  if (r?.rx && r.ry && (d = r.rx, p = r.ry), e.look === "handDrawn") {
    const m = Lt.svg(a), v = Rt(e, {}), y = d || p ? m.path(Bc(u, h, o, l, d || 0), v) : m.rectangle(u, h, o, l, v);
    f = a.insert(() => y, ":first-child"), f.attr("class", "basic label-container").attr("style", Ai(g));
  } else
    f = a.insert("rect", ":first-child"), f.attr("class", "basic label-container").attr("style", i).attr("rx", Ai(d)).attr("ry", Ai(p)).attr("x", u).attr("y", h).attr("width", o).attr("height", l);
  return It(e, f), e.calcIntersect = function(m, v) {
    return St.rect(m, v);
  }, e.intersect = function(m) {
    return St.rect(e, m);
  }, a;
}
w(h4, "drawRect");
async function jQ(t, e) {
  const { shapeSvg: r, bbox: n, label: i } = await Ht(t, e, "label"), a = r.insert("rect", ":first-child");
  return a.attr("width", 0.1).attr("height", 0.1), r.attr("class", "label edgeLabel"), i.attr(
    "transform",
    `translate(${-(n.width / 2) - (n.x - (n.left ?? 0))}, ${-(n.height / 2) - (n.y - (n.top ?? 0))})`
  ), It(e, a), e.intersect = function(l) {
    return St.rect(e, l);
  }, r;
}
w(jQ, "labelRect");
async function KQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = Math.max(a.width + (e.padding ?? 0), e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0), e?.height ?? 0), l = [
    { x: 0, y: 0 },
    { x: s + 3 * o / 6, y: 0 },
    { x: s, y: -o },
    { x: -(3 * o) / 6, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const f = Lt.svg(i), d = Rt(e, {}), p = or(l), g = f.path(p, d);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = Fc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, It(e, u), e.intersect = function(f) {
    return St.polygon(e, l, f);
  }, i;
}
w(KQ, "lean_left");
async function ZQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = Math.max(a.width + (e.padding ?? 0), e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0), e?.height ?? 0), l = [
    { x: -3 * o / 6, y: 0 },
    { x: s, y: 0 },
    { x: s + 3 * o / 6, y: -o },
    { x: 0, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const f = Lt.svg(i), d = Rt(e, {}), p = or(l), g = f.path(p, d);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = Fc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, It(e, u), e.intersect = function(f) {
    return St.polygon(e, l, f);
  }, i;
}
w(ZQ, "lean_right");
function QQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.label = "", e.labelStyle = r;
  const i = t.insert("g").attr("class", zt(e)).attr("id", e.domId ?? e.id), { cssStyles: a } = e, s = Math.max(35, e?.width ?? 0), o = Math.max(35, e?.height ?? 0), l = 7, u = [
    { x: s, y: 0 },
    { x: 0, y: o + l / 2 },
    { x: s - 2 * l, y: o + l / 2 },
    { x: 0, y: 2 * o },
    { x: s, y: o - l / 2 },
    { x: 2 * l, y: o - l / 2 }
  ], h = Lt.svg(i), f = Rt(e, {});
  e.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const d = or(u), p = h.path(d, f), g = i.insert(() => p, ":first-child");
  return a && e.look !== "handDrawn" && g.selectAll("path").attr("style", a), n && e.look !== "handDrawn" && g.selectAll("path").attr("style", n), g.attr("transform", `translate(-${s / 2},${-o})`), It(e, g), e.intersect = function(m) {
    return ae.info("lightningBolt intersect", e, m), St.polygon(e, u, m);
  }, i;
}
w(QQ, "lightningBolt");
var S4e = /* @__PURE__ */ w((t, e, r, n, i, a, s) => [
  `M${t},${e + a}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t},${e + a + s}`,
  `a${i},${a} 0,0,0 ${r},0`
].join(" "), "createCylinderPathD"), k4e = /* @__PURE__ */ w((t, e, r, n, i, a, s) => [
  `M${t},${e + a}`,
  `M${t + r},${e + a}`,
  `a${i},${a} 0,0,0 ${-r},0`,
  `l0,${n}`,
  `a${i},${a} 0,0,0 ${r},0`,
  `l0,${-n}`,
  `M${t},${e + a + s}`,
  `a${i},${a} 0,0,0 ${r},0`
].join(" "), "createOuterCylinderPathD"), C4e = /* @__PURE__ */ w((t, e, r, n, i, a) => [`M${t - r / 2},${-n / 2}`, `a${i},${a} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function JQ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0), e.width ?? 0), l = o / 2, u = l / (2.5 + o / 50), h = Math.max(a.height + u + (e.padding ?? 0), e.height ?? 0), f = h * 0.1;
  let d;
  const { cssStyles: p } = e;
  if (e.look === "handDrawn") {
    const g = Lt.svg(i), m = k4e(0, 0, o, h, l, u, f), v = C4e(0, u, o, h, l, u), y = Rt(e, {}), b = g.path(m, y), x = g.path(v, y);
    i.insert(() => x, ":first-child").attr("class", "line"), d = i.insert(() => b, ":first-child"), d.attr("class", "basic label-container"), p && d.attr("style", p);
  } else {
    const g = S4e(0, 0, o, h, l, u, f);
    d = i.insert("path", ":first-child").attr("d", g).attr("class", "basic label-container").attr("style", Ai(p)).attr("style", n);
  }
  return d.attr("label-offset-y", u), d.attr("transform", `translate(${-o / 2}, ${-(h / 2 + u)})`), It(e, d), s.attr(
    "transform",
    `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + u - (a.y - (a.top ?? 0))})`
  ), e.intersect = function(g) {
    const m = St.rect(e, g), v = m.x - (e.x ?? 0);
    if (l != 0 && (Math.abs(v) < (e.width ?? 0) / 2 || Math.abs(v) == (e.width ?? 0) / 2 && Math.abs(m.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - u)) {
      let y = u * u * (1 - v * v / (l * l));
      y > 0 && (y = Math.sqrt(y)), y = u - y, g.y - (e.y ?? 0) > 0 && (y = -y), m.y += y;
    }
    return m;
  }, i;
}
w(JQ, "linedCylinder");
async function eJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 4, h = l + u, { cssStyles: f } = e, d = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = [
    { x: -o / 2 - o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: h / 2 },
    ...pc(
      -o / 2 - o / 2 * 0.1,
      h / 2,
      o / 2 + o / 2 * 0.1,
      h / 2,
      u,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -h / 2 },
    { x: -o / 2, y: -h / 2 },
    { x: -o / 2, y: h / 2 * 1.1 },
    { x: -o / 2, y: -h / 2 }
  ], m = d.polygon(
    g.map((y) => [y.x, y.y]),
    p
  ), v = i.insert(() => m, ":first-child");
  return v.attr("class", "basic label-container"), f && e.look !== "handDrawn" && v.selectAll("path").attr("style", f), n && e.look !== "handDrawn" && v.selectAll("path").attr("style", n), v.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) + o / 2 * 0.1 / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) - u / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, v), e.intersect = function(y) {
    return St.polygon(e, g, y);
  }, i;
}
w(eJ, "linedWaveEdgedRect");
async function tJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = 5, h = -o / 2, f = -l / 2, { cssStyles: d } = e, p = Lt.svg(i), g = Rt(e, {}), m = [
    { x: h - u, y: f + u },
    { x: h - u, y: f + l + u },
    { x: h + o - u, y: f + l + u },
    { x: h + o - u, y: f + l },
    { x: h + o, y: f + l },
    { x: h + o, y: f + l - u },
    { x: h + o + u, y: f + l - u },
    { x: h + o + u, y: f - u },
    { x: h + u, y: f - u },
    { x: h + u, y: f },
    { x: h, y: f },
    { x: h, y: f + u }
  ], v = [
    { x: h, y: f + u },
    { x: h + o - u, y: f + u },
    { x: h + o - u, y: f + l },
    { x: h + o, y: f + l },
    { x: h + o, y: f },
    { x: h, y: f }
  ];
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = or(m), b = p.path(y, g), x = or(v), T = p.path(x, { ...g, fill: "none" }), E = i.insert(() => T, ":first-child");
  return E.insert(() => b, ":first-child"), E.attr("class", "basic label-container"), d && e.look !== "handDrawn" && E.selectAll("path").attr("style", d), n && e.look !== "handDrawn" && E.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${-(a.width / 2) - u - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + u - (a.y - (a.top ?? 0))})`
  ), It(e, E), e.intersect = function(A) {
    return St.polygon(e, m, A);
  }, i;
}
w(tJ, "multiRect");
async function rJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 4, h = l + u, f = -o / 2, d = -h / 2, p = 5, { cssStyles: g } = e, m = pc(
    f - p,
    d + h + p,
    f + o - p,
    d + h + p,
    u,
    0.8
  ), v = m?.[m.length - 1], y = [
    { x: f - p, y: d + p },
    { x: f - p, y: d + h + p },
    ...m,
    { x: f + o - p, y: v.y - p },
    { x: f + o, y: v.y - p },
    { x: f + o, y: v.y - 2 * p },
    { x: f + o + p, y: v.y - 2 * p },
    { x: f + o + p, y: d - p },
    { x: f + p, y: d - p },
    { x: f + p, y: d },
    { x: f, y: d },
    { x: f, y: d + p }
  ], b = [
    { x: f, y: d + p },
    { x: f + o - p, y: d + p },
    { x: f + o - p, y: v.y - p },
    { x: f + o, y: v.y - p },
    { x: f + o, y: d },
    { x: f, y: d }
  ], x = Lt.svg(i), T = Rt(e, {});
  e.look !== "handDrawn" && (T.roughness = 0, T.fillStyle = "solid");
  const E = or(y), A = x.path(E, T), S = or(b), k = x.path(S, T), _ = i.insert(() => A, ":first-child");
  return _.insert(() => k), _.attr("class", "basic label-container"), g && e.look !== "handDrawn" && _.selectAll("path").attr("style", g), n && e.look !== "handDrawn" && _.selectAll("path").attr("style", n), _.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-(a.width / 2) - p - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + p - u / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, _), e.intersect = function(R) {
    return St.polygon(e, y, R);
  }, i;
}
w(rJ, "multiWaveEdgedRectangle");
async function nJ(t, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = kt(e);
  e.labelStyle = n, e.useHtmlLabels || mr().flowchart?.htmlLabels !== !1 || (e.centerLabel = !0);
  const { shapeSvg: s, bbox: o, label: l } = await Ht(t, e, zt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, e?.width ?? 0), h = Math.max(o.height + (e.padding ?? 0) * 2, e?.height ?? 0), f = -u / 2, d = -h / 2, { cssStyles: p } = e, g = Lt.svg(s), m = Rt(e, {
    fill: r.noteBkgColor,
    stroke: r.noteBorderColor
  });
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const v = g.rectangle(f, d, u, h, m), y = s.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), p && e.look !== "handDrawn" && y.selectAll("path").attr("style", p), i && e.look !== "handDrawn" && y.selectAll("path").attr("style", i), l.attr(
    "transform",
    `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`
  ), It(e, y), e.intersect = function(b) {
    return St.rect(e, b);
  }, s;
}
w(nJ, "note");
var _4e = /* @__PURE__ */ w((t, e, r) => [
  `M${t + r / 2},${e}`,
  `L${t + r},${e - r / 2}`,
  `L${t + r / 2},${e - r}`,
  `L${t},${e - r / 2}`,
  "Z"
].join(" "), "createDecisionBoxPathD");
async function iJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = a.width + e.padding, o = a.height + e.padding, l = s + o, u = 0.5, h = [
    { x: l / 2, y: 0 },
    { x: l, y: -l / 2 },
    { x: l / 2, y: -l },
    { x: 0, y: -l / 2 }
  ];
  let f;
  const { cssStyles: d } = e;
  if (e.look === "handDrawn") {
    const p = Lt.svg(i), g = Rt(e, {}), m = _4e(0, 0, l), v = p.path(m, g);
    f = i.insert(() => v, ":first-child").attr("transform", `translate(${-l / 2 + u}, ${l / 2})`), d && f.attr("style", d);
  } else
    f = Fc(i, l, l, h), f.attr("transform", `translate(${-l / 2 + u}, ${l / 2})`);
  return n && f.attr("style", n), It(e, f), e.calcIntersect = function(p, g) {
    const m = p.width, v = [
      { x: m / 2, y: 0 },
      { x: m, y: -m / 2 },
      { x: m / 2, y: -m },
      { x: 0, y: -m / 2 }
    ], y = St.polygon(p, v, g);
    return { x: y.x - 0.5, y: y.y - 0.5 };
  }, e.intersect = function(p) {
    return this.calcIntersect(e, p);
  }, i;
}
w(iJ, "question");
async function aJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0), e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0), e?.height ?? 0), u = -o / 2, h = -l / 2, f = h / 2, d = [
    { x: u + f, y: h },
    { x: u, y: 0 },
    { x: u + f, y: -h },
    { x: -u, y: -h },
    { x: -u, y: h }
  ], { cssStyles: p } = e, g = Lt.svg(i), m = Rt(e, {});
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const v = or(d), y = g.path(v, m), b = i.insert(() => y, ":first-child");
  return b.attr("class", "basic label-container"), p && e.look !== "handDrawn" && b.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && b.selectAll("path").attr("style", n), b.attr("transform", `translate(${-f / 2},0)`), s.attr(
    "transform",
    `translate(${-f / 2 - a.width / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`
  ), It(e, b), e.intersect = function(x) {
    return St.polygon(e, d, x);
  }, i;
}
w(aJ, "rect_left_inv_arrow");
async function sJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  let i;
  e.cssClasses ? i = "node " + e.cssClasses : i = "node default";
  const a = t.insert("g").attr("class", i).attr("id", e.domId || e.id), s = a.insert("g"), o = a.insert("g").attr("class", "label").attr("style", n), l = e.description, u = e.label, h = o.node().appendChild(await Mu(u, e.labelStyle, !0, !0));
  let f = { width: 0, height: 0 };
  if (Nr(Te()?.flowchart?.htmlLabels)) {
    const k = h.children[0], _ = Qe(h);
    f = k.getBoundingClientRect(), _.attr("width", f.width), _.attr("height", f.height);
  }
  ae.info("Text 2", l);
  const d = l || [], p = h.getBBox(), g = o.node().appendChild(
    await Mu(
      d.join ? d.join("<br/>") : d,
      e.labelStyle,
      !0,
      !0
    )
  ), m = g.children[0], v = Qe(g);
  f = m.getBoundingClientRect(), v.attr("width", f.width), v.attr("height", f.height);
  const y = (e.padding || 0) / 2;
  Qe(g).attr(
    "transform",
    "translate( " + (f.width > p.width ? 0 : (p.width - f.width) / 2) + ", " + (p.height + y + 5) + ")"
  ), Qe(h).attr(
    "transform",
    "translate( " + (f.width < p.width ? 0 : -(p.width - f.width) / 2) + ", 0)"
  ), f = o.node().getBBox(), o.attr(
    "transform",
    "translate(" + -f.width / 2 + ", " + (-f.height / 2 - y + 3) + ")"
  );
  const b = f.width + (e.padding || 0), x = f.height + (e.padding || 0), T = -f.width / 2 - y, E = -f.height / 2 - y;
  let A, S;
  if (e.look === "handDrawn") {
    const k = Lt.svg(a), _ = Rt(e, {}), R = k.path(
      Bc(T, E, b, x, e.rx || 0),
      _
    ), L = k.line(
      -f.width / 2 - y,
      -f.height / 2 - y + p.height + y,
      f.width / 2 + y,
      -f.height / 2 - y + p.height + y,
      _
    );
    S = a.insert(() => (ae.debug("Rough node insert CXC", R), L), ":first-child"), A = a.insert(() => (ae.debug("Rough node insert CXC", R), R), ":first-child");
  } else
    A = s.insert("rect", ":first-child"), S = s.insert("line"), A.attr("class", "outer title-state").attr("style", n).attr("x", -f.width / 2 - y).attr("y", -f.height / 2 - y).attr("width", f.width + (e.padding || 0)).attr("height", f.height + (e.padding || 0)), S.attr("class", "divider").attr("x1", -f.width / 2 - y).attr("x2", f.width / 2 + y).attr("y1", -f.height / 2 - y + p.height + y).attr("y2", -f.height / 2 - y + p.height + y);
  return It(e, A), e.intersect = function(k) {
    return St.rect(e, k);
  }, a;
}
w(sJ, "rectWithTitle");
function Dp(t, e, r, n, i, a, s) {
  const l = (t + r) / 2, u = (e + n) / 2, h = Math.atan2(n - e, r - t), f = (r - t) / 2, d = (n - e) / 2, p = f / i, g = d / a, m = Math.sqrt(p ** 2 + g ** 2);
  if (m > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const v = Math.sqrt(1 - m ** 2), y = l + v * a * Math.sin(h) * (s ? -1 : 1), b = u - v * i * Math.cos(h) * (s ? -1 : 1), x = Math.atan2((e - b) / a, (t - y) / i);
  let E = Math.atan2((n - b) / a, (r - y) / i) - x;
  s && E < 0 && (E += 2 * Math.PI), !s && E > 0 && (E -= 2 * Math.PI);
  const A = [];
  for (let S = 0; S < 20; S++) {
    const k = S / 19, _ = x + k * E, R = y + i * Math.cos(_), L = b + a * Math.sin(_);
    A.push({ x: R, y: L });
  }
  return A;
}
w(Dp, "generateArcPoints");
async function oJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = e?.padding ?? 0, o = e?.padding ?? 0, l = (e?.width ? e?.width : a.width) + s * 2, u = (e?.height ? e?.height : a.height) + o * 2, h = e.radius || 5, f = e.taper || 5, { cssStyles: d } = e, p = Lt.svg(i), g = Rt(e, {});
  e.stroke && (g.stroke = e.stroke), e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = [
    // Top edge (left to right)
    { x: -l / 2 + f, y: -u / 2 },
    // Top-left corner start (1)
    { x: l / 2 - f, y: -u / 2 },
    // Top-right corner start (2)
    ...Dp(l / 2 - f, -u / 2, l / 2, -u / 2 + f, h, h, !0),
    // Top-left arc (2 to 3)
    // Right edge (top to bottom)
    { x: l / 2, y: -u / 2 + f },
    // Top-right taper point (3)
    { x: l / 2, y: u / 2 - f },
    // Bottom-right taper point (4)
    ...Dp(l / 2, u / 2 - f, l / 2 - f, u / 2, h, h, !0),
    // Top-left arc (4 to 5)
    // Bottom edge (right to left)
    { x: l / 2 - f, y: u / 2 },
    // Bottom-right corner start (5)
    { x: -l / 2 + f, y: u / 2 },
    // Bottom-left corner start (6)
    ...Dp(-l / 2 + f, u / 2, -l / 2, u / 2 - f, h, h, !0),
    // Top-left arc (4 to 5)
    // Left edge (bottom to top)
    { x: -l / 2, y: u / 2 - f },
    // Bottom-left taper point (7)
    { x: -l / 2, y: -u / 2 + f },
    // Top-left taper point (8)
    ...Dp(-l / 2, -u / 2 + f, -l / 2 + f, -u / 2, h, h, !0)
    // Top-left arc (4 to 5)
  ], v = or(m), y = p.path(v, g), b = i.insert(() => y, ":first-child");
  return b.attr("class", "basic label-container outer-path"), d && e.look !== "handDrawn" && b.selectChildren("path").attr("style", d), n && e.look !== "handDrawn" && b.selectChildren("path").attr("style", n), It(e, b), e.intersect = function(x) {
    return St.polygon(e, m, x);
  }, i;
}
w(oJ, "roundedRect");
async function lJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = e?.padding ?? 0, l = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = -a.width / 2 - o, f = -a.height / 2 - o, { cssStyles: d } = e, p = Lt.svg(i), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = [
    { x: h, y: f },
    { x: h + l + 8, y: f },
    { x: h + l + 8, y: f + u },
    { x: h - 8, y: f + u },
    { x: h - 8, y: f },
    { x: h, y: f },
    { x: h, y: f + u }
  ], v = p.polygon(
    m.map((b) => [b.x, b.y]),
    g
  ), y = i.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container").attr("style", Ai(d)), n && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), d && e.look !== "handDrawn" && y.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${-l / 2 + 4 + (e.padding ?? 0) - (a.x - (a.left ?? 0))},${-u / 2 + (e.padding ?? 0) - (a.y - (a.top ?? 0))})`
  ), It(e, y), e.intersect = function(b) {
    return St.rect(e, b);
  }, i;
}
w(lJ, "shadedProcess");
async function cJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = -o / 2, h = -l / 2, { cssStyles: f } = e, d = Lt.svg(i), p = Rt(e, {});
  e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = [
    { x: u, y: h },
    { x: u, y: h + l },
    { x: u + o, y: h + l },
    { x: u + o, y: h - l / 2 }
  ], m = or(g), v = d.path(m, p), y = i.insert(() => v, ":first-child");
  return y.attr("class", "basic label-container"), f && e.look !== "handDrawn" && y.selectChildren("path").attr("style", f), n && e.look !== "handDrawn" && y.selectChildren("path").attr("style", n), y.attr("transform", `translate(0, ${l / 4})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (a.x - (a.left ?? 0))}, ${-l / 4 + (e.padding ?? 0) - (a.y - (a.top ?? 0))})`
  ), It(e, y), e.intersect = function(b) {
    return St.polygon(e, g, b);
  }, i;
}
w(cJ, "slopedRect");
async function uJ(t, e) {
  const r = {
    rx: 0,
    ry: 0,
    labelPaddingX: e.labelPaddingX ?? (e?.padding || 0) * 2,
    labelPaddingY: (e?.padding || 0) * 1
  };
  return h4(t, e, r);
}
w(uJ, "squareRect");
async function hJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = a.height + e.padding, o = a.width + s / 4 + e.padding, l = s / 2, { cssStyles: u } = e, h = Lt.svg(i), f = Rt(e, {});
  e.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const d = [
    { x: -o / 2 + l, y: -s / 2 },
    { x: o / 2 - l, y: -s / 2 },
    ...d1(-o / 2 + l, 0, l, 50, 90, 270),
    { x: o / 2 - l, y: s / 2 },
    ...d1(o / 2 - l, 0, l, 50, 270, 450)
  ], p = or(d), g = h.path(p, f), m = i.insert(() => g, ":first-child");
  return m.attr("class", "basic label-container outer-path"), u && e.look !== "handDrawn" && m.selectChildren("path").attr("style", u), n && e.look !== "handDrawn" && m.selectChildren("path").attr("style", n), It(e, m), e.intersect = function(v) {
    return St.polygon(e, d, v);
  }, i;
}
w(hJ, "stadium");
async function fJ(t, e) {
  return h4(t, e, {
    rx: 5,
    ry: 5
  });
}
w(fJ, "state");
function dJ(t, e, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = kt(e);
  e.labelStyle = n;
  const { cssStyles: a } = e, { lineColor: s, stateBorder: o, nodeBorder: l } = r, u = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), h = Lt.svg(u), f = Rt(e, {});
  e.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const d = h.circle(0, 0, 14, {
    ...f,
    stroke: s,
    strokeWidth: 2
  }), p = o ?? l, g = h.circle(0, 0, 5, {
    ...f,
    fill: p,
    stroke: p,
    strokeWidth: 2,
    fillStyle: "solid"
  }), m = u.insert(() => d, ":first-child");
  return m.insert(() => g), a && m.selectAll("path").attr("style", a), i && m.selectAll("path").attr("style", i), It(e, m), e.intersect = function(v) {
    return St.circle(e, 7, v);
  }, u;
}
w(dJ, "stateEnd");
function pJ(t, e, { config: { themeVariables: r } }) {
  const { lineColor: n } = r, i = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
  let a;
  if (e.look === "handDrawn") {
    const o = Lt.svg(i).circle(0, 0, 14, dye(n));
    a = i.insert(() => o), a.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  } else
    a = i.insert("circle", ":first-child"), a.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  return It(e, a), e.intersect = function(s) {
    return St.circle(e, 7, s);
  }, i;
}
w(pJ, "stateStart");
async function gJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = (e?.padding || 0) / 2, o = a.width + e.padding, l = a.height + e.padding, u = -a.width / 2 - s, h = -a.height / 2 - s, f = [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: o, y: -l },
    { x: 0, y: -l },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: o + 8, y: 0 },
    { x: o + 8, y: -l },
    { x: -8, y: -l },
    { x: -8, y: 0 }
  ];
  if (e.look === "handDrawn") {
    const d = Lt.svg(i), p = Rt(e, {}), g = d.rectangle(u - 8, h, o + 16, l, p), m = d.line(u, h, u, h + l, p), v = d.line(u + o, h, u + o, h + l, p);
    i.insert(() => m, ":first-child"), i.insert(() => v, ":first-child");
    const y = i.insert(() => g, ":first-child"), { cssStyles: b } = e;
    y.attr("class", "basic label-container").attr("style", Ai(b)), It(e, y);
  } else {
    const d = Fc(i, o, l, f);
    n && d.attr("style", n), It(e, d);
  }
  return e.intersect = function(d) {
    return St.polygon(e, f, d);
  }, i;
}
w(gJ, "subroutine");
async function mJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), o = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), l = -s / 2, u = -o / 2, h = 0.2 * o, f = 0.2 * o, { cssStyles: d } = e, p = Lt.svg(i), g = Rt(e, {}), m = [
    { x: l - h / 2, y: u },
    { x: l + s + h / 2, y: u },
    { x: l + s + h / 2, y: u + o },
    { x: l - h / 2, y: u + o }
  ], v = [
    { x: l + s - h / 2, y: u + o },
    { x: l + s + h / 2, y: u + o },
    { x: l + s + h / 2, y: u + o - f }
  ];
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = or(m), b = p.path(y, g), x = or(v), T = p.path(x, { ...g, fillStyle: "solid" }), E = i.insert(() => T, ":first-child");
  return E.insert(() => b, ":first-child"), E.attr("class", "basic label-container"), d && e.look !== "handDrawn" && E.selectAll("path").attr("style", d), n && e.look !== "handDrawn" && E.selectAll("path").attr("style", n), It(e, E), e.intersect = function(A) {
    return St.polygon(e, m, A);
  }, i;
}
w(mJ, "taggedRect");
async function vJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 4, h = 0.2 * o, f = 0.2 * l, d = l + u, { cssStyles: p } = e, g = Lt.svg(i), m = Rt(e, {});
  e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const v = [
    { x: -o / 2 - o / 2 * 0.1, y: d / 2 },
    ...pc(
      -o / 2 - o / 2 * 0.1,
      d / 2,
      o / 2 + o / 2 * 0.1,
      d / 2,
      u,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -d / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -d / 2 }
  ], y = -o / 2 + o / 2 * 0.1, b = -d / 2 - f * 0.4, x = [
    { x: y + o - h, y: (b + l) * 1.4 },
    { x: y + o, y: b + l - f },
    { x: y + o, y: (b + l) * 0.9 },
    ...pc(
      y + o,
      (b + l) * 1.3,
      y + o - h,
      (b + l) * 1.5,
      -l * 0.03,
      0.5
    )
  ], T = or(v), E = g.path(T, m), A = or(x), S = g.path(A, {
    ...m,
    fillStyle: "solid"
  }), k = i.insert(() => S, ":first-child");
  return k.insert(() => E, ":first-child"), k.attr("class", "basic label-container"), p && e.look !== "handDrawn" && k.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), k.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) - u / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, k), e.intersect = function(_) {
    return St.polygon(e, v, _);
  }, i;
}
w(vJ, "taggedWaveEdgedRectangle");
async function yJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = Math.max(a.width + e.padding, e?.width || 0), o = Math.max(a.height + e.padding, e?.height || 0), l = -s / 2, u = -o / 2, h = i.insert("rect", ":first-child");
  return h.attr("class", "text").attr("style", n).attr("rx", 0).attr("ry", 0).attr("x", l).attr("y", u).attr("width", s).attr("height", o), It(e, h), e.intersect = function(f) {
    return St.rect(e, f);
  }, i;
}
w(yJ, "text");
var A4e = /* @__PURE__ */ w((t, e, r, n, i, a) => `M${t},${e}
    a${i},${a} 0,0,1 0,${-n}
    l${r},0
    a${i},${a} 0,0,1 0,${n}
    M${r},${-n}
    a${i},${a} 0,0,0 0,${n}
    l${-r},0`, "createCylinderPathD"), L4e = /* @__PURE__ */ w((t, e, r, n, i, a) => [
  `M${t},${e}`,
  `M${t + r},${e}`,
  `a${i},${a} 0,0,0 0,${-n}`,
  `l${-r},0`,
  `a${i},${a} 0,0,0 0,${n}`,
  `l${r},0`
].join(" "), "createOuterCylinderPathD"), R4e = /* @__PURE__ */ w((t, e, r, n, i, a) => [`M${t + r / 2},${-n / 2}`, `a${i},${a} 0,0,0 0,${n}`].join(" "), "createInnerCylinderPathD");
async function bJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s, halfPadding: o } = await Ht(
    t,
    e,
    zt(e)
  ), l = e.look === "neo" ? o * 2 : o, u = a.height + l, h = u / 2, f = h / (2.5 + u / 50), d = a.width + f + l, { cssStyles: p } = e;
  let g;
  if (e.look === "handDrawn") {
    const m = Lt.svg(i), v = L4e(0, 0, d, u, f, h), y = R4e(0, 0, d, u, f, h), b = m.path(v, Rt(e, {})), x = m.path(y, Rt(e, { fill: "none" }));
    g = i.insert(() => x, ":first-child"), g = i.insert(() => b, ":first-child"), g.attr("class", "basic label-container"), p && g.attr("style", p);
  } else {
    const m = A4e(0, 0, d, u, f, h);
    g = i.insert("path", ":first-child").attr("d", m).attr("class", "basic label-container").attr("style", Ai(p)).attr("style", n), g.attr("class", "basic label-container"), p && g.selectAll("path").attr("style", p), n && g.selectAll("path").attr("style", n);
  }
  return g.attr("label-offset-x", f), g.attr("transform", `translate(${-d / 2}, ${u / 2} )`), s.attr(
    "transform",
    `translate(${-(a.width / 2) - f - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`
  ), It(e, g), e.intersect = function(m) {
    const v = St.rect(e, m), y = v.y - (e.y ?? 0);
    if (h != 0 && (Math.abs(y) < (e.height ?? 0) / 2 || Math.abs(y) == (e.height ?? 0) / 2 && Math.abs(v.x - (e.x ?? 0)) > (e.width ?? 0) / 2 - f)) {
      let b = f * f * (1 - y * y / (h * h));
      b != 0 && (b = Math.sqrt(Math.abs(b))), b = f - b, m.x - (e.x ?? 0) > 0 && (b = -b), v.x += b;
    }
    return v;
  }, i;
}
w(bJ, "tiltedCylinder");
async function xJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = a.width + e.padding, o = a.height + e.padding, l = [
    { x: -3 * o / 6, y: 0 },
    { x: s + 3 * o / 6, y: 0 },
    { x: s, y: -o },
    { x: 0, y: -o }
  ];
  let u;
  const { cssStyles: h } = e;
  if (e.look === "handDrawn") {
    const f = Lt.svg(i), d = Rt(e, {}), p = or(l), g = f.path(p, d);
    u = i.insert(() => g, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), h && u.attr("style", h);
  } else
    u = Fc(i, s, o, l);
  return n && u.attr("style", n), e.width = s, e.height = o, It(e, u), e.intersect = function(f) {
    return St.polygon(e, l, f);
  }, i;
}
w(xJ, "trapezoid");
async function wJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = 60, o = 20, l = Math.max(s, a.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(o, a.height + (e.padding ?? 0) * 2, e?.height ?? 0), { cssStyles: h } = e, f = Lt.svg(i), d = Rt(e, {});
  e.look !== "handDrawn" && (d.roughness = 0, d.fillStyle = "solid");
  const p = [
    { x: -l / 2 * 0.8, y: -u / 2 },
    { x: l / 2 * 0.8, y: -u / 2 },
    { x: l / 2, y: -u / 2 * 0.6 },
    { x: l / 2, y: u / 2 },
    { x: -l / 2, y: u / 2 },
    { x: -l / 2, y: -u / 2 * 0.6 }
  ], g = or(p), m = f.path(g, d), v = i.insert(() => m, ":first-child");
  return v.attr("class", "basic label-container"), h && e.look !== "handDrawn" && v.selectChildren("path").attr("style", h), n && e.look !== "handDrawn" && v.selectChildren("path").attr("style", n), It(e, v), e.intersect = function(y) {
    return St.polygon(e, p, y);
  }, i;
}
w(wJ, "trapezoidalPentagon");
async function TJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Nr(Te().flowchart?.htmlLabels), l = a.width + (e.padding ?? 0), u = l + a.height, h = l + a.height, f = [
    { x: 0, y: 0 },
    { x: h, y: 0 },
    { x: h / 2, y: -u }
  ], { cssStyles: d } = e, p = Lt.svg(i), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = or(f), v = p.path(m, g), y = i.insert(() => v, ":first-child").attr("transform", `translate(${-u / 2}, ${u / 2})`);
  return d && e.look !== "handDrawn" && y.selectChildren("path").attr("style", d), n && e.look !== "handDrawn" && y.selectChildren("path").attr("style", n), e.width = l, e.height = u, It(e, y), s.attr(
    "transform",
    `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${u / 2 - (a.height + (e.padding ?? 0) / (o ? 2 : 1) - (a.y - (a.top ?? 0)))})`
  ), e.intersect = function(b) {
    return ae.info("Triangle intersect", e, f, b), St.polygon(e, f, b);
  }, i;
}
w(TJ, "triangle");
async function EJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = l / 8, h = l + u, { cssStyles: f } = e, p = 70 - o, g = p > 0 ? p / 2 : 0, m = Lt.svg(i), v = Rt(e, {});
  e.look !== "handDrawn" && (v.roughness = 0, v.fillStyle = "solid");
  const y = [
    { x: -o / 2 - g, y: h / 2 },
    ...pc(
      -o / 2 - g,
      h / 2,
      o / 2 + g,
      h / 2,
      u,
      0.8
    ),
    { x: o / 2 + g, y: -h / 2 },
    { x: -o / 2 - g, y: -h / 2 }
  ], b = or(y), x = m.path(b, v), T = i.insert(() => x, ":first-child");
  return T.attr("class", "basic label-container"), f && e.look !== "handDrawn" && T.selectAll("path").attr("style", f), n && e.look !== "handDrawn" && T.selectAll("path").attr("style", n), T.attr("transform", `translate(0,${-u / 2})`), s.attr(
    "transform",
    `translate(${-o / 2 + (e.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (e.padding ?? 0) - u - (a.y - (a.top ?? 0))})`
  ), It(e, T), e.intersect = function(E) {
    return St.polygon(e, y, E);
  }, i;
}
w(EJ, "waveEdgedRectangle");
async function SJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Ht(t, e, zt(e)), s = 100, o = 50, l = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), u = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), h = l / u;
  let f = l, d = u;
  f > d * h ? d = f / h : f = d * h, f = Math.max(f, s), d = Math.max(d, o);
  const p = Math.min(d * 0.2, d / 4), g = d + p * 2, { cssStyles: m } = e, v = Lt.svg(i), y = Rt(e, {});
  e.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const b = [
    { x: -f / 2, y: g / 2 },
    ...pc(-f / 2, g / 2, f / 2, g / 2, p, 1),
    { x: f / 2, y: -g / 2 },
    ...pc(f / 2, -g / 2, -f / 2, -g / 2, p, -1)
  ], x = or(b), T = v.path(x, y), E = i.insert(() => T, ":first-child");
  return E.attr("class", "basic label-container"), m && e.look !== "handDrawn" && E.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && E.selectAll("path").attr("style", n), It(e, E), e.intersect = function(A) {
    return St.polygon(e, b, A);
  }, i;
}
w(SJ, "waveRectangle");
async function kJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: s } = await Ht(t, e, zt(e)), o = Math.max(a.width + (e.padding ?? 0) * 2, e?.width ?? 0), l = Math.max(a.height + (e.padding ?? 0) * 2, e?.height ?? 0), u = 5, h = -o / 2, f = -l / 2, { cssStyles: d } = e, p = Lt.svg(i), g = Rt(e, {}), m = [
    { x: h - u, y: f - u },
    { x: h - u, y: f + l },
    { x: h + o, y: f + l },
    { x: h + o, y: f - u }
  ], v = `M${h - u},${f - u} L${h + o},${f - u} L${h + o},${f + l} L${h - u},${f + l} L${h - u},${f - u}
                M${h - u},${f} L${h + o},${f}
                M${h},${f - u} L${h},${f + l}`;
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const y = p.path(v, g), b = i.insert(() => y, ":first-child");
  return b.attr("transform", `translate(${u / 2}, ${u / 2})`), b.attr("class", "basic label-container"), d && e.look !== "handDrawn" && b.selectAll("path").attr("style", d), n && e.look !== "handDrawn" && b.selectAll("path").attr("style", n), s.attr(
    "transform",
    `translate(${-(a.width / 2) + u / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + u / 2 - (a.y - (a.top ?? 0))})`
  ), It(e, b), e.intersect = function(x) {
    return St.polygon(e, m, x);
  }, i;
}
w(kJ, "windowPane");
async function uL(t, e) {
  const r = e;
  if (r.alias && (e.label = r.alias), e.look === "handDrawn") {
    const { themeVariables: G } = mr(), { background: W } = G, V = {
      ...e,
      id: e.id + "-background",
      look: "default",
      cssStyles: ["stroke: none", `fill: ${W}`]
    };
    await uL(t, V);
  }
  const n = mr();
  e.useHtmlLabels = n.htmlLabels;
  let i = n.er?.diagramPadding ?? 10, a = n.er?.entityPadding ?? 6;
  const { cssStyles: s } = e, { labelStyles: o, nodeStyles: l } = kt(e);
  if (r.attributes.length === 0 && e.label) {
    const G = {
      rx: 0,
      ry: 0,
      labelPaddingX: i,
      labelPaddingY: i * 1.5
    };
    Vi(e.label, n) + G.labelPaddingX * 2 < n.er.minEntityWidth && (e.width = n.er.minEntityWidth);
    const W = await h4(t, e, G);
    if (!Nr(n.htmlLabels)) {
      const V = W.select("text"), U = V.node()?.getBBox();
      V.attr("transform", `translate(${-U.width / 2}, 0)`);
    }
    return W;
  }
  n.htmlLabels || (i *= 1.25, a *= 1.25);
  let u = zt(e);
  u || (u = "node default");
  const h = t.insert("g").attr("class", u).attr("id", e.domId || e.id), f = await pf(h, e.label ?? "", n, 0, 0, ["name"], o);
  f.height += a;
  let d = 0;
  const p = [], g = [];
  let m = 0, v = 0, y = 0, b = 0, x = !0, T = !0;
  for (const G of r.attributes) {
    const W = await pf(
      h,
      G.type,
      n,
      0,
      d,
      ["attribute-type"],
      o
    );
    m = Math.max(m, W.width + i);
    const V = await pf(
      h,
      G.name,
      n,
      0,
      d,
      ["attribute-name"],
      o
    );
    v = Math.max(v, V.width + i);
    const U = await pf(
      h,
      G.keys.join(),
      n,
      0,
      d,
      ["attribute-keys"],
      o
    );
    y = Math.max(y, U.width + i);
    const Z = await pf(
      h,
      G.comment,
      n,
      0,
      d,
      ["attribute-comment"],
      o
    );
    b = Math.max(b, Z.width + i);
    const K = Math.max(W.height, V.height, U.height, Z.height) + a;
    g.push({ yOffset: d, rowHeight: K }), d += K;
  }
  let E = 4;
  y <= i && (x = !1, y = 0, E--), b <= i && (T = !1, b = 0, E--);
  const A = h.node().getBBox();
  if (f.width + i * 2 - (m + v + y + b) > 0) {
    const G = f.width + i * 2 - (m + v + y + b);
    m += G / E, v += G / E, y > 0 && (y += G / E), b > 0 && (b += G / E);
  }
  const S = m + v + y + b, k = Lt.svg(h), _ = Rt(e, {});
  e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
  let R = 0;
  g.length > 0 && (R = g.reduce((G, W) => G + (W?.rowHeight ?? 0), 0));
  const L = Math.max(A.width + i * 2, e?.width || 0, S), M = Math.max((R ?? 0) + f.height, e?.height || 0), P = -L / 2, C = -M / 2;
  h.selectAll("g:not(:first-child)").each((G, W, V) => {
    const U = Qe(V[W]), Z = U.attr("transform");
    let K = 0, ce = 0;
    if (Z) {
      const ee = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(Z);
      ee && (K = parseFloat(ee[1]), ce = parseFloat(ee[2]), U.attr("class").includes("attribute-name") ? K += m : U.attr("class").includes("attribute-keys") ? K += m + v : U.attr("class").includes("attribute-comment") && (K += m + v + y));
    }
    U.attr(
      "transform",
      `translate(${P + i / 2 + K}, ${ce + C + f.height + a / 2})`
    );
  }), h.select(".name").attr("transform", "translate(" + -f.width / 2 + ", " + (C + a / 2) + ")");
  const I = k.rectangle(P, C, L, M, _), N = h.insert(() => I, ":first-child").attr("style", s.join("")), { themeVariables: O } = mr(), { rowEven: D, rowOdd: $, nodeBorder: z } = O;
  p.push(0);
  for (const [G, W] of g.entries()) {
    const U = (G + 1) % 2 === 0 && W.yOffset !== 0, Z = k.rectangle(P, f.height + C + W?.yOffset, L, W?.rowHeight, {
      ..._,
      fill: U ? D : $,
      stroke: z
    });
    h.insert(() => Z, "g.label").attr("style", s.join("")).attr("class", `row-rect-${U ? "even" : "odd"}`);
  }
  let B = k.line(P, f.height + C, L + P, f.height + C, _);
  h.insert(() => B).attr("class", "divider"), B = k.line(m + P, f.height + C, m + P, M + C, _), h.insert(() => B).attr("class", "divider"), x && (B = k.line(
    m + v + P,
    f.height + C,
    m + v + P,
    M + C,
    _
  ), h.insert(() => B).attr("class", "divider")), T && (B = k.line(
    m + v + y + P,
    f.height + C,
    m + v + y + P,
    M + C,
    _
  ), h.insert(() => B).attr("class", "divider"));
  for (const G of p)
    B = k.line(
      P,
      f.height + C + G,
      L + P,
      f.height + C + G,
      _
    ), h.insert(() => B).attr("class", "divider");
  if (It(e, N), l && e.look !== "handDrawn") {
    const W = l.split(";")?.filter((V) => V.includes("stroke"))?.map((V) => `${V}`).join("; ");
    h.selectAll("path").attr("style", W ?? ""), h.selectAll(".row-rect-even path").attr("style", l);
  }
  return e.intersect = function(G) {
    return St.rect(e, G);
  }, h;
}
w(uL, "erBox");
async function pf(t, e, r, n = 0, i = 0, a = [], s = "") {
  const o = t.insert("g").attr("class", `label ${a.join(" ")}`).attr("transform", `translate(${n}, ${i})`).attr("style", s);
  e !== Hl(e) && (e = Hl(e), e = e.replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
  const l = o.node().appendChild(
    await Na(
      o,
      e,
      {
        width: Vi(e, r) + 100,
        style: s,
        useHtmlLabels: r.htmlLabels
      },
      r
    )
  );
  if (e.includes("&lt;") || e.includes("&gt;")) {
    let h = l.children[0];
    for (h.textContent = h.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); h.childNodes[0]; )
      h = h.childNodes[0], h.textContent = h.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
  }
  let u = l.getBBox();
  if (Nr(r.htmlLabels)) {
    const h = l.children[0];
    h.style.textAlign = "start";
    const f = Qe(l);
    u = h.getBoundingClientRect(), f.attr("width", u.width), f.attr("height", u.height);
  }
  return u;
}
w(pf, "addText");
async function CJ(t, e, r, n, i = r.class.padding ?? 12) {
  const a = n ? 0 : 3, s = t.insert("g").attr("class", zt(e)).attr("id", e.domId || e.id);
  let o = null, l = null, u = null, h = null, f = 0, d = 0, p = 0;
  if (o = s.insert("g").attr("class", "annotation-group text"), e.annotations.length > 0) {
    const b = e.annotations[0];
    await Op(o, { text: `\xAB${b}\xBB` }, 0), f = o.node().getBBox().height;
  }
  l = s.insert("g").attr("class", "label-group text"), await Op(l, e, 0, ["font-weight: bolder"]);
  const g = l.node().getBBox();
  d = g.height, u = s.insert("g").attr("class", "members-group text");
  let m = 0;
  for (const b of e.members) {
    const x = await Op(u, b, m, [b.parseClassifier()]);
    m += x + a;
  }
  p = u.node().getBBox().height, p <= 0 && (p = i / 2), h = s.insert("g").attr("class", "methods-group text");
  let v = 0;
  for (const b of e.methods) {
    const x = await Op(h, b, v, [b.parseClassifier()]);
    v += x + a;
  }
  let y = s.node().getBBox();
  if (o !== null) {
    const b = o.node().getBBox();
    o.attr("transform", `translate(${-b.width / 2})`);
  }
  return l.attr("transform", `translate(${-g.width / 2}, ${f})`), y = s.node().getBBox(), u.attr(
    "transform",
    `translate(0, ${f + d + i * 2})`
  ), y = s.node().getBBox(), h.attr(
    "transform",
    `translate(0, ${f + d + (p ? p + i * 4 : i * 2)})`
  ), y = s.node().getBBox(), { shapeSvg: s, bbox: y };
}
w(CJ, "textHelper");
async function Op(t, e, r, n = []) {
  const i = t.insert("g").attr("class", "label").attr("style", n.join("; ")), a = mr();
  let s = "useHtmlLabels" in e ? e.useHtmlLabels : Nr(a.htmlLabels) ?? !0, o = "";
  "text" in e ? o = e.text : o = e.label, !s && o.startsWith("\\") && (o = o.substring(1)), dn(o) && (s = !0);
  const l = await Na(
    i,
    g9(mo(o)),
    {
      width: Vi(o, a) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: s
    },
    a
  );
  let u, h = 1;
  if (s) {
    const f = l.children[0], d = Qe(l);
    h = f.innerHTML.split("<br>").length, f.innerHTML.includes("</math>") && (h += f.innerHTML.split("<mrow>").length - 1);
    const p = f.getElementsByTagName("img");
    if (p) {
      const g = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...p].map(
          (m) => new Promise((v) => {
            function y() {
              if (m.style.display = "flex", m.style.flexDirection = "column", g) {
                const b = a.fontSize?.toString() ?? window.getComputedStyle(document.body).fontSize, T = parseInt(b, 10) * 5 + "px";
                m.style.minWidth = T, m.style.maxWidth = T;
              } else
                m.style.width = "100%";
              v(m);
            }
            w(y, "setupImage"), setTimeout(() => {
              m.complete && y();
            }), m.addEventListener("error", y), m.addEventListener("load", y);
          })
        )
      );
    }
    u = f.getBoundingClientRect(), d.attr("width", u.width), d.attr("height", u.height);
  } else {
    n.includes("font-weight: bolder") && Qe(l).selectAll("tspan").attr("font-weight", ""), h = l.children.length;
    const f = l.children[0];
    (l.textContent === "" || l.textContent.includes("&gt")) && (f.textContent = o[0] + o.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(), o[1] === " " && (f.textContent = f.textContent[0] + " " + f.textContent.substring(1))), f.textContent === "undefined" && (f.textContent = ""), u = l.getBBox();
  }
  return i.attr("transform", "translate(0," + (-u.height / (2 * h) + r) + ")"), u.height;
}
w(Op, "addText");
async function _J(t, e) {
  const r = Te(), n = r.class.padding ?? 12, i = n, a = e.useHtmlLabels ?? Nr(r.htmlLabels) ?? !0, s = e;
  s.annotations = s.annotations ?? [], s.members = s.members ?? [], s.methods = s.methods ?? [];
  const { shapeSvg: o, bbox: l } = await CJ(t, e, r, a, i), { labelStyles: u, nodeStyles: h } = kt(e);
  e.labelStyle = u, e.cssStyles = s.styles || "";
  const f = s.styles?.join(";") || h || "";
  e.cssStyles || (e.cssStyles = f.replaceAll("!important", "").split(";"));
  const d = s.members.length === 0 && s.methods.length === 0 && !r.class?.hideEmptyMembersBox, p = Lt.svg(o), g = Rt(e, {});
  e.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const m = l.width;
  let v = l.height;
  s.members.length === 0 && s.methods.length === 0 ? v += i : s.members.length > 0 && s.methods.length === 0 && (v += i * 2);
  const y = -m / 2, b = -v / 2, x = p.rectangle(
    y - n,
    b - n - (d ? n : s.members.length === 0 && s.methods.length === 0 ? -n / 2 : 0),
    m + 2 * n,
    v + 2 * n + (d ? n * 2 : s.members.length === 0 && s.methods.length === 0 ? -n : 0),
    g
  ), T = o.insert(() => x, ":first-child");
  T.attr("class", "basic label-container");
  const E = T.node().getBBox();
  o.selectAll(".text").each((_, R, L) => {
    const M = Qe(L[R]), P = M.attr("transform");
    let C = 0;
    if (P) {
      const D = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(P);
      D && (C = parseFloat(D[2]));
    }
    let I = C + b + n - (d ? n : s.members.length === 0 && s.methods.length === 0 ? -n / 2 : 0);
    a || (I -= 4);
    let N = y;
    (M.attr("class").includes("label-group") || M.attr("class").includes("annotation-group")) && (N = -M.node()?.getBBox().width / 2 || 0, o.selectAll("text").each(function(O, D, $) {
      window.getComputedStyle($[D]).textAnchor === "middle" && (N = 0);
    })), M.attr("transform", `translate(${N}, ${I})`);
  });
  const A = o.select(".annotation-group").node().getBBox().height - (d ? n / 2 : 0) || 0, S = o.select(".label-group").node().getBBox().height - (d ? n / 2 : 0) || 0, k = o.select(".members-group").node().getBBox().height - (d ? n / 2 : 0) || 0;
  if (s.members.length > 0 || s.methods.length > 0 || d) {
    const _ = p.line(
      E.x,
      A + S + b + n,
      E.x + E.width,
      A + S + b + n,
      g
    );
    o.insert(() => _).attr("class", "divider").attr("style", f);
  }
  if (d || s.members.length > 0 || s.methods.length > 0) {
    const _ = p.line(
      E.x,
      A + S + k + b + i * 2 + n,
      E.x + E.width,
      A + S + k + b + n + i * 2,
      g
    );
    o.insert(() => _).attr("class", "divider").attr("style", f);
  }
  if (s.look !== "handDrawn" && o.selectAll("path").attr("style", f), T.select(":nth-child(2)").attr("style", f), o.selectAll(".divider").select("path").attr("style", f), e.labelStyle ? o.selectAll("span").attr("style", e.labelStyle) : o.selectAll("span").attr("style", f), !a) {
    const _ = RegExp(/color\s*:\s*([^;]*)/), R = _.exec(f);
    if (R) {
      const L = R[0].replace("color", "fill");
      o.selectAll("tspan").attr("style", L);
    } else if (u) {
      const L = _.exec(u);
      if (L) {
        const M = L[0].replace("color", "fill");
        o.selectAll("tspan").attr("style", M);
      }
    }
  }
  return It(e, T), e.intersect = function(_) {
    return St.rect(e, _);
  }, o;
}
w(_J, "classBox");
async function AJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const i = e, a = e, s = 20, o = 20, l = "verifyMethod" in e, u = zt(e), h = t.insert("g").attr("class", u).attr("id", e.domId ?? e.id);
  let f;
  l ? f = await Xs(
    h,
    `&lt;&lt;${i.type}&gt;&gt;`,
    0,
    e.labelStyle
  ) : f = await Xs(h, "&lt;&lt;Element&gt;&gt;", 0, e.labelStyle);
  let d = f;
  const p = await Xs(
    h,
    i.name,
    d,
    e.labelStyle + "; font-weight: bold;"
  );
  if (d += p + o, l) {
    const A = await Xs(
      h,
      `${i.requirementId ? `ID: ${i.requirementId}` : ""}`,
      d,
      e.labelStyle
    );
    d += A;
    const S = await Xs(
      h,
      `${i.text ? `Text: ${i.text}` : ""}`,
      d,
      e.labelStyle
    );
    d += S;
    const k = await Xs(
      h,
      `${i.risk ? `Risk: ${i.risk}` : ""}`,
      d,
      e.labelStyle
    );
    d += k, await Xs(
      h,
      `${i.verifyMethod ? `Verification: ${i.verifyMethod}` : ""}`,
      d,
      e.labelStyle
    );
  } else {
    const A = await Xs(
      h,
      `${a.type ? `Type: ${a.type}` : ""}`,
      d,
      e.labelStyle
    );
    d += A, await Xs(
      h,
      `${a.docRef ? `Doc Ref: ${a.docRef}` : ""}`,
      d,
      e.labelStyle
    );
  }
  const g = (h.node()?.getBBox().width ?? 200) + s, m = (h.node()?.getBBox().height ?? 200) + s, v = -g / 2, y = -m / 2, b = Lt.svg(h), x = Rt(e, {});
  e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const T = b.rectangle(v, y, g, m, x), E = h.insert(() => T, ":first-child");
  if (E.attr("class", "basic label-container").attr("style", n), h.selectAll(".label").each((A, S, k) => {
    const _ = Qe(k[S]), R = _.attr("transform");
    let L = 0, M = 0;
    if (R) {
      const N = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(R);
      N && (L = parseFloat(N[1]), M = parseFloat(N[2]));
    }
    const P = M - m / 2;
    let C = v + s / 2;
    (S === 0 || S === 1) && (C = L), _.attr("transform", `translate(${C}, ${P + s})`);
  }), d > f + p + o) {
    const A = b.line(
      v,
      y + f + p + o,
      v + g,
      y + f + p + o,
      x
    );
    h.insert(() => A).attr("style", n);
  }
  return It(e, E), e.intersect = function(A) {
    return St.rect(e, A);
  }, h;
}
w(AJ, "requirementBox");
async function Xs(t, e, r, n = "") {
  if (e === "")
    return 0;
  const i = t.insert("g").attr("class", "label").attr("style", n), a = Te(), s = a.htmlLabels ?? !0, o = await Na(
    i,
    g9(mo(e)),
    {
      width: Vi(e, a) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: s,
      style: n
    },
    a
  );
  let l;
  if (s) {
    const u = o.children[0], h = Qe(o);
    l = u.getBoundingClientRect(), h.attr("width", l.width), h.attr("height", l.height);
  } else {
    const u = o.children[0];
    for (const h of u.children)
      h.textContent = h.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"), n && h.setAttribute("style", n);
    l = o.getBBox(), l.height += 6;
  }
  return i.attr("transform", `translate(${-l.width / 2},${-l.height / 2 + r})`), l.height;
}
w(Xs, "addText");
var I4e = /* @__PURE__ */ w((t) => {
  switch (t) {
    case "Very High":
      return "red";
    case "High":
      return "orange";
    case "Medium":
      return null;
    // no stroke
    case "Low":
      return "blue";
    case "Very Low":
      return "lightblue";
  }
}, "colorFromPriority");
async function LJ(t, e, { config: r }) {
  const { labelStyles: n, nodeStyles: i } = kt(e);
  e.labelStyle = n || "";
  const a = 10, s = e.width;
  e.width = (e.width ?? 200) - 10;
  const {
    shapeSvg: o,
    bbox: l,
    label: u
  } = await Ht(t, e, zt(e)), h = e.padding || 10;
  let f = "", d;
  "ticket" in e && e.ticket && r?.kanban?.ticketBaseUrl && (f = r?.kanban?.ticketBaseUrl.replace("#TICKET#", e.ticket), d = o.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", f).attr("target", "_blank"));
  const p = {
    useHtmlLabels: e.useHtmlLabels,
    labelStyle: e.labelStyle || "",
    width: e.width,
    img: e.img,
    padding: e.padding || 8,
    centerLabel: !1
  };
  let g, m;
  d ? { label: g, bbox: m } = await z5(
    d,
    "ticket" in e && e.ticket || "",
    p
  ) : { label: g, bbox: m } = await z5(
    o,
    "ticket" in e && e.ticket || "",
    p
  );
  const { label: v, bbox: y } = await z5(
    o,
    "assigned" in e && e.assigned || "",
    p
  );
  e.width = s;
  const b = 10, x = e?.width || 0, T = Math.max(m.height, y.height) / 2, E = Math.max(l.height + b * 2, e?.height || 0) + T, A = -x / 2, S = -E / 2;
  u.attr(
    "transform",
    "translate(" + (h - x / 2) + ", " + (-T - l.height / 2) + ")"
  ), g.attr(
    "transform",
    "translate(" + (h - x / 2) + ", " + (-T + l.height / 2) + ")"
  ), v.attr(
    "transform",
    "translate(" + (h + x / 2 - y.width - 2 * a) + ", " + (-T + l.height / 2) + ")"
  );
  let k;
  const { rx: _, ry: R } = e, { cssStyles: L } = e;
  if (e.look === "handDrawn") {
    const M = Lt.svg(o), P = Rt(e, {}), C = _ || R ? M.path(Bc(A, S, x, E, _ || 0), P) : M.rectangle(A, S, x, E, P);
    k = o.insert(() => C, ":first-child"), k.attr("class", "basic label-container").attr("style", L || null);
  } else {
    k = o.insert("rect", ":first-child"), k.attr("class", "basic label-container __APA__").attr("style", i).attr("rx", _ ?? 5).attr("ry", R ?? 5).attr("x", A).attr("y", S).attr("width", x).attr("height", E);
    const M = "priority" in e && e.priority;
    if (M) {
      const P = o.append("line"), C = A + 2, I = S + Math.floor((_ ?? 0) / 2), N = S + E - Math.floor((_ ?? 0) / 2);
      P.attr("x1", C).attr("y1", I).attr("x2", C).attr("y2", N).attr("stroke-width", "4").attr("stroke", I4e(M));
    }
  }
  return It(e, k), e.height = E, e.intersect = function(M) {
    return St.rect(e, M);
  }, o;
}
w(LJ, "kanbanItem");
async function RJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s, label: o } = await Ht(
    t,
    e,
    zt(e)
  ), l = a.width + 10 * s, u = a.height + 8 * s, h = 0.15 * l, { cssStyles: f } = e, d = a.width + 20, p = a.height + 20, g = Math.max(l, d), m = Math.max(u, p);
  o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`);
  let v;
  const y = `M0 0 
    a${h},${h} 1 0,0 ${g * 0.25},${-1 * m * 0.1}
    a${h},${h} 1 0,0 ${g * 0.25},0
    a${h},${h} 1 0,0 ${g * 0.25},0
    a${h},${h} 1 0,0 ${g * 0.25},${m * 0.1}

    a${h},${h} 1 0,0 ${g * 0.15},${m * 0.33}
    a${h * 0.8},${h * 0.8} 1 0,0 0,${m * 0.34}
    a${h},${h} 1 0,0 ${-1 * g * 0.15},${m * 0.33}

    a${h},${h} 1 0,0 ${-1 * g * 0.25},${m * 0.15}
    a${h},${h} 1 0,0 ${-1 * g * 0.25},0
    a${h},${h} 1 0,0 ${-1 * g * 0.25},0
    a${h},${h} 1 0,0 ${-1 * g * 0.25},${-1 * m * 0.15}

    a${h},${h} 1 0,0 ${-1 * g * 0.1},${-1 * m * 0.33}
    a${h * 0.8},${h * 0.8} 1 0,0 0,${-1 * m * 0.34}
    a${h},${h} 1 0,0 ${g * 0.1},${-1 * m * 0.33}
  H0 V0 Z`;
  if (e.look === "handDrawn") {
    const b = Lt.svg(i), x = Rt(e, {}), T = b.path(y, x);
    v = i.insert(() => T, ":first-child"), v.attr("class", "basic label-container").attr("style", Ai(f));
  } else
    v = i.insert("path", ":first-child").attr("class", "basic label-container").attr("style", n).attr("d", y);
  return v.attr("transform", `translate(${-g / 2}, ${-m / 2})`), It(e, v), e.calcIntersect = function(b, x) {
    return St.rect(b, x);
  }, e.intersect = function(b) {
    return ae.info("Bang intersect", e, b), St.rect(e, b);
  }, i;
}
w(RJ, "bang");
async function IJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s, label: o } = await Ht(
    t,
    e,
    zt(e)
  ), l = a.width + 2 * s, u = a.height + 2 * s, h = 0.15 * l, f = 0.25 * l, d = 0.35 * l, p = 0.2 * l, { cssStyles: g } = e;
  let m;
  const v = `M0 0 
    a${h},${h} 0 0,1 ${l * 0.25},${-1 * l * 0.1}
    a${d},${d} 1 0,1 ${l * 0.4},${-1 * l * 0.1}
    a${f},${f} 1 0,1 ${l * 0.35},${l * 0.2}

    a${h},${h} 1 0,1 ${l * 0.15},${u * 0.35}
    a${p},${p} 1 0,1 ${-1 * l * 0.15},${u * 0.65}

    a${f},${h} 1 0,1 ${-1 * l * 0.25},${l * 0.15}
    a${d},${d} 1 0,1 ${-1 * l * 0.5},0
    a${h},${h} 1 0,1 ${-1 * l * 0.25},${-1 * l * 0.15}

    a${h},${h} 1 0,1 ${-1 * l * 0.1},${-1 * u * 0.35}
    a${p},${p} 1 0,1 ${l * 0.1},${-1 * u * 0.65}
  H0 V0 Z`;
  if (e.look === "handDrawn") {
    const y = Lt.svg(i), b = Rt(e, {}), x = y.path(v, b);
    m = i.insert(() => x, ":first-child"), m.attr("class", "basic label-container").attr("style", Ai(g));
  } else
    m = i.insert("path", ":first-child").attr("class", "basic label-container").attr("style", n).attr("d", v);
  return o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), m.attr("transform", `translate(${-l / 2}, ${-u / 2})`), It(e, m), e.calcIntersect = function(y, b) {
    return St.rect(y, b);
  }, e.intersect = function(y) {
    return ae.info("Cloud intersect", e, y), St.rect(e, y);
  }, i;
}
w(IJ, "cloud");
async function MJ(t, e) {
  const { labelStyles: r, nodeStyles: n } = kt(e);
  e.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: s, label: o } = await Ht(
    t,
    e,
    zt(e)
  ), l = a.width + 8 * s, u = a.height + 2 * s, h = 5, f = `
    M${-l / 2} ${u / 2 - h}
    v${-u + 2 * h}
    q0,-${h} ${h},-${h}
    h${l - 2 * h}
    q${h},0 ${h},${h}
    v${u - 2 * h}
    q0,${h} -${h},${h}
    h${-l + 2 * h}
    q-${h},0 -${h},-${h}
    Z
  `, d = i.append("path").attr("id", "node-" + e.id).attr("class", "node-bkg node-" + e.type).attr("style", n).attr("d", f);
  return i.append("line").attr("class", "node-line-").attr("x1", -l / 2).attr("y1", u / 2).attr("x2", l / 2).attr("y2", u / 2), o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), i.append(() => o.node()), It(e, d), e.calcIntersect = function(p, g) {
    return St.rect(p, g);
  }, e.intersect = function(p) {
    return St.rect(e, p);
  }, i;
}
w(MJ, "defaultMindmapNode");
async function NJ(t, e) {
  const r = {
    padding: e.padding ?? 0
  };
  return cL(t, e, r);
}
w(NJ, "mindmapCircle");
var M4e = [
  {
    semanticName: "Process",
    name: "Rectangle",
    shortName: "rect",
    description: "Standard process shape",
    aliases: ["proc", "process", "rectangle"],
    internalAliases: ["squareRect"],
    handler: uJ
  },
  {
    semanticName: "Event",
    name: "Rounded Rectangle",
    shortName: "rounded",
    description: "Represents an event",
    aliases: ["event"],
    internalAliases: ["roundedRect"],
    handler: oJ
  },
  {
    semanticName: "Terminal Point",
    name: "Stadium",
    shortName: "stadium",
    description: "Terminal point",
    aliases: ["terminal", "pill"],
    handler: hJ
  },
  {
    semanticName: "Subprocess",
    name: "Framed Rectangle",
    shortName: "fr-rect",
    description: "Subprocess",
    aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
    handler: gJ
  },
  {
    semanticName: "Database",
    name: "Cylinder",
    shortName: "cyl",
    description: "Database storage",
    aliases: ["db", "database", "cylinder"],
    handler: DQ
  },
  {
    semanticName: "Start",
    name: "Circle",
    shortName: "circle",
    description: "Starting point",
    aliases: ["circ"],
    handler: cL
  },
  {
    semanticName: "Bang",
    name: "Bang",
    shortName: "bang",
    description: "Bang",
    aliases: ["bang"],
    handler: RJ
  },
  {
    semanticName: "Cloud",
    name: "Cloud",
    shortName: "cloud",
    description: "cloud",
    aliases: ["cloud"],
    handler: IJ
  },
  {
    semanticName: "Decision",
    name: "Diamond",
    shortName: "diam",
    description: "Decision-making step",
    aliases: ["decision", "diamond", "question"],
    handler: iJ
  },
  {
    semanticName: "Prepare Conditional",
    name: "Hexagon",
    shortName: "hex",
    description: "Preparation or condition step",
    aliases: ["hexagon", "prepare"],
    handler: qQ
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Right",
    shortName: "lean-r",
    description: "Represents input or output",
    aliases: ["lean-right", "in-out"],
    internalAliases: ["lean_right"],
    handler: ZQ
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Left",
    shortName: "lean-l",
    description: "Represents output or input",
    aliases: ["lean-left", "out-in"],
    internalAliases: ["lean_left"],
    handler: KQ
  },
  {
    semanticName: "Priority Action",
    name: "Trapezoid Base Bottom",
    shortName: "trap-b",
    description: "Priority action",
    aliases: ["priority", "trapezoid-bottom", "trapezoid"],
    handler: xJ
  },
  {
    semanticName: "Manual Operation",
    name: "Trapezoid Base Top",
    shortName: "trap-t",
    description: "Represents a manual task",
    aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
    internalAliases: ["inv_trapezoid"],
    handler: XQ
  },
  {
    semanticName: "Stop",
    name: "Double Circle",
    shortName: "dbl-circ",
    description: "Represents a stop point",
    aliases: ["double-circle"],
    internalAliases: ["doublecircle"],
    handler: PQ
  },
  {
    semanticName: "Text Block",
    name: "Text Block",
    shortName: "text",
    description: "Text block",
    handler: yJ
  },
  {
    semanticName: "Card",
    name: "Notched Rectangle",
    shortName: "notch-rect",
    description: "Represents a card",
    aliases: ["card", "notched-rectangle"],
    handler: CQ
  },
  {
    semanticName: "Lined/Shaded Process",
    name: "Lined Rectangle",
    shortName: "lin-rect",
    description: "Lined process shape",
    aliases: ["lined-rectangle", "lined-process", "lin-proc", "shaded-process"],
    handler: lJ
  },
  {
    semanticName: "Start",
    name: "Small Circle",
    shortName: "sm-circ",
    description: "Small starting point",
    aliases: ["start", "small-circle"],
    internalAliases: ["stateStart"],
    handler: pJ
  },
  {
    semanticName: "Stop",
    name: "Framed Circle",
    shortName: "fr-circ",
    description: "Stop point",
    aliases: ["stop", "framed-circle"],
    internalAliases: ["stateEnd"],
    handler: dJ
  },
  {
    semanticName: "Fork/Join",
    name: "Filled Rectangle",
    shortName: "fork",
    description: "Fork or join in process flow",
    aliases: ["join"],
    internalAliases: ["forkJoin"],
    handler: FQ
  },
  {
    semanticName: "Collate",
    name: "Hourglass",
    shortName: "hourglass",
    description: "Represents a collate operation",
    aliases: ["hourglass", "collate"],
    handler: GQ
  },
  {
    semanticName: "Comment",
    name: "Curly Brace",
    shortName: "brace",
    description: "Adds a comment",
    aliases: ["comment", "brace-l"],
    handler: RQ
  },
  {
    semanticName: "Comment Right",
    name: "Curly Brace",
    shortName: "brace-r",
    description: "Adds a comment",
    handler: IQ
  },
  {
    semanticName: "Comment with braces on both sides",
    name: "Curly Braces",
    shortName: "braces",
    description: "Adds a comment",
    handler: MQ
  },
  {
    semanticName: "Com Link",
    name: "Lightning Bolt",
    shortName: "bolt",
    description: "Communication link",
    aliases: ["com-link", "lightning-bolt"],
    handler: QQ
  },
  {
    semanticName: "Document",
    name: "Document",
    shortName: "doc",
    description: "Represents a document",
    aliases: ["doc", "document"],
    handler: EJ
  },
  {
    semanticName: "Delay",
    name: "Half-Rounded Rectangle",
    shortName: "delay",
    description: "Represents a delay",
    aliases: ["half-rounded-rectangle"],
    handler: zQ
  },
  {
    semanticName: "Direct Access Storage",
    name: "Horizontal Cylinder",
    shortName: "h-cyl",
    description: "Direct access storage",
    aliases: ["das", "horizontal-cylinder"],
    handler: bJ
  },
  {
    semanticName: "Disk Storage",
    name: "Lined Cylinder",
    shortName: "lin-cyl",
    description: "Disk storage",
    aliases: ["disk", "lined-cylinder"],
    handler: JQ
  },
  {
    semanticName: "Display",
    name: "Curved Trapezoid",
    shortName: "curv-trap",
    description: "Represents a display",
    aliases: ["curved-trapezoid", "display"],
    handler: NQ
  },
  {
    semanticName: "Divided Process",
    name: "Divided Rectangle",
    shortName: "div-rect",
    description: "Divided process shape",
    aliases: ["div-proc", "divided-rectangle", "divided-process"],
    handler: OQ
  },
  {
    semanticName: "Extract",
    name: "Triangle",
    shortName: "tri",
    description: "Extraction process",
    aliases: ["extract", "triangle"],
    handler: TJ
  },
  {
    semanticName: "Internal Storage",
    name: "Window Pane",
    shortName: "win-pane",
    description: "Internal storage",
    aliases: ["internal-storage", "window-pane"],
    handler: kJ
  },
  {
    semanticName: "Junction",
    name: "Filled Circle",
    shortName: "f-circ",
    description: "Junction point",
    aliases: ["junction", "filled-circle"],
    handler: $Q
  },
  {
    semanticName: "Loop Limit",
    name: "Trapezoidal Pentagon",
    shortName: "notch-pent",
    description: "Loop limit step",
    aliases: ["loop-limit", "notched-pentagon"],
    handler: wJ
  },
  {
    semanticName: "Manual File",
    name: "Flipped Triangle",
    shortName: "flip-tri",
    description: "Manual file operation",
    aliases: ["manual-file", "flipped-triangle"],
    handler: BQ
  },
  {
    semanticName: "Manual Input",
    name: "Sloped Rectangle",
    shortName: "sl-rect",
    description: "Manual input step",
    aliases: ["manual-input", "sloped-rectangle"],
    handler: cJ
  },
  {
    semanticName: "Multi-Document",
    name: "Stacked Document",
    shortName: "docs",
    description: "Multiple documents",
    aliases: ["documents", "st-doc", "stacked-document"],
    handler: rJ
  },
  {
    semanticName: "Multi-Process",
    name: "Stacked Rectangle",
    shortName: "st-rect",
    description: "Multiple processes",
    aliases: ["procs", "processes", "stacked-rectangle"],
    handler: tJ
  },
  {
    semanticName: "Stored Data",
    name: "Bow Tie Rectangle",
    shortName: "bow-rect",
    description: "Stored data",
    aliases: ["stored-data", "bow-tie-rectangle"],
    handler: kQ
  },
  {
    semanticName: "Summary",
    name: "Crossed Circle",
    shortName: "cross-circ",
    description: "Summary",
    aliases: ["summary", "crossed-circle"],
    handler: LQ
  },
  {
    semanticName: "Tagged Document",
    name: "Tagged Document",
    shortName: "tag-doc",
    description: "Tagged document",
    aliases: ["tag-doc", "tagged-document"],
    handler: vJ
  },
  {
    semanticName: "Tagged Process",
    name: "Tagged Rectangle",
    shortName: "tag-rect",
    description: "Tagged process",
    aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
    handler: mJ
  },
  {
    semanticName: "Paper Tape",
    name: "Flag",
    shortName: "flag",
    description: "Paper tape",
    aliases: ["paper-tape"],
    handler: SJ
  },
  {
    semanticName: "Odd",
    name: "Odd",
    shortName: "odd",
    description: "Odd shape",
    internalAliases: ["rect_left_inv_arrow"],
    handler: aJ
  },
  {
    semanticName: "Lined Document",
    name: "Lined Document",
    shortName: "lin-doc",
    description: "Lined document",
    aliases: ["lined-document"],
    handler: eJ
  }
], N4e = /* @__PURE__ */ w(() => {
  const e = [
    ...Object.entries({
      // States
      state: fJ,
      choice: _Q,
      note: nJ,
      // Rectangles
      rectWithTitle: sJ,
      labelRect: jQ,
      // Icons
      iconSquare: WQ,
      iconCircle: VQ,
      icon: UQ,
      iconRounded: HQ,
      imageSquare: YQ,
      anchor: SQ,
      // Kanban diagram
      kanbanItem: LJ,
      //Mindmap diagram
      mindmapCircle: NJ,
      defaultMindmapNode: MJ,
      // class diagram
      classBox: _J,
      // er diagram
      erBox: uL,
      // Requirement diagram
      requirementBox: AJ
    }),
    ...M4e.flatMap((r) => [
      r.shortName,
      ..."aliases" in r ? r.aliases : [],
      ..."internalAliases" in r ? r.internalAliases : []
    ].map((i) => [i, r.handler]))
  ];
  return Object.fromEntries(e);
}, "generateShapeMap"), DJ = N4e();
function OJ(t) {
  return t in DJ;
}
w(OJ, "isValidShape");
var f4 = /* @__PURE__ */ new Map();
async function d4(t, e, r) {
  let n, i;
  e.shape === "rect" && (e.rx && e.ry ? e.shape = "roundedRect" : e.shape = "squareRect");
  const a = e.shape ? DJ[e.shape] : void 0;
  if (!a)
    throw new Error(`No such shape: ${e.shape}. Please check your syntax.`);
  if (e.link) {
    let s;
    r.config.securityLevel === "sandbox" ? s = "_top" : e.linkTarget && (s = e.linkTarget || "_blank"), n = t.insert("svg:a").attr("xlink:href", e.link).attr("target", s ?? null), i = await a(n, e, r);
  } else
    i = await a(t, e, r), n = i;
  return e.tooltip && i.attr("title", e.tooltip), f4.set(e.id, n), e.haveCallback && n.attr("class", n.attr("class") + " clickable"), n;
}
w(d4, "insertNode");
var D4e = /* @__PURE__ */ w((t, e) => {
  f4.set(e.id, t);
}, "setNodeElem"), O4e = /* @__PURE__ */ w(() => {
  f4.clear();
}, "clear"), H_ = /* @__PURE__ */ w((t) => {
  const e = f4.get(t.id);
  ae.trace(
    "Transforming node",
    t.diff,
    t,
    "translate(" + (t.x - t.width / 2 - 5) + ", " + t.width / 2 + ")"
  );
  const r = 8, n = t.diff || 0;
  return t.clusterNode ? e.attr(
    "transform",
    "translate(" + (t.x + n - t.width / 2) + ", " + (t.y - t.height / 2 - r) + ")"
  ) : e.attr("transform", "translate(" + t.x + ", " + t.y + ")"), n;
}, "positionNode"), P4e = /* @__PURE__ */ w((t, e, r, n, i, a) => {
  e.arrowTypeStart && oD(t, "start", e.arrowTypeStart, r, n, i, a), e.arrowTypeEnd && oD(t, "end", e.arrowTypeEnd, r, n, i, a);
}, "addEdgeMarkers"), $4e = {
  arrow_cross: { type: "cross", fill: !1 },
  arrow_point: { type: "point", fill: !0 },
  arrow_barb: { type: "barb", fill: !0 },
  arrow_circle: { type: "circle", fill: !1 },
  aggregation: { type: "aggregation", fill: !1 },
  extension: { type: "extension", fill: !1 },
  composition: { type: "composition", fill: !0 },
  dependency: { type: "dependency", fill: !0 },
  lollipop: { type: "lollipop", fill: !1 },
  only_one: { type: "onlyOne", fill: !1 },
  zero_or_one: { type: "zeroOrOne", fill: !1 },
  one_or_more: { type: "oneOrMore", fill: !1 },
  zero_or_more: { type: "zeroOrMore", fill: !1 },
  requirement_arrow: { type: "requirement_arrow", fill: !1 },
  requirement_contains: { type: "requirement_contains", fill: !1 }
}, oD = /* @__PURE__ */ w((t, e, r, n, i, a, s) => {
  const o = $4e[r];
  if (!o) {
    ae.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const l = o.type, h = `${i}_${a}-${l}${e === "start" ? "Start" : "End"}`;
  if (s && s.trim() !== "") {
    const f = s.replace(/[^\dA-Za-z]/g, "_"), d = `${h}_${f}`;
    if (!document.getElementById(d)) {
      const p = document.getElementById(h);
      if (p) {
        const g = p.cloneNode(!0);
        g.id = d, g.querySelectorAll("path, circle, line").forEach((v) => {
          v.setAttribute("stroke", s), o.fill && v.setAttribute("fill", s);
        }), p.parentNode?.appendChild(g);
      }
    }
    t.attr(`marker-${e}`, `url(${n}#${d})`);
  } else
    t.attr(`marker-${e}`, `url(${n}#${h})`);
}, "addEdgeMarker"), gb = /* @__PURE__ */ new Map(), ci = /* @__PURE__ */ new Map(), B4e = /* @__PURE__ */ w(() => {
  gb.clear(), ci.clear();
}, "clear"), pv = /* @__PURE__ */ w((t) => t ? t.reduce((r, n) => r + ";" + n, "") : "", "getLabelStyles"), PJ = /* @__PURE__ */ w(async (t, e) => {
  let r = Nr(Te().flowchart.htmlLabels);
  const { labelStyles: n } = kt(e);
  e.labelStyle = n;
  const i = await Na(t, e.label, {
    style: e.labelStyle,
    useHtmlLabels: r,
    addSvgBackground: !0,
    isNode: !1
  });
  ae.info("abc82", e, e.labelType);
  const a = t.insert("g").attr("class", "edgeLabel"), s = a.insert("g").attr("class", "label").attr("data-id", e.id);
  s.node().appendChild(i);
  let o = i.getBBox();
  if (r) {
    const u = i.children[0], h = Qe(i);
    o = u.getBoundingClientRect(), h.attr("width", o.width), h.attr("height", o.height);
  }
  s.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), gb.set(e.id, a), e.width = o.width, e.height = o.height;
  let l;
  if (e.startLabelLeft) {
    const u = await Mu(
      e.startLabelLeft,
      pv(e.labelStyle)
    ), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), ci.get(e.id) || ci.set(e.id, {}), ci.get(e.id).startLeft = h, Pp(l, e.startLabelLeft);
  }
  if (e.startLabelRight) {
    const u = await Mu(
      e.startLabelRight,
      pv(e.labelStyle)
    ), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = h.node().appendChild(u), f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), ci.get(e.id) || ci.set(e.id, {}), ci.get(e.id).startRight = h, Pp(l, e.startLabelRight);
  }
  if (e.endLabelLeft) {
    const u = await Mu(e.endLabelLeft, pv(e.labelStyle)), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), h.node().appendChild(u), ci.get(e.id) || ci.set(e.id, {}), ci.get(e.id).endLeft = h, Pp(l, e.endLabelLeft);
  }
  if (e.endLabelRight) {
    const u = await Mu(e.endLabelRight, pv(e.labelStyle)), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), h.node().appendChild(u), ci.get(e.id) || ci.set(e.id, {}), ci.get(e.id).endRight = h, Pp(l, e.endLabelRight);
  }
  return i;
}, "insertEdgeLabel");
function Pp(t, e) {
  Te().flowchart.htmlLabels && t && (t.style.width = e.length * 9 + "px", t.style.height = "12px");
}
w(Pp, "setTerminalWidth");
var $J = /* @__PURE__ */ w((t, e) => {
  ae.debug("Moving label abc88 ", t.id, t.label, gb.get(t.id), e);
  let r = e.updatedPath ? e.updatedPath : e.originalPath;
  const n = Te(), { subGraphTitleTotalMargin: i } = nm(n);
  if (t.label) {
    const a = gb.get(t.id);
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcLabelPosition(r);
      ae.debug(
        "Moving label " + t.label + " from (",
        s,
        ",",
        o,
        ") to (",
        l.x,
        ",",
        l.y,
        ") abc88"
      ), e.updatedPath && (s = l.x, o = l.y);
    }
    a.attr("transform", `translate(${s}, ${o + i / 2})`);
  }
  if (t.startLabelLeft) {
    const a = ci.get(t.id).startLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.startLabelRight) {
    const a = ci.get(t.id).startRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(
        t.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelLeft) {
    const a = ci.get(t.id).endLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelRight) {
    const a = ci.get(t.id).endRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_right", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
}, "positionEdgeLabel"), F4e = /* @__PURE__ */ w((t, e) => {
  const r = t.x, n = t.y, i = Math.abs(e.x - r), a = Math.abs(e.y - n), s = t.width / 2, o = t.height / 2;
  return i >= s || a >= o;
}, "outsideNode"), z4e = /* @__PURE__ */ w((t, e, r) => {
  ae.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${t.x} y:${t.y} w:${t.width} h:${t.height}`);
  const n = t.x, i = t.y, a = Math.abs(n - r.x), s = t.width / 2;
  let o = r.x < e.x ? s - a : s + a;
  const l = t.height / 2, u = Math.abs(e.y - r.y), h = Math.abs(e.x - r.x);
  if (Math.abs(i - e.y) * s > Math.abs(n - e.x) * l) {
    let f = r.y < e.y ? e.y - l - i : i - l - e.y;
    o = h * f / u;
    const d = {
      x: r.x < e.x ? r.x + o : r.x - h + o,
      y: r.y < e.y ? r.y + u - f : r.y - u + f
    };
    return o === 0 && (d.x = e.x, d.y = e.y), h === 0 && (d.x = e.x), u === 0 && (d.y = e.y), ae.debug(`abc89 top/bottom calc, Q ${u}, q ${f}, R ${h}, r ${o}`, d), d;
  } else {
    r.x < e.x ? o = e.x - s - n : o = n - s - e.x;
    let f = u * o / h, d = r.x < e.x ? r.x + h - o : r.x - h + o, p = r.y < e.y ? r.y + f : r.y - f;
    return ae.debug(`sides calc abc89, Q ${u}, q ${f}, R ${h}, r ${o}`, { _x: d, _y: p }), o === 0 && (d = e.x, p = e.y), h === 0 && (d = e.x), u === 0 && (p = e.y), { x: d, y: p };
  }
}, "intersection"), lD = /* @__PURE__ */ w((t, e) => {
  ae.warn("abc88 cutPathAtIntersect", t, e);
  let r = [], n = t[0], i = !1;
  return t.forEach((a) => {
    if (ae.info("abc88 checking point", a, e), !F4e(e, a) && !i) {
      const s = z4e(e, n, a);
      ae.debug("abc88 inside", a, n, s), ae.debug("abc88 intersection", s, e);
      let o = !1;
      r.forEach((l) => {
        o = o || l.x === s.x && l.y === s.y;
      }), r.some((l) => l.x === s.x && l.y === s.y) ? ae.warn("abc88 no intersect", s, r) : r.push(s), i = !0;
    } else
      ae.warn("abc88 outside", a, n), n = a, i || r.push(a);
  }), ae.debug("returning points", r), r;
}, "cutPathAtIntersect");
function BJ(t) {
  const e = [], r = [];
  for (let n = 1; n < t.length - 1; n++) {
    const i = t[n - 1], a = t[n], s = t[n + 1];
    (i.x === a.x && a.y === s.y && Math.abs(a.x - s.x) > 5 && Math.abs(a.y - i.y) > 5 || i.y === a.y && a.x === s.x && Math.abs(a.x - i.x) > 5 && Math.abs(a.y - s.y) > 5) && (e.push(a), r.push(n));
  }
  return { cornerPoints: e, cornerPointPositions: r };
}
w(BJ, "extractCornerPoints");
var cD = /* @__PURE__ */ w(function(t, e, r) {
  const n = e.x - t.x, i = e.y - t.y, a = Math.sqrt(n * n + i * i), s = r / a;
  return { x: e.x - s * n, y: e.y - s * i };
}, "findAdjacentPoint"), q4e = /* @__PURE__ */ w(function(t) {
  const { cornerPointPositions: e } = BJ(t), r = [];
  for (let n = 0; n < t.length; n++)
    if (e.includes(n)) {
      const i = t[n - 1], a = t[n + 1], s = t[n], o = cD(i, s, 5), l = cD(a, s, 5), u = l.x - o.x, h = l.y - o.y;
      r.push(o);
      const f = Math.sqrt(2) * 2;
      let d = { x: s.x, y: s.y };
      if (Math.abs(a.x - i.x) > 10 && Math.abs(a.y - i.y) >= 10) {
        ae.debug(
          "Corner point fixing",
          Math.abs(a.x - i.x),
          Math.abs(a.y - i.y)
        );
        const p = 5;
        s.x === o.x ? d = {
          x: u < 0 ? o.x - p + f : o.x + p - f,
          y: h < 0 ? o.y - f : o.y + f
        } : d = {
          x: u < 0 ? o.x - f : o.x + f,
          y: h < 0 ? o.y - p + f : o.y + p - f
        };
      } else
        ae.debug(
          "Corner point skipping fixing",
          Math.abs(a.x - i.x),
          Math.abs(a.y - i.y)
        );
      r.push(d, l);
    } else
      r.push(t[n]);
  return r;
}, "fixCorners"), G4e = /* @__PURE__ */ w((t, e, r) => {
  const n = t - e - r, i = 2, a = 2, s = i + a, o = Math.floor(n / s), l = Array(o).fill(`${i} ${a}`).join(" ");
  return `0 ${e} ${l} ${r}`;
}, "generateDashArray"), FJ = /* @__PURE__ */ w(function(t, e, r, n, i, a, s, o = !1) {
  const { handDrawnSeed: l } = Te();
  let u = e.points, h = !1;
  const f = i;
  var d = a;
  const p = [];
  for (const C in e.cssCompiledStyles)
    B9(C) || p.push(e.cssCompiledStyles[C]);
  ae.debug("UIO intersect check", e.points, d.x, f.x), d.intersect && f.intersect && !o && (u = u.slice(1, e.points.length - 1), u.unshift(f.intersect(u[0])), ae.debug(
    "Last point UIO",
    e.start,
    "-->",
    e.end,
    u[u.length - 1],
    d,
    d.intersect(u[u.length - 1])
  ), u.push(d.intersect(u[u.length - 1])));
  const g = btoa(JSON.stringify(u));
  e.toCluster && (ae.info("to cluster abc88", r.get(e.toCluster)), u = lD(e.points, r.get(e.toCluster).node), h = !0), e.fromCluster && (ae.debug(
    "from cluster abc88",
    r.get(e.fromCluster),
    JSON.stringify(u, null, 2)
  ), u = lD(u.reverse(), r.get(e.fromCluster).node).reverse(), h = !0);
  let m = u.filter((C) => !Number.isNaN(C.y));
  m = q4e(m);
  let v = Mf;
  switch (v = W2, e.curve) {
    case "linear":
      v = W2;
      break;
    case "basis":
      v = Mf;
      break;
    case "cardinal":
      v = uj;
      break;
    case "bumpX":
      v = aj;
      break;
    case "bumpY":
      v = sj;
      break;
    case "catmullRom":
      v = fj;
      break;
    case "monotoneX":
      v = yj;
      break;
    case "monotoneY":
      v = bj;
      break;
    case "natural":
      v = wj;
      break;
    case "step":
      v = Tj;
      break;
    case "stepAfter":
      v = Sj;
      break;
    case "stepBefore":
      v = Ej;
      break;
    default:
      v = Mf;
  }
  const { x: y, y: b } = sZ(e), x = i1().x(y).y(b).curve(v);
  let T;
  switch (e.thickness) {
    case "normal":
      T = "edge-thickness-normal";
      break;
    case "thick":
      T = "edge-thickness-thick";
      break;
    case "invisible":
      T = "edge-thickness-invisible";
      break;
    default:
      T = "edge-thickness-normal";
  }
  switch (e.pattern) {
    case "solid":
      T += " edge-pattern-solid";
      break;
    case "dotted":
      T += " edge-pattern-dotted";
      break;
    case "dashed":
      T += " edge-pattern-dashed";
      break;
    default:
      T += " edge-pattern-solid";
  }
  let E, A = e.curve === "rounded" ? zJ(qJ(m, e), 5) : x(m);
  const S = Array.isArray(e.style) ? e.style : [e.style];
  let k = S.find((C) => C?.startsWith("stroke:")), _ = !1;
  if (e.look === "handDrawn") {
    const C = Lt.svg(t);
    Object.assign([], m);
    const I = C.path(A, {
      roughness: 0.3,
      seed: l
    });
    T += " transition", E = Qe(I).select("path").attr("id", e.id).attr("class", " " + T + (e.classes ? " " + e.classes : "")).attr("style", S ? S.reduce((O, D) => O + ";" + D, "") : "");
    let N = E.attr("d");
    E.attr("d", N), t.node().appendChild(E.node());
  } else {
    const C = p.join(";"), I = S ? S.reduce((G, W) => G + W + ";", "") : "";
    let N = "";
    e.animate && (N = " edge-animation-fast"), e.animation && (N = " edge-animation-" + e.animation);
    const O = (C ? C + ";" + I + ";" : I) + ";" + (S ? S.reduce((G, W) => G + ";" + W, "") : "");
    E = t.append("path").attr("d", A).attr("id", e.id).attr(
      "class",
      " " + T + (e.classes ? " " + e.classes : "") + (N ?? "")
    ).attr("style", O), k = O.match(/stroke:([^;]+)/)?.[1], _ = e.animate === !0 || !!e.animation || C.includes("animation");
    const D = E.node(), $ = typeof D.getTotalLength == "function" ? D.getTotalLength() : 0, z = _N[e.arrowTypeStart] || 0, B = _N[e.arrowTypeEnd] || 0;
    if (e.look === "neo" && !_) {
      const W = `stroke-dasharray: ${e.pattern === "dotted" || e.pattern === "dashed" ? G4e($, z, B) : `0 ${z} ${$ - z - B} ${B}`}; stroke-dashoffset: 0;`;
      E.attr("style", W + E.attr("style"));
    }
  }
  E.attr("data-edge", !0), E.attr("data-et", "edge"), E.attr("data-id", e.id), E.attr("data-points", g), e.showPoints && m.forEach((C) => {
    t.append("circle").style("stroke", "red").style("fill", "red").attr("r", 1).attr("cx", C.x).attr("cy", C.y);
  });
  let R = "";
  (Te().flowchart.arrowMarkerAbsolute || Te().state.arrowMarkerAbsolute) && (R = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, R = R.replace(/\(/g, "\\(").replace(/\)/g, "\\)")), ae.info("arrowTypeStart", e.arrowTypeStart), ae.info("arrowTypeEnd", e.arrowTypeEnd), P4e(E, e, R, s, n, k);
  const L = Math.floor(u.length / 2), M = u[L];
  Jt.isLabelCoordinateInPath(M, E.attr("d")) || (h = !0);
  let P = {};
  return h && (P.updatedPath = u), P.originalPath = e.points, P;
}, "insertEdge");
function zJ(t, e) {
  if (t.length < 2)
    return "";
  let r = "";
  const n = t.length, i = 1e-5;
  for (let a = 0; a < n; a++) {
    const s = t[a], o = t[a - 1], l = t[a + 1];
    if (a === 0)
      r += `M${s.x},${s.y}`;
    else if (a === n - 1)
      r += `L${s.x},${s.y}`;
    else {
      const u = s.x - o.x, h = s.y - o.y, f = l.x - s.x, d = l.y - s.y, p = Math.hypot(u, h), g = Math.hypot(f, d);
      if (p < i || g < i) {
        r += `L${s.x},${s.y}`;
        continue;
      }
      const m = u / p, v = h / p, y = f / g, b = d / g, x = m * y + v * b, T = Math.max(-1, Math.min(1, x)), E = Math.acos(T);
      if (E < i || Math.abs(Math.PI - E) < i) {
        r += `L${s.x},${s.y}`;
        continue;
      }
      const A = Math.min(e / Math.sin(E / 2), p / 2, g / 2), S = s.x - m * A, k = s.y - v * A, _ = s.x + y * A, R = s.y + b * A;
      r += `L${S},${k}`, r += `Q${s.x},${s.y} ${_},${R}`;
    }
  }
  return r;
}
w(zJ, "generateRoundedPath");
function W_(t, e) {
  if (!t || !e)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  const r = e.x - t.x, n = e.y - t.y;
  return { angle: Math.atan2(n, r), deltaX: r, deltaY: n };
}
w(W_, "calculateDeltaAndAngle");
function qJ(t, e) {
  const r = t.map((i) => ({ ...i }));
  if (t.length >= 2 && Ei[e.arrowTypeStart]) {
    const i = Ei[e.arrowTypeStart], a = t[0], s = t[1], { angle: o } = W_(a, s), l = i * Math.cos(o), u = i * Math.sin(o);
    r[0].x = a.x + l, r[0].y = a.y + u;
  }
  const n = t.length;
  if (n >= 2 && Ei[e.arrowTypeEnd]) {
    const i = Ei[e.arrowTypeEnd], a = t[n - 1], s = t[n - 2], { angle: o } = W_(s, a), l = i * Math.cos(o), u = i * Math.sin(o);
    r[n - 1].x = a.x - l, r[n - 1].y = a.y - u;
  }
  return r;
}
w(qJ, "applyMarkerOffsetsToPoints");
var U4e = /* @__PURE__ */ w((t, e, r, n) => {
  e.forEach((i) => {
    a3e[i](t, r, n);
  });
}, "insertMarkers"), V4e = /* @__PURE__ */ w((t, e, r) => {
  ae.trace("Making markers for ", r), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), H4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), W4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), Y4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), X4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), j4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), K4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), Z4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), Q4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), J4e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneStart").attr("class", "marker onlyOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"), t.append("defs").append("marker").attr("id", r + "_" + e + "-onlyOneEnd").attr("class", "marker onlyOne " + e).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
}, "only_one"), e3e = /* @__PURE__ */ w((t, e, r) => {
  const n = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), n.append("path").attr("d", "M9,0 L9,18");
  const i = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + e).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), i.append("path").attr("d", "M21,0 L21,18");
}, "zero_or_one"), t3e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreStart").attr("class", "marker oneOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), t.append("defs").append("marker").attr("id", r + "_" + e + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + e).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
}, "one_or_more"), r3e = /* @__PURE__ */ w((t, e, r) => {
  const n = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  n.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), n.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  const i = t.append("defs").append("marker").attr("id", r + "_" + e + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + e).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), i.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, "zero_or_more"), n3e = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L20,10
      M20,10
      L0,20`
  );
}, "requirement_arrow"), i3e = /* @__PURE__ */ w((t, e, r) => {
  const n = t.append("defs").append("marker").attr("id", r + "_" + e + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
  n.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"), n.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10), n.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
}, "requirement_contains"), a3e = {
  extension: V4e,
  composition: H4e,
  aggregation: W4e,
  dependency: Y4e,
  lollipop: X4e,
  point: j4e,
  circle: K4e,
  cross: Z4e,
  barb: Q4e,
  only_one: J4e,
  zero_or_one: e3e,
  one_or_more: t3e,
  zero_or_more: r3e,
  requirement_arrow: n3e,
  requirement_contains: i3e
}, GJ = U4e, s3e = {
  common: at,
  getConfig: mr,
  insertCluster: lL,
  insertEdge: FJ,
  insertEdgeLabel: PJ,
  insertMarkers: GJ,
  insertNode: d4,
  interpolateToCurve: U9,
  labelHelper: Ht,
  log: ae,
  positionEdgeLabel: $J
}, p1 = {}, UJ = /* @__PURE__ */ w((t) => {
  for (const e of t)
    p1[e.name] = e;
}, "registerLayoutLoaders"), o3e = /* @__PURE__ */ w(() => {
  UJ([
    {
      name: "dagre",
      loader: /* @__PURE__ */ w(async () => await Promise.resolve().then(() => X9e), "loader")
    },
    {
      name: "cose-bilkent",
      loader: /* @__PURE__ */ w(async () => await Promise.resolve().then(() => OOe), "loader")
    }
  ]);
}, "registerDefaultLayoutLoaders");
o3e();
var I0 = /* @__PURE__ */ w(async (t, e) => {
  if (!(t.layoutAlgorithm in p1))
    throw new Error(`Unknown layout algorithm: ${t.layoutAlgorithm}`);
  const r = p1[t.layoutAlgorithm];
  return (await r.loader()).render(t, e, s3e, {
    algorithm: r.algorithm
  });
}, "render"), om = /* @__PURE__ */ w((t = "", { fallback: e = "dagre" } = {}) => {
  if (t in p1)
    return t;
  if (e in p1)
    return ae.warn(`Layout algorithm ${t} is not registered. Using ${e} as fallback.`), e;
  throw new Error(`Both layout algorithms ${t} and ${e} are not registered.`);
}, "getRegisteredLayoutAlgorithm"), VJ = "comm", HJ = "rule", WJ = "decl", l3e = "@import", c3e = "@namespace", u3e = "@keyframes", h3e = "@layer", YJ = Math.abs, hL = String.fromCharCode;
function XJ(t) {
  return t.trim();
}
function Ry(t, e, r) {
  return t.replace(e, r);
}
function f3e(t, e, r) {
  return t.indexOf(e, r);
}
function Df(t, e) {
  return t.charCodeAt(e) | 0;
}
function a0(t, e, r) {
  return t.slice(e, r);
}
function Zs(t) {
  return t.length;
}
function d3e(t) {
  return t.length;
}
function gv(t, e) {
  return e.push(t), t;
}
var p4 = 1, s0 = 1, jJ = 0, is = 0, An = 0, M0 = "";
function fL(t, e, r, n, i, a, s, o) {
  return { value: t, root: e, parent: r, type: n, props: i, children: a, line: p4, column: s0, length: s, return: "", siblings: o };
}
function p3e() {
  return An;
}
function g3e() {
  return An = is > 0 ? Df(M0, --is) : 0, s0--, An === 10 && (s0 = 1, p4--), An;
}
function Cs() {
  return An = is < jJ ? Df(M0, is++) : 0, s0++, An === 10 && (s0 = 1, p4++), An;
}
function Ql() {
  return Df(M0, is);
}
function Iy() {
  return is;
}
function g4(t, e) {
  return a0(M0, t, e);
}
function g1(t) {
  switch (t) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function m3e(t) {
  return p4 = s0 = 1, jJ = Zs(M0 = t), is = 0, [];
}
function v3e(t) {
  return M0 = "", t;
}
function q5(t) {
  return XJ(g4(is - 1, Y_(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function y3e(t) {
  for (; (An = Ql()) && An < 33; )
    Cs();
  return g1(t) > 2 || g1(An) > 3 ? "" : " ";
}
function b3e(t, e) {
  for (; --e && Cs() && !(An < 48 || An > 102 || An > 57 && An < 65 || An > 70 && An < 97); )
    ;
  return g4(t, Iy() + (e < 6 && Ql() == 32 && Cs() == 32));
}
function Y_(t) {
  for (; Cs(); )
    switch (An) {
      // ] ) " '
      case t:
        return is;
      // " '
      case 34:
      case 39:
        t !== 34 && t !== 39 && Y_(An);
        break;
      // (
      case 40:
        t === 41 && Y_(t);
        break;
      // \
      case 92:
        Cs();
        break;
    }
  return is;
}
function x3e(t, e) {
  for (; Cs() && t + An !== 57; )
    if (t + An === 84 && Ql() === 47)
      break;
  return "/*" + g4(e, is - 1) + "*" + hL(t === 47 ? t : Cs());
}
function w3e(t) {
  for (; !g1(Ql()); )
    Cs();
  return g4(t, is);
}
function T3e(t) {
  return v3e(My("", null, null, null, [""], t = m3e(t), 0, [0], t));
}
function My(t, e, r, n, i, a, s, o, l) {
  for (var u = 0, h = 0, f = s, d = 0, p = 0, g = 0, m = 1, v = 1, y = 1, b = 0, x = "", T = i, E = a, A = n, S = x; v; )
    switch (g = b, b = Cs()) {
      // (
      case 40:
        if (g != 108 && Df(S, f - 1) == 58) {
          f3e(S += Ry(q5(b), "&", "&\f"), "&\f", YJ(u ? o[u - 1] : 0)) != -1 && (y = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        S += q5(b);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        S += y3e(g);
        break;
      // \
      case 92:
        S += b3e(Iy() - 1, 7);
        continue;
      // /
      case 47:
        switch (Ql()) {
          case 42:
          case 47:
            gv(E3e(x3e(Cs(), Iy()), e, r, l), l), (g1(g || 1) == 5 || g1(Ql() || 1) == 5) && Zs(S) && a0(S, -1, void 0) !== " " && (S += " ");
            break;
          default:
            S += "/";
        }
        break;
      // {
      case 123 * m:
        o[u++] = Zs(S) * y;
      // } ; \0
      case 125 * m:
      case 59:
      case 0:
        switch (b) {
          // \0 }
          case 0:
          case 125:
            v = 0;
          // ;
          case 59 + h:
            y == -1 && (S = Ry(S, /\f/g, "")), p > 0 && (Zs(S) - f || m === 0 && g === 47) && gv(p > 32 ? hD(S + ";", n, r, f - 1, l) : hD(Ry(S, " ", "") + ";", n, r, f - 2, l), l);
            break;
          // @ ;
          case 59:
            S += ";";
          // { rule/at-rule
          default:
            if (gv(A = uD(S, e, r, u, h, i, o, x, T = [], E = [], f, a), a), b === 123)
              if (h === 0)
                My(S, e, A, A, T, a, f, o, E);
              else {
                switch (d) {
                  // c(ontainer)
                  case 99:
                    if (Df(S, 3) === 110) break;
                  // l(ayer)
                  case 108:
                    if (Df(S, 2) === 97) break;
                  default:
                    h = 0;
                  // d(ocument) m(edia) s(upports)
                  case 100:
                  case 109:
                  case 115:
                }
                h ? My(t, A, A, n && gv(uD(t, A, A, 0, 0, i, o, x, i, T = [], f, E), E), i, E, f, o, n ? T : E) : My(S, A, A, A, [""], E, 0, o, E);
              }
        }
        u = h = p = 0, m = y = 1, x = S = "", f = s;
        break;
      // :
      case 58:
        f = 1 + Zs(S), p = g;
      default:
        if (m < 1) {
          if (b == 123)
            --m;
          else if (b == 125 && m++ == 0 && g3e() == 125)
            continue;
        }
        switch (S += hL(b), b * m) {
          // &
          case 38:
            y = h > 0 ? 1 : (S += "\f", -1);
            break;
          // ,
          case 44:
            o[u++] = (Zs(S) - 1) * y, y = 1;
            break;
          // @
          case 64:
            Ql() === 45 && (S += q5(Cs())), d = Ql(), h = f = Zs(x = S += w3e(Iy())), b++;
            break;
          // -
          case 45:
            g === 45 && Zs(S) == 2 && (m = 0);
        }
    }
  return a;
}
function uD(t, e, r, n, i, a, s, o, l, u, h, f) {
  for (var d = i - 1, p = i === 0 ? a : [""], g = d3e(p), m = 0, v = 0, y = 0; m < n; ++m)
    for (var b = 0, x = a0(t, d + 1, d = YJ(v = s[m])), T = t; b < g; ++b)
      (T = XJ(v > 0 ? p[b] + " " + x : Ry(x, /&\f/g, p[b]))) && (l[y++] = T);
  return fL(t, e, r, i === 0 ? HJ : o, l, u, h, f);
}
function E3e(t, e, r, n) {
  return fL(t, e, r, VJ, hL(p3e()), a0(t, 2, -2), 0, n);
}
function hD(t, e, r, n, i) {
  return fL(t, e, r, WJ, a0(t, 0, n), a0(t, n + 1, -1), n, i);
}
function X_(t, e) {
  for (var r = "", n = 0; n < t.length; n++)
    r += e(t[n], n, t, e) || "";
  return r;
}
function S3e(t, e, r, n) {
  switch (t.type) {
    case h3e:
      if (t.children.length) break;
    case l3e:
    case c3e:
    case WJ:
      return t.return = t.return || t.value;
    case VJ:
      return "";
    case u3e:
      return t.return = t.value + "{" + X_(t.children, n) + "}";
    case HJ:
      if (!Zs(t.value = t.props.join(","))) return "";
  }
  return Zs(r = X_(t.children, n)) ? t.return = t.value + "{" + r + "}" : "";
}
var k3e = dZ(Object.keys, Object), C3e = Object.prototype, _3e = C3e.hasOwnProperty;
function KJ(t) {
  if (!e4(t))
    return k3e(t);
  var e = [];
  for (var r in Object(t))
    _3e.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
var j_ = wh(wo, "DataView"), K_ = wh(wo, "Promise"), Of = wh(wo, "Set"), Z_ = wh(wo, "WeakMap"), fD = "[object Map]", A3e = "[object Object]", dD = "[object Promise]", pD = "[object Set]", gD = "[object WeakMap]", mD = "[object DataView]", L3e = xh(j_), R3e = xh(h1), I3e = xh(K_), M3e = xh(Of), N3e = xh(Z_), Ha = bh;
(j_ && Ha(new j_(new ArrayBuffer(1))) != mD || h1 && Ha(new h1()) != fD || K_ && Ha(K_.resolve()) != dD || Of && Ha(new Of()) != pD || Z_ && Ha(new Z_()) != gD) && (Ha = function(t) {
  var e = bh(t), r = e == A3e ? t.constructor : void 0, n = r ? xh(r) : "";
  if (n)
    switch (n) {
      case L3e:
        return mD;
      case R3e:
        return fD;
      case I3e:
        return dD;
      case M3e:
        return pD;
      case N3e:
        return gD;
    }
  return e;
});
var D3e = "[object Map]", O3e = "[object Set]", P3e = Object.prototype, $3e = P3e.hasOwnProperty;
function m1(t) {
  if (t == null)
    return !0;
  if ($c(t) && (Rn(t) || typeof t == "string" || typeof t.splice == "function" || n0(t) || r4(t) || r0(t)))
    return !t.length;
  var e = Ha(t);
  if (e == D3e || e == O3e)
    return !t.size;
  if (e4(t))
    return !KJ(t).length;
  for (var r in t)
    if ($3e.call(t, r))
      return !1;
  return !0;
}
var ZJ = "c4", B3e = /* @__PURE__ */ w((t) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(t), "detector"), F3e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => IPe);
  return { id: ZJ, diagram: t };
}, "loader"), z3e = {
  id: ZJ,
  detector: B3e,
  loader: F3e
}, q3e = z3e, QJ = "flowchart", G3e = /* @__PURE__ */ w((t, e) => e?.flowchart?.defaultRenderer === "dagre-wrapper" || e?.flowchart?.defaultRenderer === "elk" ? !1 : /^\s*graph/.test(t), "detector"), U3e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => HR);
  return { id: QJ, diagram: t };
}, "loader"), V3e = {
  id: QJ,
  detector: G3e,
  loader: U3e
}, H3e = V3e, JJ = "flowchart-v2", W3e = /* @__PURE__ */ w((t, e) => e?.flowchart?.defaultRenderer === "dagre-d3" ? !1 : (e?.flowchart?.defaultRenderer === "elk" && (e.layout = "elk"), /^\s*graph/.test(t) && e?.flowchart?.defaultRenderer === "dagre-wrapper" ? !0 : /^\s*flowchart/.test(t)), "detector"), Y3e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => HR);
  return { id: JJ, diagram: t };
}, "loader"), X3e = {
  id: JJ,
  detector: W3e,
  loader: Y3e
}, j3e = X3e, eee = "er", K3e = /* @__PURE__ */ w((t) => /^\s*erDiagram/.test(t), "detector"), Z3e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => ZPe);
  return { id: eee, diagram: t };
}, "loader"), Q3e = {
  id: eee,
  detector: K3e,
  loader: Z3e
}, J3e = Q3e, tee = "gitGraph", e5e = /* @__PURE__ */ w((t) => /^\s*gitGraph/.test(t), "detector"), t5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => jJe);
  return { id: tee, diagram: t };
}, "loader"), r5e = {
  id: tee,
  detector: e5e,
  loader: t5e
}, n5e = r5e, ree = "gantt", i5e = /* @__PURE__ */ w((t) => /^\s*gantt/.test(t), "detector"), a5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => itt);
  return { id: ree, diagram: t };
}, "loader"), s5e = {
  id: ree,
  detector: i5e,
  loader: a5e
}, o5e = s5e, nee = "info", l5e = /* @__PURE__ */ w((t) => /^\s*info/.test(t), "detector"), c5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => ftt);
  return { id: nee, diagram: t };
}, "loader"), u5e = {
  id: nee,
  detector: l5e,
  loader: c5e
}, iee = "pie", h5e = /* @__PURE__ */ w((t) => /^\s*pie/.test(t), "detector"), f5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Ltt);
  return { id: iee, diagram: t };
}, "loader"), d5e = {
  id: iee,
  detector: h5e,
  loader: f5e
}, aee = "quadrantChart", p5e = /* @__PURE__ */ w((t) => /^\s*quadrantChart/.test(t), "detector"), g5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Btt);
  return { id: aee, diagram: t };
}, "loader"), m5e = {
  id: aee,
  detector: p5e,
  loader: g5e
}, v5e = m5e, see = "xychart", y5e = /* @__PURE__ */ w((t) => /^\s*xychart(-beta)?/.test(t), "detector"), b5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Jtt);
  return { id: see, diagram: t };
}, "loader"), x5e = {
  id: see,
  detector: y5e,
  loader: b5e
}, w5e = x5e, oee = "requirement", T5e = /* @__PURE__ */ w((t) => /^\s*requirement(Diagram)?/.test(t), "detector"), E5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => srt);
  return { id: oee, diagram: t };
}, "loader"), S5e = {
  id: oee,
  detector: T5e,
  loader: E5e
}, k5e = S5e, lee = "sequence", C5e = /* @__PURE__ */ w((t) => /^\s*sequenceDiagram/.test(t), "detector"), _5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Yrt);
  return { id: lee, diagram: t };
}, "loader"), A5e = {
  id: lee,
  detector: C5e,
  loader: _5e
}, L5e = A5e, cee = "class", R5e = /* @__PURE__ */ w((t, e) => e?.class?.defaultRenderer === "dagre-wrapper" ? !1 : /^\s*classDiagram/.test(t), "detector"), I5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Jrt);
  return { id: cee, diagram: t };
}, "loader"), M5e = {
  id: cee,
  detector: R5e,
  loader: I5e
}, N5e = M5e, uee = "classDiagram", D5e = /* @__PURE__ */ w((t, e) => /^\s*classDiagram/.test(t) && e?.class?.defaultRenderer === "dagre-wrapper" ? !0 : /^\s*classDiagram-v2/.test(t), "detector"), O5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => tnt);
  return { id: uee, diagram: t };
}, "loader"), P5e = {
  id: uee,
  detector: D5e,
  loader: O5e
}, $5e = P5e, hee = "state", B5e = /* @__PURE__ */ w((t, e) => e?.state?.defaultRenderer === "dagre-wrapper" ? !1 : /^\s*stateDiagram/.test(t), "detector"), F5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Vnt);
  return { id: hee, diagram: t };
}, "loader"), z5e = {
  id: hee,
  detector: B5e,
  loader: F5e
}, q5e = z5e, fee = "stateDiagram", G5e = /* @__PURE__ */ w((t, e) => !!(/^\s*stateDiagram-v2/.test(t) || /^\s*stateDiagram/.test(t) && e?.state?.defaultRenderer === "dagre-wrapper"), "detector"), U5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Wnt);
  return { id: fee, diagram: t };
}, "loader"), V5e = {
  id: fee,
  detector: G5e,
  loader: U5e
}, H5e = V5e, dee = "journey", W5e = /* @__PURE__ */ w((t) => /^\s*journey/.test(t), "detector"), Y5e = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => pit);
  return { id: dee, diagram: t };
}, "loader"), X5e = {
  id: dee,
  detector: W5e,
  loader: Y5e
}, j5e = X5e, K5e = /* @__PURE__ */ w((t, e, r) => {
  ae.debug(`rendering svg for syntax error
`);
  const n = El(e), i = n.append("g");
  n.attr("viewBox", "0 0 2412 512"), Qi(n, 100, 512, !0), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
  ), i.append("path").attr("class", "error-icon").attr(
    "d",
    "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
  ), i.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"), i.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${r}`);
}, "draw"), pee = { draw: K5e }, Z5e = pee, Q5e = {
  db: {},
  renderer: pee,
  parser: {
    parse: /* @__PURE__ */ w(() => {
    }, "parse")
  }
}, J5e = Q5e, gee = "flowchart-elk", ewe = /* @__PURE__ */ w((t, e = {}) => (
  // If diagram explicitly states flowchart-elk
  /^\s*flowchart-elk/.test(t) || // If a flowchart/graph diagram has their default renderer set to elk
  /^\s*(flowchart|graph)/.test(t) && e?.flowchart?.defaultRenderer === "elk" ? (e.layout = "elk", !0) : !1
), "detector"), twe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => HR);
  return { id: gee, diagram: t };
}, "loader"), rwe = {
  id: gee,
  detector: ewe,
  loader: twe
}, nwe = rwe, mee = "timeline", iwe = /* @__PURE__ */ w((t) => /^\s*timeline/.test(t), "detector"), awe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Pit);
  return { id: mee, diagram: t };
}, "loader"), swe = {
  id: mee,
  detector: iwe,
  loader: awe
}, owe = swe, vee = "mindmap", lwe = /* @__PURE__ */ w((t) => /^\s*mindmap/.test(t), "detector"), cwe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Kit);
  return { id: vee, diagram: t };
}, "loader"), uwe = {
  id: vee,
  detector: lwe,
  loader: cwe
}, hwe = uwe, yee = "kanban", fwe = /* @__PURE__ */ w((t) => /^\s*kanban/.test(t), "detector"), dwe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => mat);
  return { id: yee, diagram: t };
}, "loader"), pwe = {
  id: yee,
  detector: fwe,
  loader: dwe
}, gwe = pwe, bee = "sankey", mwe = /* @__PURE__ */ w((t) => /^\s*sankey(-beta)?/.test(t), "detector"), vwe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => est);
  return { id: bee, diagram: t };
}, "loader"), ywe = {
  id: bee,
  detector: mwe,
  loader: vwe
}, bwe = ywe, xee = "packet", xwe = /* @__PURE__ */ w((t) => /^\s*packet(-beta)?/.test(t), "detector"), wwe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => hst);
  return { id: xee, diagram: t };
}, "loader"), Twe = {
  id: xee,
  detector: xwe,
  loader: wwe
}, wee = "radar", Ewe = /* @__PURE__ */ w((t) => /^\s*radar-beta/.test(t), "detector"), Swe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Mst);
  return { id: wee, diagram: t };
}, "loader"), kwe = {
  id: wee,
  detector: Ewe,
  loader: Swe
}, Tee = "block", Cwe = /* @__PURE__ */ w((t) => /^\s*block(-beta)?/.test(t), "detector"), _we = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => ilt);
  return { id: Tee, diagram: t };
}, "loader"), Awe = {
  id: Tee,
  detector: Cwe,
  loader: _we
}, Lwe = Awe, Eee = "architecture", Rwe = /* @__PURE__ */ w((t) => /^\s*architecture/.test(t), "detector"), Iwe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Mlt);
  return { id: Eee, diagram: t };
}, "loader"), Mwe = {
  id: Eee,
  detector: Rwe,
  loader: Iwe
}, Nwe = Mwe, See = "treemap", Dwe = /* @__PURE__ */ w((t) => /^\s*treemap/.test(t), "detector"), Owe = /* @__PURE__ */ w(async () => {
  const { diagram: t } = await Promise.resolve().then(() => Ult);
  return { id: See, diagram: t };
}, "loader"), Pwe = {
  id: See,
  detector: Dwe,
  loader: Owe
}, vD = !1, m4 = /* @__PURE__ */ w(() => {
  vD || (vD = !0, L2("error", J5e, (t) => t.toLowerCase().trim() === "error"), L2(
    "---",
    // --- diagram type may appear if YAML front-matter is not parsed correctly
    {
      db: {
        clear: /* @__PURE__ */ w(() => {
        }, "clear")
      },
      styles: {},
      // should never be used
      renderer: {
        draw: /* @__PURE__ */ w(() => {
        }, "draw")
      },
      parser: {
        parse: /* @__PURE__ */ w(() => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks"
          );
        }, "parse")
      },
      init: /* @__PURE__ */ w(() => null, "init")
      // no op
    },
    (t) => t.toLowerCase().trimStart().startsWith("---")
  ), Z7(nwe, hwe, Nwe), Z7(
    q3e,
    gwe,
    $5e,
    N5e,
    J3e,
    o5e,
    u5e,
    d5e,
    k5e,
    L5e,
    j3e,
    H3e,
    owe,
    n5e,
    H5e,
    q5e,
    j5e,
    v5e,
    bwe,
    Twe,
    w5e,
    Lwe,
    kwe,
    Pwe
  ));
}, "addDiagrams"), $we = /* @__PURE__ */ w(async () => {
  ae.debug("Loading registered diagrams");
  const e = (await Promise.allSettled(
    Object.entries(qu).map(async ([r, { detector: n, loader: i }]) => {
      if (i)
        try {
          r_(r);
        } catch {
          try {
            const { diagram: a, id: s } = await i();
            L2(s, a, n);
          } catch (a) {
            throw ae.error(`Failed to load external diagram with key ${r}. Removing from detectors.`), delete qu[r], a;
          }
        }
    })
  )).filter((r) => r.status === "rejected");
  if (e.length > 0) {
    ae.error(`Failed to load ${e.length} external diagrams`);
    for (const r of e)
      ae.error(r);
    throw new Error(`Failed to load ${e.length} external diagrams`);
  }
}, "loadRegisteredDiagrams"), Bwe = "graphics-document document";
function kee(t, e) {
  t.attr("role", Bwe), e !== "" && t.attr("aria-roledescription", e);
}
w(kee, "setA11yDiagramInfo");
function Cee(t, e, r, n) {
  if (t.insert !== void 0) {
    if (r) {
      const i = `chart-desc-${n}`;
      t.attr("aria-describedby", i), t.insert("desc", ":first-child").attr("id", i).text(r);
    }
    if (e) {
      const i = `chart-title-${n}`;
      t.attr("aria-labelledby", i), t.insert("title", ":first-child").attr("id", i).text(e);
    }
  }
}
w(Cee, "addSVGa11yTitleDescription");
var Fu, Q_ = (Fu = class {
  constructor(e, r, n, i, a) {
    this.type = e, this.text = r, this.db = n, this.parser = i, this.renderer = a;
  }
  static async fromText(e, r = {}) {
    const n = mr(), i = c9(e, n);
    e = Gbe(e) + `
`;
    try {
      r_(i);
    } catch {
      const u = Xhe(i);
      if (!u)
        throw new XY(`Diagram ${i} not found.`);
      const { id: h, diagram: f } = await u();
      L2(h, f);
    }
    const { db: a, parser: s, renderer: o, init: l } = r_(i);
    return s.parser && (s.parser.yy = a), a.clear?.(), l?.(n), r.title && a.setDiagramTitle?.(r.title), await s.parse(e), new Fu(i, e, a, s, o);
  }
  async render(e, r) {
    await this.renderer.draw(this.text, e, r, this);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}, w(Fu, "Diagram"), Fu), yD = [], Fwe = /* @__PURE__ */ w(() => {
  yD.forEach((t) => {
    t();
  }), yD = [];
}, "attachFunctions"), zwe = /* @__PURE__ */ w((t) => t.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
function _ee(t) {
  const e = t.match(YY);
  if (!e)
    return {
      text: t,
      metadata: {}
    };
  let r = Kx(e[1], {
    // To support config, we need JSON schema.
    // https://www.yaml.org/spec/1.2/spec.html#id2803231
    schema: jx
  }) ?? {};
  r = typeof r == "object" && !Array.isArray(r) ? r : {};
  const n = {};
  return r.displayMode && (n.displayMode = r.displayMode.toString()), r.title && (n.title = r.title.toString()), r.config && (n.config = r.config), {
    text: t.slice(e[0].length),
    metadata: n
  };
}
w(_ee, "extractFrontMatter");
var qwe = /* @__PURE__ */ w((t) => t.replace(/\r\n?/g, `
`).replace(
  /<(\w+)([^>]*)>/g,
  (e, r, n) => "<" + r + n.replace(/="([^"]*)"/g, "='$1'") + ">"
), "cleanupText"), Gwe = /* @__PURE__ */ w((t) => {
  const { text: e, metadata: r } = _ee(t), { displayMode: n, title: i, config: a = {} } = r;
  return n && (a.gantt || (a.gantt = {}), a.gantt.displayMode = n), { title: i, config: a, text: e };
}, "processFrontmatter"), Uwe = /* @__PURE__ */ w((t) => {
  const e = Jt.detectInit(t) ?? {}, r = Jt.detectDirective(t, "wrap");
  return Array.isArray(r) ? e.wrap = r.some(({ type: n }) => n === "wrap") : r?.type === "wrap" && (e.wrap = !0), {
    text: Mbe(t),
    directive: e
  };
}, "processDirectives");
function dL(t) {
  const e = qwe(t), r = Gwe(e), n = Uwe(r.text), i = Xi(r.config, n.directive);
  return t = zwe(n.text), {
    code: t,
    title: r.title,
    config: i
  };
}
w(dL, "preprocessDiagram");
function Aee(t) {
  const e = new TextEncoder().encode(t), r = Array.from(e, (n) => String.fromCodePoint(n)).join("");
  return btoa(r);
}
w(Aee, "toBase64");
var Vwe = 5e4, Hwe = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa", Wwe = "sandbox", Ywe = "loose", Xwe = "http://www.w3.org/2000/svg", jwe = "http://www.w3.org/1999/xlink", Kwe = "http://www.w3.org/1999/xhtml", Zwe = "100%", Qwe = "100%", Jwe = "border:0;margin:0;", eTe = "margin:0", tTe = "allow-top-navigation-by-user-activation allow-popups", rTe = 'The "iframe" tag is not supported by your browser.', nTe = ["foreignobject"], iTe = ["dominant-baseline"];
function pL(t) {
  const e = dL(t);
  return _2(), cfe(e.config ?? {}), e;
}
w(pL, "processAndSetConfigs");
async function Lee(t, e) {
  m4();
  try {
    const { code: r, config: n } = pL(t);
    return { diagramType: (await Iee(r)).type, config: n };
  } catch (r) {
    if (e?.suppressErrors)
      return !1;
    throw r;
  }
}
w(Lee, "parse");
var bD = /* @__PURE__ */ w((t, e, r = []) => `
.${t} ${e} { ${r.join(" !important; ")} !important; }`, "cssImportantStyles"), aTe = /* @__PURE__ */ w((t, e = /* @__PURE__ */ new Map()) => {
  let r = "";
  if (t.themeCSS !== void 0 && (r += `
${t.themeCSS}`), t.fontFamily !== void 0 && (r += `
:root { --mermaid-font-family: ${t.fontFamily}}`), t.altFontFamily !== void 0 && (r += `
:root { --mermaid-alt-font-family: ${t.altFontFamily}}`), e instanceof Map) {
    const s = t.htmlLabels ?? t.flowchart?.htmlLabels ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
    e.forEach((o) => {
      m1(o.styles) || s.forEach((l) => {
        r += bD(o.id, l, o.styles);
      }), m1(o.textStyles) || (r += bD(
        o.id,
        "tspan",
        (o?.textStyles || []).map((l) => l.replace("color", "fill"))
      ));
    });
  }
  return r;
}, "createCssStyles"), sTe = /* @__PURE__ */ w((t, e, r, n) => {
  const i = aTe(t, r), a = Afe(e, i, t.themeVariables);
  return X_(T3e(`${n}{${a}}`), S3e);
}, "createUserStyles"), oTe = /* @__PURE__ */ w((t = "", e, r) => {
  let n = t;
  return !r && !e && (n = n.replace(
    /marker-end="url\([\d+./:=?A-Za-z-]*?#/g,
    'marker-end="url(#'
  )), n = mo(n), n = n.replace(/<br>/g, "<br/>"), n;
}, "cleanUpSvgCode"), lTe = /* @__PURE__ */ w((t = "", e) => {
  const r = e?.viewBox?.baseVal?.height ? e.viewBox.baseVal.height + "px" : Qwe, n = Aee(`<body style="${eTe}">${t}</body>`);
  return `<iframe style="width:${Zwe};height:${r};${Jwe}" src="data:text/html;charset=UTF-8;base64,${n}" sandbox="${tTe}">
  ${rTe}
</iframe>`;
}, "putIntoIFrame"), xD = /* @__PURE__ */ w((t, e, r, n, i) => {
  const a = t.append("div");
  a.attr("id", r), n && a.attr("style", n);
  const s = a.append("svg").attr("id", e).attr("width", "100%").attr("xmlns", Xwe);
  return i && s.attr("xmlns:xlink", i), s.append("g"), t;
}, "appendDivSvgG");
function J_(t, e) {
  return t.append("iframe").attr("id", e).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
w(J_, "sandboxedIframe");
var cTe = /* @__PURE__ */ w((t, e, r, n) => {
  t.getElementById(e)?.remove(), t.getElementById(r)?.remove(), t.getElementById(n)?.remove();
}, "removeExistingElements"), uTe = /* @__PURE__ */ w(async function(t, e, r) {
  m4();
  const n = pL(e);
  e = n.code;
  const i = mr();
  ae.debug(i), e.length > (i?.maxTextSize ?? Vwe) && (e = Hwe);
  const a = "#" + t, s = "i" + t, o = "#" + s, l = "d" + t, u = "#" + l, h = /* @__PURE__ */ w(() => {
    const P = Qe(d ? o : u).node();
    P && "remove" in P && P.remove();
  }, "removeTempElements");
  let f = Qe("body");
  const d = i.securityLevel === Wwe, p = i.securityLevel === Ywe, g = i.fontFamily;
  if (r !== void 0) {
    if (r && (r.innerHTML = ""), d) {
      const M = J_(Qe(r), s);
      f = Qe(M.nodes()[0].contentDocument.body), f.node().style.margin = 0;
    } else
      f = Qe(r);
    xD(f, t, l, `font-family: ${g}`, jwe);
  } else {
    if (cTe(document, t, l, s), d) {
      const M = J_(Qe("body"), s);
      f = Qe(M.nodes()[0].contentDocument.body), f.node().style.margin = 0;
    } else
      f = Qe("body");
    xD(f, t, l);
  }
  let m, v;
  try {
    m = await Q_.fromText(e, { title: n.title });
  } catch (M) {
    if (i.suppressErrorRendering)
      throw h(), M;
    m = await Q_.fromText("error"), v = M;
  }
  const y = f.select(u).node(), b = m.type, x = y.firstChild, T = x.firstChild, E = m.renderer.getClasses?.(e, m), A = sTe(i, b, E, a), S = document.createElement("style");
  S.innerHTML = A, x.insertBefore(S, T);
  try {
    await m.renderer.draw(e, t, Y7.version, m);
  } catch (M) {
    throw i.suppressErrorRendering ? h() : Z5e.draw(e, t, Y7.version), M;
  }
  const k = f.select(`${u} svg`), _ = m.db.getAccTitle?.(), R = m.db.getAccDescription?.();
  Mee(b, k, _, R), f.select(`[id="${t}"]`).selectAll("foreignobject > *").attr("xmlns", Kwe);
  let L = f.select(u).node().innerHTML;
  if (ae.debug("config.arrowMarkerAbsolute", i.arrowMarkerAbsolute), L = oTe(L, d, Nr(i.arrowMarkerAbsolute)), d) {
    const M = f.select(u + " svg").node();
    L = lTe(L, M);
  } else p || (L = Hd.sanitize(L, {
    ADD_TAGS: nTe,
    ADD_ATTR: iTe,
    HTML_INTEGRATION_POINTS: { foreignobject: !0 }
  }));
  if (Fwe(), v)
    throw v;
  return h(), {
    diagramType: b,
    svg: L,
    bindFunctions: m.db.bindFunctions
  };
}, "render");
function Ree(t = {}) {
  const e = bn({}, t);
  e?.fontFamily && !e.themeVariables?.fontFamily && (e.themeVariables || (e.themeVariables = {}), e.themeVariables.fontFamily = e.fontFamily), ofe(e), e?.theme && e.theme in il ? e.themeVariables = il[e.theme].getThemeVariables(
    e.themeVariables
  ) : e && (e.themeVariables = il.default.getThemeVariables(e.themeVariables));
  const r = typeof e == "object" ? sfe(e) : QY();
  o9(r.logLevel), m4();
}
w(Ree, "initialize");
var Iee = /* @__PURE__ */ w((t, e = {}) => {
  const { code: r } = dL(t);
  return Q_.fromText(r, e);
}, "getDiagramFromText");
function Mee(t, e, r, n) {
  kee(e, t), Cee(e, r, n, e.attr("id"));
}
w(Mee, "addA11yInfo");
var Zu = Object.freeze({
  render: uTe,
  parse: Lee,
  getDiagramFromText: Iee,
  initialize: Ree,
  getConfig: mr,
  setConfig: JY,
  getSiteConfig: QY,
  updateSiteConfig: lfe,
  reset: /* @__PURE__ */ w(() => {
    _2();
  }, "reset"),
  globalReset: /* @__PURE__ */ w(() => {
    _2(Wd);
  }, "globalReset"),
  defaultConfig: Wd
});
o9(mr().logLevel);
_2(mr());
var hTe = /* @__PURE__ */ w((t, e, r) => {
  ae.warn(t), X9(t) ? (r && r(t.str, t.hash), e.push({ ...t, message: t.str, error: t })) : (r && r(t), t instanceof Error && e.push({
    str: t.message,
    message: t.message,
    hash: t.name,
    error: t
  }));
}, "handleError"), Nee = /* @__PURE__ */ w(async function(t = {
  querySelector: ".mermaid"
}) {
  try {
    await fTe(t);
  } catch (e) {
    if (X9(e) && ae.error(e.str), pl.parseError && pl.parseError(e), !t.suppressErrors)
      throw ae.error("Use the suppressErrors option to suppress these errors"), e;
  }
}, "run"), fTe = /* @__PURE__ */ w(async function({ postRenderCallback: t, querySelector: e, nodes: r } = {
  querySelector: ".mermaid"
}) {
  const n = Zu.getConfig();
  ae.debug(`${t ? "" : "No "}Callback function found`);
  let i;
  if (r)
    i = r;
  else if (e)
    i = document.querySelectorAll(e);
  else
    throw new Error("Nodes and querySelector are both undefined");
  ae.debug(`Found ${i.length} diagrams`), n?.startOnLoad !== void 0 && (ae.debug("Start On Load: " + n?.startOnLoad), Zu.updateSiteConfig({ startOnLoad: n?.startOnLoad }));
  const a = new Jt.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed);
  let s;
  const o = [];
  for (const l of Array.from(i)) {
    if (ae.info("Rendering diagram: " + l.id), l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const u = `mermaid-${a.next()}`;
    s = l.innerHTML, s = YZ(Jt.entityDecode(s)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const h = Jt.detectInit(s);
    h && ae.debug("Detected early reinit: ", h);
    try {
      const { svg: f, bindFunctions: d } = await $ee(u, s, l);
      l.innerHTML = f, t && await t(u), d && d(l);
    } catch (f) {
      hTe(f, o, pl.parseError);
    }
  }
  if (o.length > 0)
    throw o[0];
}, "runThrowsErrors"), Dee = /* @__PURE__ */ w(function(t) {
  Zu.initialize(t);
}, "initialize"), dTe = /* @__PURE__ */ w(async function(t, e, r) {
  ae.warn("mermaid.init is deprecated. Please use run instead."), t && Dee(t);
  const n = { postRenderCallback: r, querySelector: ".mermaid" };
  typeof e == "string" ? n.querySelector = e : e && (e instanceof HTMLElement ? n.nodes = [e] : n.nodes = e), await Nee(n);
}, "init"), pTe = /* @__PURE__ */ w(async (t, {
  lazyLoad: e = !0
} = {}) => {
  m4(), Z7(...t), e === !1 && await $we();
}, "registerExternalDiagrams"), Oee = /* @__PURE__ */ w(function() {
  if (pl.startOnLoad) {
    const { startOnLoad: t } = Zu.getConfig();
    t && pl.run().catch((e) => ae.error("Mermaid failed to initialize", e));
  }
}, "contentLoaded");
typeof document < "u" && window.addEventListener("load", Oee, !1);
var gTe = /* @__PURE__ */ w(function(t) {
  pl.parseError = t;
}, "setParseErrorHandler"), mb = [], G5 = !1, Pee = /* @__PURE__ */ w(async () => {
  if (!G5) {
    for (G5 = !0; mb.length > 0; ) {
      const t = mb.shift();
      if (t)
        try {
          await t();
        } catch (e) {
          ae.error("Error executing queue", e);
        }
    }
    G5 = !1;
  }
}, "executeQueue"), mTe = /* @__PURE__ */ w(async (t, e) => new Promise((r, n) => {
  const i = /* @__PURE__ */ w(() => new Promise((a, s) => {
    Zu.parse(t, e).then(
      (o) => {
        a(o), r(o);
      },
      (o) => {
        ae.error("Error parsing", o), pl.parseError?.(o), s(o), n(o);
      }
    );
  }), "performCall");
  mb.push(i), Pee().catch(n);
}), "parse"), $ee = /* @__PURE__ */ w((t, e, r) => new Promise((n, i) => {
  const a = /* @__PURE__ */ w(() => new Promise((s, o) => {
    Zu.render(t, e, r).then(
      (l) => {
        s(l), n(l);
      },
      (l) => {
        ae.error("Error parsing", l), pl.parseError?.(l), o(l), i(l);
      }
    );
  }), "performCall");
  mb.push(a), Pee().catch(i);
}), "render"), vTe = /* @__PURE__ */ w(() => Object.keys(qu).map((t) => ({
  id: t
})), "getRegisteredDiagramsMetadata"), pl = {
  startOnLoad: !0,
  mermaidAPI: Zu,
  parse: mTe,
  render: $ee,
  init: dTe,
  run: Nee,
  registerExternalDiagrams: pTe,
  registerLayoutLoaders: UJ,
  initialize: Dee,
  parseError: void 0,
  contentLoaded: Oee,
  setParseErrorHandler: gTe,
  detectType: c9,
  registerIconPacks: KZ,
  getRegisteredDiagramsMetadata: vTe
}, wD = pl;
/*! Check if previously processed */
/*!
 * Wait for document loaded before starting the execution
 */
function yTe(t, e, r) {
  const n = t.toUpperCase(), i = /* @__PURE__ */ new Map();
  i.set(n, 0);
  const a = /* @__PURE__ */ new Map();
  for (const l of e.links) {
    const u = to(l.source), h = to(l.target);
    a.has(u) || a.set(u, []), a.has(h) || a.set(h, []), a.get(u).push(h), a.get(h).push(u);
  }
  const s = [n];
  let o = 0;
  for (; s.length > 0; ) {
    const l = s.shift(), u = i.get(l);
    if (u >= r) continue;
    const h = a.get(l) || [];
    for (const f of h)
      if (!i.has(f)) {
        const d = u + 1;
        i.set(f, d), d > o && (o = d), s.push(f);
      }
  }
  return { depths: i, maxDepth: o };
}
function Bee(t, e) {
  if (t === 0)
    return { bg: "hsl(210, 75%, 48%)", text: "#fff" };
  const r = e <= 1 ? 0 : (t - 1) / (e - 1), n = Math.round(60 - r * 25), i = Math.round(52 - r * 8);
  return { bg: `hsl(40, ${n}%, ${i}%)`, text: "#fff" };
}
function to(t) {
  return t.toUpperCase().split(".").pop();
}
let TD = !1, bTe = 0;
class xTe {
  constructor(e, r) {
    if (this.container = e, this.diagram = r, this.entityMap = /* @__PURE__ */ new Map(), this._originalStyles = /* @__PURE__ */ new Map(), this.svgEl = null, !TD) {
      const n = typeof document < "u" && document.body && (document.body.classList.contains("vscode-dark") || document.body.getAttribute("data-vscode-theme-kind") === "vscode-dark") || typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      wD.initialize({
        startOnLoad: !1,
        theme: n ? "dark" : "base",
        themeVariables: {
          fontSize: "12px"
        },
        er: {
          useMaxWidth: !1
        }
      }), TD = !0;
    }
    this.wrapper = document.createElement("div"), this.wrapper.className = "qs-erd-mermaid-wrapper", this.inner = document.createElement("div"), this.inner.className = "qs-erd-mermaid-inner", this.wrapper.appendChild(this.inner), this.container.appendChild(this.wrapper), this._scale = 1, this._setupZoom(), this._setupPan();
  }
  async render(e) {
    const r = this._generateMermaidCode(e), n = `qs-erd-mermaid-${bTe++}`;
    try {
      const { svg: i } = await wD.render(n, r);
      this.inner.innerHTML = i, this.svgEl = this.inner.querySelector("svg"), this._buildEntityMap(), this._attachClickHandlers();
    } catch (i) {
      this.inner.innerHTML = `<pre class="qs-erd-error">Diagram render error: ${i.message}</pre>`;
    }
  }
  _generateMermaidCode(e) {
    let r = `erDiagram
`;
    for (const n of e.items) {
      const i = U5(n.name);
      if (r += `    ${i} {
`, n.columns)
        for (const a of n.columns) {
          const s = ED(a.name), o = ED(a.datatype);
          r += `        ${s} ${o}
`;
        }
      r += `    }
`;
    }
    for (const n of e.links) {
      const i = U5(n.source), a = U5(n.target);
      r += `    ${i} ||--o{ ${a} : ""
`;
    }
    return r;
  }
  _buildEntityMap() {
    if (this.entityMap.clear(), this._originalStyles.clear(), !this.svgEl) return;
    let e = this.svgEl.querySelectorAll("g.node");
    e.length > 0 ? this._buildEntityMapV11(e) : (e = this.svgEl.querySelectorAll(".entity"), this._buildEntityMapLegacy(e));
  }
  _buildEntityMapV11(e) {
    for (const r of e) {
      const n = r.querySelector("g.name, g.label.name");
      if (!n) continue;
      const i = n.textContent.trim().toUpperCase();
      if (!i) continue;
      const a = r.querySelectorAll(
        ":scope > g:first-child path, .row-rect-even path, .row-rect-odd path"
      );
      this.entityMap.set(i, { g: r, fillPaths: a });
      const s = [];
      for (const o of a)
        s.push(o.getAttribute("style") || "");
      this._originalStyles.set(i, s);
    }
  }
  _buildEntityMapLegacy(e) {
    for (const r of e) {
      const n = r.querySelector(".er-entityLabel");
      if (!n) continue;
      const i = n.textContent.trim().toUpperCase();
      if (!i) continue;
      const a = r.querySelector(".er-entityBox") || r.querySelector("rect"), s = a ? [a] : [];
      this.entityMap.set(i, { g: r, fillPaths: s });
      const o = [];
      for (const l of s)
        o.push(l.getAttribute("style") || "");
      this._originalStyles.set(i, o);
    }
  }
  _attachClickHandlers() {
    for (const [e, { g: r }] of this.entityMap)
      r.style.cursor = "pointer", r.addEventListener("click", (n) => {
        n.stopPropagation(), this.diagram.onTableClick(e);
      });
    this.svgEl && this.svgEl.addEventListener("click", () => {
      this.diagram.highlightedTable && this.diagram.onTableClick(this.diagram.highlightedTable);
    });
  }
  _colorEntity(e, r, n, i) {
    for (const a of r)
      a.style.fill = n, a.style.stroke = n;
    if (i)
      for (const a of e.querySelectorAll("text"))
        a.style.fill = i;
  }
  applyHighlight(e) {
    const { depths: r, maxDepth: n } = e;
    for (const [i, { g: a, fillPaths: s }] of this.entityMap) {
      const o = to(i);
      if (r.has(o)) {
        const l = r.get(o), { bg: u, text: h } = Bee(l, n);
        this._colorEntity(a, s, u, h), a.style.opacity = "1";
      } else
        a.style.opacity = "0.15";
    }
    if (this.svgEl) {
      const i = this.svgEl.querySelectorAll(".edge, .er-relationshipLine, .relationship");
      for (const a of i)
        a.style.opacity = "0.1";
    }
  }
  focusEntity(e) {
    if (!e) {
      this.clearHighlight();
      return;
    }
    const r = e.toUpperCase();
    for (const [n, { g: i, fillPaths: a }] of this.entityMap)
      if (n === r) {
        this._colorEntity(i, a, "hsl(210, 75%, 48%)", "#fff"), i.style.opacity = "1";
        const s = this.wrapper.getBoundingClientRect(), o = i.getBoundingClientRect(), l = o.left + o.width / 2 - s.left, u = o.top + o.height / 2 - s.top;
        this.wrapper.scrollLeft += l - s.width / 2, this.wrapper.scrollTop += u - s.height / 2;
      } else
        i.style.opacity = "0.15";
    if (this.svgEl) {
      const n = this.svgEl.querySelectorAll(".edge, .er-relationshipLine, .relationship");
      for (const i of n)
        i.style.opacity = "0.1";
    }
  }
  clearHighlight() {
    for (const [e, { g: r, fillPaths: n }] of this.entityMap) {
      r.style.opacity = "";
      const i = this._originalStyles.get(e) || [];
      n.forEach((a, s) => {
        i[s] != null ? a.setAttribute("style", i[s]) : (a.style.fill = "", a.style.stroke = "");
      });
      for (const a of r.querySelectorAll("text"))
        a.style.fill = "";
    }
    if (this.svgEl) {
      const e = this.svgEl.querySelectorAll(".edge, .er-relationshipLine, .relationship, path, line");
      for (const r of e)
        r.style.opacity = "";
    }
  }
  _setupZoom() {
    this.wrapper.addEventListener("wheel", (e) => {
      e.preventDefault();
      const r = this._scale, n = e.deltaY > 0 ? -0.1 : 0.1, i = Math.min(3, Math.max(0.2, r + n));
      if (i === r) return;
      const a = this.wrapper.getBoundingClientRect(), s = e.clientX - a.left + this.wrapper.scrollLeft, o = e.clientY - a.top + this.wrapper.scrollTop, l = s / r, u = o / r;
      this._scale = i, this.inner.style.transform = `scale(${i})`, this.wrapper.scrollLeft = l * i - (e.clientX - a.left), this.wrapper.scrollTop = u * i - (e.clientY - a.top);
    }, { passive: !1 });
  }
  _setupPan() {
    let e = !1, r = !1, n = 0, i = 0, a = 0, s = 0;
    this.wrapper.addEventListener("mousedown", (o) => {
      o.button === 0 && (e = !0, r = !1, n = o.clientX, i = o.clientY, a = this.wrapper.scrollLeft, s = this.wrapper.scrollTop);
    }), window.addEventListener("mousemove", (o) => {
      if (!e) return;
      const l = o.clientX - n, u = o.clientY - i;
      !r && Math.abs(l) < 3 && Math.abs(u) < 3 || (r = !0, o.preventDefault(), this.wrapper.style.cursor = "grabbing", this.wrapper.scrollLeft = a - l, this.wrapper.scrollTop = s - u);
    }), window.addEventListener("mouseup", () => {
      e && (e = !1, this.wrapper.style.cursor = "grab");
    });
  }
  destroy() {
    this.container.innerHTML = "", this.entityMap.clear(), this._originalStyles.clear(), this.svgEl = null;
  }
}
function U5(t) {
  return t.replace(/\./g, "_").replace(/[^a-zA-Z0-9_]/g, "_").toUpperCase();
}
function ED(t) {
  return t.replace(/[^a-zA-Z0-9_()]/g, "_");
}
function gL(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var V5, SD;
function wTe() {
  if (SD) return V5;
  SD = 1;
  function t() {
    this.__data__ = [], this.size = 0;
  }
  return V5 = t, V5;
}
var H5, kD;
function N0() {
  if (kD) return H5;
  kD = 1;
  function t(e, r) {
    return e === r || e !== e && r !== r;
  }
  return H5 = t, H5;
}
var W5, CD;
function v4() {
  if (CD) return W5;
  CD = 1;
  var t = N0();
  function e(r, n) {
    for (var i = r.length; i--; )
      if (t(r[i][0], n))
        return i;
    return -1;
  }
  return W5 = e, W5;
}
var Y5, _D;
function TTe() {
  if (_D) return Y5;
  _D = 1;
  var t = v4(), e = Array.prototype, r = e.splice;
  function n(i) {
    var a = this.__data__, s = t(a, i);
    if (s < 0)
      return !1;
    var o = a.length - 1;
    return s == o ? a.pop() : r.call(a, s, 1), --this.size, !0;
  }
  return Y5 = n, Y5;
}
var X5, AD;
function ETe() {
  if (AD) return X5;
  AD = 1;
  var t = v4();
  function e(r) {
    var n = this.__data__, i = t(n, r);
    return i < 0 ? void 0 : n[i][1];
  }
  return X5 = e, X5;
}
var j5, LD;
function STe() {
  if (LD) return j5;
  LD = 1;
  var t = v4();
  function e(r) {
    return t(this.__data__, r) > -1;
  }
  return j5 = e, j5;
}
var K5, RD;
function kTe() {
  if (RD) return K5;
  RD = 1;
  var t = v4();
  function e(r, n) {
    var i = this.__data__, a = t(i, r);
    return a < 0 ? (++this.size, i.push([r, n])) : i[a][1] = n, this;
  }
  return K5 = e, K5;
}
var Z5, ID;
function y4() {
  if (ID) return Z5;
  ID = 1;
  var t = wTe(), e = TTe(), r = ETe(), n = STe(), i = kTe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, Z5 = a, Z5;
}
var Q5, MD;
function CTe() {
  if (MD) return Q5;
  MD = 1;
  var t = y4();
  function e() {
    this.__data__ = new t(), this.size = 0;
  }
  return Q5 = e, Q5;
}
var J5, ND;
function _Te() {
  if (ND) return J5;
  ND = 1;
  function t(e) {
    var r = this.__data__, n = r.delete(e);
    return this.size = r.size, n;
  }
  return J5 = t, J5;
}
var ew, DD;
function ATe() {
  if (DD) return ew;
  DD = 1;
  function t(e) {
    return this.__data__.get(e);
  }
  return ew = t, ew;
}
var tw, OD;
function LTe() {
  if (OD) return tw;
  OD = 1;
  function t(e) {
    return this.__data__.has(e);
  }
  return tw = t, tw;
}
var rw, PD;
function Fee() {
  if (PD) return rw;
  PD = 1;
  var t = typeof Jm == "object" && Jm && Jm.Object === Object && Jm;
  return rw = t, rw;
}
var nw, $D;
function Fs() {
  if ($D) return nw;
  $D = 1;
  var t = Fee(), e = typeof self == "object" && self && self.Object === Object && self, r = t || e || Function("return this")();
  return nw = r, nw;
}
var iw, BD;
function D0() {
  if (BD) return iw;
  BD = 1;
  var t = Fs(), e = t.Symbol;
  return iw = e, iw;
}
var aw, FD;
function RTe() {
  if (FD) return aw;
  FD = 1;
  var t = D0(), e = Object.prototype, r = e.hasOwnProperty, n = e.toString, i = t ? t.toStringTag : void 0;
  function a(s) {
    var o = r.call(s, i), l = s[i];
    try {
      s[i] = void 0;
      var u = !0;
    } catch {
    }
    var h = n.call(s);
    return u && (o ? s[i] = l : delete s[i]), h;
  }
  return aw = a, aw;
}
var sw, zD;
function ITe() {
  if (zD) return sw;
  zD = 1;
  var t = Object.prototype, e = t.toString;
  function r(n) {
    return e.call(n);
  }
  return sw = r, sw;
}
var ow, qD;
function Ch() {
  if (qD) return ow;
  qD = 1;
  var t = D0(), e = RTe(), r = ITe(), n = "[object Null]", i = "[object Undefined]", a = t ? t.toStringTag : void 0;
  function s(o) {
    return o == null ? o === void 0 ? i : n : a && a in Object(o) ? e(o) : r(o);
  }
  return ow = s, ow;
}
var lw, GD;
function hs() {
  if (GD) return lw;
  GD = 1;
  function t(e) {
    var r = typeof e;
    return e != null && (r == "object" || r == "function");
  }
  return lw = t, lw;
}
var cw, UD;
function lm() {
  if (UD) return cw;
  UD = 1;
  var t = Ch(), e = hs(), r = "[object AsyncFunction]", n = "[object Function]", i = "[object GeneratorFunction]", a = "[object Proxy]";
  function s(o) {
    if (!e(o))
      return !1;
    var l = t(o);
    return l == n || l == i || l == r || l == a;
  }
  return cw = s, cw;
}
var uw, VD;
function MTe() {
  if (VD) return uw;
  VD = 1;
  var t = Fs(), e = t["__core-js_shared__"];
  return uw = e, uw;
}
var hw, HD;
function NTe() {
  if (HD) return hw;
  HD = 1;
  var t = MTe(), e = (function() {
    var n = /[^.]+$/.exec(t && t.keys && t.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  })();
  function r(n) {
    return !!e && e in n;
  }
  return hw = r, hw;
}
var fw, WD;
function zee() {
  if (WD) return fw;
  WD = 1;
  var t = Function.prototype, e = t.toString;
  function r(n) {
    if (n != null) {
      try {
        return e.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  return fw = r, fw;
}
var dw, YD;
function DTe() {
  if (YD) return dw;
  YD = 1;
  var t = lm(), e = NTe(), r = hs(), n = zee(), i = /[\\^$.*+?()[\]{}|]/g, a = /^\[object .+?Constructor\]$/, s = Function.prototype, o = Object.prototype, l = s.toString, u = o.hasOwnProperty, h = RegExp(
    "^" + l.call(u).replace(i, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function f(d) {
    if (!r(d) || e(d))
      return !1;
    var p = t(d) ? h : a;
    return p.test(n(d));
  }
  return dw = f, dw;
}
var pw, XD;
function OTe() {
  if (XD) return pw;
  XD = 1;
  function t(e, r) {
    return e?.[r];
  }
  return pw = t, pw;
}
var gw, jD;
function _h() {
  if (jD) return gw;
  jD = 1;
  var t = DTe(), e = OTe();
  function r(n, i) {
    var a = e(n, i);
    return t(a) ? a : void 0;
  }
  return gw = r, gw;
}
var mw, KD;
function mL() {
  if (KD) return mw;
  KD = 1;
  var t = _h(), e = Fs(), r = t(e, "Map");
  return mw = r, mw;
}
var vw, ZD;
function b4() {
  if (ZD) return vw;
  ZD = 1;
  var t = _h(), e = t(Object, "create");
  return vw = e, vw;
}
var yw, QD;
function PTe() {
  if (QD) return yw;
  QD = 1;
  var t = b4();
  function e() {
    this.__data__ = t ? t(null) : {}, this.size = 0;
  }
  return yw = e, yw;
}
var bw, JD;
function $Te() {
  if (JD) return bw;
  JD = 1;
  function t(e) {
    var r = this.has(e) && delete this.__data__[e];
    return this.size -= r ? 1 : 0, r;
  }
  return bw = t, bw;
}
var xw, eO;
function BTe() {
  if (eO) return xw;
  eO = 1;
  var t = b4(), e = "__lodash_hash_undefined__", r = Object.prototype, n = r.hasOwnProperty;
  function i(a) {
    var s = this.__data__;
    if (t) {
      var o = s[a];
      return o === e ? void 0 : o;
    }
    return n.call(s, a) ? s[a] : void 0;
  }
  return xw = i, xw;
}
var ww, tO;
function FTe() {
  if (tO) return ww;
  tO = 1;
  var t = b4(), e = Object.prototype, r = e.hasOwnProperty;
  function n(i) {
    var a = this.__data__;
    return t ? a[i] !== void 0 : r.call(a, i);
  }
  return ww = n, ww;
}
var Tw, rO;
function zTe() {
  if (rO) return Tw;
  rO = 1;
  var t = b4(), e = "__lodash_hash_undefined__";
  function r(n, i) {
    var a = this.__data__;
    return this.size += this.has(n) ? 0 : 1, a[n] = t && i === void 0 ? e : i, this;
  }
  return Tw = r, Tw;
}
var Ew, nO;
function qTe() {
  if (nO) return Ew;
  nO = 1;
  var t = PTe(), e = $Te(), r = BTe(), n = FTe(), i = zTe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, Ew = a, Ew;
}
var Sw, iO;
function GTe() {
  if (iO) return Sw;
  iO = 1;
  var t = qTe(), e = y4(), r = mL();
  function n() {
    this.size = 0, this.__data__ = {
      hash: new t(),
      map: new (r || e)(),
      string: new t()
    };
  }
  return Sw = n, Sw;
}
var kw, aO;
function UTe() {
  if (aO) return kw;
  aO = 1;
  function t(e) {
    var r = typeof e;
    return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? e !== "__proto__" : e === null;
  }
  return kw = t, kw;
}
var Cw, sO;
function x4() {
  if (sO) return Cw;
  sO = 1;
  var t = UTe();
  function e(r, n) {
    var i = r.__data__;
    return t(n) ? i[typeof n == "string" ? "string" : "hash"] : i.map;
  }
  return Cw = e, Cw;
}
var _w, oO;
function VTe() {
  if (oO) return _w;
  oO = 1;
  var t = x4();
  function e(r) {
    var n = t(this, r).delete(r);
    return this.size -= n ? 1 : 0, n;
  }
  return _w = e, _w;
}
var Aw, lO;
function HTe() {
  if (lO) return Aw;
  lO = 1;
  var t = x4();
  function e(r) {
    return t(this, r).get(r);
  }
  return Aw = e, Aw;
}
var Lw, cO;
function WTe() {
  if (cO) return Lw;
  cO = 1;
  var t = x4();
  function e(r) {
    return t(this, r).has(r);
  }
  return Lw = e, Lw;
}
var Rw, uO;
function YTe() {
  if (uO) return Rw;
  uO = 1;
  var t = x4();
  function e(r, n) {
    var i = t(this, r), a = i.size;
    return i.set(r, n), this.size += i.size == a ? 0 : 1, this;
  }
  return Rw = e, Rw;
}
var Iw, hO;
function vL() {
  if (hO) return Iw;
  hO = 1;
  var t = GTe(), e = VTe(), r = HTe(), n = WTe(), i = YTe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, Iw = a, Iw;
}
var Mw, fO;
function XTe() {
  if (fO) return Mw;
  fO = 1;
  var t = y4(), e = mL(), r = vL(), n = 200;
  function i(a, s) {
    var o = this.__data__;
    if (o instanceof t) {
      var l = o.__data__;
      if (!e || l.length < n - 1)
        return l.push([a, s]), this.size = ++o.size, this;
      o = this.__data__ = new r(l);
    }
    return o.set(a, s), this.size = o.size, this;
  }
  return Mw = i, Mw;
}
var Nw, dO;
function w4() {
  if (dO) return Nw;
  dO = 1;
  var t = y4(), e = CTe(), r = _Te(), n = ATe(), i = LTe(), a = XTe();
  function s(o) {
    var l = this.__data__ = new t(o);
    this.size = l.size;
  }
  return s.prototype.clear = e, s.prototype.delete = r, s.prototype.get = n, s.prototype.has = i, s.prototype.set = a, Nw = s, Nw;
}
var Dw, pO;
function yL() {
  if (pO) return Dw;
  pO = 1;
  function t(e, r) {
    for (var n = -1, i = e == null ? 0 : e.length; ++n < i && r(e[n], n, e) !== !1; )
      ;
    return e;
  }
  return Dw = t, Dw;
}
var Ow, gO;
function qee() {
  if (gO) return Ow;
  gO = 1;
  var t = _h(), e = (function() {
    try {
      var r = t(Object, "defineProperty");
      return r({}, "", {}), r;
    } catch {
    }
  })();
  return Ow = e, Ow;
}
var Pw, mO;
function T4() {
  if (mO) return Pw;
  mO = 1;
  var t = qee();
  function e(r, n, i) {
    n == "__proto__" && t ? t(r, n, {
      configurable: !0,
      enumerable: !0,
      value: i,
      writable: !0
    }) : r[n] = i;
  }
  return Pw = e, Pw;
}
var $w, vO;
function E4() {
  if (vO) return $w;
  vO = 1;
  var t = T4(), e = N0(), r = Object.prototype, n = r.hasOwnProperty;
  function i(a, s, o) {
    var l = a[s];
    (!(n.call(a, s) && e(l, o)) || o === void 0 && !(s in a)) && t(a, s, o);
  }
  return $w = i, $w;
}
var Bw, yO;
function cm() {
  if (yO) return Bw;
  yO = 1;
  var t = E4(), e = T4();
  function r(n, i, a, s) {
    var o = !a;
    a || (a = {});
    for (var l = -1, u = i.length; ++l < u; ) {
      var h = i[l], f = s ? s(a[h], n[h], h, a, n) : void 0;
      f === void 0 && (f = n[h]), o ? e(a, h, f) : t(a, h, f);
    }
    return a;
  }
  return Bw = r, Bw;
}
var Fw, bO;
function jTe() {
  if (bO) return Fw;
  bO = 1;
  function t(e, r) {
    for (var n = -1, i = Array(e); ++n < e; )
      i[n] = r(n);
    return i;
  }
  return Fw = t, Fw;
}
var zw, xO;
function To() {
  if (xO) return zw;
  xO = 1;
  function t(e) {
    return e != null && typeof e == "object";
  }
  return zw = t, zw;
}
var qw, wO;
function KTe() {
  if (wO) return qw;
  wO = 1;
  var t = Ch(), e = To(), r = "[object Arguments]";
  function n(i) {
    return e(i) && t(i) == r;
  }
  return qw = n, qw;
}
var Gw, TO;
function um() {
  if (TO) return Gw;
  TO = 1;
  var t = KTe(), e = To(), r = Object.prototype, n = r.hasOwnProperty, i = r.propertyIsEnumerable, a = t(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? t : function(s) {
    return e(s) && n.call(s, "callee") && !i.call(s, "callee");
  };
  return Gw = a, Gw;
}
var Uw, EO;
function Nn() {
  if (EO) return Uw;
  EO = 1;
  var t = Array.isArray;
  return Uw = t, Uw;
}
var $p = { exports: {} }, Vw, SO;
function ZTe() {
  if (SO) return Vw;
  SO = 1;
  function t() {
    return !1;
  }
  return Vw = t, Vw;
}
$p.exports;
var kO;
function O0() {
  return kO || (kO = 1, (function(t, e) {
    var r = Fs(), n = ZTe(), i = e && !e.nodeType && e, a = i && !0 && t && !t.nodeType && t, s = a && a.exports === i, o = s ? r.Buffer : void 0, l = o ? o.isBuffer : void 0, u = l || n;
    t.exports = u;
  })($p, $p.exports)), $p.exports;
}
var Hw, CO;
function S4() {
  if (CO) return Hw;
  CO = 1;
  var t = 9007199254740991, e = /^(?:0|[1-9]\d*)$/;
  function r(n, i) {
    var a = typeof n;
    return i = i ?? t, !!i && (a == "number" || a != "symbol" && e.test(n)) && n > -1 && n % 1 == 0 && n < i;
  }
  return Hw = r, Hw;
}
var Ww, _O;
function bL() {
  if (_O) return Ww;
  _O = 1;
  var t = 9007199254740991;
  function e(r) {
    return typeof r == "number" && r > -1 && r % 1 == 0 && r <= t;
  }
  return Ww = e, Ww;
}
var Yw, AO;
function QTe() {
  if (AO) return Yw;
  AO = 1;
  var t = Ch(), e = bL(), r = To(), n = "[object Arguments]", i = "[object Array]", a = "[object Boolean]", s = "[object Date]", o = "[object Error]", l = "[object Function]", u = "[object Map]", h = "[object Number]", f = "[object Object]", d = "[object RegExp]", p = "[object Set]", g = "[object String]", m = "[object WeakMap]", v = "[object ArrayBuffer]", y = "[object DataView]", b = "[object Float32Array]", x = "[object Float64Array]", T = "[object Int8Array]", E = "[object Int16Array]", A = "[object Int32Array]", S = "[object Uint8Array]", k = "[object Uint8ClampedArray]", _ = "[object Uint16Array]", R = "[object Uint32Array]", L = {};
  L[b] = L[x] = L[T] = L[E] = L[A] = L[S] = L[k] = L[_] = L[R] = !0, L[n] = L[i] = L[v] = L[a] = L[y] = L[s] = L[o] = L[l] = L[u] = L[h] = L[f] = L[d] = L[p] = L[g] = L[m] = !1;
  function M(P) {
    return r(P) && e(P.length) && !!L[t(P)];
  }
  return Yw = M, Yw;
}
var Xw, LO;
function k4() {
  if (LO) return Xw;
  LO = 1;
  function t(e) {
    return function(r) {
      return e(r);
    };
  }
  return Xw = t, Xw;
}
var Bp = { exports: {} };
Bp.exports;
var RO;
function xL() {
  return RO || (RO = 1, (function(t, e) {
    var r = Fee(), n = e && !e.nodeType && e, i = n && !0 && t && !t.nodeType && t, a = i && i.exports === n, s = a && r.process, o = (function() {
      try {
        var l = i && i.require && i.require("util").types;
        return l || s && s.binding && s.binding("util");
      } catch {
      }
    })();
    t.exports = o;
  })(Bp, Bp.exports)), Bp.exports;
}
var jw, IO;
function hm() {
  if (IO) return jw;
  IO = 1;
  var t = QTe(), e = k4(), r = xL(), n = r && r.isTypedArray, i = n ? e(n) : t;
  return jw = i, jw;
}
var Kw, MO;
function Gee() {
  if (MO) return Kw;
  MO = 1;
  var t = jTe(), e = um(), r = Nn(), n = O0(), i = S4(), a = hm(), s = Object.prototype, o = s.hasOwnProperty;
  function l(u, h) {
    var f = r(u), d = !f && e(u), p = !f && !d && n(u), g = !f && !d && !p && a(u), m = f || d || p || g, v = m ? t(u.length, String) : [], y = v.length;
    for (var b in u)
      (h || o.call(u, b)) && !(m && // Safari 9 has enumerable `arguments.length` in strict mode.
      (b == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      p && (b == "offset" || b == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      g && (b == "buffer" || b == "byteLength" || b == "byteOffset") || // Skip index properties.
      i(b, y))) && v.push(b);
    return v;
  }
  return Kw = l, Kw;
}
var Zw, NO;
function C4() {
  if (NO) return Zw;
  NO = 1;
  var t = Object.prototype;
  function e(r) {
    var n = r && r.constructor, i = typeof n == "function" && n.prototype || t;
    return r === i;
  }
  return Zw = e, Zw;
}
var Qw, DO;
function Uee() {
  if (DO) return Qw;
  DO = 1;
  function t(e, r) {
    return function(n) {
      return e(r(n));
    };
  }
  return Qw = t, Qw;
}
var Jw, OO;
function JTe() {
  if (OO) return Jw;
  OO = 1;
  var t = Uee(), e = t(Object.keys, Object);
  return Jw = e, Jw;
}
var eT, PO;
function wL() {
  if (PO) return eT;
  PO = 1;
  var t = C4(), e = JTe(), r = Object.prototype, n = r.hasOwnProperty;
  function i(a) {
    if (!t(a))
      return e(a);
    var s = [];
    for (var o in Object(a))
      n.call(a, o) && o != "constructor" && s.push(o);
    return s;
  }
  return eT = i, eT;
}
var tT, $O;
function Cl() {
  if ($O) return tT;
  $O = 1;
  var t = lm(), e = bL();
  function r(n) {
    return n != null && e(n.length) && !t(n);
  }
  return tT = r, tT;
}
var rT, BO;
function zc() {
  if (BO) return rT;
  BO = 1;
  var t = Gee(), e = wL(), r = Cl();
  function n(i) {
    return r(i) ? t(i) : e(i);
  }
  return rT = n, rT;
}
var nT, FO;
function e6e() {
  if (FO) return nT;
  FO = 1;
  var t = cm(), e = zc();
  function r(n, i) {
    return n && t(i, e(i), n);
  }
  return nT = r, nT;
}
var iT, zO;
function t6e() {
  if (zO) return iT;
  zO = 1;
  function t(e) {
    var r = [];
    if (e != null)
      for (var n in Object(e))
        r.push(n);
    return r;
  }
  return iT = t, iT;
}
var aT, qO;
function r6e() {
  if (qO) return aT;
  qO = 1;
  var t = hs(), e = C4(), r = t6e(), n = Object.prototype, i = n.hasOwnProperty;
  function a(s) {
    if (!t(s))
      return r(s);
    var o = e(s), l = [];
    for (var u in s)
      u == "constructor" && (o || !i.call(s, u)) || l.push(u);
    return l;
  }
  return aT = a, aT;
}
var sT, GO;
function Ah() {
  if (GO) return sT;
  GO = 1;
  var t = Gee(), e = r6e(), r = Cl();
  function n(i) {
    return r(i) ? t(i, !0) : e(i);
  }
  return sT = n, sT;
}
var oT, UO;
function n6e() {
  if (UO) return oT;
  UO = 1;
  var t = cm(), e = Ah();
  function r(n, i) {
    return n && t(i, e(i), n);
  }
  return oT = r, oT;
}
var Fp = { exports: {} };
Fp.exports;
var VO;
function Vee() {
  return VO || (VO = 1, (function(t, e) {
    var r = Fs(), n = e && !e.nodeType && e, i = n && !0 && t && !t.nodeType && t, a = i && i.exports === n, s = a ? r.Buffer : void 0, o = s ? s.allocUnsafe : void 0;
    function l(u, h) {
      if (h)
        return u.slice();
      var f = u.length, d = o ? o(f) : new u.constructor(f);
      return u.copy(d), d;
    }
    t.exports = l;
  })(Fp, Fp.exports)), Fp.exports;
}
var lT, HO;
function Hee() {
  if (HO) return lT;
  HO = 1;
  function t(e, r) {
    var n = -1, i = e.length;
    for (r || (r = Array(i)); ++n < i; )
      r[n] = e[n];
    return r;
  }
  return lT = t, lT;
}
var cT, WO;
function Wee() {
  if (WO) return cT;
  WO = 1;
  function t(e, r) {
    for (var n = -1, i = e == null ? 0 : e.length, a = 0, s = []; ++n < i; ) {
      var o = e[n];
      r(o, n, e) && (s[a++] = o);
    }
    return s;
  }
  return cT = t, cT;
}
var uT, YO;
function Yee() {
  if (YO) return uT;
  YO = 1;
  function t() {
    return [];
  }
  return uT = t, uT;
}
var hT, XO;
function TL() {
  if (XO) return hT;
  XO = 1;
  var t = Wee(), e = Yee(), r = Object.prototype, n = r.propertyIsEnumerable, i = Object.getOwnPropertySymbols, a = i ? function(s) {
    return s == null ? [] : (s = Object(s), t(i(s), function(o) {
      return n.call(s, o);
    }));
  } : e;
  return hT = a, hT;
}
var fT, jO;
function i6e() {
  if (jO) return fT;
  jO = 1;
  var t = cm(), e = TL();
  function r(n, i) {
    return t(n, e(n), i);
  }
  return fT = r, fT;
}
var dT, KO;
function EL() {
  if (KO) return dT;
  KO = 1;
  function t(e, r) {
    for (var n = -1, i = r.length, a = e.length; ++n < i; )
      e[a + n] = r[n];
    return e;
  }
  return dT = t, dT;
}
var pT, ZO;
function _4() {
  if (ZO) return pT;
  ZO = 1;
  var t = Uee(), e = t(Object.getPrototypeOf, Object);
  return pT = e, pT;
}
var gT, QO;
function Xee() {
  if (QO) return gT;
  QO = 1;
  var t = EL(), e = _4(), r = TL(), n = Yee(), i = Object.getOwnPropertySymbols, a = i ? function(s) {
    for (var o = []; s; )
      t(o, r(s)), s = e(s);
    return o;
  } : n;
  return gT = a, gT;
}
var mT, JO;
function a6e() {
  if (JO) return mT;
  JO = 1;
  var t = cm(), e = Xee();
  function r(n, i) {
    return t(n, e(n), i);
  }
  return mT = r, mT;
}
var vT, eP;
function jee() {
  if (eP) return vT;
  eP = 1;
  var t = EL(), e = Nn();
  function r(n, i, a) {
    var s = i(n);
    return e(n) ? s : t(s, a(n));
  }
  return vT = r, vT;
}
var yT, tP;
function Kee() {
  if (tP) return yT;
  tP = 1;
  var t = jee(), e = TL(), r = zc();
  function n(i) {
    return t(i, r, e);
  }
  return yT = n, yT;
}
var bT, rP;
function s6e() {
  if (rP) return bT;
  rP = 1;
  var t = jee(), e = Xee(), r = Ah();
  function n(i) {
    return t(i, r, e);
  }
  return bT = n, bT;
}
var xT, nP;
function o6e() {
  if (nP) return xT;
  nP = 1;
  var t = _h(), e = Fs(), r = t(e, "DataView");
  return xT = r, xT;
}
var wT, iP;
function l6e() {
  if (iP) return wT;
  iP = 1;
  var t = _h(), e = Fs(), r = t(e, "Promise");
  return wT = r, wT;
}
var TT, aP;
function Zee() {
  if (aP) return TT;
  aP = 1;
  var t = _h(), e = Fs(), r = t(e, "Set");
  return TT = r, TT;
}
var ET, sP;
function c6e() {
  if (sP) return ET;
  sP = 1;
  var t = _h(), e = Fs(), r = t(e, "WeakMap");
  return ET = r, ET;
}
var ST, oP;
function P0() {
  if (oP) return ST;
  oP = 1;
  var t = o6e(), e = mL(), r = l6e(), n = Zee(), i = c6e(), a = Ch(), s = zee(), o = "[object Map]", l = "[object Object]", u = "[object Promise]", h = "[object Set]", f = "[object WeakMap]", d = "[object DataView]", p = s(t), g = s(e), m = s(r), v = s(n), y = s(i), b = a;
  return (t && b(new t(new ArrayBuffer(1))) != d || e && b(new e()) != o || r && b(r.resolve()) != u || n && b(new n()) != h || i && b(new i()) != f) && (b = function(x) {
    var T = a(x), E = T == l ? x.constructor : void 0, A = E ? s(E) : "";
    if (A)
      switch (A) {
        case p:
          return d;
        case g:
          return o;
        case m:
          return u;
        case v:
          return h;
        case y:
          return f;
      }
    return T;
  }), ST = b, ST;
}
var kT, lP;
function u6e() {
  if (lP) return kT;
  lP = 1;
  var t = Object.prototype, e = t.hasOwnProperty;
  function r(n) {
    var i = n.length, a = new n.constructor(i);
    return i && typeof n[0] == "string" && e.call(n, "index") && (a.index = n.index, a.input = n.input), a;
  }
  return kT = r, kT;
}
var CT, cP;
function Qee() {
  if (cP) return CT;
  cP = 1;
  var t = Fs(), e = t.Uint8Array;
  return CT = e, CT;
}
var _T, uP;
function SL() {
  if (uP) return _T;
  uP = 1;
  var t = Qee();
  function e(r) {
    var n = new r.constructor(r.byteLength);
    return new t(n).set(new t(r)), n;
  }
  return _T = e, _T;
}
var AT, hP;
function h6e() {
  if (hP) return AT;
  hP = 1;
  var t = SL();
  function e(r, n) {
    var i = n ? t(r.buffer) : r.buffer;
    return new r.constructor(i, r.byteOffset, r.byteLength);
  }
  return AT = e, AT;
}
var LT, fP;
function f6e() {
  if (fP) return LT;
  fP = 1;
  var t = /\w*$/;
  function e(r) {
    var n = new r.constructor(r.source, t.exec(r));
    return n.lastIndex = r.lastIndex, n;
  }
  return LT = e, LT;
}
var RT, dP;
function d6e() {
  if (dP) return RT;
  dP = 1;
  var t = D0(), e = t ? t.prototype : void 0, r = e ? e.valueOf : void 0;
  function n(i) {
    return r ? Object(r.call(i)) : {};
  }
  return RT = n, RT;
}
var IT, pP;
function Jee() {
  if (pP) return IT;
  pP = 1;
  var t = SL();
  function e(r, n) {
    var i = n ? t(r.buffer) : r.buffer;
    return new r.constructor(i, r.byteOffset, r.length);
  }
  return IT = e, IT;
}
var MT, gP;
function p6e() {
  if (gP) return MT;
  gP = 1;
  var t = SL(), e = h6e(), r = f6e(), n = d6e(), i = Jee(), a = "[object Boolean]", s = "[object Date]", o = "[object Map]", l = "[object Number]", u = "[object RegExp]", h = "[object Set]", f = "[object String]", d = "[object Symbol]", p = "[object ArrayBuffer]", g = "[object DataView]", m = "[object Float32Array]", v = "[object Float64Array]", y = "[object Int8Array]", b = "[object Int16Array]", x = "[object Int32Array]", T = "[object Uint8Array]", E = "[object Uint8ClampedArray]", A = "[object Uint16Array]", S = "[object Uint32Array]";
  function k(_, R, L) {
    var M = _.constructor;
    switch (R) {
      case p:
        return t(_);
      case a:
      case s:
        return new M(+_);
      case g:
        return e(_, L);
      case m:
      case v:
      case y:
      case b:
      case x:
      case T:
      case E:
      case A:
      case S:
        return i(_, L);
      case o:
        return new M();
      case l:
      case f:
        return new M(_);
      case u:
        return r(_);
      case h:
        return new M();
      case d:
        return n(_);
    }
  }
  return MT = k, MT;
}
var NT, mP;
function ete() {
  if (mP) return NT;
  mP = 1;
  var t = hs(), e = Object.create, r = /* @__PURE__ */ (function() {
    function n() {
    }
    return function(i) {
      if (!t(i))
        return {};
      if (e)
        return e(i);
      n.prototype = i;
      var a = new n();
      return n.prototype = void 0, a;
    };
  })();
  return NT = r, NT;
}
var DT, vP;
function tte() {
  if (vP) return DT;
  vP = 1;
  var t = ete(), e = _4(), r = C4();
  function n(i) {
    return typeof i.constructor == "function" && !r(i) ? t(e(i)) : {};
  }
  return DT = n, DT;
}
var OT, yP;
function g6e() {
  if (yP) return OT;
  yP = 1;
  var t = P0(), e = To(), r = "[object Map]";
  function n(i) {
    return e(i) && t(i) == r;
  }
  return OT = n, OT;
}
var PT, bP;
function m6e() {
  if (bP) return PT;
  bP = 1;
  var t = g6e(), e = k4(), r = xL(), n = r && r.isMap, i = n ? e(n) : t;
  return PT = i, PT;
}
var $T, xP;
function v6e() {
  if (xP) return $T;
  xP = 1;
  var t = P0(), e = To(), r = "[object Set]";
  function n(i) {
    return e(i) && t(i) == r;
  }
  return $T = n, $T;
}
var BT, wP;
function y6e() {
  if (wP) return BT;
  wP = 1;
  var t = v6e(), e = k4(), r = xL(), n = r && r.isSet, i = n ? e(n) : t;
  return BT = i, BT;
}
var FT, TP;
function rte() {
  if (TP) return FT;
  TP = 1;
  var t = w4(), e = yL(), r = E4(), n = e6e(), i = n6e(), a = Vee(), s = Hee(), o = i6e(), l = a6e(), u = Kee(), h = s6e(), f = P0(), d = u6e(), p = p6e(), g = tte(), m = Nn(), v = O0(), y = m6e(), b = hs(), x = y6e(), T = zc(), E = Ah(), A = 1, S = 2, k = 4, _ = "[object Arguments]", R = "[object Array]", L = "[object Boolean]", M = "[object Date]", P = "[object Error]", C = "[object Function]", I = "[object GeneratorFunction]", N = "[object Map]", O = "[object Number]", D = "[object Object]", $ = "[object RegExp]", z = "[object Set]", B = "[object String]", G = "[object Symbol]", W = "[object WeakMap]", V = "[object ArrayBuffer]", U = "[object DataView]", Z = "[object Float32Array]", K = "[object Float64Array]", ce = "[object Int8Array]", J = "[object Int16Array]", ee = "[object Int32Array]", j = "[object Uint8Array]", X = "[object Uint8ClampedArray]", re = "[object Uint16Array]", Q = "[object Uint32Array]", ue = {};
  ue[_] = ue[R] = ue[V] = ue[U] = ue[L] = ue[M] = ue[Z] = ue[K] = ue[ce] = ue[J] = ue[ee] = ue[N] = ue[O] = ue[D] = ue[$] = ue[z] = ue[B] = ue[G] = ue[j] = ue[X] = ue[re] = ue[Q] = !0, ue[P] = ue[C] = ue[W] = !1;
  function ne(xe, Y, Ne, fe, qe, ze) {
    var Ge, Ee = Y & A, Oe = Y & S, Ce = Y & k;
    if (Ne && (Ge = qe ? Ne(xe, fe, qe, ze) : Ne(xe)), Ge !== void 0)
      return Ge;
    if (!b(xe))
      return xe;
    var Ae = m(xe);
    if (Ae) {
      if (Ge = d(xe), !Ee)
        return s(xe, Ge);
    } else {
      var $e = f(xe), me = $e == C || $e == I;
      if (v(xe))
        return a(xe, Ee);
      if ($e == D || $e == _ || me && !qe) {
        if (Ge = Oe || me ? {} : g(xe), !Ee)
          return Oe ? l(xe, i(Ge, xe)) : o(xe, n(Ge, xe));
      } else {
        if (!ue[$e])
          return qe ? xe : {};
        Ge = p(xe, $e, Ee);
      }
    }
    ze || (ze = new t());
    var Ie = ze.get(xe);
    if (Ie)
      return Ie;
    ze.set(xe, Ge), x(xe) ? xe.forEach(function(F) {
      Ge.add(ne(F, Y, Ne, F, xe, ze));
    }) : y(xe) && xe.forEach(function(F, oe) {
      Ge.set(oe, ne(F, Y, Ne, oe, xe, ze));
    });
    var te = Ce ? Oe ? h : u : Oe ? E : T, he = Ae ? void 0 : te(xe);
    return e(he || xe, function(F, oe) {
      he && (oe = F, F = xe[oe]), r(Ge, oe, ne(F, Y, Ne, oe, xe, ze));
    }), Ge;
  }
  return FT = ne, FT;
}
var zT, EP;
function b6e() {
  if (EP) return zT;
  EP = 1;
  var t = rte(), e = 4;
  function r(n) {
    return t(n, e);
  }
  return zT = r, zT;
}
var qT, SP;
function kL() {
  if (SP) return qT;
  SP = 1;
  function t(e) {
    return function() {
      return e;
    };
  }
  return qT = t, qT;
}
var GT, kP;
function x6e() {
  if (kP) return GT;
  kP = 1;
  function t(e) {
    return function(r, n, i) {
      for (var a = -1, s = Object(r), o = i(r), l = o.length; l--; ) {
        var u = o[e ? l : ++a];
        if (n(s[u], u, s) === !1)
          break;
      }
      return r;
    };
  }
  return GT = t, GT;
}
var UT, CP;
function CL() {
  if (CP) return UT;
  CP = 1;
  var t = x6e(), e = t();
  return UT = e, UT;
}
var VT, _P;
function _L() {
  if (_P) return VT;
  _P = 1;
  var t = CL(), e = zc();
  function r(n, i) {
    return n && t(n, i, e);
  }
  return VT = r, VT;
}
var HT, AP;
function w6e() {
  if (AP) return HT;
  AP = 1;
  var t = Cl();
  function e(r, n) {
    return function(i, a) {
      if (i == null)
        return i;
      if (!t(i))
        return r(i, a);
      for (var s = i.length, o = n ? s : -1, l = Object(i); (n ? o-- : ++o < s) && a(l[o], o, l) !== !1; )
        ;
      return i;
    };
  }
  return HT = e, HT;
}
var WT, LP;
function A4() {
  if (LP) return WT;
  LP = 1;
  var t = _L(), e = w6e(), r = e(t);
  return WT = r, WT;
}
var YT, RP;
function Lh() {
  if (RP) return YT;
  RP = 1;
  function t(e) {
    return e;
  }
  return YT = t, YT;
}
var XT, IP;
function nte() {
  if (IP) return XT;
  IP = 1;
  var t = Lh();
  function e(r) {
    return typeof r == "function" ? r : t;
  }
  return XT = e, XT;
}
var jT, MP;
function ite() {
  if (MP) return jT;
  MP = 1;
  var t = yL(), e = A4(), r = nte(), n = Nn();
  function i(a, s) {
    var o = n(a) ? t : e;
    return o(a, r(s));
  }
  return jT = i, jT;
}
var KT, NP;
function ate() {
  return NP || (NP = 1, KT = ite()), KT;
}
var ZT, DP;
function T6e() {
  if (DP) return ZT;
  DP = 1;
  var t = A4();
  function e(r, n) {
    var i = [];
    return t(r, function(a, s, o) {
      n(a, s, o) && i.push(a);
    }), i;
  }
  return ZT = e, ZT;
}
var QT, OP;
function E6e() {
  if (OP) return QT;
  OP = 1;
  var t = "__lodash_hash_undefined__";
  function e(r) {
    return this.__data__.set(r, t), this;
  }
  return QT = e, QT;
}
var JT, PP;
function S6e() {
  if (PP) return JT;
  PP = 1;
  function t(e) {
    return this.__data__.has(e);
  }
  return JT = t, JT;
}
var e6, $P;
function ste() {
  if ($P) return e6;
  $P = 1;
  var t = vL(), e = E6e(), r = S6e();
  function n(i) {
    var a = -1, s = i == null ? 0 : i.length;
    for (this.__data__ = new t(); ++a < s; )
      this.add(i[a]);
  }
  return n.prototype.add = n.prototype.push = e, n.prototype.has = r, e6 = n, e6;
}
var t6, BP;
function k6e() {
  if (BP) return t6;
  BP = 1;
  function t(e, r) {
    for (var n = -1, i = e == null ? 0 : e.length; ++n < i; )
      if (r(e[n], n, e))
        return !0;
    return !1;
  }
  return t6 = t, t6;
}
var r6, FP;
function ote() {
  if (FP) return r6;
  FP = 1;
  function t(e, r) {
    return e.has(r);
  }
  return r6 = t, r6;
}
var n6, zP;
function lte() {
  if (zP) return n6;
  zP = 1;
  var t = ste(), e = k6e(), r = ote(), n = 1, i = 2;
  function a(s, o, l, u, h, f) {
    var d = l & n, p = s.length, g = o.length;
    if (p != g && !(d && g > p))
      return !1;
    var m = f.get(s), v = f.get(o);
    if (m && v)
      return m == o && v == s;
    var y = -1, b = !0, x = l & i ? new t() : void 0;
    for (f.set(s, o), f.set(o, s); ++y < p; ) {
      var T = s[y], E = o[y];
      if (u)
        var A = d ? u(E, T, y, o, s, f) : u(T, E, y, s, o, f);
      if (A !== void 0) {
        if (A)
          continue;
        b = !1;
        break;
      }
      if (x) {
        if (!e(o, function(S, k) {
          if (!r(x, k) && (T === S || h(T, S, l, u, f)))
            return x.push(k);
        })) {
          b = !1;
          break;
        }
      } else if (!(T === E || h(T, E, l, u, f))) {
        b = !1;
        break;
      }
    }
    return f.delete(s), f.delete(o), b;
  }
  return n6 = a, n6;
}
var i6, qP;
function C6e() {
  if (qP) return i6;
  qP = 1;
  function t(e) {
    var r = -1, n = Array(e.size);
    return e.forEach(function(i, a) {
      n[++r] = [a, i];
    }), n;
  }
  return i6 = t, i6;
}
var a6, GP;
function AL() {
  if (GP) return a6;
  GP = 1;
  function t(e) {
    var r = -1, n = Array(e.size);
    return e.forEach(function(i) {
      n[++r] = i;
    }), n;
  }
  return a6 = t, a6;
}
var s6, UP;
function _6e() {
  if (UP) return s6;
  UP = 1;
  var t = D0(), e = Qee(), r = N0(), n = lte(), i = C6e(), a = AL(), s = 1, o = 2, l = "[object Boolean]", u = "[object Date]", h = "[object Error]", f = "[object Map]", d = "[object Number]", p = "[object RegExp]", g = "[object Set]", m = "[object String]", v = "[object Symbol]", y = "[object ArrayBuffer]", b = "[object DataView]", x = t ? t.prototype : void 0, T = x ? x.valueOf : void 0;
  function E(A, S, k, _, R, L, M) {
    switch (k) {
      case b:
        if (A.byteLength != S.byteLength || A.byteOffset != S.byteOffset)
          return !1;
        A = A.buffer, S = S.buffer;
      case y:
        return !(A.byteLength != S.byteLength || !L(new e(A), new e(S)));
      case l:
      case u:
      case d:
        return r(+A, +S);
      case h:
        return A.name == S.name && A.message == S.message;
      case p:
      case m:
        return A == S + "";
      case f:
        var P = i;
      case g:
        var C = _ & s;
        if (P || (P = a), A.size != S.size && !C)
          return !1;
        var I = M.get(A);
        if (I)
          return I == S;
        _ |= o, M.set(A, S);
        var N = n(P(A), P(S), _, R, L, M);
        return M.delete(A), N;
      case v:
        if (T)
          return T.call(A) == T.call(S);
    }
    return !1;
  }
  return s6 = E, s6;
}
var o6, VP;
function A6e() {
  if (VP) return o6;
  VP = 1;
  var t = Kee(), e = 1, r = Object.prototype, n = r.hasOwnProperty;
  function i(a, s, o, l, u, h) {
    var f = o & e, d = t(a), p = d.length, g = t(s), m = g.length;
    if (p != m && !f)
      return !1;
    for (var v = p; v--; ) {
      var y = d[v];
      if (!(f ? y in s : n.call(s, y)))
        return !1;
    }
    var b = h.get(a), x = h.get(s);
    if (b && x)
      return b == s && x == a;
    var T = !0;
    h.set(a, s), h.set(s, a);
    for (var E = f; ++v < p; ) {
      y = d[v];
      var A = a[y], S = s[y];
      if (l)
        var k = f ? l(S, A, y, s, a, h) : l(A, S, y, a, s, h);
      if (!(k === void 0 ? A === S || u(A, S, o, l, h) : k)) {
        T = !1;
        break;
      }
      E || (E = y == "constructor");
    }
    if (T && !E) {
      var _ = a.constructor, R = s.constructor;
      _ != R && "constructor" in a && "constructor" in s && !(typeof _ == "function" && _ instanceof _ && typeof R == "function" && R instanceof R) && (T = !1);
    }
    return h.delete(a), h.delete(s), T;
  }
  return o6 = i, o6;
}
var l6, HP;
function L6e() {
  if (HP) return l6;
  HP = 1;
  var t = w4(), e = lte(), r = _6e(), n = A6e(), i = P0(), a = Nn(), s = O0(), o = hm(), l = 1, u = "[object Arguments]", h = "[object Array]", f = "[object Object]", d = Object.prototype, p = d.hasOwnProperty;
  function g(m, v, y, b, x, T) {
    var E = a(m), A = a(v), S = E ? h : i(m), k = A ? h : i(v);
    S = S == u ? f : S, k = k == u ? f : k;
    var _ = S == f, R = k == f, L = S == k;
    if (L && s(m)) {
      if (!s(v))
        return !1;
      E = !0, _ = !1;
    }
    if (L && !_)
      return T || (T = new t()), E || o(m) ? e(m, v, y, b, x, T) : r(m, v, S, y, b, x, T);
    if (!(y & l)) {
      var M = _ && p.call(m, "__wrapped__"), P = R && p.call(v, "__wrapped__");
      if (M || P) {
        var C = M ? m.value() : m, I = P ? v.value() : v;
        return T || (T = new t()), x(C, I, y, b, T);
      }
    }
    return L ? (T || (T = new t()), n(m, v, y, b, x, T)) : !1;
  }
  return l6 = g, l6;
}
var c6, WP;
function cte() {
  if (WP) return c6;
  WP = 1;
  var t = L6e(), e = To();
  function r(n, i, a, s, o) {
    return n === i ? !0 : n == null || i == null || !e(n) && !e(i) ? n !== n && i !== i : t(n, i, a, s, r, o);
  }
  return c6 = r, c6;
}
var u6, YP;
function R6e() {
  if (YP) return u6;
  YP = 1;
  var t = w4(), e = cte(), r = 1, n = 2;
  function i(a, s, o, l) {
    var u = o.length, h = u, f = !l;
    if (a == null)
      return !h;
    for (a = Object(a); u--; ) {
      var d = o[u];
      if (f && d[2] ? d[1] !== a[d[0]] : !(d[0] in a))
        return !1;
    }
    for (; ++u < h; ) {
      d = o[u];
      var p = d[0], g = a[p], m = d[1];
      if (f && d[2]) {
        if (g === void 0 && !(p in a))
          return !1;
      } else {
        var v = new t();
        if (l)
          var y = l(g, m, p, a, s, v);
        if (!(y === void 0 ? e(m, g, r | n, l, v) : y))
          return !1;
      }
    }
    return !0;
  }
  return u6 = i, u6;
}
var h6, XP;
function ute() {
  if (XP) return h6;
  XP = 1;
  var t = hs();
  function e(r) {
    return r === r && !t(r);
  }
  return h6 = e, h6;
}
var f6, jP;
function I6e() {
  if (jP) return f6;
  jP = 1;
  var t = ute(), e = zc();
  function r(n) {
    for (var i = e(n), a = i.length; a--; ) {
      var s = i[a], o = n[s];
      i[a] = [s, o, t(o)];
    }
    return i;
  }
  return f6 = r, f6;
}
var d6, KP;
function hte() {
  if (KP) return d6;
  KP = 1;
  function t(e, r) {
    return function(n) {
      return n == null ? !1 : n[e] === r && (r !== void 0 || e in Object(n));
    };
  }
  return d6 = t, d6;
}
var p6, ZP;
function M6e() {
  if (ZP) return p6;
  ZP = 1;
  var t = R6e(), e = I6e(), r = hte();
  function n(i) {
    var a = e(i);
    return a.length == 1 && a[0][2] ? r(a[0][0], a[0][1]) : function(s) {
      return s === i || t(s, i, a);
    };
  }
  return p6 = n, p6;
}
var g6, QP;
function $0() {
  if (QP) return g6;
  QP = 1;
  var t = Ch(), e = To(), r = "[object Symbol]";
  function n(i) {
    return typeof i == "symbol" || e(i) && t(i) == r;
  }
  return g6 = n, g6;
}
var m6, JP;
function LL() {
  if (JP) return m6;
  JP = 1;
  var t = Nn(), e = $0(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
  function i(a, s) {
    if (t(a))
      return !1;
    var o = typeof a;
    return o == "number" || o == "symbol" || o == "boolean" || a == null || e(a) ? !0 : n.test(a) || !r.test(a) || s != null && a in Object(s);
  }
  return m6 = i, m6;
}
var v6, e$;
function N6e() {
  if (e$) return v6;
  e$ = 1;
  var t = vL(), e = "Expected a function";
  function r(n, i) {
    if (typeof n != "function" || i != null && typeof i != "function")
      throw new TypeError(e);
    var a = function() {
      var s = arguments, o = i ? i.apply(this, s) : s[0], l = a.cache;
      if (l.has(o))
        return l.get(o);
      var u = n.apply(this, s);
      return a.cache = l.set(o, u) || l, u;
    };
    return a.cache = new (r.Cache || t)(), a;
  }
  return r.Cache = t, v6 = r, v6;
}
var y6, t$;
function D6e() {
  if (t$) return y6;
  t$ = 1;
  var t = N6e(), e = 500;
  function r(n) {
    var i = t(n, function(s) {
      return a.size === e && a.clear(), s;
    }), a = i.cache;
    return i;
  }
  return y6 = r, y6;
}
var b6, r$;
function O6e() {
  if (r$) return b6;
  r$ = 1;
  var t = D6e(), e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g, n = t(function(i) {
    var a = [];
    return i.charCodeAt(0) === 46 && a.push(""), i.replace(e, function(s, o, l, u) {
      a.push(l ? u.replace(r, "$1") : o || s);
    }), a;
  });
  return b6 = n, b6;
}
var x6, n$;
function L4() {
  if (n$) return x6;
  n$ = 1;
  function t(e, r) {
    for (var n = -1, i = e == null ? 0 : e.length, a = Array(i); ++n < i; )
      a[n] = r(e[n], n, e);
    return a;
  }
  return x6 = t, x6;
}
var w6, i$;
function P6e() {
  if (i$) return w6;
  i$ = 1;
  var t = D0(), e = L4(), r = Nn(), n = $0(), i = t ? t.prototype : void 0, a = i ? i.toString : void 0;
  function s(o) {
    if (typeof o == "string")
      return o;
    if (r(o))
      return e(o, s) + "";
    if (n(o))
      return a ? a.call(o) : "";
    var l = o + "";
    return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
  }
  return w6 = s, w6;
}
var T6, a$;
function fte() {
  if (a$) return T6;
  a$ = 1;
  var t = P6e();
  function e(r) {
    return r == null ? "" : t(r);
  }
  return T6 = e, T6;
}
var E6, s$;
function R4() {
  if (s$) return E6;
  s$ = 1;
  var t = Nn(), e = LL(), r = O6e(), n = fte();
  function i(a, s) {
    return t(a) ? a : e(a, s) ? [a] : r(n(a));
  }
  return E6 = i, E6;
}
var S6, o$;
function fm() {
  if (o$) return S6;
  o$ = 1;
  var t = $0();
  function e(r) {
    if (typeof r == "string" || t(r))
      return r;
    var n = r + "";
    return n == "0" && 1 / r == -1 / 0 ? "-0" : n;
  }
  return S6 = e, S6;
}
var k6, l$;
function I4() {
  if (l$) return k6;
  l$ = 1;
  var t = R4(), e = fm();
  function r(n, i) {
    i = t(i, n);
    for (var a = 0, s = i.length; n != null && a < s; )
      n = n[e(i[a++])];
    return a && a == s ? n : void 0;
  }
  return k6 = r, k6;
}
var C6, c$;
function $6e() {
  if (c$) return C6;
  c$ = 1;
  var t = I4();
  function e(r, n, i) {
    var a = r == null ? void 0 : t(r, n);
    return a === void 0 ? i : a;
  }
  return C6 = e, C6;
}
var _6, u$;
function B6e() {
  if (u$) return _6;
  u$ = 1;
  function t(e, r) {
    return e != null && r in Object(e);
  }
  return _6 = t, _6;
}
var A6, h$;
function dte() {
  if (h$) return A6;
  h$ = 1;
  var t = R4(), e = um(), r = Nn(), n = S4(), i = bL(), a = fm();
  function s(o, l, u) {
    l = t(l, o);
    for (var h = -1, f = l.length, d = !1; ++h < f; ) {
      var p = a(l[h]);
      if (!(d = o != null && u(o, p)))
        break;
      o = o[p];
    }
    return d || ++h != f ? d : (f = o == null ? 0 : o.length, !!f && i(f) && n(p, f) && (r(o) || e(o)));
  }
  return A6 = s, A6;
}
var L6, f$;
function pte() {
  if (f$) return L6;
  f$ = 1;
  var t = B6e(), e = dte();
  function r(n, i) {
    return n != null && e(n, i, t);
  }
  return L6 = r, L6;
}
var R6, d$;
function F6e() {
  if (d$) return R6;
  d$ = 1;
  var t = cte(), e = $6e(), r = pte(), n = LL(), i = ute(), a = hte(), s = fm(), o = 1, l = 2;
  function u(h, f) {
    return n(h) && i(f) ? a(s(h), f) : function(d) {
      var p = e(d, h);
      return p === void 0 && p === f ? r(d, h) : t(f, p, o | l);
    };
  }
  return R6 = u, R6;
}
var I6, p$;
function gte() {
  if (p$) return I6;
  p$ = 1;
  function t(e) {
    return function(r) {
      return r?.[e];
    };
  }
  return I6 = t, I6;
}
var M6, g$;
function z6e() {
  if (g$) return M6;
  g$ = 1;
  var t = I4();
  function e(r) {
    return function(n) {
      return t(n, r);
    };
  }
  return M6 = e, M6;
}
var N6, m$;
function q6e() {
  if (m$) return N6;
  m$ = 1;
  var t = gte(), e = z6e(), r = LL(), n = fm();
  function i(a) {
    return r(a) ? t(n(a)) : e(a);
  }
  return N6 = i, N6;
}
var D6, v$;
function _l() {
  if (v$) return D6;
  v$ = 1;
  var t = M6e(), e = F6e(), r = Lh(), n = Nn(), i = q6e();
  function a(s) {
    return typeof s == "function" ? s : s == null ? r : typeof s == "object" ? n(s) ? e(s[0], s[1]) : t(s) : i(s);
  }
  return D6 = a, D6;
}
var O6, y$;
function mte() {
  if (y$) return O6;
  y$ = 1;
  var t = Wee(), e = T6e(), r = _l(), n = Nn();
  function i(a, s) {
    var o = n(a) ? t : e;
    return o(a, r(s, 3));
  }
  return O6 = i, O6;
}
var P6, b$;
function G6e() {
  if (b$) return P6;
  b$ = 1;
  var t = Object.prototype, e = t.hasOwnProperty;
  function r(n, i) {
    return n != null && e.call(n, i);
  }
  return P6 = r, P6;
}
var $6, x$;
function vte() {
  if (x$) return $6;
  x$ = 1;
  var t = G6e(), e = dte();
  function r(n, i) {
    return n != null && e(n, i, t);
  }
  return $6 = r, $6;
}
var B6, w$;
function U6e() {
  if (w$) return B6;
  w$ = 1;
  var t = wL(), e = P0(), r = um(), n = Nn(), i = Cl(), a = O0(), s = C4(), o = hm(), l = "[object Map]", u = "[object Set]", h = Object.prototype, f = h.hasOwnProperty;
  function d(p) {
    if (p == null)
      return !0;
    if (i(p) && (n(p) || typeof p == "string" || typeof p.splice == "function" || a(p) || o(p) || r(p)))
      return !p.length;
    var g = e(p);
    if (g == l || g == u)
      return !p.size;
    if (s(p))
      return !t(p).length;
    for (var m in p)
      if (f.call(p, m))
        return !1;
    return !0;
  }
  return B6 = d, B6;
}
var F6, T$;
function yte() {
  if (T$) return F6;
  T$ = 1;
  function t(e) {
    return e === void 0;
  }
  return F6 = t, F6;
}
var z6, E$;
function bte() {
  if (E$) return z6;
  E$ = 1;
  var t = A4(), e = Cl();
  function r(n, i) {
    var a = -1, s = e(n) ? Array(n.length) : [];
    return t(n, function(o, l, u) {
      s[++a] = i(o, l, u);
    }), s;
  }
  return z6 = r, z6;
}
var q6, S$;
function xte() {
  if (S$) return q6;
  S$ = 1;
  var t = L4(), e = _l(), r = bte(), n = Nn();
  function i(a, s) {
    var o = n(a) ? t : r;
    return o(a, e(s, 3));
  }
  return q6 = i, q6;
}
var G6, k$;
function V6e() {
  if (k$) return G6;
  k$ = 1;
  function t(e, r, n, i) {
    var a = -1, s = e == null ? 0 : e.length;
    for (i && s && (n = e[++a]); ++a < s; )
      n = r(n, e[a], a, e);
    return n;
  }
  return G6 = t, G6;
}
var U6, C$;
function H6e() {
  if (C$) return U6;
  C$ = 1;
  function t(e, r, n, i, a) {
    return a(e, function(s, o, l) {
      n = i ? (i = !1, s) : r(n, s, o, l);
    }), n;
  }
  return U6 = t, U6;
}
var V6, _$;
function wte() {
  if (_$) return V6;
  _$ = 1;
  var t = V6e(), e = A4(), r = _l(), n = H6e(), i = Nn();
  function a(s, o, l) {
    var u = i(s) ? t : n, h = arguments.length < 3;
    return u(s, r(o, 4), l, h, e);
  }
  return V6 = a, V6;
}
var H6, A$;
function W6e() {
  if (A$) return H6;
  A$ = 1;
  var t = Ch(), e = Nn(), r = To(), n = "[object String]";
  function i(a) {
    return typeof a == "string" || !e(a) && r(a) && t(a) == n;
  }
  return H6 = i, H6;
}
var W6, L$;
function Y6e() {
  if (L$) return W6;
  L$ = 1;
  var t = gte(), e = t("length");
  return W6 = e, W6;
}
var Y6, R$;
function X6e() {
  if (R$) return Y6;
  R$ = 1;
  var t = "\\ud800-\\udfff", e = "\\u0300-\\u036f", r = "\\ufe20-\\ufe2f", n = "\\u20d0-\\u20ff", i = e + r + n, a = "\\ufe0e\\ufe0f", s = "\\u200d", o = RegExp("[" + s + t + i + a + "]");
  function l(u) {
    return o.test(u);
  }
  return Y6 = l, Y6;
}
var X6, I$;
function j6e() {
  if (I$) return X6;
  I$ = 1;
  var t = "\\ud800-\\udfff", e = "\\u0300-\\u036f", r = "\\ufe20-\\ufe2f", n = "\\u20d0-\\u20ff", i = e + r + n, a = "\\ufe0e\\ufe0f", s = "[" + t + "]", o = "[" + i + "]", l = "\\ud83c[\\udffb-\\udfff]", u = "(?:" + o + "|" + l + ")", h = "[^" + t + "]", f = "(?:\\ud83c[\\udde6-\\uddff]){2}", d = "[\\ud800-\\udbff][\\udc00-\\udfff]", p = "\\u200d", g = u + "?", m = "[" + a + "]?", v = "(?:" + p + "(?:" + [h, f, d].join("|") + ")" + m + g + ")*", y = m + g + v, b = "(?:" + [h + o + "?", o, f, d, s].join("|") + ")", x = RegExp(l + "(?=" + l + ")|" + b + y, "g");
  function T(E) {
    for (var A = x.lastIndex = 0; x.test(E); )
      ++A;
    return A;
  }
  return X6 = T, X6;
}
var j6, M$;
function K6e() {
  if (M$) return j6;
  M$ = 1;
  var t = Y6e(), e = X6e(), r = j6e();
  function n(i) {
    return e(i) ? r(i) : t(i);
  }
  return j6 = n, j6;
}
var K6, N$;
function Z6e() {
  if (N$) return K6;
  N$ = 1;
  var t = wL(), e = P0(), r = Cl(), n = W6e(), i = K6e(), a = "[object Map]", s = "[object Set]";
  function o(l) {
    if (l == null)
      return 0;
    if (r(l))
      return n(l) ? i(l) : l.length;
    var u = e(l);
    return u == a || u == s ? l.size : t(l).length;
  }
  return K6 = o, K6;
}
var Z6, D$;
function Q6e() {
  if (D$) return Z6;
  D$ = 1;
  var t = yL(), e = ete(), r = _L(), n = _l(), i = _4(), a = Nn(), s = O0(), o = lm(), l = hs(), u = hm();
  function h(f, d, p) {
    var g = a(f), m = g || s(f) || u(f);
    if (d = n(d, 4), p == null) {
      var v = f && f.constructor;
      m ? p = g ? new v() : [] : l(f) ? p = o(v) ? e(i(f)) : {} : p = {};
    }
    return (m ? t : r)(f, function(y, b, x) {
      return d(p, y, b, x);
    }), p;
  }
  return Z6 = h, Z6;
}
var Q6, O$;
function J6e() {
  if (O$) return Q6;
  O$ = 1;
  var t = D0(), e = um(), r = Nn(), n = t ? t.isConcatSpreadable : void 0;
  function i(a) {
    return r(a) || e(a) || !!(n && a && a[n]);
  }
  return Q6 = i, Q6;
}
var J6, P$;
function RL() {
  if (P$) return J6;
  P$ = 1;
  var t = EL(), e = J6e();
  function r(n, i, a, s, o) {
    var l = -1, u = n.length;
    for (a || (a = e), o || (o = []); ++l < u; ) {
      var h = n[l];
      i > 0 && a(h) ? i > 1 ? r(h, i - 1, a, s, o) : t(o, h) : s || (o[o.length] = h);
    }
    return o;
  }
  return J6 = r, J6;
}
var eE, $$;
function eEe() {
  if ($$) return eE;
  $$ = 1;
  function t(e, r, n) {
    switch (n.length) {
      case 0:
        return e.call(r);
      case 1:
        return e.call(r, n[0]);
      case 2:
        return e.call(r, n[0], n[1]);
      case 3:
        return e.call(r, n[0], n[1], n[2]);
    }
    return e.apply(r, n);
  }
  return eE = t, eE;
}
var tE, B$;
function Tte() {
  if (B$) return tE;
  B$ = 1;
  var t = eEe(), e = Math.max;
  function r(n, i, a) {
    return i = e(i === void 0 ? n.length - 1 : i, 0), function() {
      for (var s = arguments, o = -1, l = e(s.length - i, 0), u = Array(l); ++o < l; )
        u[o] = s[i + o];
      o = -1;
      for (var h = Array(i + 1); ++o < i; )
        h[o] = s[o];
      return h[i] = a(u), t(n, this, h);
    };
  }
  return tE = r, tE;
}
var rE, F$;
function tEe() {
  if (F$) return rE;
  F$ = 1;
  var t = kL(), e = qee(), r = Lh(), n = e ? function(i, a) {
    return e(i, "toString", {
      configurable: !0,
      enumerable: !1,
      value: t(a),
      writable: !0
    });
  } : r;
  return rE = n, rE;
}
var nE, z$;
function rEe() {
  if (z$) return nE;
  z$ = 1;
  var t = 800, e = 16, r = Date.now;
  function n(i) {
    var a = 0, s = 0;
    return function() {
      var o = r(), l = e - (o - s);
      if (s = o, l > 0) {
        if (++a >= t)
          return arguments[0];
      } else
        a = 0;
      return i.apply(void 0, arguments);
    };
  }
  return nE = n, nE;
}
var iE, q$;
function Ete() {
  if (q$) return iE;
  q$ = 1;
  var t = tEe(), e = rEe(), r = e(t);
  return iE = r, iE;
}
var aE, G$;
function M4() {
  if (G$) return aE;
  G$ = 1;
  var t = Lh(), e = Tte(), r = Ete();
  function n(i, a) {
    return r(e(i, a, t), i + "");
  }
  return aE = n, aE;
}
var sE, U$;
function Ste() {
  if (U$) return sE;
  U$ = 1;
  function t(e, r, n, i) {
    for (var a = e.length, s = n + (i ? 1 : -1); i ? s-- : ++s < a; )
      if (r(e[s], s, e))
        return s;
    return -1;
  }
  return sE = t, sE;
}
var oE, V$;
function nEe() {
  if (V$) return oE;
  V$ = 1;
  function t(e) {
    return e !== e;
  }
  return oE = t, oE;
}
var lE, H$;
function iEe() {
  if (H$) return lE;
  H$ = 1;
  function t(e, r, n) {
    for (var i = n - 1, a = e.length; ++i < a; )
      if (e[i] === r)
        return i;
    return -1;
  }
  return lE = t, lE;
}
var cE, W$;
function aEe() {
  if (W$) return cE;
  W$ = 1;
  var t = Ste(), e = nEe(), r = iEe();
  function n(i, a, s) {
    return a === a ? r(i, a, s) : t(i, e, s);
  }
  return cE = n, cE;
}
var uE, Y$;
function sEe() {
  if (Y$) return uE;
  Y$ = 1;
  var t = aEe();
  function e(r, n) {
    var i = r == null ? 0 : r.length;
    return !!i && t(r, n, 0) > -1;
  }
  return uE = e, uE;
}
var hE, X$;
function oEe() {
  if (X$) return hE;
  X$ = 1;
  function t(e, r, n) {
    for (var i = -1, a = e == null ? 0 : e.length; ++i < a; )
      if (n(r, e[i]))
        return !0;
    return !1;
  }
  return hE = t, hE;
}
var fE, j$;
function lEe() {
  if (j$) return fE;
  j$ = 1;
  function t() {
  }
  return fE = t, fE;
}
var dE, K$;
function cEe() {
  if (K$) return dE;
  K$ = 1;
  var t = Zee(), e = lEe(), r = AL(), n = 1 / 0, i = t && 1 / r(new t([, -0]))[1] == n ? function(a) {
    return new t(a);
  } : e;
  return dE = i, dE;
}
var pE, Z$;
function uEe() {
  if (Z$) return pE;
  Z$ = 1;
  var t = ste(), e = sEe(), r = oEe(), n = ote(), i = cEe(), a = AL(), s = 200;
  function o(l, u, h) {
    var f = -1, d = e, p = l.length, g = !0, m = [], v = m;
    if (h)
      g = !1, d = r;
    else if (p >= s) {
      var y = u ? null : i(l);
      if (y)
        return a(y);
      g = !1, d = n, v = new t();
    } else
      v = u ? [] : m;
    e:
      for (; ++f < p; ) {
        var b = l[f], x = u ? u(b) : b;
        if (b = h || b !== 0 ? b : 0, g && x === x) {
          for (var T = v.length; T--; )
            if (v[T] === x)
              continue e;
          u && v.push(x), m.push(b);
        } else d(v, x, h) || (v !== m && v.push(x), m.push(b));
      }
    return m;
  }
  return pE = o, pE;
}
var gE, Q$;
function kte() {
  if (Q$) return gE;
  Q$ = 1;
  var t = Cl(), e = To();
  function r(n) {
    return e(n) && t(n);
  }
  return gE = r, gE;
}
var mE, J$;
function hEe() {
  if (J$) return mE;
  J$ = 1;
  var t = RL(), e = M4(), r = uEe(), n = kte(), i = e(function(a) {
    return r(t(a, 1, n, !0));
  });
  return mE = i, mE;
}
var vE, eB;
function fEe() {
  if (eB) return vE;
  eB = 1;
  var t = L4();
  function e(r, n) {
    return t(n, function(i) {
      return r[i];
    });
  }
  return vE = e, vE;
}
var yE, tB;
function Cte() {
  if (tB) return yE;
  tB = 1;
  var t = fEe(), e = zc();
  function r(n) {
    return n == null ? [] : t(n, e(n));
  }
  return yE = r, yE;
}
var bE, rB;
function fs() {
  if (rB) return bE;
  rB = 1;
  var t;
  if (typeof gL == "function")
    try {
      t = {
        clone: b6e(),
        constant: kL(),
        each: ate(),
        filter: mte(),
        has: vte(),
        isArray: Nn(),
        isEmpty: U6e(),
        isFunction: lm(),
        isUndefined: yte(),
        keys: zc(),
        map: xte(),
        reduce: wte(),
        size: Z6e(),
        transform: Q6e(),
        union: hEe(),
        values: Cte()
      };
    } catch {
    }
  return t || (t = window._), bE = t, bE;
}
var xE, nB;
function IL() {
  if (nB) return xE;
  nB = 1;
  var t = fs();
  xE = i;
  var e = "\0", r = "\0", n = "";
  function i(h) {
    this._isDirected = t.has(h, "directed") ? h.directed : !0, this._isMultigraph = t.has(h, "multigraph") ? h.multigraph : !1, this._isCompound = t.has(h, "compound") ? h.compound : !1, this._label = void 0, this._defaultNodeLabelFn = t.constant(void 0), this._defaultEdgeLabelFn = t.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[r] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  i.prototype._nodeCount = 0, i.prototype._edgeCount = 0, i.prototype.isDirected = function() {
    return this._isDirected;
  }, i.prototype.isMultigraph = function() {
    return this._isMultigraph;
  }, i.prototype.isCompound = function() {
    return this._isCompound;
  }, i.prototype.setGraph = function(h) {
    return this._label = h, this;
  }, i.prototype.graph = function() {
    return this._label;
  }, i.prototype.setDefaultNodeLabel = function(h) {
    return t.isFunction(h) || (h = t.constant(h)), this._defaultNodeLabelFn = h, this;
  }, i.prototype.nodeCount = function() {
    return this._nodeCount;
  }, i.prototype.nodes = function() {
    return t.keys(this._nodes);
  }, i.prototype.sources = function() {
    var h = this;
    return t.filter(this.nodes(), function(f) {
      return t.isEmpty(h._in[f]);
    });
  }, i.prototype.sinks = function() {
    var h = this;
    return t.filter(this.nodes(), function(f) {
      return t.isEmpty(h._out[f]);
    });
  }, i.prototype.setNodes = function(h, f) {
    var d = arguments, p = this;
    return t.each(h, function(g) {
      d.length > 1 ? p.setNode(g, f) : p.setNode(g);
    }), this;
  }, i.prototype.setNode = function(h, f) {
    return t.has(this._nodes, h) ? (arguments.length > 1 && (this._nodes[h] = f), this) : (this._nodes[h] = arguments.length > 1 ? f : this._defaultNodeLabelFn(h), this._isCompound && (this._parent[h] = r, this._children[h] = {}, this._children[r][h] = !0), this._in[h] = {}, this._preds[h] = {}, this._out[h] = {}, this._sucs[h] = {}, ++this._nodeCount, this);
  }, i.prototype.node = function(h) {
    return this._nodes[h];
  }, i.prototype.hasNode = function(h) {
    return t.has(this._nodes, h);
  }, i.prototype.removeNode = function(h) {
    var f = this;
    if (t.has(this._nodes, h)) {
      var d = function(p) {
        f.removeEdge(f._edgeObjs[p]);
      };
      delete this._nodes[h], this._isCompound && (this._removeFromParentsChildList(h), delete this._parent[h], t.each(this.children(h), function(p) {
        f.setParent(p);
      }), delete this._children[h]), t.each(t.keys(this._in[h]), d), delete this._in[h], delete this._preds[h], t.each(t.keys(this._out[h]), d), delete this._out[h], delete this._sucs[h], --this._nodeCount;
    }
    return this;
  }, i.prototype.setParent = function(h, f) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (t.isUndefined(f))
      f = r;
    else {
      f += "";
      for (var d = f; !t.isUndefined(d); d = this.parent(d))
        if (d === h)
          throw new Error("Setting " + f + " as parent of " + h + " would create a cycle");
      this.setNode(f);
    }
    return this.setNode(h), this._removeFromParentsChildList(h), this._parent[h] = f, this._children[f][h] = !0, this;
  }, i.prototype._removeFromParentsChildList = function(h) {
    delete this._children[this._parent[h]][h];
  }, i.prototype.parent = function(h) {
    if (this._isCompound) {
      var f = this._parent[h];
      if (f !== r)
        return f;
    }
  }, i.prototype.children = function(h) {
    if (t.isUndefined(h) && (h = r), this._isCompound) {
      var f = this._children[h];
      if (f)
        return t.keys(f);
    } else {
      if (h === r)
        return this.nodes();
      if (this.hasNode(h))
        return [];
    }
  }, i.prototype.predecessors = function(h) {
    var f = this._preds[h];
    if (f)
      return t.keys(f);
  }, i.prototype.successors = function(h) {
    var f = this._sucs[h];
    if (f)
      return t.keys(f);
  }, i.prototype.neighbors = function(h) {
    var f = this.predecessors(h);
    if (f)
      return t.union(f, this.successors(h));
  }, i.prototype.isLeaf = function(h) {
    var f;
    return this.isDirected() ? f = this.successors(h) : f = this.neighbors(h), f.length === 0;
  }, i.prototype.filterNodes = function(h) {
    var f = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    f.setGraph(this.graph());
    var d = this;
    t.each(this._nodes, function(m, v) {
      h(v) && f.setNode(v, m);
    }), t.each(this._edgeObjs, function(m) {
      f.hasNode(m.v) && f.hasNode(m.w) && f.setEdge(m, d.edge(m));
    });
    var p = {};
    function g(m) {
      var v = d.parent(m);
      return v === void 0 || f.hasNode(v) ? (p[m] = v, v) : v in p ? p[v] : g(v);
    }
    return this._isCompound && t.each(f.nodes(), function(m) {
      f.setParent(m, g(m));
    }), f;
  }, i.prototype.setDefaultEdgeLabel = function(h) {
    return t.isFunction(h) || (h = t.constant(h)), this._defaultEdgeLabelFn = h, this;
  }, i.prototype.edgeCount = function() {
    return this._edgeCount;
  }, i.prototype.edges = function() {
    return t.values(this._edgeObjs);
  }, i.prototype.setPath = function(h, f) {
    var d = this, p = arguments;
    return t.reduce(h, function(g, m) {
      return p.length > 1 ? d.setEdge(g, m, f) : d.setEdge(g, m), m;
    }), this;
  }, i.prototype.setEdge = function() {
    var h, f, d, p, g = !1, m = arguments[0];
    typeof m == "object" && m !== null && "v" in m ? (h = m.v, f = m.w, d = m.name, arguments.length === 2 && (p = arguments[1], g = !0)) : (h = m, f = arguments[1], d = arguments[3], arguments.length > 2 && (p = arguments[2], g = !0)), h = "" + h, f = "" + f, t.isUndefined(d) || (d = "" + d);
    var v = o(this._isDirected, h, f, d);
    if (t.has(this._edgeLabels, v))
      return g && (this._edgeLabels[v] = p), this;
    if (!t.isUndefined(d) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(h), this.setNode(f), this._edgeLabels[v] = g ? p : this._defaultEdgeLabelFn(h, f, d);
    var y = l(this._isDirected, h, f, d);
    return h = y.v, f = y.w, Object.freeze(y), this._edgeObjs[v] = y, a(this._preds[f], h), a(this._sucs[h], f), this._in[f][v] = y, this._out[h][v] = y, this._edgeCount++, this;
  }, i.prototype.edge = function(h, f, d) {
    var p = arguments.length === 1 ? u(this._isDirected, arguments[0]) : o(this._isDirected, h, f, d);
    return this._edgeLabels[p];
  }, i.prototype.hasEdge = function(h, f, d) {
    var p = arguments.length === 1 ? u(this._isDirected, arguments[0]) : o(this._isDirected, h, f, d);
    return t.has(this._edgeLabels, p);
  }, i.prototype.removeEdge = function(h, f, d) {
    var p = arguments.length === 1 ? u(this._isDirected, arguments[0]) : o(this._isDirected, h, f, d), g = this._edgeObjs[p];
    return g && (h = g.v, f = g.w, delete this._edgeLabels[p], delete this._edgeObjs[p], s(this._preds[f], h), s(this._sucs[h], f), delete this._in[f][p], delete this._out[h][p], this._edgeCount--), this;
  }, i.prototype.inEdges = function(h, f) {
    var d = this._in[h];
    if (d) {
      var p = t.values(d);
      return f ? t.filter(p, function(g) {
        return g.v === f;
      }) : p;
    }
  }, i.prototype.outEdges = function(h, f) {
    var d = this._out[h];
    if (d) {
      var p = t.values(d);
      return f ? t.filter(p, function(g) {
        return g.w === f;
      }) : p;
    }
  }, i.prototype.nodeEdges = function(h, f) {
    var d = this.inEdges(h, f);
    if (d)
      return d.concat(this.outEdges(h, f));
  };
  function a(h, f) {
    h[f] ? h[f]++ : h[f] = 1;
  }
  function s(h, f) {
    --h[f] || delete h[f];
  }
  function o(h, f, d, p) {
    var g = "" + f, m = "" + d;
    if (!h && g > m) {
      var v = g;
      g = m, m = v;
    }
    return g + n + m + n + (t.isUndefined(p) ? e : p);
  }
  function l(h, f, d, p) {
    var g = "" + f, m = "" + d;
    if (!h && g > m) {
      var v = g;
      g = m, m = v;
    }
    var y = { v: g, w: m };
    return p && (y.name = p), y;
  }
  function u(h, f) {
    return o(h, f.v, f.w, f.name);
  }
  return xE;
}
var wE, iB;
function dEe() {
  return iB || (iB = 1, wE = "2.1.8"), wE;
}
var TE, aB;
function pEe() {
  return aB || (aB = 1, TE = {
    Graph: IL(),
    version: dEe()
  }), TE;
}
var EE, sB;
function gEe() {
  if (sB) return EE;
  sB = 1;
  var t = fs(), e = IL();
  EE = {
    write: r,
    read: a
  };
  function r(s) {
    var o = {
      options: {
        directed: s.isDirected(),
        multigraph: s.isMultigraph(),
        compound: s.isCompound()
      },
      nodes: n(s),
      edges: i(s)
    };
    return t.isUndefined(s.graph()) || (o.value = t.clone(s.graph())), o;
  }
  function n(s) {
    return t.map(s.nodes(), function(o) {
      var l = s.node(o), u = s.parent(o), h = { v: o };
      return t.isUndefined(l) || (h.value = l), t.isUndefined(u) || (h.parent = u), h;
    });
  }
  function i(s) {
    return t.map(s.edges(), function(o) {
      var l = s.edge(o), u = { v: o.v, w: o.w };
      return t.isUndefined(o.name) || (u.name = o.name), t.isUndefined(l) || (u.value = l), u;
    });
  }
  function a(s) {
    var o = new e(s.options).setGraph(s.value);
    return t.each(s.nodes, function(l) {
      o.setNode(l.v, l.value), l.parent && o.setParent(l.v, l.parent);
    }), t.each(s.edges, function(l) {
      o.setEdge({ v: l.v, w: l.w, name: l.name }, l.value);
    }), o;
  }
  return EE;
}
var SE, oB;
function mEe() {
  if (oB) return SE;
  oB = 1;
  var t = fs();
  SE = e;
  function e(r) {
    var n = {}, i = [], a;
    function s(o) {
      t.has(n, o) || (n[o] = !0, a.push(o), t.each(r.successors(o), s), t.each(r.predecessors(o), s));
    }
    return t.each(r.nodes(), function(o) {
      a = [], s(o), a.length && i.push(a);
    }), i;
  }
  return SE;
}
var kE, lB;
function _te() {
  if (lB) return kE;
  lB = 1;
  var t = fs();
  kE = e;
  function e() {
    this._arr = [], this._keyIndices = {};
  }
  return e.prototype.size = function() {
    return this._arr.length;
  }, e.prototype.keys = function() {
    return this._arr.map(function(r) {
      return r.key;
    });
  }, e.prototype.has = function(r) {
    return t.has(this._keyIndices, r);
  }, e.prototype.priority = function(r) {
    var n = this._keyIndices[r];
    if (n !== void 0)
      return this._arr[n].priority;
  }, e.prototype.min = function() {
    if (this.size() === 0)
      throw new Error("Queue underflow");
    return this._arr[0].key;
  }, e.prototype.add = function(r, n) {
    var i = this._keyIndices;
    if (r = String(r), !t.has(i, r)) {
      var a = this._arr, s = a.length;
      return i[r] = s, a.push({ key: r, priority: n }), this._decrease(s), !0;
    }
    return !1;
  }, e.prototype.removeMin = function() {
    this._swap(0, this._arr.length - 1);
    var r = this._arr.pop();
    return delete this._keyIndices[r.key], this._heapify(0), r.key;
  }, e.prototype.decrease = function(r, n) {
    var i = this._keyIndices[r];
    if (n > this._arr[i].priority)
      throw new Error("New priority is greater than current priority. Key: " + r + " Old: " + this._arr[i].priority + " New: " + n);
    this._arr[i].priority = n, this._decrease(i);
  }, e.prototype._heapify = function(r) {
    var n = this._arr, i = 2 * r, a = i + 1, s = r;
    i < n.length && (s = n[i].priority < n[s].priority ? i : s, a < n.length && (s = n[a].priority < n[s].priority ? a : s), s !== r && (this._swap(r, s), this._heapify(s)));
  }, e.prototype._decrease = function(r) {
    for (var n = this._arr, i = n[r].priority, a; r !== 0 && (a = r >> 1, !(n[a].priority < i)); )
      this._swap(r, a), r = a;
  }, e.prototype._swap = function(r, n) {
    var i = this._arr, a = this._keyIndices, s = i[r], o = i[n];
    i[r] = o, i[n] = s, a[o.key] = r, a[s.key] = n;
  }, kE;
}
var CE, cB;
function Ate() {
  if (cB) return CE;
  cB = 1;
  var t = fs(), e = _te();
  CE = n;
  var r = t.constant(1);
  function n(a, s, o, l) {
    return i(
      a,
      String(s),
      o || r,
      l || function(u) {
        return a.outEdges(u);
      }
    );
  }
  function i(a, s, o, l) {
    var u = {}, h = new e(), f, d, p = function(g) {
      var m = g.v !== f ? g.v : g.w, v = u[m], y = o(g), b = d.distance + y;
      if (y < 0)
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + g + " Weight: " + y);
      b < v.distance && (v.distance = b, v.predecessor = f, h.decrease(m, b));
    };
    for (a.nodes().forEach(function(g) {
      var m = g === s ? 0 : Number.POSITIVE_INFINITY;
      u[g] = { distance: m }, h.add(g, m);
    }); h.size() > 0 && (f = h.removeMin(), d = u[f], d.distance !== Number.POSITIVE_INFINITY); )
      l(f).forEach(p);
    return u;
  }
  return CE;
}
var _E, uB;
function vEe() {
  if (uB) return _E;
  uB = 1;
  var t = Ate(), e = fs();
  _E = r;
  function r(n, i, a) {
    return e.transform(n.nodes(), function(s, o) {
      s[o] = t(n, o, i, a);
    }, {});
  }
  return _E;
}
var AE, hB;
function Lte() {
  if (hB) return AE;
  hB = 1;
  var t = fs();
  AE = e;
  function e(r) {
    var n = 0, i = [], a = {}, s = [];
    function o(l) {
      var u = a[l] = {
        onStack: !0,
        lowlink: n,
        index: n++
      };
      if (i.push(l), r.successors(l).forEach(function(d) {
        t.has(a, d) ? a[d].onStack && (u.lowlink = Math.min(u.lowlink, a[d].index)) : (o(d), u.lowlink = Math.min(u.lowlink, a[d].lowlink));
      }), u.lowlink === u.index) {
        var h = [], f;
        do
          f = i.pop(), a[f].onStack = !1, h.push(f);
        while (l !== f);
        s.push(h);
      }
    }
    return r.nodes().forEach(function(l) {
      t.has(a, l) || o(l);
    }), s;
  }
  return AE;
}
var LE, fB;
function yEe() {
  if (fB) return LE;
  fB = 1;
  var t = fs(), e = Lte();
  LE = r;
  function r(n) {
    return t.filter(e(n), function(i) {
      return i.length > 1 || i.length === 1 && n.hasEdge(i[0], i[0]);
    });
  }
  return LE;
}
var RE, dB;
function bEe() {
  if (dB) return RE;
  dB = 1;
  var t = fs();
  RE = r;
  var e = t.constant(1);
  function r(i, a, s) {
    return n(
      i,
      a || e,
      s || function(o) {
        return i.outEdges(o);
      }
    );
  }
  function n(i, a, s) {
    var o = {}, l = i.nodes();
    return l.forEach(function(u) {
      o[u] = {}, o[u][u] = { distance: 0 }, l.forEach(function(h) {
        u !== h && (o[u][h] = { distance: Number.POSITIVE_INFINITY });
      }), s(u).forEach(function(h) {
        var f = h.v === u ? h.w : h.v, d = a(h);
        o[u][f] = { distance: d, predecessor: u };
      });
    }), l.forEach(function(u) {
      var h = o[u];
      l.forEach(function(f) {
        var d = o[f];
        l.forEach(function(p) {
          var g = d[u], m = h[p], v = d[p], y = g.distance + m.distance;
          y < v.distance && (v.distance = y, v.predecessor = m.predecessor);
        });
      });
    }), o;
  }
  return RE;
}
var IE, pB;
function Rte() {
  if (pB) return IE;
  pB = 1;
  var t = fs();
  IE = e, e.CycleException = r;
  function e(n) {
    var i = {}, a = {}, s = [];
    function o(l) {
      if (t.has(a, l))
        throw new r();
      t.has(i, l) || (a[l] = !0, i[l] = !0, t.each(n.predecessors(l), o), delete a[l], s.push(l));
    }
    if (t.each(n.sinks(), o), t.size(i) !== n.nodeCount())
      throw new r();
    return s;
  }
  function r() {
  }
  return r.prototype = new Error(), IE;
}
var ME, gB;
function xEe() {
  if (gB) return ME;
  gB = 1;
  var t = Rte();
  ME = e;
  function e(r) {
    try {
      t(r);
    } catch (n) {
      if (n instanceof t.CycleException)
        return !1;
      throw n;
    }
    return !0;
  }
  return ME;
}
var NE, mB;
function Ite() {
  if (mB) return NE;
  mB = 1;
  var t = fs();
  NE = e;
  function e(n, i, a) {
    t.isArray(i) || (i = [i]);
    var s = (n.isDirected() ? n.successors : n.neighbors).bind(n), o = [], l = {};
    return t.each(i, function(u) {
      if (!n.hasNode(u))
        throw new Error("Graph does not have node: " + u);
      r(n, u, a === "post", l, s, o);
    }), o;
  }
  function r(n, i, a, s, o, l) {
    t.has(s, i) || (s[i] = !0, a || l.push(i), t.each(o(i), function(u) {
      r(n, u, a, s, o, l);
    }), a && l.push(i));
  }
  return NE;
}
var DE, vB;
function wEe() {
  if (vB) return DE;
  vB = 1;
  var t = Ite();
  DE = e;
  function e(r, n) {
    return t(r, n, "post");
  }
  return DE;
}
var OE, yB;
function TEe() {
  if (yB) return OE;
  yB = 1;
  var t = Ite();
  OE = e;
  function e(r, n) {
    return t(r, n, "pre");
  }
  return OE;
}
var PE, bB;
function EEe() {
  if (bB) return PE;
  bB = 1;
  var t = fs(), e = IL(), r = _te();
  PE = n;
  function n(i, a) {
    var s = new e(), o = {}, l = new r(), u;
    function h(d) {
      var p = d.v === u ? d.w : d.v, g = l.priority(p);
      if (g !== void 0) {
        var m = a(d);
        m < g && (o[p] = u, l.decrease(p, m));
      }
    }
    if (i.nodeCount() === 0)
      return s;
    t.each(i.nodes(), function(d) {
      l.add(d, Number.POSITIVE_INFINITY), s.setNode(d);
    }), l.decrease(i.nodes()[0], 0);
    for (var f = !1; l.size() > 0; ) {
      if (u = l.removeMin(), t.has(o, u))
        s.setEdge(u, o[u]);
      else {
        if (f)
          throw new Error("Input graph is not connected: " + i);
        f = !0;
      }
      i.nodeEdges(u).forEach(h);
    }
    return s;
  }
  return PE;
}
var $E, xB;
function SEe() {
  return xB || (xB = 1, $E = {
    components: mEe(),
    dijkstra: Ate(),
    dijkstraAll: vEe(),
    findCycles: yEe(),
    floydWarshall: bEe(),
    isAcyclic: xEe(),
    postorder: wEe(),
    preorder: TEe(),
    prim: EEe(),
    tarjan: Lte(),
    topsort: Rte()
  }), $E;
}
var BE, wB;
function kEe() {
  if (wB) return BE;
  wB = 1;
  var t = pEe();
  return BE = {
    Graph: t.Graph,
    json: gEe(),
    alg: SEe(),
    version: t.version
  }, BE;
}
var FE, TB;
function Ms() {
  if (TB) return FE;
  TB = 1;
  var t;
  if (typeof gL == "function")
    try {
      t = kEe();
    } catch {
    }
  return t || (t = window.graphlib), FE = t, FE;
}
var zE, EB;
function CEe() {
  if (EB) return zE;
  EB = 1;
  var t = rte(), e = 1, r = 4;
  function n(i) {
    return t(i, e | r);
  }
  return zE = n, zE;
}
var qE, SB;
function N4() {
  if (SB) return qE;
  SB = 1;
  var t = N0(), e = Cl(), r = S4(), n = hs();
  function i(a, s, o) {
    if (!n(o))
      return !1;
    var l = typeof s;
    return (l == "number" ? e(o) && r(s, o.length) : l == "string" && s in o) ? t(o[s], a) : !1;
  }
  return qE = i, qE;
}
var GE, kB;
function _Ee() {
  if (kB) return GE;
  kB = 1;
  var t = M4(), e = N0(), r = N4(), n = Ah(), i = Object.prototype, a = i.hasOwnProperty, s = t(function(o, l) {
    o = Object(o);
    var u = -1, h = l.length, f = h > 2 ? l[2] : void 0;
    for (f && r(l[0], l[1], f) && (h = 1); ++u < h; )
      for (var d = l[u], p = n(d), g = -1, m = p.length; ++g < m; ) {
        var v = p[g], y = o[v];
        (y === void 0 || e(y, i[v]) && !a.call(o, v)) && (o[v] = d[v]);
      }
    return o;
  });
  return GE = s, GE;
}
var UE, CB;
function AEe() {
  if (CB) return UE;
  CB = 1;
  var t = _l(), e = Cl(), r = zc();
  function n(i) {
    return function(a, s, o) {
      var l = Object(a);
      if (!e(a)) {
        var u = t(s, 3);
        a = r(a), s = function(f) {
          return u(l[f], f, l);
        };
      }
      var h = i(a, s, o);
      return h > -1 ? l[u ? a[h] : h] : void 0;
    };
  }
  return UE = n, UE;
}
var VE, _B;
function LEe() {
  if (_B) return VE;
  _B = 1;
  var t = /\s/;
  function e(r) {
    for (var n = r.length; n-- && t.test(r.charAt(n)); )
      ;
    return n;
  }
  return VE = e, VE;
}
var HE, AB;
function REe() {
  if (AB) return HE;
  AB = 1;
  var t = LEe(), e = /^\s+/;
  function r(n) {
    return n && n.slice(0, t(n) + 1).replace(e, "");
  }
  return HE = r, HE;
}
var WE, LB;
function IEe() {
  if (LB) return WE;
  LB = 1;
  var t = REe(), e = hs(), r = $0(), n = NaN, i = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, s = /^0o[0-7]+$/i, o = parseInt;
  function l(u) {
    if (typeof u == "number")
      return u;
    if (r(u))
      return n;
    if (e(u)) {
      var h = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(h) ? h + "" : h;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = t(u);
    var f = a.test(u);
    return f || s.test(u) ? o(u.slice(2), f ? 2 : 8) : i.test(u) ? n : +u;
  }
  return WE = l, WE;
}
var YE, RB;
function Mte() {
  if (RB) return YE;
  RB = 1;
  var t = IEe(), e = 1 / 0, r = 17976931348623157e292;
  function n(i) {
    if (!i)
      return i === 0 ? i : 0;
    if (i = t(i), i === e || i === -e) {
      var a = i < 0 ? -1 : 1;
      return a * r;
    }
    return i === i ? i : 0;
  }
  return YE = n, YE;
}
var XE, IB;
function MEe() {
  if (IB) return XE;
  IB = 1;
  var t = Mte();
  function e(r) {
    var n = t(r), i = n % 1;
    return n === n ? i ? n - i : n : 0;
  }
  return XE = e, XE;
}
var jE, MB;
function NEe() {
  if (MB) return jE;
  MB = 1;
  var t = Ste(), e = _l(), r = MEe(), n = Math.max;
  function i(a, s, o) {
    var l = a == null ? 0 : a.length;
    if (!l)
      return -1;
    var u = o == null ? 0 : r(o);
    return u < 0 && (u = n(l + u, 0)), t(a, e(s, 3), u);
  }
  return jE = i, jE;
}
var KE, NB;
function DEe() {
  if (NB) return KE;
  NB = 1;
  var t = AEe(), e = NEe(), r = t(e);
  return KE = r, KE;
}
var ZE, DB;
function Nte() {
  if (DB) return ZE;
  DB = 1;
  var t = RL();
  function e(r) {
    var n = r == null ? 0 : r.length;
    return n ? t(r, 1) : [];
  }
  return ZE = e, ZE;
}
var QE, OB;
function OEe() {
  if (OB) return QE;
  OB = 1;
  var t = CL(), e = nte(), r = Ah();
  function n(i, a) {
    return i == null ? i : t(i, e(a), r);
  }
  return QE = n, QE;
}
var JE, PB;
function PEe() {
  if (PB) return JE;
  PB = 1;
  function t(e) {
    var r = e == null ? 0 : e.length;
    return r ? e[r - 1] : void 0;
  }
  return JE = t, JE;
}
var eS, $B;
function $Ee() {
  if ($B) return eS;
  $B = 1;
  var t = T4(), e = _L(), r = _l();
  function n(i, a) {
    var s = {};
    return a = r(a, 3), e(i, function(o, l, u) {
      t(s, l, a(o, l, u));
    }), s;
  }
  return eS = n, eS;
}
var tS, BB;
function ML() {
  if (BB) return tS;
  BB = 1;
  var t = $0();
  function e(r, n, i) {
    for (var a = -1, s = r.length; ++a < s; ) {
      var o = r[a], l = n(o);
      if (l != null && (u === void 0 ? l === l && !t(l) : i(l, u)))
        var u = l, h = o;
    }
    return h;
  }
  return tS = e, tS;
}
var rS, FB;
function BEe() {
  if (FB) return rS;
  FB = 1;
  function t(e, r) {
    return e > r;
  }
  return rS = t, rS;
}
var nS, zB;
function FEe() {
  if (zB) return nS;
  zB = 1;
  var t = ML(), e = BEe(), r = Lh();
  function n(i) {
    return i && i.length ? t(i, r, e) : void 0;
  }
  return nS = n, nS;
}
var iS, qB;
function Dte() {
  if (qB) return iS;
  qB = 1;
  var t = T4(), e = N0();
  function r(n, i, a) {
    (a !== void 0 && !e(n[i], a) || a === void 0 && !(i in n)) && t(n, i, a);
  }
  return iS = r, iS;
}
var aS, GB;
function zEe() {
  if (GB) return aS;
  GB = 1;
  var t = Ch(), e = _4(), r = To(), n = "[object Object]", i = Function.prototype, a = Object.prototype, s = i.toString, o = a.hasOwnProperty, l = s.call(Object);
  function u(h) {
    if (!r(h) || t(h) != n)
      return !1;
    var f = e(h);
    if (f === null)
      return !0;
    var d = o.call(f, "constructor") && f.constructor;
    return typeof d == "function" && d instanceof d && s.call(d) == l;
  }
  return aS = u, aS;
}
var sS, UB;
function Ote() {
  if (UB) return sS;
  UB = 1;
  function t(e, r) {
    if (!(r === "constructor" && typeof e[r] == "function") && r != "__proto__")
      return e[r];
  }
  return sS = t, sS;
}
var oS, VB;
function qEe() {
  if (VB) return oS;
  VB = 1;
  var t = cm(), e = Ah();
  function r(n) {
    return t(n, e(n));
  }
  return oS = r, oS;
}
var lS, HB;
function GEe() {
  if (HB) return lS;
  HB = 1;
  var t = Dte(), e = Vee(), r = Jee(), n = Hee(), i = tte(), a = um(), s = Nn(), o = kte(), l = O0(), u = lm(), h = hs(), f = zEe(), d = hm(), p = Ote(), g = qEe();
  function m(v, y, b, x, T, E, A) {
    var S = p(v, b), k = p(y, b), _ = A.get(k);
    if (_) {
      t(v, b, _);
      return;
    }
    var R = E ? E(S, k, b + "", v, y, A) : void 0, L = R === void 0;
    if (L) {
      var M = s(k), P = !M && l(k), C = !M && !P && d(k);
      R = k, M || P || C ? s(S) ? R = S : o(S) ? R = n(S) : P ? (L = !1, R = e(k, !0)) : C ? (L = !1, R = r(k, !0)) : R = [] : f(k) || a(k) ? (R = S, a(S) ? R = g(S) : (!h(S) || u(S)) && (R = i(k))) : L = !1;
    }
    L && (A.set(k, R), T(R, k, x, E, A), A.delete(k)), t(v, b, R);
  }
  return lS = m, lS;
}
var cS, WB;
function UEe() {
  if (WB) return cS;
  WB = 1;
  var t = w4(), e = Dte(), r = CL(), n = GEe(), i = hs(), a = Ah(), s = Ote();
  function o(l, u, h, f, d) {
    l !== u && r(u, function(p, g) {
      if (d || (d = new t()), i(p))
        n(l, u, g, h, o, f, d);
      else {
        var m = f ? f(s(l, g), p, g + "", l, u, d) : void 0;
        m === void 0 && (m = p), e(l, g, m);
      }
    }, a);
  }
  return cS = o, cS;
}
var uS, YB;
function VEe() {
  if (YB) return uS;
  YB = 1;
  var t = M4(), e = N4();
  function r(n) {
    return t(function(i, a) {
      var s = -1, o = a.length, l = o > 1 ? a[o - 1] : void 0, u = o > 2 ? a[2] : void 0;
      for (l = n.length > 3 && typeof l == "function" ? (o--, l) : void 0, u && e(a[0], a[1], u) && (l = o < 3 ? void 0 : l, o = 1), i = Object(i); ++s < o; ) {
        var h = a[s];
        h && n(i, h, s, l);
      }
      return i;
    });
  }
  return uS = r, uS;
}
var hS, XB;
function HEe() {
  if (XB) return hS;
  XB = 1;
  var t = UEe(), e = VEe(), r = e(function(n, i, a) {
    t(n, i, a);
  });
  return hS = r, hS;
}
var fS, jB;
function Pte() {
  if (jB) return fS;
  jB = 1;
  function t(e, r) {
    return e < r;
  }
  return fS = t, fS;
}
var dS, KB;
function WEe() {
  if (KB) return dS;
  KB = 1;
  var t = ML(), e = Pte(), r = Lh();
  function n(i) {
    return i && i.length ? t(i, r, e) : void 0;
  }
  return dS = n, dS;
}
var pS, ZB;
function YEe() {
  if (ZB) return pS;
  ZB = 1;
  var t = ML(), e = _l(), r = Pte();
  function n(i, a) {
    return i && i.length ? t(i, e(a, 2), r) : void 0;
  }
  return pS = n, pS;
}
var gS, QB;
function XEe() {
  if (QB) return gS;
  QB = 1;
  var t = Fs(), e = function() {
    return t.Date.now();
  };
  return gS = e, gS;
}
var mS, JB;
function jEe() {
  if (JB) return mS;
  JB = 1;
  var t = E4(), e = R4(), r = S4(), n = hs(), i = fm();
  function a(s, o, l, u) {
    if (!n(s))
      return s;
    o = e(o, s);
    for (var h = -1, f = o.length, d = f - 1, p = s; p != null && ++h < f; ) {
      var g = i(o[h]), m = l;
      if (g === "__proto__" || g === "constructor" || g === "prototype")
        return s;
      if (h != d) {
        var v = p[g];
        m = u ? u(v, g, p) : void 0, m === void 0 && (m = n(v) ? v : r(o[h + 1]) ? [] : {});
      }
      t(p, g, m), p = p[g];
    }
    return s;
  }
  return mS = a, mS;
}
var vS, eF;
function KEe() {
  if (eF) return vS;
  eF = 1;
  var t = I4(), e = jEe(), r = R4();
  function n(i, a, s) {
    for (var o = -1, l = a.length, u = {}; ++o < l; ) {
      var h = a[o], f = t(i, h);
      s(f, h) && e(u, r(h, i), f);
    }
    return u;
  }
  return vS = n, vS;
}
var yS, tF;
function ZEe() {
  if (tF) return yS;
  tF = 1;
  var t = KEe(), e = pte();
  function r(n, i) {
    return t(n, i, function(a, s) {
      return e(n, s);
    });
  }
  return yS = r, yS;
}
var bS, rF;
function QEe() {
  if (rF) return bS;
  rF = 1;
  var t = Nte(), e = Tte(), r = Ete();
  function n(i) {
    return r(e(i, void 0, t), i + "");
  }
  return bS = n, bS;
}
var xS, nF;
function JEe() {
  if (nF) return xS;
  nF = 1;
  var t = ZEe(), e = QEe(), r = e(function(n, i) {
    return n == null ? {} : t(n, i);
  });
  return xS = r, xS;
}
var wS, iF;
function eSe() {
  if (iF) return wS;
  iF = 1;
  var t = Math.ceil, e = Math.max;
  function r(n, i, a, s) {
    for (var o = -1, l = e(t((i - n) / (a || 1)), 0), u = Array(l); l--; )
      u[s ? l : ++o] = n, n += a;
    return u;
  }
  return wS = r, wS;
}
var TS, aF;
function tSe() {
  if (aF) return TS;
  aF = 1;
  var t = eSe(), e = N4(), r = Mte();
  function n(i) {
    return function(a, s, o) {
      return o && typeof o != "number" && e(a, s, o) && (s = o = void 0), a = r(a), s === void 0 ? (s = a, a = 0) : s = r(s), o = o === void 0 ? a < s ? 1 : -1 : r(o), t(a, s, o, i);
    };
  }
  return TS = n, TS;
}
var ES, sF;
function rSe() {
  if (sF) return ES;
  sF = 1;
  var t = tSe(), e = t();
  return ES = e, ES;
}
var SS, oF;
function nSe() {
  if (oF) return SS;
  oF = 1;
  function t(e, r) {
    var n = e.length;
    for (e.sort(r); n--; )
      e[n] = e[n].value;
    return e;
  }
  return SS = t, SS;
}
var kS, lF;
function iSe() {
  if (lF) return kS;
  lF = 1;
  var t = $0();
  function e(r, n) {
    if (r !== n) {
      var i = r !== void 0, a = r === null, s = r === r, o = t(r), l = n !== void 0, u = n === null, h = n === n, f = t(n);
      if (!u && !f && !o && r > n || o && l && h && !u && !f || a && l && h || !i && h || !s)
        return 1;
      if (!a && !o && !f && r < n || f && i && s && !a && !o || u && i && s || !l && s || !h)
        return -1;
    }
    return 0;
  }
  return kS = e, kS;
}
var CS, cF;
function aSe() {
  if (cF) return CS;
  cF = 1;
  var t = iSe();
  function e(r, n, i) {
    for (var a = -1, s = r.criteria, o = n.criteria, l = s.length, u = i.length; ++a < l; ) {
      var h = t(s[a], o[a]);
      if (h) {
        if (a >= u)
          return h;
        var f = i[a];
        return h * (f == "desc" ? -1 : 1);
      }
    }
    return r.index - n.index;
  }
  return CS = e, CS;
}
var _S, uF;
function sSe() {
  if (uF) return _S;
  uF = 1;
  var t = L4(), e = I4(), r = _l(), n = bte(), i = nSe(), a = k4(), s = aSe(), o = Lh(), l = Nn();
  function u(h, f, d) {
    f.length ? f = t(f, function(m) {
      return l(m) ? function(v) {
        return e(v, m.length === 1 ? m[0] : m);
      } : m;
    }) : f = [o];
    var p = -1;
    f = t(f, a(r));
    var g = n(h, function(m, v, y) {
      var b = t(f, function(x) {
        return x(m);
      });
      return { criteria: b, index: ++p, value: m };
    });
    return i(g, function(m, v) {
      return s(m, v, d);
    });
  }
  return _S = u, _S;
}
var AS, hF;
function oSe() {
  if (hF) return AS;
  hF = 1;
  var t = RL(), e = sSe(), r = M4(), n = N4(), i = r(function(a, s) {
    if (a == null)
      return [];
    var o = s.length;
    return o > 1 && n(a, s[0], s[1]) ? s = [] : o > 2 && n(s[0], s[1], s[2]) && (s = [s[0]]), e(a, t(s, 1), []);
  });
  return AS = i, AS;
}
var LS, fF;
function lSe() {
  if (fF) return LS;
  fF = 1;
  var t = fte(), e = 0;
  function r(n) {
    var i = ++e;
    return t(n) + i;
  }
  return LS = r, LS;
}
var RS, dF;
function cSe() {
  if (dF) return RS;
  dF = 1;
  function t(e, r, n) {
    for (var i = -1, a = e.length, s = r.length, o = {}; ++i < a; ) {
      var l = i < s ? r[i] : void 0;
      n(o, e[i], l);
    }
    return o;
  }
  return RS = t, RS;
}
var IS, pF;
function uSe() {
  if (pF) return IS;
  pF = 1;
  var t = E4(), e = cSe();
  function r(n, i) {
    return e(n || [], i || [], t);
  }
  return IS = r, IS;
}
var MS, gF;
function en() {
  if (gF) return MS;
  gF = 1;
  var t;
  if (typeof gL == "function")
    try {
      t = {
        cloneDeep: CEe(),
        constant: kL(),
        defaults: _Ee(),
        each: ate(),
        filter: mte(),
        find: DEe(),
        flatten: Nte(),
        forEach: ite(),
        forIn: OEe(),
        has: vte(),
        isUndefined: yte(),
        last: PEe(),
        map: xte(),
        mapValues: $Ee(),
        max: FEe(),
        merge: HEe(),
        min: WEe(),
        minBy: YEe(),
        now: XEe(),
        pick: JEe(),
        range: rSe(),
        reduce: wte(),
        sortBy: oSe(),
        uniqueId: lSe(),
        values: Cte(),
        zipObject: uSe()
      };
    } catch {
    }
  return t || (t = window._), MS = t, MS;
}
var NS, mF;
function hSe() {
  if (mF) return NS;
  mF = 1, NS = t;
  function t() {
    var n = {};
    n._next = n._prev = n, this._sentinel = n;
  }
  t.prototype.dequeue = function() {
    var n = this._sentinel, i = n._prev;
    if (i !== n)
      return e(i), i;
  }, t.prototype.enqueue = function(n) {
    var i = this._sentinel;
    n._prev && n._next && e(n), n._next = i._next, i._next._prev = n, i._next = n, n._prev = i;
  }, t.prototype.toString = function() {
    for (var n = [], i = this._sentinel, a = i._prev; a !== i; )
      n.push(JSON.stringify(a, r)), a = a._prev;
    return "[" + n.join(", ") + "]";
  };
  function e(n) {
    n._prev._next = n._next, n._next._prev = n._prev, delete n._next, delete n._prev;
  }
  function r(n, i) {
    if (n !== "_next" && n !== "_prev")
      return i;
  }
  return NS;
}
var DS, vF;
function fSe() {
  if (vF) return DS;
  vF = 1;
  var t = en(), e = Ms().Graph, r = hSe();
  DS = i;
  var n = t.constant(1);
  function i(u, h) {
    if (u.nodeCount() <= 1)
      return [];
    var f = o(u, h || n), d = a(f.graph, f.buckets, f.zeroIdx);
    return t.flatten(t.map(d, function(p) {
      return u.outEdges(p.v, p.w);
    }), !0);
  }
  function a(u, h, f) {
    for (var d = [], p = h[h.length - 1], g = h[0], m; u.nodeCount(); ) {
      for (; m = g.dequeue(); )
        s(u, h, f, m);
      for (; m = p.dequeue(); )
        s(u, h, f, m);
      if (u.nodeCount()) {
        for (var v = h.length - 2; v > 0; --v)
          if (m = h[v].dequeue(), m) {
            d = d.concat(s(u, h, f, m, !0));
            break;
          }
      }
    }
    return d;
  }
  function s(u, h, f, d, p) {
    var g = p ? [] : void 0;
    return t.forEach(u.inEdges(d.v), function(m) {
      var v = u.edge(m), y = u.node(m.v);
      p && g.push({ v: m.v, w: m.w }), y.out -= v, l(h, f, y);
    }), t.forEach(u.outEdges(d.v), function(m) {
      var v = u.edge(m), y = m.w, b = u.node(y);
      b.in -= v, l(h, f, b);
    }), u.removeNode(d.v), g;
  }
  function o(u, h) {
    var f = new e(), d = 0, p = 0;
    t.forEach(u.nodes(), function(v) {
      f.setNode(v, { v, in: 0, out: 0 });
    }), t.forEach(u.edges(), function(v) {
      var y = f.edge(v.v, v.w) || 0, b = h(v), x = y + b;
      f.setEdge(v.v, v.w, x), p = Math.max(p, f.node(v.v).out += b), d = Math.max(d, f.node(v.w).in += b);
    });
    var g = t.range(p + d + 3).map(function() {
      return new r();
    }), m = d + 1;
    return t.forEach(f.nodes(), function(v) {
      l(g, m, f.node(v));
    }), { graph: f, buckets: g, zeroIdx: m };
  }
  function l(u, h, f) {
    f.out ? f.in ? u[f.out - f.in + h].enqueue(f) : u[u.length - 1].enqueue(f) : u[0].enqueue(f);
  }
  return DS;
}
var OS, yF;
function dSe() {
  if (yF) return OS;
  yF = 1;
  var t = en(), e = fSe();
  OS = {
    run: r,
    undo: i
  };
  function r(a) {
    var s = a.graph().acyclicer === "greedy" ? e(a, o(a)) : n(a);
    t.forEach(s, function(l) {
      var u = a.edge(l);
      a.removeEdge(l), u.forwardName = l.name, u.reversed = !0, a.setEdge(l.w, l.v, u, t.uniqueId("rev"));
    });
    function o(l) {
      return function(u) {
        return l.edge(u).weight;
      };
    }
  }
  function n(a) {
    var s = [], o = {}, l = {};
    function u(h) {
      t.has(l, h) || (l[h] = !0, o[h] = !0, t.forEach(a.outEdges(h), function(f) {
        t.has(o, f.w) ? s.push(f) : u(f.w);
      }), delete o[h]);
    }
    return t.forEach(a.nodes(), u), s;
  }
  function i(a) {
    t.forEach(a.edges(), function(s) {
      var o = a.edge(s);
      if (o.reversed) {
        a.removeEdge(s);
        var l = o.forwardName;
        delete o.reversed, delete o.forwardName, a.setEdge(s.w, s.v, o, l);
      }
    });
  }
  return OS;
}
var PS, bF;
function ua() {
  if (bF) return PS;
  bF = 1;
  var t = en(), e = Ms().Graph;
  PS = {
    addDummyNode: r,
    simplify: n,
    asNonCompoundGraph: i,
    successorWeights: a,
    predecessorWeights: s,
    intersectRect: o,
    buildLayerMatrix: l,
    normalizeRanks: u,
    removeEmptyRanks: h,
    addBorderNode: f,
    maxRank: d,
    partition: p,
    time: g,
    notime: m
  };
  function r(v, y, b, x) {
    var T;
    do
      T = t.uniqueId(x);
    while (v.hasNode(T));
    return b.dummy = y, v.setNode(T, b), T;
  }
  function n(v) {
    var y = new e().setGraph(v.graph());
    return t.forEach(v.nodes(), function(b) {
      y.setNode(b, v.node(b));
    }), t.forEach(v.edges(), function(b) {
      var x = y.edge(b.v, b.w) || { weight: 0, minlen: 1 }, T = v.edge(b);
      y.setEdge(b.v, b.w, {
        weight: x.weight + T.weight,
        minlen: Math.max(x.minlen, T.minlen)
      });
    }), y;
  }
  function i(v) {
    var y = new e({ multigraph: v.isMultigraph() }).setGraph(v.graph());
    return t.forEach(v.nodes(), function(b) {
      v.children(b).length || y.setNode(b, v.node(b));
    }), t.forEach(v.edges(), function(b) {
      y.setEdge(b, v.edge(b));
    }), y;
  }
  function a(v) {
    var y = t.map(v.nodes(), function(b) {
      var x = {};
      return t.forEach(v.outEdges(b), function(T) {
        x[T.w] = (x[T.w] || 0) + v.edge(T).weight;
      }), x;
    });
    return t.zipObject(v.nodes(), y);
  }
  function s(v) {
    var y = t.map(v.nodes(), function(b) {
      var x = {};
      return t.forEach(v.inEdges(b), function(T) {
        x[T.v] = (x[T.v] || 0) + v.edge(T).weight;
      }), x;
    });
    return t.zipObject(v.nodes(), y);
  }
  function o(v, y) {
    var b = v.x, x = v.y, T = y.x - b, E = y.y - x, A = v.width / 2, S = v.height / 2;
    if (!T && !E)
      throw new Error("Not possible to find intersection inside of the rectangle");
    var k, _;
    return Math.abs(E) * A > Math.abs(T) * S ? (E < 0 && (S = -S), k = S * T / E, _ = S) : (T < 0 && (A = -A), k = A, _ = A * E / T), { x: b + k, y: x + _ };
  }
  function l(v) {
    var y = t.map(t.range(d(v) + 1), function() {
      return [];
    });
    return t.forEach(v.nodes(), function(b) {
      var x = v.node(b), T = x.rank;
      t.isUndefined(T) || (y[T][x.order] = b);
    }), y;
  }
  function u(v) {
    var y = t.min(t.map(v.nodes(), function(b) {
      return v.node(b).rank;
    }));
    t.forEach(v.nodes(), function(b) {
      var x = v.node(b);
      t.has(x, "rank") && (x.rank -= y);
    });
  }
  function h(v) {
    var y = t.min(t.map(v.nodes(), function(E) {
      return v.node(E).rank;
    })), b = [];
    t.forEach(v.nodes(), function(E) {
      var A = v.node(E).rank - y;
      b[A] || (b[A] = []), b[A].push(E);
    });
    var x = 0, T = v.graph().nodeRankFactor;
    t.forEach(b, function(E, A) {
      t.isUndefined(E) && A % T !== 0 ? --x : x && t.forEach(E, function(S) {
        v.node(S).rank += x;
      });
    });
  }
  function f(v, y, b, x) {
    var T = {
      width: 0,
      height: 0
    };
    return arguments.length >= 4 && (T.rank = b, T.order = x), r(v, "border", T, y);
  }
  function d(v) {
    return t.max(t.map(v.nodes(), function(y) {
      var b = v.node(y).rank;
      if (!t.isUndefined(b))
        return b;
    }));
  }
  function p(v, y) {
    var b = { lhs: [], rhs: [] };
    return t.forEach(v, function(x) {
      y(x) ? b.lhs.push(x) : b.rhs.push(x);
    }), b;
  }
  function g(v, y) {
    var b = t.now();
    try {
      return y();
    } finally {
      console.log(v + " time: " + (t.now() - b) + "ms");
    }
  }
  function m(v, y) {
    return y();
  }
  return PS;
}
var $S, xF;
function pSe() {
  if (xF) return $S;
  xF = 1;
  var t = en(), e = ua();
  $S = {
    run: r,
    undo: i
  };
  function r(a) {
    a.graph().dummyChains = [], t.forEach(a.edges(), function(s) {
      n(a, s);
    });
  }
  function n(a, s) {
    var o = s.v, l = a.node(o).rank, u = s.w, h = a.node(u).rank, f = s.name, d = a.edge(s), p = d.labelRank;
    if (h !== l + 1) {
      a.removeEdge(s);
      var g, m, v;
      for (v = 0, ++l; l < h; ++v, ++l)
        d.points = [], m = {
          width: 0,
          height: 0,
          edgeLabel: d,
          edgeObj: s,
          rank: l
        }, g = e.addDummyNode(a, "edge", m, "_d"), l === p && (m.width = d.width, m.height = d.height, m.dummy = "edge-label", m.labelpos = d.labelpos), a.setEdge(o, g, { weight: d.weight }, f), v === 0 && a.graph().dummyChains.push(g), o = g;
      a.setEdge(o, u, { weight: d.weight }, f);
    }
  }
  function i(a) {
    t.forEach(a.graph().dummyChains, function(s) {
      var o = a.node(s), l = o.edgeLabel, u;
      for (a.setEdge(o.edgeObj, l); o.dummy; )
        u = a.successors(s)[0], a.removeNode(s), l.points.push({ x: o.x, y: o.y }), o.dummy === "edge-label" && (l.x = o.x, l.y = o.y, l.width = o.width, l.height = o.height), s = u, o = a.node(s);
    });
  }
  return $S;
}
var BS, wF;
function vb() {
  if (wF) return BS;
  wF = 1;
  var t = en();
  BS = {
    longestPath: e,
    slack: r
  };
  function e(n) {
    var i = {};
    function a(s) {
      var o = n.node(s);
      if (t.has(i, s))
        return o.rank;
      i[s] = !0;
      var l = t.min(t.map(n.outEdges(s), function(u) {
        return a(u.w) - n.edge(u).minlen;
      }));
      return (l === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
      l === void 0 || // return value of _.map([]) for Lodash 4
      l === null) && (l = 0), o.rank = l;
    }
    t.forEach(n.sources(), a);
  }
  function r(n, i) {
    return n.node(i.w).rank - n.node(i.v).rank - n.edge(i).minlen;
  }
  return BS;
}
var FS, TF;
function $te() {
  if (TF) return FS;
  TF = 1;
  var t = en(), e = Ms().Graph, r = vb().slack;
  FS = n;
  function n(o) {
    var l = new e({ directed: !1 }), u = o.nodes()[0], h = o.nodeCount();
    l.setNode(u, {});
    for (var f, d; i(l, o) < h; )
      f = a(l, o), d = l.hasNode(f.v) ? r(o, f) : -r(o, f), s(l, o, d);
    return l;
  }
  function i(o, l) {
    function u(h) {
      t.forEach(l.nodeEdges(h), function(f) {
        var d = f.v, p = h === d ? f.w : d;
        !o.hasNode(p) && !r(l, f) && (o.setNode(p, {}), o.setEdge(h, p, {}), u(p));
      });
    }
    return t.forEach(o.nodes(), u), o.nodeCount();
  }
  function a(o, l) {
    return t.minBy(l.edges(), function(u) {
      if (o.hasNode(u.v) !== o.hasNode(u.w))
        return r(l, u);
    });
  }
  function s(o, l, u) {
    t.forEach(o.nodes(), function(h) {
      l.node(h).rank += u;
    });
  }
  return FS;
}
var zS, EF;
function gSe() {
  if (EF) return zS;
  EF = 1;
  var t = en(), e = $te(), r = vb().slack, n = vb().longestPath, i = Ms().alg.preorder, a = Ms().alg.postorder, s = ua().simplify;
  zS = o, o.initLowLimValues = f, o.initCutValues = l, o.calcCutValue = h, o.leaveEdge = p, o.enterEdge = g, o.exchangeEdges = m;
  function o(x) {
    x = s(x), n(x);
    var T = e(x);
    f(T), l(T, x);
    for (var E, A; E = p(T); )
      A = g(T, x, E), m(T, x, E, A);
  }
  function l(x, T) {
    var E = a(x, x.nodes());
    E = E.slice(0, E.length - 1), t.forEach(E, function(A) {
      u(x, T, A);
    });
  }
  function u(x, T, E) {
    var A = x.node(E), S = A.parent;
    x.edge(E, S).cutvalue = h(x, T, E);
  }
  function h(x, T, E) {
    var A = x.node(E), S = A.parent, k = !0, _ = T.edge(E, S), R = 0;
    return _ || (k = !1, _ = T.edge(S, E)), R = _.weight, t.forEach(T.nodeEdges(E), function(L) {
      var M = L.v === E, P = M ? L.w : L.v;
      if (P !== S) {
        var C = M === k, I = T.edge(L).weight;
        if (R += C ? I : -I, y(x, E, P)) {
          var N = x.edge(E, P).cutvalue;
          R += C ? -N : N;
        }
      }
    }), R;
  }
  function f(x, T) {
    arguments.length < 2 && (T = x.nodes()[0]), d(x, {}, 1, T);
  }
  function d(x, T, E, A, S) {
    var k = E, _ = x.node(A);
    return T[A] = !0, t.forEach(x.neighbors(A), function(R) {
      t.has(T, R) || (E = d(x, T, E, R, A));
    }), _.low = k, _.lim = E++, S ? _.parent = S : delete _.parent, E;
  }
  function p(x) {
    return t.find(x.edges(), function(T) {
      return x.edge(T).cutvalue < 0;
    });
  }
  function g(x, T, E) {
    var A = E.v, S = E.w;
    T.hasEdge(A, S) || (A = E.w, S = E.v);
    var k = x.node(A), _ = x.node(S), R = k, L = !1;
    k.lim > _.lim && (R = _, L = !0);
    var M = t.filter(T.edges(), function(P) {
      return L === b(x, x.node(P.v), R) && L !== b(x, x.node(P.w), R);
    });
    return t.minBy(M, function(P) {
      return r(T, P);
    });
  }
  function m(x, T, E, A) {
    var S = E.v, k = E.w;
    x.removeEdge(S, k), x.setEdge(A.v, A.w, {}), f(x), l(x, T), v(x, T);
  }
  function v(x, T) {
    var E = t.find(x.nodes(), function(S) {
      return !T.node(S).parent;
    }), A = i(x, E);
    A = A.slice(1), t.forEach(A, function(S) {
      var k = x.node(S).parent, _ = T.edge(S, k), R = !1;
      _ || (_ = T.edge(k, S), R = !0), T.node(S).rank = T.node(k).rank + (R ? _.minlen : -_.minlen);
    });
  }
  function y(x, T, E) {
    return x.hasEdge(T, E);
  }
  function b(x, T, E) {
    return E.low <= T.lim && T.lim <= E.lim;
  }
  return zS;
}
var qS, SF;
function mSe() {
  if (SF) return qS;
  SF = 1;
  var t = vb(), e = t.longestPath, r = $te(), n = gSe();
  qS = i;
  function i(l) {
    switch (l.graph().ranker) {
      case "network-simplex":
        o(l);
        break;
      case "tight-tree":
        s(l);
        break;
      case "longest-path":
        a(l);
        break;
      default:
        o(l);
    }
  }
  var a = e;
  function s(l) {
    e(l), r(l);
  }
  function o(l) {
    n(l);
  }
  return qS;
}
var GS, kF;
function vSe() {
  if (kF) return GS;
  kF = 1;
  var t = en();
  GS = e;
  function e(i) {
    var a = n(i);
    t.forEach(i.graph().dummyChains, function(s) {
      for (var o = i.node(s), l = o.edgeObj, u = r(i, a, l.v, l.w), h = u.path, f = u.lca, d = 0, p = h[d], g = !0; s !== l.w; ) {
        if (o = i.node(s), g) {
          for (; (p = h[d]) !== f && i.node(p).maxRank < o.rank; )
            d++;
          p === f && (g = !1);
        }
        if (!g) {
          for (; d < h.length - 1 && i.node(p = h[d + 1]).minRank <= o.rank; )
            d++;
          p = h[d];
        }
        i.setParent(s, p), s = i.successors(s)[0];
      }
    });
  }
  function r(i, a, s, o) {
    var l = [], u = [], h = Math.min(a[s].low, a[o].low), f = Math.max(a[s].lim, a[o].lim), d, p;
    d = s;
    do
      d = i.parent(d), l.push(d);
    while (d && (a[d].low > h || f > a[d].lim));
    for (p = d, d = o; (d = i.parent(d)) !== p; )
      u.push(d);
    return { path: l.concat(u.reverse()), lca: p };
  }
  function n(i) {
    var a = {}, s = 0;
    function o(l) {
      var u = s;
      t.forEach(i.children(l), o), a[l] = { low: u, lim: s++ };
    }
    return t.forEach(i.children(), o), a;
  }
  return GS;
}
var US, CF;
function ySe() {
  if (CF) return US;
  CF = 1;
  var t = en(), e = ua();
  US = {
    run: r,
    cleanup: s
  };
  function r(o) {
    var l = e.addDummyNode(o, "root", {}, "_root"), u = i(o), h = t.max(t.values(u)) - 1, f = 2 * h + 1;
    o.graph().nestingRoot = l, t.forEach(o.edges(), function(p) {
      o.edge(p).minlen *= f;
    });
    var d = a(o) + 1;
    t.forEach(o.children(), function(p) {
      n(o, l, f, d, h, u, p);
    }), o.graph().nodeRankFactor = f;
  }
  function n(o, l, u, h, f, d, p) {
    var g = o.children(p);
    if (!g.length) {
      p !== l && o.setEdge(l, p, { weight: 0, minlen: u });
      return;
    }
    var m = e.addBorderNode(o, "_bt"), v = e.addBorderNode(o, "_bb"), y = o.node(p);
    o.setParent(m, p), y.borderTop = m, o.setParent(v, p), y.borderBottom = v, t.forEach(g, function(b) {
      n(o, l, u, h, f, d, b);
      var x = o.node(b), T = x.borderTop ? x.borderTop : b, E = x.borderBottom ? x.borderBottom : b, A = x.borderTop ? h : 2 * h, S = T !== E ? 1 : f - d[p] + 1;
      o.setEdge(m, T, {
        weight: A,
        minlen: S,
        nestingEdge: !0
      }), o.setEdge(E, v, {
        weight: A,
        minlen: S,
        nestingEdge: !0
      });
    }), o.parent(p) || o.setEdge(l, m, { weight: 0, minlen: f + d[p] });
  }
  function i(o) {
    var l = {};
    function u(h, f) {
      var d = o.children(h);
      d && d.length && t.forEach(d, function(p) {
        u(p, f + 1);
      }), l[h] = f;
    }
    return t.forEach(o.children(), function(h) {
      u(h, 1);
    }), l;
  }
  function a(o) {
    return t.reduce(o.edges(), function(l, u) {
      return l + o.edge(u).weight;
    }, 0);
  }
  function s(o) {
    var l = o.graph();
    o.removeNode(l.nestingRoot), delete l.nestingRoot, t.forEach(o.edges(), function(u) {
      var h = o.edge(u);
      h.nestingEdge && o.removeEdge(u);
    });
  }
  return US;
}
var VS, _F;
function bSe() {
  if (_F) return VS;
  _F = 1;
  var t = en(), e = ua();
  VS = r;
  function r(i) {
    function a(s) {
      var o = i.children(s), l = i.node(s);
      if (o.length && t.forEach(o, a), t.has(l, "minRank")) {
        l.borderLeft = [], l.borderRight = [];
        for (var u = l.minRank, h = l.maxRank + 1; u < h; ++u)
          n(i, "borderLeft", "_bl", s, l, u), n(i, "borderRight", "_br", s, l, u);
      }
    }
    t.forEach(i.children(), a);
  }
  function n(i, a, s, o, l, u) {
    var h = { width: 0, height: 0, rank: u, borderType: a }, f = l[a][u - 1], d = e.addDummyNode(i, "border", h, s);
    l[a][u] = d, i.setParent(d, o), f && i.setEdge(f, d, { weight: 1 });
  }
  return VS;
}
var HS, AF;
function xSe() {
  if (AF) return HS;
  AF = 1;
  var t = en();
  HS = {
    adjust: e,
    undo: r
  };
  function e(u) {
    var h = u.graph().rankdir.toLowerCase();
    (h === "lr" || h === "rl") && n(u);
  }
  function r(u) {
    var h = u.graph().rankdir.toLowerCase();
    (h === "bt" || h === "rl") && a(u), (h === "lr" || h === "rl") && (o(u), n(u));
  }
  function n(u) {
    t.forEach(u.nodes(), function(h) {
      i(u.node(h));
    }), t.forEach(u.edges(), function(h) {
      i(u.edge(h));
    });
  }
  function i(u) {
    var h = u.width;
    u.width = u.height, u.height = h;
  }
  function a(u) {
    t.forEach(u.nodes(), function(h) {
      s(u.node(h));
    }), t.forEach(u.edges(), function(h) {
      var f = u.edge(h);
      t.forEach(f.points, s), t.has(f, "y") && s(f);
    });
  }
  function s(u) {
    u.y = -u.y;
  }
  function o(u) {
    t.forEach(u.nodes(), function(h) {
      l(u.node(h));
    }), t.forEach(u.edges(), function(h) {
      var f = u.edge(h);
      t.forEach(f.points, l), t.has(f, "x") && l(f);
    });
  }
  function l(u) {
    var h = u.x;
    u.x = u.y, u.y = h;
  }
  return HS;
}
var WS, LF;
function wSe() {
  if (LF) return WS;
  LF = 1;
  var t = en();
  WS = e;
  function e(r) {
    var n = {}, i = t.filter(r.nodes(), function(u) {
      return !r.children(u).length;
    }), a = t.max(t.map(i, function(u) {
      return r.node(u).rank;
    })), s = t.map(t.range(a + 1), function() {
      return [];
    });
    function o(u) {
      if (!t.has(n, u)) {
        n[u] = !0;
        var h = r.node(u);
        s[h.rank].push(u), t.forEach(r.successors(u), o);
      }
    }
    var l = t.sortBy(i, function(u) {
      return r.node(u).rank;
    });
    return t.forEach(l, o), s;
  }
  return WS;
}
var YS, RF;
function TSe() {
  if (RF) return YS;
  RF = 1;
  var t = en();
  YS = e;
  function e(n, i) {
    for (var a = 0, s = 1; s < i.length; ++s)
      a += r(n, i[s - 1], i[s]);
    return a;
  }
  function r(n, i, a) {
    for (var s = t.zipObject(
      a,
      t.map(a, function(d, p) {
        return p;
      })
    ), o = t.flatten(t.map(i, function(d) {
      return t.sortBy(t.map(n.outEdges(d), function(p) {
        return { pos: s[p.w], weight: n.edge(p).weight };
      }), "pos");
    }), !0), l = 1; l < a.length; ) l <<= 1;
    var u = 2 * l - 1;
    l -= 1;
    var h = t.map(new Array(u), function() {
      return 0;
    }), f = 0;
    return t.forEach(o.forEach(function(d) {
      var p = d.pos + l;
      h[p] += d.weight;
      for (var g = 0; p > 0; )
        p % 2 && (g += h[p + 1]), p = p - 1 >> 1, h[p] += d.weight;
      f += d.weight * g;
    })), f;
  }
  return YS;
}
var XS, IF;
function ESe() {
  if (IF) return XS;
  IF = 1;
  var t = en();
  XS = e;
  function e(r, n) {
    return t.map(n, function(i) {
      var a = r.inEdges(i);
      if (a.length) {
        var s = t.reduce(a, function(o, l) {
          var u = r.edge(l), h = r.node(l.v);
          return {
            sum: o.sum + u.weight * h.order,
            weight: o.weight + u.weight
          };
        }, { sum: 0, weight: 0 });
        return {
          v: i,
          barycenter: s.sum / s.weight,
          weight: s.weight
        };
      } else
        return { v: i };
    });
  }
  return XS;
}
var jS, MF;
function SSe() {
  if (MF) return jS;
  MF = 1;
  var t = en();
  jS = e;
  function e(i, a) {
    var s = {};
    t.forEach(i, function(l, u) {
      var h = s[l.v] = {
        indegree: 0,
        in: [],
        out: [],
        vs: [l.v],
        i: u
      };
      t.isUndefined(l.barycenter) || (h.barycenter = l.barycenter, h.weight = l.weight);
    }), t.forEach(a.edges(), function(l) {
      var u = s[l.v], h = s[l.w];
      !t.isUndefined(u) && !t.isUndefined(h) && (h.indegree++, u.out.push(s[l.w]));
    });
    var o = t.filter(s, function(l) {
      return !l.indegree;
    });
    return r(o);
  }
  function r(i) {
    var a = [];
    function s(u) {
      return function(h) {
        h.merged || (t.isUndefined(h.barycenter) || t.isUndefined(u.barycenter) || h.barycenter >= u.barycenter) && n(u, h);
      };
    }
    function o(u) {
      return function(h) {
        h.in.push(u), --h.indegree === 0 && i.push(h);
      };
    }
    for (; i.length; ) {
      var l = i.pop();
      a.push(l), t.forEach(l.in.reverse(), s(l)), t.forEach(l.out, o(l));
    }
    return t.map(
      t.filter(a, function(u) {
        return !u.merged;
      }),
      function(u) {
        return t.pick(u, ["vs", "i", "barycenter", "weight"]);
      }
    );
  }
  function n(i, a) {
    var s = 0, o = 0;
    i.weight && (s += i.barycenter * i.weight, o += i.weight), a.weight && (s += a.barycenter * a.weight, o += a.weight), i.vs = a.vs.concat(i.vs), i.barycenter = s / o, i.weight = o, i.i = Math.min(a.i, i.i), a.merged = !0;
  }
  return jS;
}
var KS, NF;
function kSe() {
  if (NF) return KS;
  NF = 1;
  var t = en(), e = ua();
  KS = r;
  function r(a, s) {
    var o = e.partition(a, function(m) {
      return t.has(m, "barycenter");
    }), l = o.lhs, u = t.sortBy(o.rhs, function(m) {
      return -m.i;
    }), h = [], f = 0, d = 0, p = 0;
    l.sort(i(!!s)), p = n(h, u, p), t.forEach(l, function(m) {
      p += m.vs.length, h.push(m.vs), f += m.barycenter * m.weight, d += m.weight, p = n(h, u, p);
    });
    var g = { vs: t.flatten(h, !0) };
    return d && (g.barycenter = f / d, g.weight = d), g;
  }
  function n(a, s, o) {
    for (var l; s.length && (l = t.last(s)).i <= o; )
      s.pop(), a.push(l.vs), o++;
    return o;
  }
  function i(a) {
    return function(s, o) {
      return s.barycenter < o.barycenter ? -1 : s.barycenter > o.barycenter ? 1 : a ? o.i - s.i : s.i - o.i;
    };
  }
  return KS;
}
var ZS, DF;
function CSe() {
  if (DF) return ZS;
  DF = 1;
  var t = en(), e = ESe(), r = SSe(), n = kSe();
  ZS = i;
  function i(o, l, u, h) {
    var f = o.children(l), d = o.node(l), p = d ? d.borderLeft : void 0, g = d ? d.borderRight : void 0, m = {};
    p && (f = t.filter(f, function(E) {
      return E !== p && E !== g;
    }));
    var v = e(o, f);
    t.forEach(v, function(E) {
      if (o.children(E.v).length) {
        var A = i(o, E.v, u, h);
        m[E.v] = A, t.has(A, "barycenter") && s(E, A);
      }
    });
    var y = r(v, u);
    a(y, m);
    var b = n(y, h);
    if (p && (b.vs = t.flatten([p, b.vs, g], !0), o.predecessors(p).length)) {
      var x = o.node(o.predecessors(p)[0]), T = o.node(o.predecessors(g)[0]);
      t.has(b, "barycenter") || (b.barycenter = 0, b.weight = 0), b.barycenter = (b.barycenter * b.weight + x.order + T.order) / (b.weight + 2), b.weight += 2;
    }
    return b;
  }
  function a(o, l) {
    t.forEach(o, function(u) {
      u.vs = t.flatten(u.vs.map(function(h) {
        return l[h] ? l[h].vs : h;
      }), !0);
    });
  }
  function s(o, l) {
    t.isUndefined(o.barycenter) ? (o.barycenter = l.barycenter, o.weight = l.weight) : (o.barycenter = (o.barycenter * o.weight + l.barycenter * l.weight) / (o.weight + l.weight), o.weight += l.weight);
  }
  return ZS;
}
var QS, OF;
function _Se() {
  if (OF) return QS;
  OF = 1;
  var t = en(), e = Ms().Graph;
  QS = r;
  function r(i, a, s) {
    var o = n(i), l = new e({ compound: !0 }).setGraph({ root: o }).setDefaultNodeLabel(function(u) {
      return i.node(u);
    });
    return t.forEach(i.nodes(), function(u) {
      var h = i.node(u), f = i.parent(u);
      (h.rank === a || h.minRank <= a && a <= h.maxRank) && (l.setNode(u), l.setParent(u, f || o), t.forEach(i[s](u), function(d) {
        var p = d.v === u ? d.w : d.v, g = l.edge(p, u), m = t.isUndefined(g) ? 0 : g.weight;
        l.setEdge(p, u, { weight: i.edge(d).weight + m });
      }), t.has(h, "minRank") && l.setNode(u, {
        borderLeft: h.borderLeft[a],
        borderRight: h.borderRight[a]
      }));
    }), l;
  }
  function n(i) {
    for (var a; i.hasNode(a = t.uniqueId("_root")); ) ;
    return a;
  }
  return QS;
}
var JS, PF;
function ASe() {
  if (PF) return JS;
  PF = 1;
  var t = en();
  JS = e;
  function e(r, n, i) {
    var a = {}, s;
    t.forEach(i, function(o) {
      for (var l = r.parent(o), u, h; l; ) {
        if (u = r.parent(l), u ? (h = a[u], a[u] = l) : (h = s, s = l), h && h !== l) {
          n.setEdge(h, l);
          return;
        }
        l = u;
      }
    });
  }
  return JS;
}
var ek, $F;
function LSe() {
  if ($F) return ek;
  $F = 1;
  var t = en(), e = wSe(), r = TSe(), n = CSe(), i = _Se(), a = ASe(), s = Ms().Graph, o = ua();
  ek = l;
  function l(d) {
    var p = o.maxRank(d), g = u(d, t.range(1, p + 1), "inEdges"), m = u(d, t.range(p - 1, -1, -1), "outEdges"), v = e(d);
    f(d, v);
    for (var y = Number.POSITIVE_INFINITY, b, x = 0, T = 0; T < 4; ++x, ++T) {
      h(x % 2 ? g : m, x % 4 >= 2), v = o.buildLayerMatrix(d);
      var E = r(d, v);
      E < y && (T = 0, b = t.cloneDeep(v), y = E);
    }
    f(d, b);
  }
  function u(d, p, g) {
    return t.map(p, function(m) {
      return i(d, m, g);
    });
  }
  function h(d, p) {
    var g = new s();
    t.forEach(d, function(m) {
      var v = m.graph().root, y = n(m, v, g, p);
      t.forEach(y.vs, function(b, x) {
        m.node(b).order = x;
      }), a(m, g, y.vs);
    });
  }
  function f(d, p) {
    t.forEach(p, function(g) {
      t.forEach(g, function(m, v) {
        d.node(m).order = v;
      });
    });
  }
  return ek;
}
var tk, BF;
function RSe() {
  if (BF) return tk;
  BF = 1;
  var t = en(), e = Ms().Graph, r = ua();
  tk = {
    positionX: g,
    findType1Conflicts: n,
    findType2Conflicts: i,
    addConflict: s,
    hasConflict: o,
    verticalAlignment: l,
    horizontalCompaction: u,
    alignCoordinates: d,
    findSmallestWidthAlignment: f,
    balance: p
  };
  function n(y, b) {
    var x = {};
    function T(E, A) {
      var S = 0, k = 0, _ = E.length, R = t.last(A);
      return t.forEach(A, function(L, M) {
        var P = a(y, L), C = P ? y.node(P).order : _;
        (P || L === R) && (t.forEach(A.slice(k, M + 1), function(I) {
          t.forEach(y.predecessors(I), function(N) {
            var O = y.node(N), D = O.order;
            (D < S || C < D) && !(O.dummy && y.node(I).dummy) && s(x, N, I);
          });
        }), k = M + 1, S = C);
      }), A;
    }
    return t.reduce(b, T), x;
  }
  function i(y, b) {
    var x = {};
    function T(A, S, k, _, R) {
      var L;
      t.forEach(t.range(S, k), function(M) {
        L = A[M], y.node(L).dummy && t.forEach(y.predecessors(L), function(P) {
          var C = y.node(P);
          C.dummy && (C.order < _ || C.order > R) && s(x, P, L);
        });
      });
    }
    function E(A, S) {
      var k = -1, _, R = 0;
      return t.forEach(S, function(L, M) {
        if (y.node(L).dummy === "border") {
          var P = y.predecessors(L);
          P.length && (_ = y.node(P[0]).order, T(S, R, M, k, _), R = M, k = _);
        }
        T(S, R, S.length, _, A.length);
      }), S;
    }
    return t.reduce(b, E), x;
  }
  function a(y, b) {
    if (y.node(b).dummy)
      return t.find(y.predecessors(b), function(x) {
        return y.node(x).dummy;
      });
  }
  function s(y, b, x) {
    if (b > x) {
      var T = b;
      b = x, x = T;
    }
    var E = y[b];
    E || (y[b] = E = {}), E[x] = !0;
  }
  function o(y, b, x) {
    if (b > x) {
      var T = b;
      b = x, x = T;
    }
    return t.has(y[b], x);
  }
  function l(y, b, x, T) {
    var E = {}, A = {}, S = {};
    return t.forEach(b, function(k) {
      t.forEach(k, function(_, R) {
        E[_] = _, A[_] = _, S[_] = R;
      });
    }), t.forEach(b, function(k) {
      var _ = -1;
      t.forEach(k, function(R) {
        var L = T(R);
        if (L.length) {
          L = t.sortBy(L, function(N) {
            return S[N];
          });
          for (var M = (L.length - 1) / 2, P = Math.floor(M), C = Math.ceil(M); P <= C; ++P) {
            var I = L[P];
            A[R] === R && _ < S[I] && !o(x, R, I) && (A[I] = R, A[R] = E[R] = E[I], _ = S[I]);
          }
        }
      });
    }), { root: E, align: A };
  }
  function u(y, b, x, T, E) {
    var A = {}, S = h(y, b, x, E), k = E ? "borderLeft" : "borderRight";
    function _(M, P) {
      for (var C = S.nodes(), I = C.pop(), N = {}; I; )
        N[I] ? M(I) : (N[I] = !0, C.push(I), C = C.concat(P(I))), I = C.pop();
    }
    function R(M) {
      A[M] = S.inEdges(M).reduce(function(P, C) {
        return Math.max(P, A[C.v] + S.edge(C));
      }, 0);
    }
    function L(M) {
      var P = S.outEdges(M).reduce(function(I, N) {
        return Math.min(I, A[N.w] - S.edge(N));
      }, Number.POSITIVE_INFINITY), C = y.node(M);
      P !== Number.POSITIVE_INFINITY && C.borderType !== k && (A[M] = Math.max(A[M], P));
    }
    return _(R, S.predecessors.bind(S)), _(L, S.successors.bind(S)), t.forEach(T, function(M) {
      A[M] = A[x[M]];
    }), A;
  }
  function h(y, b, x, T) {
    var E = new e(), A = y.graph(), S = m(A.nodesep, A.edgesep, T);
    return t.forEach(b, function(k) {
      var _;
      t.forEach(k, function(R) {
        var L = x[R];
        if (E.setNode(L), _) {
          var M = x[_], P = E.edge(M, L);
          E.setEdge(M, L, Math.max(S(y, R, _), P || 0));
        }
        _ = R;
      });
    }), E;
  }
  function f(y, b) {
    return t.minBy(t.values(b), function(x) {
      var T = Number.NEGATIVE_INFINITY, E = Number.POSITIVE_INFINITY;
      return t.forIn(x, function(A, S) {
        var k = v(y, S) / 2;
        T = Math.max(A + k, T), E = Math.min(A - k, E);
      }), T - E;
    });
  }
  function d(y, b) {
    var x = t.values(b), T = t.min(x), E = t.max(x);
    t.forEach(["u", "d"], function(A) {
      t.forEach(["l", "r"], function(S) {
        var k = A + S, _ = y[k], R;
        if (_ !== b) {
          var L = t.values(_);
          R = S === "l" ? T - t.min(L) : E - t.max(L), R && (y[k] = t.mapValues(_, function(M) {
            return M + R;
          }));
        }
      });
    });
  }
  function p(y, b) {
    return t.mapValues(y.ul, function(x, T) {
      if (b)
        return y[b.toLowerCase()][T];
      var E = t.sortBy(t.map(y, T));
      return (E[1] + E[2]) / 2;
    });
  }
  function g(y) {
    var b = r.buildLayerMatrix(y), x = t.merge(
      n(y, b),
      i(y, b)
    ), T = {}, E;
    t.forEach(["u", "d"], function(S) {
      E = S === "u" ? b : t.values(b).reverse(), t.forEach(["l", "r"], function(k) {
        k === "r" && (E = t.map(E, function(M) {
          return t.values(M).reverse();
        }));
        var _ = (S === "u" ? y.predecessors : y.successors).bind(y), R = l(y, E, x, _), L = u(
          y,
          E,
          R.root,
          R.align,
          k === "r"
        );
        k === "r" && (L = t.mapValues(L, function(M) {
          return -M;
        })), T[S + k] = L;
      });
    });
    var A = f(y, T);
    return d(T, A), p(T, y.graph().align);
  }
  function m(y, b, x) {
    return function(T, E, A) {
      var S = T.node(E), k = T.node(A), _ = 0, R;
      if (_ += S.width / 2, t.has(S, "labelpos"))
        switch (S.labelpos.toLowerCase()) {
          case "l":
            R = -S.width / 2;
            break;
          case "r":
            R = S.width / 2;
            break;
        }
      if (R && (_ += x ? R : -R), R = 0, _ += (S.dummy ? b : y) / 2, _ += (k.dummy ? b : y) / 2, _ += k.width / 2, t.has(k, "labelpos"))
        switch (k.labelpos.toLowerCase()) {
          case "l":
            R = k.width / 2;
            break;
          case "r":
            R = -k.width / 2;
            break;
        }
      return R && (_ += x ? R : -R), R = 0, _;
    };
  }
  function v(y, b) {
    return y.node(b).width;
  }
  return tk;
}
var rk, FF;
function ISe() {
  if (FF) return rk;
  FF = 1;
  var t = en(), e = ua(), r = RSe().positionX;
  rk = n;
  function n(a) {
    a = e.asNonCompoundGraph(a), i(a), t.forEach(r(a), function(s, o) {
      a.node(o).x = s;
    });
  }
  function i(a) {
    var s = e.buildLayerMatrix(a), o = a.graph().ranksep, l = 0;
    t.forEach(s, function(u) {
      var h = t.max(t.map(u, function(f) {
        return a.node(f).height;
      }));
      t.forEach(u, function(f) {
        a.node(f).y = l + h / 2;
      }), l += h + o;
    });
  }
  return rk;
}
var nk, zF;
function MSe() {
  if (zF) return nk;
  zF = 1;
  var t = en(), e = dSe(), r = pSe(), n = mSe(), i = ua().normalizeRanks, a = vSe(), s = ua().removeEmptyRanks, o = ySe(), l = bSe(), u = xSe(), h = LSe(), f = ISe(), d = ua(), p = Ms().Graph;
  nk = g;
  function g(V, U) {
    var Z = U && U.debugTiming ? d.time : d.notime;
    Z("layout", function() {
      var K = Z("  buildLayoutGraph", function() {
        return _(V);
      });
      Z("  runLayout", function() {
        m(K, Z);
      }), Z("  updateInputGraph", function() {
        v(V, K);
      });
    });
  }
  function m(V, U) {
    U("    makeSpaceForEdgeLabels", function() {
      R(V);
    }), U("    removeSelfEdges", function() {
      $(V);
    }), U("    acyclic", function() {
      e.run(V);
    }), U("    nestingGraph.run", function() {
      o.run(V);
    }), U("    rank", function() {
      n(d.asNonCompoundGraph(V));
    }), U("    injectEdgeLabelProxies", function() {
      L(V);
    }), U("    removeEmptyRanks", function() {
      s(V);
    }), U("    nestingGraph.cleanup", function() {
      o.cleanup(V);
    }), U("    normalizeRanks", function() {
      i(V);
    }), U("    assignRankMinMax", function() {
      M(V);
    }), U("    removeEdgeLabelProxies", function() {
      P(V);
    }), U("    normalize.run", function() {
      r.run(V);
    }), U("    parentDummyChains", function() {
      a(V);
    }), U("    addBorderSegments", function() {
      l(V);
    }), U("    order", function() {
      h(V);
    }), U("    insertSelfEdges", function() {
      z(V);
    }), U("    adjustCoordinateSystem", function() {
      u.adjust(V);
    }), U("    position", function() {
      f(V);
    }), U("    positionSelfEdges", function() {
      B(V);
    }), U("    removeBorderNodes", function() {
      D(V);
    }), U("    normalize.undo", function() {
      r.undo(V);
    }), U("    fixupEdgeLabelCoords", function() {
      N(V);
    }), U("    undoCoordinateSystem", function() {
      u.undo(V);
    }), U("    translateGraph", function() {
      C(V);
    }), U("    assignNodeIntersects", function() {
      I(V);
    }), U("    reversePoints", function() {
      O(V);
    }), U("    acyclic.undo", function() {
      e.undo(V);
    });
  }
  function v(V, U) {
    t.forEach(V.nodes(), function(Z) {
      var K = V.node(Z), ce = U.node(Z);
      K && (K.x = ce.x, K.y = ce.y, U.children(Z).length && (K.width = ce.width, K.height = ce.height));
    }), t.forEach(V.edges(), function(Z) {
      var K = V.edge(Z), ce = U.edge(Z);
      K.points = ce.points, t.has(ce, "x") && (K.x = ce.x, K.y = ce.y);
    }), V.graph().width = U.graph().width, V.graph().height = U.graph().height;
  }
  var y = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], b = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, x = ["acyclicer", "ranker", "rankdir", "align"], T = ["width", "height"], E = { width: 0, height: 0 }, A = ["minlen", "weight", "width", "height", "labeloffset"], S = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: "r"
  }, k = ["labelpos"];
  function _(V) {
    var U = new p({ multigraph: !0, compound: !0 }), Z = W(V.graph());
    return U.setGraph(t.merge(
      {},
      b,
      G(Z, y),
      t.pick(Z, x)
    )), t.forEach(V.nodes(), function(K) {
      var ce = W(V.node(K));
      U.setNode(K, t.defaults(G(ce, T), E)), U.setParent(K, V.parent(K));
    }), t.forEach(V.edges(), function(K) {
      var ce = W(V.edge(K));
      U.setEdge(K, t.merge(
        {},
        S,
        G(ce, A),
        t.pick(ce, k)
      ));
    }), U;
  }
  function R(V) {
    var U = V.graph();
    U.ranksep /= 2, t.forEach(V.edges(), function(Z) {
      var K = V.edge(Z);
      K.minlen *= 2, K.labelpos.toLowerCase() !== "c" && (U.rankdir === "TB" || U.rankdir === "BT" ? K.width += K.labeloffset : K.height += K.labeloffset);
    });
  }
  function L(V) {
    t.forEach(V.edges(), function(U) {
      var Z = V.edge(U);
      if (Z.width && Z.height) {
        var K = V.node(U.v), ce = V.node(U.w), J = { rank: (ce.rank - K.rank) / 2 + K.rank, e: U };
        d.addDummyNode(V, "edge-proxy", J, "_ep");
      }
    });
  }
  function M(V) {
    var U = 0;
    t.forEach(V.nodes(), function(Z) {
      var K = V.node(Z);
      K.borderTop && (K.minRank = V.node(K.borderTop).rank, K.maxRank = V.node(K.borderBottom).rank, U = t.max(U, K.maxRank));
    }), V.graph().maxRank = U;
  }
  function P(V) {
    t.forEach(V.nodes(), function(U) {
      var Z = V.node(U);
      Z.dummy === "edge-proxy" && (V.edge(Z.e).labelRank = Z.rank, V.removeNode(U));
    });
  }
  function C(V) {
    var U = Number.POSITIVE_INFINITY, Z = 0, K = Number.POSITIVE_INFINITY, ce = 0, J = V.graph(), ee = J.marginx || 0, j = J.marginy || 0;
    function X(re) {
      var Q = re.x, ue = re.y, ne = re.width, xe = re.height;
      U = Math.min(U, Q - ne / 2), Z = Math.max(Z, Q + ne / 2), K = Math.min(K, ue - xe / 2), ce = Math.max(ce, ue + xe / 2);
    }
    t.forEach(V.nodes(), function(re) {
      X(V.node(re));
    }), t.forEach(V.edges(), function(re) {
      var Q = V.edge(re);
      t.has(Q, "x") && X(Q);
    }), U -= ee, K -= j, t.forEach(V.nodes(), function(re) {
      var Q = V.node(re);
      Q.x -= U, Q.y -= K;
    }), t.forEach(V.edges(), function(re) {
      var Q = V.edge(re);
      t.forEach(Q.points, function(ue) {
        ue.x -= U, ue.y -= K;
      }), t.has(Q, "x") && (Q.x -= U), t.has(Q, "y") && (Q.y -= K);
    }), J.width = Z - U + ee, J.height = ce - K + j;
  }
  function I(V) {
    t.forEach(V.edges(), function(U) {
      var Z = V.edge(U), K = V.node(U.v), ce = V.node(U.w), J, ee;
      Z.points ? (J = Z.points[0], ee = Z.points[Z.points.length - 1]) : (Z.points = [], J = ce, ee = K), Z.points.unshift(d.intersectRect(K, J)), Z.points.push(d.intersectRect(ce, ee));
    });
  }
  function N(V) {
    t.forEach(V.edges(), function(U) {
      var Z = V.edge(U);
      if (t.has(Z, "x"))
        switch ((Z.labelpos === "l" || Z.labelpos === "r") && (Z.width -= Z.labeloffset), Z.labelpos) {
          case "l":
            Z.x -= Z.width / 2 + Z.labeloffset;
            break;
          case "r":
            Z.x += Z.width / 2 + Z.labeloffset;
            break;
        }
    });
  }
  function O(V) {
    t.forEach(V.edges(), function(U) {
      var Z = V.edge(U);
      Z.reversed && Z.points.reverse();
    });
  }
  function D(V) {
    t.forEach(V.nodes(), function(U) {
      if (V.children(U).length) {
        var Z = V.node(U), K = V.node(Z.borderTop), ce = V.node(Z.borderBottom), J = V.node(t.last(Z.borderLeft)), ee = V.node(t.last(Z.borderRight));
        Z.width = Math.abs(ee.x - J.x), Z.height = Math.abs(ce.y - K.y), Z.x = J.x + Z.width / 2, Z.y = K.y + Z.height / 2;
      }
    }), t.forEach(V.nodes(), function(U) {
      V.node(U).dummy === "border" && V.removeNode(U);
    });
  }
  function $(V) {
    t.forEach(V.edges(), function(U) {
      if (U.v === U.w) {
        var Z = V.node(U.v);
        Z.selfEdges || (Z.selfEdges = []), Z.selfEdges.push({ e: U, label: V.edge(U) }), V.removeEdge(U);
      }
    });
  }
  function z(V) {
    var U = d.buildLayerMatrix(V);
    t.forEach(U, function(Z) {
      var K = 0;
      t.forEach(Z, function(ce, J) {
        var ee = V.node(ce);
        ee.order = J + K, t.forEach(ee.selfEdges, function(j) {
          d.addDummyNode(V, "selfedge", {
            width: j.label.width,
            height: j.label.height,
            rank: ee.rank,
            order: J + ++K,
            e: j.e,
            label: j.label
          }, "_se");
        }), delete ee.selfEdges;
      });
    });
  }
  function B(V) {
    t.forEach(V.nodes(), function(U) {
      var Z = V.node(U);
      if (Z.dummy === "selfedge") {
        var K = V.node(Z.e.v), ce = K.x + K.width / 2, J = K.y, ee = Z.x - ce, j = K.height / 2;
        V.setEdge(Z.e, Z.label), V.removeNode(U), Z.label.points = [
          { x: ce + 2 * ee / 3, y: J - j },
          { x: ce + 5 * ee / 6, y: J - j },
          { x: ce + ee, y: J },
          { x: ce + 5 * ee / 6, y: J + j },
          { x: ce + 2 * ee / 3, y: J + j }
        ], Z.label.x = Z.x, Z.label.y = Z.y;
      }
    });
  }
  function G(V, U) {
    return t.mapValues(t.pick(V, U), Number);
  }
  function W(V) {
    var U = {};
    return t.forEach(V, function(Z, K) {
      U[K.toLowerCase()] = Z;
    }), U;
  }
  return nk;
}
var ik, qF;
function NSe() {
  if (qF) return ik;
  qF = 1;
  var t = en(), e = ua(), r = Ms().Graph;
  ik = {
    debugOrdering: n
  };
  function n(i) {
    var a = e.buildLayerMatrix(i), s = new r({ compound: !0, multigraph: !0 }).setGraph({});
    return t.forEach(i.nodes(), function(o) {
      s.setNode(o, { label: o }), s.setParent(o, "layer" + i.node(o).rank);
    }), t.forEach(i.edges(), function(o) {
      s.setEdge(o.v, o.w, {}, o.name);
    }), t.forEach(a, function(o, l) {
      var u = "layer" + l;
      s.setNode(u, { rank: "same" }), t.reduce(o, function(h, f) {
        return s.setEdge(h, f, { style: "invis" }), f;
      });
    }), s;
  }
  return ik;
}
var ak, GF;
function DSe() {
  return GF || (GF = 1, ak = "0.8.5"), ak;
}
var sk, UF;
function OSe() {
  return UF || (UF = 1, sk = {
    graphlib: Ms(),
    layout: MSe(),
    debug: NSe(),
    util: {
      time: ua().time,
      notime: ua().notime
    },
    version: DSe()
  }), sk;
}
var PSe = OSe();
const VF = /* @__PURE__ */ Oc(PSe);
class $Se {
  constructor(e, r) {
    this.container = e, this.diagram = r, this.entityMap = /* @__PURE__ */ new Map(), joint.anchors.columnAnchor = function(a, s, o) {
      let l;
      const { model: u } = a, h = a.getNodeUnrotatedBBox(s), f = u.getBBox().center(), d = u.angle();
      let p = o;
      if (o instanceof Element) {
        const g = this.paper.findView(o);
        p = g ? g.getNodeBBox(o).center() : new joint.g.Point();
      }
      return p.rotate(f, d), l = p.x <= h.x + h.width ? h.leftMiddle() : h.rightMiddle(), l.rotate(f, -d);
    }, this.graph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }), this.paper = new joint.dia.Paper({
      width: 100,
      height: 100,
      gridSize: 1,
      model: this.graph,
      highlighting: !1,
      sorting: joint.dia.Paper.sorting.APPROX,
      cellViewNamespace: joint.shapes,
      defaultRouter: { name: "metro" },
      defaultAnchor: { name: "columnAnchor" },
      defaultConnector: { name: "rounded" },
      linkPinning: !1,
      interactive: {
        vertexAdd: !1,
        linkMove: !1,
        elementMove: !0
      }
    }), this.paperScroller = new joint.ui.PaperScroller({
      autoResizePaper: !0,
      padding: 50,
      paper: this.paper
    }), this.paper.on("blank:pointerdown", (a, s, o) => {
      this.paperScroller.setCursor("grabbing"), this.paperScroller.startPanning(a, s, o);
    }), this.paper.on("blank:pointerup", () => {
      this.paperScroller.setCursor("default");
    });
    const n = (a, s, o, l, u) => {
      s.preventDefault(), this.paperScroller.zoom(u === -1 ? -0.2 : 0.2, {
        min: 0.1,
        max: 3
      });
    };
    this.paper.on("cell:mousewheel", n), this.paper.on("blank:mousewheel", (a, s, o, l) => {
      n(null, a, s, o, l);
    }), this.paper.on("element:pointerclick", (a) => {
      const s = a.model.attr("headerLabel/text");
      s && this.diagram.onTableClick(to(s));
    }), this.paper.on("blank:pointerclick", () => {
      this.diagram.highlightedTable && this.diagram.onTableClick(this.diagram.highlightedTable);
    }), this.keyboard && this.keyboard.disable(), this.keyboard = new joint.ui.Keyboard(), this.wrapper = document.createElement("div"), this.wrapper.className = "qs-erd-rappid-wrapper";
    const i = this.paperScroller.render().el;
    i.style.width = "100%", i.style.height = "100%", this.wrapper.appendChild(i), this.container.appendChild(this.wrapper);
  }
  async render(e) {
    if (e.items?.length) {
      this.graph.clear(), this.entityMap.clear();
      try {
        const r = [], n = /* @__PURE__ */ new Map();
        for (const i of e.items) {
          const a = i.name.toUpperCase();
          let s = i.schema;
          s && (s = s.toUpperCase());
          const o = (i.columns || []).map((d) => ({
            name: d.name.toUpperCase(),
            datatype: d.datatype.replace("(", " (").toUpperCase()
          })), l = Aa.calcWidth(s, a, o), u = s ? `${s}.${a}` : a, h = i.type === "view" ? joint.shapes.quicksql.View : joint.shapes.quicksql.Table, f = new h({
            id: Aa.newGuid(),
            size: { width: l }
          });
          f.setName(u), f.setColumns(o), n.set(u, f.id), this.entityMap.set(to(i.name), f), r.push(f);
        }
        for (const i of e.links) {
          const a = n.get(i.source.toUpperCase()), s = n.get(i.target.toUpperCase());
          if (a && s) {
            const o = new joint.shapes.quicksql.Relation({
              source: { id: a, port: i.source_id.toUpperCase() },
              target: { id: s, port: i.target_id.toUpperCase() },
              style: "solid"
            });
            r.push(o);
          }
        }
        this.graph.resetCells(r), this._dagreLayout(), this.graph.getLinks().forEach((i) => i.toBack()), setTimeout(() => {
          this.paperScroller.adjustPaper(), this.paperScroller.zoom(1, { absolute: !0 }), this.paperScroller.centerContent();
        }, 100);
      } catch (r) {
        console.error("RappidRenderer render error:", r), this.container.innerHTML = `<pre class="qs-erd-error">Diagram render error: ${r.message}</pre>`;
      }
    }
  }
  _dagreLayout() {
    const e = new VF.graphlib.Graph();
    e.setGraph({ rankdir: "TB", nodesep: 120, edgesep: 100, ranksep: 100 }), e.setDefaultEdgeLabel(() => ({}));
    for (const r of this.graph.getElements()) {
      const n = r.size();
      e.setNode(r.id, { width: n.width, height: n.height });
    }
    for (const r of this.graph.getLinks())
      e.setEdge(r.source().id, r.target().id);
    VF.layout(e);
    for (const r of this.graph.getElements()) {
      const n = e.node(r.id);
      r.position(n.x - n.width / 2, n.y - n.height / 2);
    }
  }
  applyHighlight(e) {
    const { depths: r, maxDepth: n } = e;
    for (const i of this.graph.getElements()) {
      const a = to(i.attr("headerLabel/text") || "");
      if (r.has(a)) {
        const { bg: s, text: o } = Bee(r.get(a), n);
        i.attr("body/fill", s), i.attr("body/stroke", s), i.attr("headerLabel/fill", o), i.attr("itemLabels/fill", o), i.attr("itemLabels_1/fill", o), i.attr("root/opacity", 1);
      } else
        i.attr("root/opacity", 0.15);
    }
    for (const i of this.graph.getLinks())
      i.attr("./opacity", 0.1);
  }
  focusEntity(e) {
    if (!e) {
      this.clearHighlight();
      return;
    }
    const r = e.toUpperCase();
    let n = null;
    for (const i of this.graph.getElements())
      to(i.attr("headerLabel/text") || "") === r ? (i.attr("body/fill", "hsl(210, 75%, 48%)"), i.attr("body/stroke", "hsl(210, 75%, 48%)"), i.attr("headerLabel/fill", "#fff"), i.attr("itemLabels/fill", "#fff"), i.attr("itemLabels_1/fill", "#fff"), i.attr("root/opacity", 1), n = i) : i.attr("root/opacity", 0.15);
    for (const i of this.graph.getLinks())
      i.attr("./opacity", 0.1);
    n && this.paperScroller && this.paperScroller.scrollToElement(n, { animation: !0 });
  }
  clearHighlight() {
    for (const e of this.graph.getElements()) {
      const r = e.get("type") === "quicksql.View";
      e.attr("body/fill", r ? Ft.colors.VIEW_BACKGROUND : Ft.colors.TABLE_BACKGROUND), e.attr("body/stroke", r ? Ft.colors.VIEW_BORDER : Ft.colors.TABLE_BORDER), e.attr("headerLabel/fill", r ? Ft.colors.VIEW_NAME_TEXT : Ft.colors.TABLE_NAME_TEXT), e.attr("itemLabels/fill", r ? Ft.colors.VIEW_COLUMN_TEXT : Ft.colors.TABLE_COLUMN_TEXT), e.attr("itemLabels_1/fill", r ? Ft.colors.VIEW_DATA_TYPE_TEXT : Ft.colors.TABLE_DATA_TYPE_TEXT), e.attr("root/opacity", 1);
    }
    for (const e of this.graph.getLinks())
      e.attr("./opacity", 1);
  }
  destroy() {
    this.keyboard && (this.keyboard.disable(), this.keyboard = null), this.wrapper && this.wrapper.parentNode && this.wrapper.parentNode.removeChild(this.wrapper), this.graph.clear(), this.entityMap.clear(), this.paper = null, this.paperScroller = null, this.graph = null;
  }
}
function HF(t) {
  const e = document.createElement("div");
  e.className = "qs-erd-toolbar";
  const r = typeof joint < "u", n = document.createElement("select");
  n.className = "qs-erd-renderer-select";
  const i = document.createElement("option");
  i.value = "rappid", i.textContent = "Rappid", r ? i.selected = !0 : (i.disabled = !0, i.title = "Requires Rappid library"), n.appendChild(i);
  const a = document.createElement("option");
  a.value = "mermaid", a.textContent = "Mermaid", r || (a.selected = !0), n.appendChild(a), n.addEventListener("change", () => {
    t.switchRenderer(n.value);
  }), e.appendChild(n);
  const s = document.createElement("input");
  s.type = "text", s.className = "qs-erd-search", s.placeholder = "Search tables...";
  let o = [], l = -1;
  s.addEventListener("input", () => {
    const f = s.value.trim().toUpperCase();
    if (!f) {
      o = [], l = -1, t.searchTable(null);
      return;
    }
    o = t.getFilteredData().items.filter((p) => p.name.toUpperCase().includes(f) || p.columns && p.columns.some((g) => g.name.toUpperCase().includes(f))).map((p) => p.name.toUpperCase()), o.length > 0 ? (l = 0, t.searchTable(o[0])) : (l = -1, t.searchTable(null));
  }), s.addEventListener("keydown", (f) => {
    f.key === "Enter" && o.length > 0 && (f.preventDefault(), l = (l + 1) % o.length, t.searchTable(o[l])), f.key === "Escape" && (s.value = "", s.dispatchEvent(new Event("input")), s.blur());
  }), e.appendChild(s), document.addEventListener("keydown", (f) => {
    (f.metaKey || f.ctrlKey) && f.key === "f" && (f.preventDefault(), s.focus(), s.select());
  });
  const u = Object.keys(t.groups || {});
  let h = null;
  if (u.length > 0) {
    h = document.createElement("div"), h.className = "qs-erd-chip-container";
    const f = WF("All", !0);
    f.addEventListener("click", () => {
      FSe(h), t.setActiveGroups(null);
    }), h.appendChild(f);
    for (const d of u) {
      const p = WF(d, !1);
      p.addEventListener("click", () => {
        BSe(p, h, t);
      }), h.appendChild(p);
    }
    e.appendChild(h);
  }
  return { el: e };
}
function WF(t, e) {
  const r = document.createElement("button");
  return r.className = "qs-erd-chip" + (e ? " active" : ""), r.textContent = t, r.dataset.group = t, r;
}
function BSe(t, e, r) {
  const n = e.querySelector('[data-group="All"]');
  t.classList.toggle("active"), n.classList.remove("active");
  const i = [];
  e.querySelectorAll(".qs-erd-chip.active").forEach((a) => {
    a.dataset.group !== "All" && i.push(a.dataset.group);
  }), i.length === 0 ? (n.classList.add("active"), r.setActiveGroups(null)) : r.setActiveGroups(i);
}
function FSe(t) {
  t.querySelectorAll(".qs-erd-chip").forEach((e) => {
    e.classList.remove("active");
  }), t.querySelector('[data-group="All"]').classList.add("active");
}
class zSe {
  constructor(e, r = "#quickERD") {
    if (!r || !(typeof r == "string" && (this.element = document.querySelector(r))) && !(typeof r == "object" && (this.element = r) && typeof this.element.append == "function"))
      throw new Error("Invalid element or selector provided");
    this.data = e, this.groups = e.groups || {}, this.activeGroups = null, this.highlightedTable = null, this._setupContainer(), this.toolbar = HF(this), this.toolbarEl.appendChild(this.toolbar.el), this.rendererType = typeof joint < "u" ? "rappid" : "mermaid", this.renderer = this._createRenderer(this.rendererType), this.refresh();
  }
  _setupContainer() {
    this.element.innerHTML = "", this.toolbarEl = document.createElement("div"), this.toolbarEl.className = "qs-erd-toolbar-container", this.element.appendChild(this.toolbarEl), this.canvasEl = document.createElement("div"), this.canvasEl.className = "qs-erd-canvas", this.element.appendChild(this.canvasEl);
  }
  getFilteredData() {
    if (!this.activeGroups?.length) return this.data;
    const e = /* @__PURE__ */ new Set();
    for (const a of this.activeGroups)
      (this.groups[a] || []).forEach((s) => e.add(s.toUpperCase()));
    const r = this.data.items.filter((a) => e.has(a.name.toUpperCase())), n = new Set(r.map((a) => to(a.name))), i = this.data.links.filter((a) => {
      const s = to(a.source), o = to(a.target);
      return n.has(s) && n.has(o);
    });
    return { items: r, links: i, groups: this.groups };
  }
  setActiveGroups(e) {
    this.activeGroups = e, this.highlightedTable = null, this.refresh();
  }
  async refresh() {
    await this.renderer.render(this.getFilteredData()), this.highlightedTable && this._applyHighlight(this.highlightedTable);
  }
  onTableClick(e) {
    this.highlightedTable === e ? (this.highlightedTable = null, this.renderer.clearHighlight()) : (this.highlightedTable = e, this._applyHighlight(e));
  }
  highlightTable(e) {
    e ? (this.highlightedTable = e, this._applyHighlight(e)) : (this.highlightedTable = null, this.renderer.clearHighlight());
  }
  searchTable(e) {
    e ? (this.highlightedTable = e, this.renderer.focusEntity(e)) : (this.highlightedTable = null, this.renderer.clearHighlight());
  }
  _applyHighlight(e) {
    const r = yTe(e, this.getFilteredData(), 1);
    this.renderer.applyHighlight(r);
  }
  updateData(e) {
    const r = e.groups || {}, n = JSON.stringify(r) !== JSON.stringify(this.groups);
    this.data = e, this.groups = r, this.highlightedTable = null, n && (this.activeGroups = null, this.toolbarEl.innerHTML = "", this.toolbar = HF(this), this.toolbarEl.appendChild(this.toolbar.el)), this.refresh();
  }
  switchRenderer(e) {
    e !== this.rendererType && (this.highlightedTable = null, this.renderer.destroy(), this.rendererType = e, this.renderer = this._createRenderer(e), this.refresh());
  }
  _createRenderer(e) {
    return e === "rappid" && typeof joint < "u" ? new $Se(this.canvasEl, this) : new xTe(this.canvasEl, this);
  }
}
class qSe {
  constructor(e, r = "#quickERD") {
    if (!r || !(typeof r == "string" && (this.element = document.querySelector(r))) && !(typeof r == "object" && (this.element = r) && typeof this.element.append == "function"))
      throw new Error("Invalid element or selector provided");
    joint.anchors.columnAnchor = function(n, i, a) {
      let s;
      const { model: o } = n, l = n.getNodeUnrotatedBBox(i), u = o.getBBox().center(), h = o.angle();
      let f = a;
      if (a instanceof Element) {
        const d = this.paper.findView(a);
        f = d ? d.getNodeBBox(a).center() : new joint.g.Point();
      }
      return f.rotate(u, h), s = f.x <= l.x + l.width ? l.leftMiddle() : l.rightMiddle(), s.rotate(u, -h);
    }, this.data = e, this.graph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }), this.paper = new joint.dia.Paper({
      width: 100,
      height: 100,
      gridSize: 1,
      model: this.graph,
      highlighting: !1,
      sorting: joint.dia.Paper.sorting.APPROX,
      cellViewNamespace: joint.shapes,
      defaultRouter: { name: "metro" },
      defaultAnchor: { name: "columnAnchor" },
      defaultConnector: { name: "rounded" },
      linkPinning: !1,
      interactive: {
        vertexAdd: !1,
        linkMove: !1,
        elementMove: !0
      }
    }), this.paperScroller = new joint.ui.PaperScroller({
      autoResizePaper: !0,
      padding: 50,
      paper: this.paper
    }), this.paper.on("blank:pointerdown", (n, i, a) => {
      this.paperScroller.setCursor("grabbing"), this.paperScroller.startPanning(n, i, a);
    }), this.paper.on("blank:pointerup", () => {
      this.paperScroller.setCursor("default");
    }), this.paper.on("cell:mousewheel", (n, i, a, s, o) => {
      this.onMouseWheel(i, a, s, o);
    }), this.paper.on("blank:mousewheel", (n, i, a, s) => {
      this.onMouseWheel(n, i, a, s);
    }), new joint.ui.Snaplines({ paper: this.paper }), this.keyboard && this.keyboard.disable(), this.keyboard = new joint.ui.Keyboard(), this.keyboard.on({
      "shift+alt+a": function(n) {
        this.actualSize(), n.preventDefault(), n.stopPropagation();
      },
      "shift+alt+c": function(n) {
        this.paperScroller.centerContent(), n.preventDefault(), n.stopPropagation();
      },
      "shift+alt+f": function(n) {
        this.fitScreen(), n.preventDefault(), n.stopPropagation();
      },
      "shift+alt+p": function(n) {
        this.printDiagram(), n.preventDefault(), n.stopPropagation();
      },
      "shift+alt+s": function(n) {
        this.exportAsSVG(), n.preventDefault(), n.stopPropagation();
      }
    }, this), this.element.append(this.paperScroller.render().el), this.updateDiagram();
  }
  async updateDiagram() {
    if (this.data.items?.length) {
      let e = [];
      this.buildDiagram(e, this.data), this.graph.resetCells(e), this.autoLayout(), setTimeout(() => {
        this.paperScroller.adjustPaper(), this.actualSize();
      }, 100);
    }
  }
  buildDiagram = (e, r) => {
    let n = /* @__PURE__ */ new Map();
    r.items.forEach((i) => {
      const a = i.name.toUpperCase();
      let s = i.schema;
      s && (s = s.toUpperCase());
      const l = (i.columns || []).map((d) => ({ name: d.name.toUpperCase(), datatype: d.datatype.replace("(", " (").toUpperCase() }));
      let u = Aa.calcWidth(s, a, l, []), h;
      i.type && i.type === "view" ? h = this.addView(a, s, l, u) : h = this.addTable(a, s, l, u);
      const f = s ? `${s}.${a}` : a;
      n.set(f, h.id), e.push(h);
    }), r.links.forEach((i) => {
      const a = n.get(i.source.toUpperCase()), s = n.get(i.target.toUpperCase());
      a && s && e.push(this.addLink(a, s, i.source_id, i.target_id));
    });
  };
  addTable = (e, r, n, i) => {
    let a = e;
    r && (a = `${r}.${e}`);
    let s = new joint.shapes.quicksql.Table({
      id: Aa.newGuid(),
      size: { width: i }
    });
    return s.setName(a), s.setColumns(n), s;
  };
  addView = (e, r, n, i) => {
    let a = e;
    r && (a = `${r}.${e}`);
    let s = new joint.shapes.quicksql.View({
      id: Aa.newGuid(),
      size: { width: i }
    });
    return s.setName(a), s.setColumns(n), s;
  };
  addLink = (e, r, n, i) => {
    let a = "solid";
    return new joint.shapes.quicksql.Relation({
      source: { id: e, port: n.toUpperCase() },
      target: { id: r, port: i.toUpperCase() },
      style: a
    });
  };
  printDiagram = () => {
    this.paper.print();
  };
  exportAsSVG = () => {
    const e = this.graph.getBBox().inflate(50);
    this.paper.toSVG((r) => {
      var n = "QuickSqlDiagram-";
      this.saveDiagram(n, r);
    }, {
      area: e,
      convertImagesToDataUris: !0,
      preserveDimensions: this.paper.getComputedSize()
    });
  };
  saveDiagram = (e, r) => {
    function n(h) {
      return h >= 100 ? n(h % 100) : (h < 10 ? "0" : "") + h;
    }
    var i = /* @__PURE__ */ new Date(), s = {
      type: "text/plain;charset=UTF-8",
      name: e + n(i.getFullYear()) + "-" + n(i.getMonth() + 1) + "-" + n(i.getDate()) + "_" + n(i.getHours() + 1) + "-" + n(i.getMinutes()) + ".svg"
    }, o = new Blob([r], { type: s.type }), l = window.URL.createObjectURL(o), u = document.createElement("a");
    document.body.appendChild(u), u.style = "display: none", u.href = l, u.download = s.name, setTimeout(() => {
      u.click(), window.URL.revokeObjectURL(l), u.remove();
    }, 0);
  };
  zoomIn = () => {
    this.paperScroller.zoom(0.2, { max: 3 }), this.paperScroller.centerContent();
  };
  zoomOut = () => {
    this.paperScroller.zoom(-0.2, { min: 0.1 }), this.paperScroller.centerContent();
  };
  fitScreen = () => {
    this.paperScroller.zoomToFit({
      padding: 10,
      scaleGrid: 0.2,
      minScale: 0.1,
      maxScale: 3
    }), this.paperScroller.centerContent();
  };
  actualSize = () => {
    this.paperScroller.zoom(1, { absolute: !0 }), this.paperScroller.centerContent();
  };
  onMouseWheel = (e, r, n, i) => {
    e.shiftKey && (e.preventDefault(), i === -1 ? this.paperScroller.zoom(-0.2, { min: 0.1 }) : i === 1 && this.paperScroller.zoom(0.2, { max: 3 }), this.paperScroller.centerContent());
  };
  autoLayout() {
    joint.layout.DirectedGraph.layout(this.graph, {
      nodeSep: 120,
      edgeSep: 100,
      rankSep: 100
    }), this.graph.getLinks().forEach((e) => {
      e.toBack();
    });
  }
}
const GSe = "1.3.14", oct = {
  Diagram: qSe,
  DiagramPreview: zSe,
  version: GSe
};
class Ta {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, r, n) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = r, this.end = n;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, r) {
    return r ? !e || !e.loc || !r.loc || e.loc.lexer !== r.loc.lexer ? null : new Ta(e.loc.lexer, e.loc.start, r.loc.end) : e && e.loc;
  }
}
class es {
  // don't expand the token
  // used in \noexpand
  constructor(e, r) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = r;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, r) {
    return new es(r, Ta.range(this, e));
  }
}
class ot {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, r) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var n = "KaTeX parse error: " + e, i, a, s = r && r.loc;
    if (s && s.start <= s.end) {
      var o = s.lexer.input;
      i = s.start, a = s.end, i === o.length ? n += " at end of input: " : n += " at position " + (i + 1) + ": ";
      var l = o.slice(i, a).replace(/[^]/g, "$&\u0332"), u;
      i > 15 ? u = "\u2026" + o.slice(i - 15, i) : u = o.slice(0, i);
      var h;
      a + 15 < o.length ? h = o.slice(a, a + 15) + "\u2026" : h = o.slice(a), n += u + l + h;
    }
    var f = new Error(n);
    return f.name = "ParseError", f.__proto__ = ot.prototype, f.position = i, i != null && a != null && (f.length = a - i), f.rawMessage = e, f;
  }
}
ot.prototype.__proto__ = Error.prototype;
var USe = function(e, r) {
  return e.indexOf(r) !== -1;
}, VSe = function(e, r) {
  return e === void 0 ? r : e;
}, HSe = /([A-Z])/g, WSe = function(e) {
  return e.replace(HSe, "-$1").toLowerCase();
}, YSe = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, XSe = /[&><"']/g;
function jSe(t) {
  return String(t).replace(XSe, (e) => YSe[e]);
}
var Bte = function t(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? t(e.body[0]) : e : e.type === "font" ? t(e.body) : e;
}, KSe = function(e) {
  var r = Bte(e);
  return r.type === "mathord" || r.type === "textord" || r.type === "atom";
}, ZSe = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, QSe = function(e) {
  var r = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return r ? r[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(r[1]) ? null : r[1].toLowerCase() : "_relative";
}, Bt = {
  contains: USe,
  deflt: VSe,
  escape: jSe,
  hyphenate: WSe,
  getBaseElem: Bte,
  isCharacterBox: KSe,
  protocolFromUrl: QSe
}, Fg = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (t) => "#" + t
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (t, e) => (e.push(t), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t) => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (t) => Math.max(0, t),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (t) => Math.max(0, t),
    cli: "-e, --max-expand <n>",
    cliProcessor: (t) => t === "Infinity" ? 1 / 0 : parseInt(t)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function JSe(t) {
  if (t.default)
    return t.default;
  var e = t.type, r = Array.isArray(e) ? e[0] : e;
  if (typeof r != "string")
    return r.enum[0];
  switch (r) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class NL {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var r in Fg)
      if (Fg.hasOwnProperty(r)) {
        var n = Fg[r];
        this[r] = e[r] !== void 0 ? n.processor ? n.processor(e[r]) : e[r] : JSe(n);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, r, n) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, r, n)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new ot("LaTeX-incompatible input and strict mode is set to 'error': " + (r + " [" + e + "]"), n);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + r + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, r, n) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, r, n);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + r + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var r = Bt.protocolFromUrl(e.url);
      if (r == null)
        return !1;
      e.protocol = r;
    }
    var n = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!n;
  }
}
class zl {
  constructor(e, r, n) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = r, this.cramped = n;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return Js[eke[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return Js[tke[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return Js[rke[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return Js[nke[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return Js[ike[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return Js[ake[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var DL = 0, yb = 1, Pf = 2, sl = 3, v1 = 4, Za = 5, o0 = 6, Ui = 7, Js = [new zl(DL, 0, !1), new zl(yb, 0, !0), new zl(Pf, 1, !1), new zl(sl, 1, !0), new zl(v1, 2, !1), new zl(Za, 2, !0), new zl(o0, 3, !1), new zl(Ui, 3, !0)], eke = [v1, Za, v1, Za, o0, Ui, o0, Ui], tke = [Za, Za, Za, Za, Ui, Ui, Ui, Ui], rke = [Pf, sl, v1, Za, o0, Ui, o0, Ui], nke = [sl, sl, Za, Za, Ui, Ui, Ui, Ui], ike = [yb, yb, sl, sl, Za, Za, Ui, Ui], ake = [DL, yb, Pf, sl, Pf, sl, Pf, sl], Gt = {
  DISPLAY: Js[DL],
  TEXT: Js[Pf],
  SCRIPT: Js[v1],
  SCRIPTSCRIPT: Js[o0]
}, eA = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function ske(t) {
  for (var e = 0; e < eA.length; e++)
    for (var r = eA[e], n = 0; n < r.blocks.length; n++) {
      var i = r.blocks[n];
      if (t >= i[0] && t <= i[1])
        return r.name;
    }
  return null;
}
var Ny = [];
eA.forEach((t) => t.blocks.forEach((e) => Ny.push(...e)));
function Fte(t) {
  for (var e = 0; e < Ny.length; e += 2)
    if (t >= Ny[e] && t <= Ny[e + 1])
      return !0;
  return !1;
}
var Jh = 80, oke = function(e, r) {
  return "M95," + (622 + e + r) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, lke = function(e, r) {
  return "M263," + (601 + e + r) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, cke = function(e, r) {
  return "M983 " + (10 + e + r) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, uke = function(e, r) {
  return "M424," + (2398 + e + r) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + r + `
h400000v` + (40 + e) + "h-400000z";
}, hke = function(e, r) {
  return "M473," + (2713 + e + r) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "H1017.7z";
}, fke = function(e) {
  var r = e / 2;
  return "M400000 " + e + " H0 L" + r + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, dke = function(e, r, n) {
  var i = n - 54 - r - e;
  return "M702 " + (e + r) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + r + "H400000v" + (40 + e) + "H742z";
}, pke = function(e, r, n) {
  r = 1e3 * r;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = oke(r, Jh);
      break;
    case "sqrtSize1":
      i = lke(r, Jh);
      break;
    case "sqrtSize2":
      i = cke(r, Jh);
      break;
    case "sqrtSize3":
      i = uke(r, Jh);
      break;
    case "sqrtSize4":
      i = hke(r, Jh);
      break;
    case "sqrtTall":
      i = dke(r, Jh, n);
  }
  return i;
}, gke = function(e, r) {
  switch (e) {
    case "\u239C":
      return "M291 0 H417 V" + r + " H291z M291 0 H417 V" + r + " H291z";
    case "\u2223":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z";
    case "\u2225":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z" + ("M367 0 H410 V" + r + " H367z M367 0 H410 V" + r + " H367z");
    case "\u239F":
      return "M457 0 H583 V" + r + " H457z M457 0 H583 V" + r + " H457z";
    case "\u23A2":
      return "M319 0 H403 V" + r + " H319z M319 0 H403 V" + r + " H319z";
    case "\u23A5":
      return "M263 0 H347 V" + r + " H263z M263 0 H347 V" + r + " H263z";
    case "\u23AA":
      return "M384 0 H504 V" + r + " H384z M384 0 H504 V" + r + " H384z";
    case "\u23D0":
      return "M312 0 H355 V" + r + " H312z M312 0 H355 V" + r + " H312z";
    case "\u2016":
      return "M257 0 H300 V" + r + " H257z M257 0 H300 V" + r + " H257z" + ("M478 0 H521 V" + r + " H478z M478 0 H521 V" + r + " H478z");
    default:
      return "";
  }
}, YF = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, mke = function(e, r) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + r + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + r + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + ` v585 h43z
M367 15 v585 v` + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + r + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v602 h84z
M403 1759 V0 H319 V1759 v` + r + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + r + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (r + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (r + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (r + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (r + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class dm {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return Bt.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), r = 0; r < this.children.length; r++)
      e.appendChild(this.children[r].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (r) => r.toText();
    return this.children.map(e).join("");
  }
}
var ro = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, mv = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, XF = {
  // Latin-1
  \u00C5: "A",
  \u00D0: "D",
  \u00DE: "o",
  \u00E5: "a",
  \u00F0: "d",
  \u00FE: "o",
  // Cyrillic
  \u0410: "A",
  \u0411: "B",
  \u0412: "B",
  \u0413: "F",
  \u0414: "A",
  \u0415: "E",
  \u0416: "K",
  \u0417: "3",
  \u0418: "N",
  \u0419: "N",
  \u041A: "K",
  \u041B: "N",
  \u041C: "M",
  \u041D: "H",
  \u041E: "O",
  \u041F: "N",
  \u0420: "P",
  \u0421: "C",
  \u0422: "T",
  \u0423: "y",
  \u0424: "O",
  \u0425: "X",
  \u0426: "U",
  \u0427: "h",
  \u0428: "W",
  \u0429: "W",
  \u042A: "B",
  \u042B: "X",
  \u042C: "B",
  \u042D: "3",
  \u042E: "X",
  \u042F: "R",
  \u0430: "a",
  \u0431: "b",
  \u0432: "a",
  \u0433: "r",
  \u0434: "y",
  \u0435: "e",
  \u0436: "m",
  \u0437: "e",
  \u0438: "n",
  \u0439: "n",
  \u043A: "n",
  \u043B: "n",
  \u043C: "m",
  \u043D: "n",
  \u043E: "o",
  \u043F: "n",
  \u0440: "p",
  \u0441: "c",
  \u0442: "o",
  \u0443: "y",
  \u0444: "b",
  \u0445: "x",
  \u0446: "n",
  \u0447: "n",
  \u0448: "w",
  \u0449: "w",
  \u044A: "a",
  \u044B: "m",
  \u044C: "a",
  \u044D: "e",
  \u044E: "m",
  \u044F: "r"
};
function zte(t, e) {
  ro[t] = e;
}
function OL(t, e, r) {
  if (!ro[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var n = t.charCodeAt(0), i = ro[e][n];
  if (!i && t[0] in XF && (n = XF[t[0]].charCodeAt(0), i = ro[e][n]), !i && r === "text" && Fte(n) && (i = ro[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var ok = {};
function vke(t) {
  var e;
  if (t >= 5 ? e = 0 : t >= 3 ? e = 1 : e = 2, !ok[e]) {
    var r = ok[e] = {
      cssEmPerMu: mv.quad[e] / 18
    };
    for (var n in mv)
      mv.hasOwnProperty(n) && (r[n] = mv[n][e]);
  }
  return ok[e];
}
var yke = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], jF = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], KF = function(e, r) {
  return r.size < 2 ? e : yke[e - 1][r.size - 1];
};
class Wo {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Wo.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = jF[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var r = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var n in e)
      e.hasOwnProperty(n) && (r[n] = e[n]);
    return new Wo(r);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: KF(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: jF[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var r = KF(Wo.BASESIZE, e);
    return this.size === r && this.textSize === Wo.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: r
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Wo.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Wo.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = vke(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Wo.BASESIZE = 6;
var tA = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, bke = {
  ex: !0,
  em: !0,
  mu: !0
}, qte = function(e) {
  return typeof e != "string" && (e = e.unit), e in tA || e in bke || e === "ex";
}, an = function(e, r) {
  var n;
  if (e.unit in tA)
    n = tA[e.unit] / r.fontMetrics().ptPerEm / r.sizeMultiplier;
  else if (e.unit === "mu")
    n = r.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (r.style.isTight() ? i = r.havingStyle(r.style.text()) : i = r, e.unit === "ex")
      n = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      n = i.fontMetrics().quad;
    else
      throw new ot("Invalid unit: '" + e.unit + "'");
    i !== r && (n *= i.sizeMultiplier / r.sizeMultiplier);
  }
  return Math.min(e.number * n, r.maxSize);
}, pt = function(e) {
  return +e.toFixed(4) + "em";
}, gc = function(e) {
  return e.filter((r) => r).join(" ");
}, Gte = function(e, r, n) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = n || {}, r) {
    r.style.isTight() && this.classes.push("mtight");
    var i = r.getColor();
    i && (this.style.color = i);
  }
}, Ute = function(e) {
  var r = document.createElement(e);
  r.className = gc(this.classes);
  for (var n in this.style)
    this.style.hasOwnProperty(n) && (r.style[n] = this.style[n]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && r.setAttribute(i, this.attributes[i]);
  for (var a = 0; a < this.children.length; a++)
    r.appendChild(this.children[a].toNode());
  return r;
}, xke = /[\s"'>/=\x00-\x1f]/, Vte = function(e) {
  var r = "<" + e;
  this.classes.length && (r += ' class="' + Bt.escape(gc(this.classes)) + '"');
  var n = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (n += Bt.hyphenate(i) + ":" + this.style[i] + ";");
  n && (r += ' style="' + Bt.escape(n) + '"');
  for (var a in this.attributes)
    if (this.attributes.hasOwnProperty(a)) {
      if (xke.test(a))
        throw new ot("Invalid attribute name '" + a + "'");
      r += " " + a + '="' + Bt.escape(this.attributes[a]) + '"';
    }
  r += ">";
  for (var s = 0; s < this.children.length; s++)
    r += this.children[s].toMarkup();
  return r += "</" + e + ">", r;
};
class pm {
  constructor(e, r, n, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, Gte.call(this, e, n, i), this.children = r || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return Bt.contains(this.classes, e);
  }
  toNode() {
    return Ute.call(this, "span");
  }
  toMarkup() {
    return Vte.call(this, "span");
  }
}
class PL {
  constructor(e, r, n, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, Gte.call(this, r, i), this.children = n || [], this.setAttribute("href", e);
  }
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return Bt.contains(this.classes, e);
  }
  toNode() {
    return Ute.call(this, "a");
  }
  toMarkup() {
    return Vte.call(this, "a");
  }
}
class wke {
  constructor(e, r, n) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = r, this.src = e, this.classes = ["mord"], this.style = n;
  }
  hasClass(e) {
    return Bt.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (e.style[r] = this.style[r]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + Bt.escape(this.src) + '"' + (' alt="' + Bt.escape(this.alt) + '"'), r = "";
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r += Bt.hyphenate(n) + ":" + this.style[n] + ";");
    return r && (e += ' style="' + Bt.escape(r) + '"'), e += "'/>", e;
  }
}
var Tke = {
  \u00EE: "\u0131\u0302",
  \u00EF: "\u0131\u0308",
  \u00ED: "\u0131\u0301",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  \u00EC: "\u0131\u0300"
};
class as {
  constructor(e, r, n, i, a, s, o, l) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = r || 0, this.depth = n || 0, this.italic = i || 0, this.skew = a || 0, this.width = s || 0, this.classes = o || [], this.style = l || {}, this.maxFontSize = 0;
    var u = ske(this.text.charCodeAt(0));
    u && this.classes.push(u + "_fallback"), /[]/.test(this.text) && (this.text = Tke[this.text]);
  }
  hasClass(e) {
    return Bt.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), r = null;
    this.italic > 0 && (r = document.createElement("span"), r.style.marginRight = pt(this.italic)), this.classes.length > 0 && (r = r || document.createElement("span"), r.className = gc(this.classes));
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r = r || document.createElement("span"), r.style[n] = this.style[n]);
    return r ? (r.appendChild(e), r) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, r = "<span";
    this.classes.length && (e = !0, r += ' class="', r += Bt.escape(gc(this.classes)), r += '"');
    var n = "";
    this.italic > 0 && (n += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (n += Bt.hyphenate(i) + ":" + this.style[i] + ";");
    n && (e = !0, r += ' style="' + Bt.escape(n) + '"');
    var a = Bt.escape(this.text);
    return e ? (r += ">", r += a, r += "</span>", r) : a;
  }
}
class gl {
  constructor(e, r) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = r || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "svg");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    for (var i = 0; i < this.children.length; i++)
      r.appendChild(this.children[i].toNode());
    return r;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + Bt.escape(this.attributes[r]) + '"');
    e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</svg>", e;
  }
}
class mc {
  constructor(e, r) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = r;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "path");
    return this.alternate ? r.setAttribute("d", this.alternate) : r.setAttribute("d", YF[this.pathName]), r;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + Bt.escape(this.alternate) + '"/>' : '<path d="' + Bt.escape(YF[this.pathName]) + '"/>';
  }
}
class rA {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "line");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    return r;
  }
  toMarkup() {
    var e = "<line";
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + Bt.escape(this.attributes[r]) + '"');
    return e += "/>", e;
  }
}
function ZF(t) {
  if (t instanceof as)
    return t;
  throw new Error("Expected symbolNode but got " + String(t) + ".");
}
function Eke(t) {
  if (t instanceof pm)
    return t;
  throw new Error("Expected span<HtmlDomNode> but got " + String(t) + ".");
}
var Ske = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, kke = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, Gr = {
  math: {},
  text: {}
};
function q(t, e, r, n, i, a) {
  Gr[t][i] = {
    font: e,
    group: r,
    replace: n
  }, a && n && (Gr[t][n] = Gr[t][i]);
}
var H = "math", tt = "text", ie = "main", ye = "ams", tn = "accent-token", Ct = "bin", Ji = "close", B0 = "inner", qt = "mathord", Dn = "op-token", Da = "open", D4 = "punct", be = "rel", Al = "spacing", Le = "textord";
q(H, ie, be, "\u2261", "\\equiv", !0);
q(H, ie, be, "\u227A", "\\prec", !0);
q(H, ie, be, "\u227B", "\\succ", !0);
q(H, ie, be, "\u223C", "\\sim", !0);
q(H, ie, be, "\u22A5", "\\perp");
q(H, ie, be, "\u2AAF", "\\preceq", !0);
q(H, ie, be, "\u2AB0", "\\succeq", !0);
q(H, ie, be, "\u2243", "\\simeq", !0);
q(H, ie, be, "\u2223", "\\mid", !0);
q(H, ie, be, "\u226A", "\\ll", !0);
q(H, ie, be, "\u226B", "\\gg", !0);
q(H, ie, be, "\u224D", "\\asymp", !0);
q(H, ie, be, "\u2225", "\\parallel");
q(H, ie, be, "\u22C8", "\\bowtie", !0);
q(H, ie, be, "\u2323", "\\smile", !0);
q(H, ie, be, "\u2291", "\\sqsubseteq", !0);
q(H, ie, be, "\u2292", "\\sqsupseteq", !0);
q(H, ie, be, "\u2250", "\\doteq", !0);
q(H, ie, be, "\u2322", "\\frown", !0);
q(H, ie, be, "\u220B", "\\ni", !0);
q(H, ie, be, "\u221D", "\\propto", !0);
q(H, ie, be, "\u22A2", "\\vdash", !0);
q(H, ie, be, "\u22A3", "\\dashv", !0);
q(H, ie, be, "\u220B", "\\owns");
q(H, ie, D4, ".", "\\ldotp");
q(H, ie, D4, "\u22C5", "\\cdotp");
q(H, ie, Le, "#", "\\#");
q(tt, ie, Le, "#", "\\#");
q(H, ie, Le, "&", "\\&");
q(tt, ie, Le, "&", "\\&");
q(H, ie, Le, "\u2135", "\\aleph", !0);
q(H, ie, Le, "\u2200", "\\forall", !0);
q(H, ie, Le, "\u210F", "\\hbar", !0);
q(H, ie, Le, "\u2203", "\\exists", !0);
q(H, ie, Le, "\u2207", "\\nabla", !0);
q(H, ie, Le, "\u266D", "\\flat", !0);
q(H, ie, Le, "\u2113", "\\ell", !0);
q(H, ie, Le, "\u266E", "\\natural", !0);
q(H, ie, Le, "\u2663", "\\clubsuit", !0);
q(H, ie, Le, "\u2118", "\\wp", !0);
q(H, ie, Le, "\u266F", "\\sharp", !0);
q(H, ie, Le, "\u2662", "\\diamondsuit", !0);
q(H, ie, Le, "\u211C", "\\Re", !0);
q(H, ie, Le, "\u2661", "\\heartsuit", !0);
q(H, ie, Le, "\u2111", "\\Im", !0);
q(H, ie, Le, "\u2660", "\\spadesuit", !0);
q(H, ie, Le, "\xA7", "\\S", !0);
q(tt, ie, Le, "\xA7", "\\S");
q(H, ie, Le, "\xB6", "\\P", !0);
q(tt, ie, Le, "\xB6", "\\P");
q(H, ie, Le, "\u2020", "\\dag");
q(tt, ie, Le, "\u2020", "\\dag");
q(tt, ie, Le, "\u2020", "\\textdagger");
q(H, ie, Le, "\u2021", "\\ddag");
q(tt, ie, Le, "\u2021", "\\ddag");
q(tt, ie, Le, "\u2021", "\\textdaggerdbl");
q(H, ie, Ji, "\u23B1", "\\rmoustache", !0);
q(H, ie, Da, "\u23B0", "\\lmoustache", !0);
q(H, ie, Ji, "\u27EF", "\\rgroup", !0);
q(H, ie, Da, "\u27EE", "\\lgroup", !0);
q(H, ie, Ct, "\u2213", "\\mp", !0);
q(H, ie, Ct, "\u2296", "\\ominus", !0);
q(H, ie, Ct, "\u228E", "\\uplus", !0);
q(H, ie, Ct, "\u2293", "\\sqcap", !0);
q(H, ie, Ct, "\u2217", "\\ast");
q(H, ie, Ct, "\u2294", "\\sqcup", !0);
q(H, ie, Ct, "\u25EF", "\\bigcirc", !0);
q(H, ie, Ct, "\u2219", "\\bullet", !0);
q(H, ie, Ct, "\u2021", "\\ddagger");
q(H, ie, Ct, "\u2240", "\\wr", !0);
q(H, ie, Ct, "\u2A3F", "\\amalg");
q(H, ie, Ct, "&", "\\And");
q(H, ie, be, "\u27F5", "\\longleftarrow", !0);
q(H, ie, be, "\u21D0", "\\Leftarrow", !0);
q(H, ie, be, "\u27F8", "\\Longleftarrow", !0);
q(H, ie, be, "\u27F6", "\\longrightarrow", !0);
q(H, ie, be, "\u21D2", "\\Rightarrow", !0);
q(H, ie, be, "\u27F9", "\\Longrightarrow", !0);
q(H, ie, be, "\u2194", "\\leftrightarrow", !0);
q(H, ie, be, "\u27F7", "\\longleftrightarrow", !0);
q(H, ie, be, "\u21D4", "\\Leftrightarrow", !0);
q(H, ie, be, "\u27FA", "\\Longleftrightarrow", !0);
q(H, ie, be, "\u21A6", "\\mapsto", !0);
q(H, ie, be, "\u27FC", "\\longmapsto", !0);
q(H, ie, be, "\u2197", "\\nearrow", !0);
q(H, ie, be, "\u21A9", "\\hookleftarrow", !0);
q(H, ie, be, "\u21AA", "\\hookrightarrow", !0);
q(H, ie, be, "\u2198", "\\searrow", !0);
q(H, ie, be, "\u21BC", "\\leftharpoonup", !0);
q(H, ie, be, "\u21C0", "\\rightharpoonup", !0);
q(H, ie, be, "\u2199", "\\swarrow", !0);
q(H, ie, be, "\u21BD", "\\leftharpoondown", !0);
q(H, ie, be, "\u21C1", "\\rightharpoondown", !0);
q(H, ie, be, "\u2196", "\\nwarrow", !0);
q(H, ie, be, "\u21CC", "\\rightleftharpoons", !0);
q(H, ye, be, "\u226E", "\\nless", !0);
q(H, ye, be, "\uE010", "\\@nleqslant");
q(H, ye, be, "\uE011", "\\@nleqq");
q(H, ye, be, "\u2A87", "\\lneq", !0);
q(H, ye, be, "\u2268", "\\lneqq", !0);
q(H, ye, be, "\uE00C", "\\@lvertneqq");
q(H, ye, be, "\u22E6", "\\lnsim", !0);
q(H, ye, be, "\u2A89", "\\lnapprox", !0);
q(H, ye, be, "\u2280", "\\nprec", !0);
q(H, ye, be, "\u22E0", "\\npreceq", !0);
q(H, ye, be, "\u22E8", "\\precnsim", !0);
q(H, ye, be, "\u2AB9", "\\precnapprox", !0);
q(H, ye, be, "\u2241", "\\nsim", !0);
q(H, ye, be, "\uE006", "\\@nshortmid");
q(H, ye, be, "\u2224", "\\nmid", !0);
q(H, ye, be, "\u22AC", "\\nvdash", !0);
q(H, ye, be, "\u22AD", "\\nvDash", !0);
q(H, ye, be, "\u22EA", "\\ntriangleleft");
q(H, ye, be, "\u22EC", "\\ntrianglelefteq", !0);
q(H, ye, be, "\u228A", "\\subsetneq", !0);
q(H, ye, be, "\uE01A", "\\@varsubsetneq");
q(H, ye, be, "\u2ACB", "\\subsetneqq", !0);
q(H, ye, be, "\uE017", "\\@varsubsetneqq");
q(H, ye, be, "\u226F", "\\ngtr", !0);
q(H, ye, be, "\uE00F", "\\@ngeqslant");
q(H, ye, be, "\uE00E", "\\@ngeqq");
q(H, ye, be, "\u2A88", "\\gneq", !0);
q(H, ye, be, "\u2269", "\\gneqq", !0);
q(H, ye, be, "\uE00D", "\\@gvertneqq");
q(H, ye, be, "\u22E7", "\\gnsim", !0);
q(H, ye, be, "\u2A8A", "\\gnapprox", !0);
q(H, ye, be, "\u2281", "\\nsucc", !0);
q(H, ye, be, "\u22E1", "\\nsucceq", !0);
q(H, ye, be, "\u22E9", "\\succnsim", !0);
q(H, ye, be, "\u2ABA", "\\succnapprox", !0);
q(H, ye, be, "\u2246", "\\ncong", !0);
q(H, ye, be, "\uE007", "\\@nshortparallel");
q(H, ye, be, "\u2226", "\\nparallel", !0);
q(H, ye, be, "\u22AF", "\\nVDash", !0);
q(H, ye, be, "\u22EB", "\\ntriangleright");
q(H, ye, be, "\u22ED", "\\ntrianglerighteq", !0);
q(H, ye, be, "\uE018", "\\@nsupseteqq");
q(H, ye, be, "\u228B", "\\supsetneq", !0);
q(H, ye, be, "\uE01B", "\\@varsupsetneq");
q(H, ye, be, "\u2ACC", "\\supsetneqq", !0);
q(H, ye, be, "\uE019", "\\@varsupsetneqq");
q(H, ye, be, "\u22AE", "\\nVdash", !0);
q(H, ye, be, "\u2AB5", "\\precneqq", !0);
q(H, ye, be, "\u2AB6", "\\succneqq", !0);
q(H, ye, be, "\uE016", "\\@nsubseteqq");
q(H, ye, Ct, "\u22B4", "\\unlhd");
q(H, ye, Ct, "\u22B5", "\\unrhd");
q(H, ye, be, "\u219A", "\\nleftarrow", !0);
q(H, ye, be, "\u219B", "\\nrightarrow", !0);
q(H, ye, be, "\u21CD", "\\nLeftarrow", !0);
q(H, ye, be, "\u21CF", "\\nRightarrow", !0);
q(H, ye, be, "\u21AE", "\\nleftrightarrow", !0);
q(H, ye, be, "\u21CE", "\\nLeftrightarrow", !0);
q(H, ye, be, "\u25B3", "\\vartriangle");
q(H, ye, Le, "\u210F", "\\hslash");
q(H, ye, Le, "\u25BD", "\\triangledown");
q(H, ye, Le, "\u25CA", "\\lozenge");
q(H, ye, Le, "\u24C8", "\\circledS");
q(H, ye, Le, "\xAE", "\\circledR");
q(tt, ye, Le, "\xAE", "\\circledR");
q(H, ye, Le, "\u2221", "\\measuredangle", !0);
q(H, ye, Le, "\u2204", "\\nexists");
q(H, ye, Le, "\u2127", "\\mho");
q(H, ye, Le, "\u2132", "\\Finv", !0);
q(H, ye, Le, "\u2141", "\\Game", !0);
q(H, ye, Le, "\u2035", "\\backprime");
q(H, ye, Le, "\u25B2", "\\blacktriangle");
q(H, ye, Le, "\u25BC", "\\blacktriangledown");
q(H, ye, Le, "\u25A0", "\\blacksquare");
q(H, ye, Le, "\u29EB", "\\blacklozenge");
q(H, ye, Le, "\u2605", "\\bigstar");
q(H, ye, Le, "\u2222", "\\sphericalangle", !0);
q(H, ye, Le, "\u2201", "\\complement", !0);
q(H, ye, Le, "\xF0", "\\eth", !0);
q(tt, ie, Le, "\xF0", "\xF0");
q(H, ye, Le, "\u2571", "\\diagup");
q(H, ye, Le, "\u2572", "\\diagdown");
q(H, ye, Le, "\u25A1", "\\square");
q(H, ye, Le, "\u25A1", "\\Box");
q(H, ye, Le, "\u25CA", "\\Diamond");
q(H, ye, Le, "\xA5", "\\yen", !0);
q(tt, ye, Le, "\xA5", "\\yen", !0);
q(H, ye, Le, "\u2713", "\\checkmark", !0);
q(tt, ye, Le, "\u2713", "\\checkmark");
q(H, ye, Le, "\u2136", "\\beth", !0);
q(H, ye, Le, "\u2138", "\\daleth", !0);
q(H, ye, Le, "\u2137", "\\gimel", !0);
q(H, ye, Le, "\u03DD", "\\digamma", !0);
q(H, ye, Le, "\u03F0", "\\varkappa");
q(H, ye, Da, "\u250C", "\\@ulcorner", !0);
q(H, ye, Ji, "\u2510", "\\@urcorner", !0);
q(H, ye, Da, "\u2514", "\\@llcorner", !0);
q(H, ye, Ji, "\u2518", "\\@lrcorner", !0);
q(H, ye, be, "\u2266", "\\leqq", !0);
q(H, ye, be, "\u2A7D", "\\leqslant", !0);
q(H, ye, be, "\u2A95", "\\eqslantless", !0);
q(H, ye, be, "\u2272", "\\lesssim", !0);
q(H, ye, be, "\u2A85", "\\lessapprox", !0);
q(H, ye, be, "\u224A", "\\approxeq", !0);
q(H, ye, Ct, "\u22D6", "\\lessdot");
q(H, ye, be, "\u22D8", "\\lll", !0);
q(H, ye, be, "\u2276", "\\lessgtr", !0);
q(H, ye, be, "\u22DA", "\\lesseqgtr", !0);
q(H, ye, be, "\u2A8B", "\\lesseqqgtr", !0);
q(H, ye, be, "\u2251", "\\doteqdot");
q(H, ye, be, "\u2253", "\\risingdotseq", !0);
q(H, ye, be, "\u2252", "\\fallingdotseq", !0);
q(H, ye, be, "\u223D", "\\backsim", !0);
q(H, ye, be, "\u22CD", "\\backsimeq", !0);
q(H, ye, be, "\u2AC5", "\\subseteqq", !0);
q(H, ye, be, "\u22D0", "\\Subset", !0);
q(H, ye, be, "\u228F", "\\sqsubset", !0);
q(H, ye, be, "\u227C", "\\preccurlyeq", !0);
q(H, ye, be, "\u22DE", "\\curlyeqprec", !0);
q(H, ye, be, "\u227E", "\\precsim", !0);
q(H, ye, be, "\u2AB7", "\\precapprox", !0);
q(H, ye, be, "\u22B2", "\\vartriangleleft");
q(H, ye, be, "\u22B4", "\\trianglelefteq");
q(H, ye, be, "\u22A8", "\\vDash", !0);
q(H, ye, be, "\u22AA", "\\Vvdash", !0);
q(H, ye, be, "\u2323", "\\smallsmile");
q(H, ye, be, "\u2322", "\\smallfrown");
q(H, ye, be, "\u224F", "\\bumpeq", !0);
q(H, ye, be, "\u224E", "\\Bumpeq", !0);
q(H, ye, be, "\u2267", "\\geqq", !0);
q(H, ye, be, "\u2A7E", "\\geqslant", !0);
q(H, ye, be, "\u2A96", "\\eqslantgtr", !0);
q(H, ye, be, "\u2273", "\\gtrsim", !0);
q(H, ye, be, "\u2A86", "\\gtrapprox", !0);
q(H, ye, Ct, "\u22D7", "\\gtrdot");
q(H, ye, be, "\u22D9", "\\ggg", !0);
q(H, ye, be, "\u2277", "\\gtrless", !0);
q(H, ye, be, "\u22DB", "\\gtreqless", !0);
q(H, ye, be, "\u2A8C", "\\gtreqqless", !0);
q(H, ye, be, "\u2256", "\\eqcirc", !0);
q(H, ye, be, "\u2257", "\\circeq", !0);
q(H, ye, be, "\u225C", "\\triangleq", !0);
q(H, ye, be, "\u223C", "\\thicksim");
q(H, ye, be, "\u2248", "\\thickapprox");
q(H, ye, be, "\u2AC6", "\\supseteqq", !0);
q(H, ye, be, "\u22D1", "\\Supset", !0);
q(H, ye, be, "\u2290", "\\sqsupset", !0);
q(H, ye, be, "\u227D", "\\succcurlyeq", !0);
q(H, ye, be, "\u22DF", "\\curlyeqsucc", !0);
q(H, ye, be, "\u227F", "\\succsim", !0);
q(H, ye, be, "\u2AB8", "\\succapprox", !0);
q(H, ye, be, "\u22B3", "\\vartriangleright");
q(H, ye, be, "\u22B5", "\\trianglerighteq");
q(H, ye, be, "\u22A9", "\\Vdash", !0);
q(H, ye, be, "\u2223", "\\shortmid");
q(H, ye, be, "\u2225", "\\shortparallel");
q(H, ye, be, "\u226C", "\\between", !0);
q(H, ye, be, "\u22D4", "\\pitchfork", !0);
q(H, ye, be, "\u221D", "\\varpropto");
q(H, ye, be, "\u25C0", "\\blacktriangleleft");
q(H, ye, be, "\u2234", "\\therefore", !0);
q(H, ye, be, "\u220D", "\\backepsilon");
q(H, ye, be, "\u25B6", "\\blacktriangleright");
q(H, ye, be, "\u2235", "\\because", !0);
q(H, ye, be, "\u22D8", "\\llless");
q(H, ye, be, "\u22D9", "\\gggtr");
q(H, ye, Ct, "\u22B2", "\\lhd");
q(H, ye, Ct, "\u22B3", "\\rhd");
q(H, ye, be, "\u2242", "\\eqsim", !0);
q(H, ie, be, "\u22C8", "\\Join");
q(H, ye, be, "\u2251", "\\Doteq", !0);
q(H, ye, Ct, "\u2214", "\\dotplus", !0);
q(H, ye, Ct, "\u2216", "\\smallsetminus");
q(H, ye, Ct, "\u22D2", "\\Cap", !0);
q(H, ye, Ct, "\u22D3", "\\Cup", !0);
q(H, ye, Ct, "\u2A5E", "\\doublebarwedge", !0);
q(H, ye, Ct, "\u229F", "\\boxminus", !0);
q(H, ye, Ct, "\u229E", "\\boxplus", !0);
q(H, ye, Ct, "\u22C7", "\\divideontimes", !0);
q(H, ye, Ct, "\u22C9", "\\ltimes", !0);
q(H, ye, Ct, "\u22CA", "\\rtimes", !0);
q(H, ye, Ct, "\u22CB", "\\leftthreetimes", !0);
q(H, ye, Ct, "\u22CC", "\\rightthreetimes", !0);
q(H, ye, Ct, "\u22CF", "\\curlywedge", !0);
q(H, ye, Ct, "\u22CE", "\\curlyvee", !0);
q(H, ye, Ct, "\u229D", "\\circleddash", !0);
q(H, ye, Ct, "\u229B", "\\circledast", !0);
q(H, ye, Ct, "\u22C5", "\\centerdot");
q(H, ye, Ct, "\u22BA", "\\intercal", !0);
q(H, ye, Ct, "\u22D2", "\\doublecap");
q(H, ye, Ct, "\u22D3", "\\doublecup");
q(H, ye, Ct, "\u22A0", "\\boxtimes", !0);
q(H, ye, be, "\u21E2", "\\dashrightarrow", !0);
q(H, ye, be, "\u21E0", "\\dashleftarrow", !0);
q(H, ye, be, "\u21C7", "\\leftleftarrows", !0);
q(H, ye, be, "\u21C6", "\\leftrightarrows", !0);
q(H, ye, be, "\u21DA", "\\Lleftarrow", !0);
q(H, ye, be, "\u219E", "\\twoheadleftarrow", !0);
q(H, ye, be, "\u21A2", "\\leftarrowtail", !0);
q(H, ye, be, "\u21AB", "\\looparrowleft", !0);
q(H, ye, be, "\u21CB", "\\leftrightharpoons", !0);
q(H, ye, be, "\u21B6", "\\curvearrowleft", !0);
q(H, ye, be, "\u21BA", "\\circlearrowleft", !0);
q(H, ye, be, "\u21B0", "\\Lsh", !0);
q(H, ye, be, "\u21C8", "\\upuparrows", !0);
q(H, ye, be, "\u21BF", "\\upharpoonleft", !0);
q(H, ye, be, "\u21C3", "\\downharpoonleft", !0);
q(H, ie, be, "\u22B6", "\\origof", !0);
q(H, ie, be, "\u22B7", "\\imageof", !0);
q(H, ye, be, "\u22B8", "\\multimap", !0);
q(H, ye, be, "\u21AD", "\\leftrightsquigarrow", !0);
q(H, ye, be, "\u21C9", "\\rightrightarrows", !0);
q(H, ye, be, "\u21C4", "\\rightleftarrows", !0);
q(H, ye, be, "\u21A0", "\\twoheadrightarrow", !0);
q(H, ye, be, "\u21A3", "\\rightarrowtail", !0);
q(H, ye, be, "\u21AC", "\\looparrowright", !0);
q(H, ye, be, "\u21B7", "\\curvearrowright", !0);
q(H, ye, be, "\u21BB", "\\circlearrowright", !0);
q(H, ye, be, "\u21B1", "\\Rsh", !0);
q(H, ye, be, "\u21CA", "\\downdownarrows", !0);
q(H, ye, be, "\u21BE", "\\upharpoonright", !0);
q(H, ye, be, "\u21C2", "\\downharpoonright", !0);
q(H, ye, be, "\u21DD", "\\rightsquigarrow", !0);
q(H, ye, be, "\u21DD", "\\leadsto");
q(H, ye, be, "\u21DB", "\\Rrightarrow", !0);
q(H, ye, be, "\u21BE", "\\restriction");
q(H, ie, Le, "\u2018", "`");
q(H, ie, Le, "$", "\\$");
q(tt, ie, Le, "$", "\\$");
q(tt, ie, Le, "$", "\\textdollar");
q(H, ie, Le, "%", "\\%");
q(tt, ie, Le, "%", "\\%");
q(H, ie, Le, "_", "\\_");
q(tt, ie, Le, "_", "\\_");
q(tt, ie, Le, "_", "\\textunderscore");
q(H, ie, Le, "\u2220", "\\angle", !0);
q(H, ie, Le, "\u221E", "\\infty", !0);
q(H, ie, Le, "\u2032", "\\prime");
q(H, ie, Le, "\u25B3", "\\triangle");
q(H, ie, Le, "\u0393", "\\Gamma", !0);
q(H, ie, Le, "\u0394", "\\Delta", !0);
q(H, ie, Le, "\u0398", "\\Theta", !0);
q(H, ie, Le, "\u039B", "\\Lambda", !0);
q(H, ie, Le, "\u039E", "\\Xi", !0);
q(H, ie, Le, "\u03A0", "\\Pi", !0);
q(H, ie, Le, "\u03A3", "\\Sigma", !0);
q(H, ie, Le, "\u03A5", "\\Upsilon", !0);
q(H, ie, Le, "\u03A6", "\\Phi", !0);
q(H, ie, Le, "\u03A8", "\\Psi", !0);
q(H, ie, Le, "\u03A9", "\\Omega", !0);
q(H, ie, Le, "A", "\u0391");
q(H, ie, Le, "B", "\u0392");
q(H, ie, Le, "E", "\u0395");
q(H, ie, Le, "Z", "\u0396");
q(H, ie, Le, "H", "\u0397");
q(H, ie, Le, "I", "\u0399");
q(H, ie, Le, "K", "\u039A");
q(H, ie, Le, "M", "\u039C");
q(H, ie, Le, "N", "\u039D");
q(H, ie, Le, "O", "\u039F");
q(H, ie, Le, "P", "\u03A1");
q(H, ie, Le, "T", "\u03A4");
q(H, ie, Le, "X", "\u03A7");
q(H, ie, Le, "\xAC", "\\neg", !0);
q(H, ie, Le, "\xAC", "\\lnot");
q(H, ie, Le, "\u22A4", "\\top");
q(H, ie, Le, "\u22A5", "\\bot");
q(H, ie, Le, "\u2205", "\\emptyset");
q(H, ye, Le, "\u2205", "\\varnothing");
q(H, ie, qt, "\u03B1", "\\alpha", !0);
q(H, ie, qt, "\u03B2", "\\beta", !0);
q(H, ie, qt, "\u03B3", "\\gamma", !0);
q(H, ie, qt, "\u03B4", "\\delta", !0);
q(H, ie, qt, "\u03F5", "\\epsilon", !0);
q(H, ie, qt, "\u03B6", "\\zeta", !0);
q(H, ie, qt, "\u03B7", "\\eta", !0);
q(H, ie, qt, "\u03B8", "\\theta", !0);
q(H, ie, qt, "\u03B9", "\\iota", !0);
q(H, ie, qt, "\u03BA", "\\kappa", !0);
q(H, ie, qt, "\u03BB", "\\lambda", !0);
q(H, ie, qt, "\u03BC", "\\mu", !0);
q(H, ie, qt, "\u03BD", "\\nu", !0);
q(H, ie, qt, "\u03BE", "\\xi", !0);
q(H, ie, qt, "\u03BF", "\\omicron", !0);
q(H, ie, qt, "\u03C0", "\\pi", !0);
q(H, ie, qt, "\u03C1", "\\rho", !0);
q(H, ie, qt, "\u03C3", "\\sigma", !0);
q(H, ie, qt, "\u03C4", "\\tau", !0);
q(H, ie, qt, "\u03C5", "\\upsilon", !0);
q(H, ie, qt, "\u03D5", "\\phi", !0);
q(H, ie, qt, "\u03C7", "\\chi", !0);
q(H, ie, qt, "\u03C8", "\\psi", !0);
q(H, ie, qt, "\u03C9", "\\omega", !0);
q(H, ie, qt, "\u03B5", "\\varepsilon", !0);
q(H, ie, qt, "\u03D1", "\\vartheta", !0);
q(H, ie, qt, "\u03D6", "\\varpi", !0);
q(H, ie, qt, "\u03F1", "\\varrho", !0);
q(H, ie, qt, "\u03C2", "\\varsigma", !0);
q(H, ie, qt, "\u03C6", "\\varphi", !0);
q(H, ie, Ct, "\u2217", "*", !0);
q(H, ie, Ct, "+", "+");
q(H, ie, Ct, "\u2212", "-", !0);
q(H, ie, Ct, "\u22C5", "\\cdot", !0);
q(H, ie, Ct, "\u2218", "\\circ", !0);
q(H, ie, Ct, "\xF7", "\\div", !0);
q(H, ie, Ct, "\xB1", "\\pm", !0);
q(H, ie, Ct, "\xD7", "\\times", !0);
q(H, ie, Ct, "\u2229", "\\cap", !0);
q(H, ie, Ct, "\u222A", "\\cup", !0);
q(H, ie, Ct, "\u2216", "\\setminus", !0);
q(H, ie, Ct, "\u2227", "\\land");
q(H, ie, Ct, "\u2228", "\\lor");
q(H, ie, Ct, "\u2227", "\\wedge", !0);
q(H, ie, Ct, "\u2228", "\\vee", !0);
q(H, ie, Le, "\u221A", "\\surd");
q(H, ie, Da, "\u27E8", "\\langle", !0);
q(H, ie, Da, "\u2223", "\\lvert");
q(H, ie, Da, "\u2225", "\\lVert");
q(H, ie, Ji, "?", "?");
q(H, ie, Ji, "!", "!");
q(H, ie, Ji, "\u27E9", "\\rangle", !0);
q(H, ie, Ji, "\u2223", "\\rvert");
q(H, ie, Ji, "\u2225", "\\rVert");
q(H, ie, be, "=", "=");
q(H, ie, be, ":", ":");
q(H, ie, be, "\u2248", "\\approx", !0);
q(H, ie, be, "\u2245", "\\cong", !0);
q(H, ie, be, "\u2265", "\\ge");
q(H, ie, be, "\u2265", "\\geq", !0);
q(H, ie, be, "\u2190", "\\gets");
q(H, ie, be, ">", "\\gt", !0);
q(H, ie, be, "\u2208", "\\in", !0);
q(H, ie, be, "\uE020", "\\@not");
q(H, ie, be, "\u2282", "\\subset", !0);
q(H, ie, be, "\u2283", "\\supset", !0);
q(H, ie, be, "\u2286", "\\subseteq", !0);
q(H, ie, be, "\u2287", "\\supseteq", !0);
q(H, ye, be, "\u2288", "\\nsubseteq", !0);
q(H, ye, be, "\u2289", "\\nsupseteq", !0);
q(H, ie, be, "\u22A8", "\\models");
q(H, ie, be, "\u2190", "\\leftarrow", !0);
q(H, ie, be, "\u2264", "\\le");
q(H, ie, be, "\u2264", "\\leq", !0);
q(H, ie, be, "<", "\\lt", !0);
q(H, ie, be, "\u2192", "\\rightarrow", !0);
q(H, ie, be, "\u2192", "\\to");
q(H, ye, be, "\u2271", "\\ngeq", !0);
q(H, ye, be, "\u2270", "\\nleq", !0);
q(H, ie, Al, "\xA0", "\\ ");
q(H, ie, Al, "\xA0", "\\space");
q(H, ie, Al, "\xA0", "\\nobreakspace");
q(tt, ie, Al, "\xA0", "\\ ");
q(tt, ie, Al, "\xA0", " ");
q(tt, ie, Al, "\xA0", "\\space");
q(tt, ie, Al, "\xA0", "\\nobreakspace");
q(H, ie, Al, null, "\\nobreak");
q(H, ie, Al, null, "\\allowbreak");
q(H, ie, D4, ",", ",");
q(H, ie, D4, ";", ";");
q(H, ye, Ct, "\u22BC", "\\barwedge", !0);
q(H, ye, Ct, "\u22BB", "\\veebar", !0);
q(H, ie, Ct, "\u2299", "\\odot", !0);
q(H, ie, Ct, "\u2295", "\\oplus", !0);
q(H, ie, Ct, "\u2297", "\\otimes", !0);
q(H, ie, Le, "\u2202", "\\partial", !0);
q(H, ie, Ct, "\u2298", "\\oslash", !0);
q(H, ye, Ct, "\u229A", "\\circledcirc", !0);
q(H, ye, Ct, "\u22A1", "\\boxdot", !0);
q(H, ie, Ct, "\u25B3", "\\bigtriangleup");
q(H, ie, Ct, "\u25BD", "\\bigtriangledown");
q(H, ie, Ct, "\u2020", "\\dagger");
q(H, ie, Ct, "\u22C4", "\\diamond");
q(H, ie, Ct, "\u22C6", "\\star");
q(H, ie, Ct, "\u25C3", "\\triangleleft");
q(H, ie, Ct, "\u25B9", "\\triangleright");
q(H, ie, Da, "{", "\\{");
q(tt, ie, Le, "{", "\\{");
q(tt, ie, Le, "{", "\\textbraceleft");
q(H, ie, Ji, "}", "\\}");
q(tt, ie, Le, "}", "\\}");
q(tt, ie, Le, "}", "\\textbraceright");
q(H, ie, Da, "{", "\\lbrace");
q(H, ie, Ji, "}", "\\rbrace");
q(H, ie, Da, "[", "\\lbrack", !0);
q(tt, ie, Le, "[", "\\lbrack", !0);
q(H, ie, Ji, "]", "\\rbrack", !0);
q(tt, ie, Le, "]", "\\rbrack", !0);
q(H, ie, Da, "(", "\\lparen", !0);
q(H, ie, Ji, ")", "\\rparen", !0);
q(tt, ie, Le, "<", "\\textless", !0);
q(tt, ie, Le, ">", "\\textgreater", !0);
q(H, ie, Da, "\u230A", "\\lfloor", !0);
q(H, ie, Ji, "\u230B", "\\rfloor", !0);
q(H, ie, Da, "\u2308", "\\lceil", !0);
q(H, ie, Ji, "\u2309", "\\rceil", !0);
q(H, ie, Le, "\\", "\\backslash");
q(H, ie, Le, "\u2223", "|");
q(H, ie, Le, "\u2223", "\\vert");
q(tt, ie, Le, "|", "\\textbar", !0);
q(H, ie, Le, "\u2225", "\\|");
q(H, ie, Le, "\u2225", "\\Vert");
q(tt, ie, Le, "\u2225", "\\textbardbl");
q(tt, ie, Le, "~", "\\textasciitilde");
q(tt, ie, Le, "\\", "\\textbackslash");
q(tt, ie, Le, "^", "\\textasciicircum");
q(H, ie, be, "\u2191", "\\uparrow", !0);
q(H, ie, be, "\u21D1", "\\Uparrow", !0);
q(H, ie, be, "\u2193", "\\downarrow", !0);
q(H, ie, be, "\u21D3", "\\Downarrow", !0);
q(H, ie, be, "\u2195", "\\updownarrow", !0);
q(H, ie, be, "\u21D5", "\\Updownarrow", !0);
q(H, ie, Dn, "\u2210", "\\coprod");
q(H, ie, Dn, "\u22C1", "\\bigvee");
q(H, ie, Dn, "\u22C0", "\\bigwedge");
q(H, ie, Dn, "\u2A04", "\\biguplus");
q(H, ie, Dn, "\u22C2", "\\bigcap");
q(H, ie, Dn, "\u22C3", "\\bigcup");
q(H, ie, Dn, "\u222B", "\\int");
q(H, ie, Dn, "\u222B", "\\intop");
q(H, ie, Dn, "\u222C", "\\iint");
q(H, ie, Dn, "\u222D", "\\iiint");
q(H, ie, Dn, "\u220F", "\\prod");
q(H, ie, Dn, "\u2211", "\\sum");
q(H, ie, Dn, "\u2A02", "\\bigotimes");
q(H, ie, Dn, "\u2A01", "\\bigoplus");
q(H, ie, Dn, "\u2A00", "\\bigodot");
q(H, ie, Dn, "\u222E", "\\oint");
q(H, ie, Dn, "\u222F", "\\oiint");
q(H, ie, Dn, "\u2230", "\\oiiint");
q(H, ie, Dn, "\u2A06", "\\bigsqcup");
q(H, ie, Dn, "\u222B", "\\smallint");
q(tt, ie, B0, "\u2026", "\\textellipsis");
q(H, ie, B0, "\u2026", "\\mathellipsis");
q(tt, ie, B0, "\u2026", "\\ldots", !0);
q(H, ie, B0, "\u2026", "\\ldots", !0);
q(H, ie, B0, "\u22EF", "\\@cdots", !0);
q(H, ie, B0, "\u22F1", "\\ddots", !0);
q(H, ie, Le, "\u22EE", "\\varvdots");
q(tt, ie, Le, "\u22EE", "\\varvdots");
q(H, ie, tn, "\u02CA", "\\acute");
q(H, ie, tn, "\u02CB", "\\grave");
q(H, ie, tn, "\xA8", "\\ddot");
q(H, ie, tn, "~", "\\tilde");
q(H, ie, tn, "\u02C9", "\\bar");
q(H, ie, tn, "\u02D8", "\\breve");
q(H, ie, tn, "\u02C7", "\\check");
q(H, ie, tn, "^", "\\hat");
q(H, ie, tn, "\u20D7", "\\vec");
q(H, ie, tn, "\u02D9", "\\dot");
q(H, ie, tn, "\u02DA", "\\mathring");
q(H, ie, qt, "\uE131", "\\@imath");
q(H, ie, qt, "\uE237", "\\@jmath");
q(H, ie, Le, "\u0131", "\u0131");
q(H, ie, Le, "\u0237", "\u0237");
q(tt, ie, Le, "\u0131", "\\i", !0);
q(tt, ie, Le, "\u0237", "\\j", !0);
q(tt, ie, Le, "\xDF", "\\ss", !0);
q(tt, ie, Le, "\xE6", "\\ae", !0);
q(tt, ie, Le, "\u0153", "\\oe", !0);
q(tt, ie, Le, "\xF8", "\\o", !0);
q(tt, ie, Le, "\xC6", "\\AE", !0);
q(tt, ie, Le, "\u0152", "\\OE", !0);
q(tt, ie, Le, "\xD8", "\\O", !0);
q(tt, ie, tn, "\u02CA", "\\'");
q(tt, ie, tn, "\u02CB", "\\`");
q(tt, ie, tn, "\u02C6", "\\^");
q(tt, ie, tn, "\u02DC", "\\~");
q(tt, ie, tn, "\u02C9", "\\=");
q(tt, ie, tn, "\u02D8", "\\u");
q(tt, ie, tn, "\u02D9", "\\.");
q(tt, ie, tn, "\xB8", "\\c");
q(tt, ie, tn, "\u02DA", "\\r");
q(tt, ie, tn, "\u02C7", "\\v");
q(tt, ie, tn, "\xA8", '\\"');
q(tt, ie, tn, "\u02DD", "\\H");
q(tt, ie, tn, "\u25EF", "\\textcircled");
var Hte = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
q(tt, ie, Le, "\u2013", "--", !0);
q(tt, ie, Le, "\u2013", "\\textendash");
q(tt, ie, Le, "\u2014", "---", !0);
q(tt, ie, Le, "\u2014", "\\textemdash");
q(tt, ie, Le, "\u2018", "`", !0);
q(tt, ie, Le, "\u2018", "\\textquoteleft");
q(tt, ie, Le, "\u2019", "'", !0);
q(tt, ie, Le, "\u2019", "\\textquoteright");
q(tt, ie, Le, "\u201C", "``", !0);
q(tt, ie, Le, "\u201C", "\\textquotedblleft");
q(tt, ie, Le, "\u201D", "''", !0);
q(tt, ie, Le, "\u201D", "\\textquotedblright");
q(H, ie, Le, "\xB0", "\\degree", !0);
q(tt, ie, Le, "\xB0", "\\degree");
q(tt, ie, Le, "\xB0", "\\textdegree", !0);
q(H, ie, Le, "\xA3", "\\pounds");
q(H, ie, Le, "\xA3", "\\mathsterling", !0);
q(tt, ie, Le, "\xA3", "\\pounds");
q(tt, ie, Le, "\xA3", "\\textsterling", !0);
q(H, ye, Le, "\u2720", "\\maltese");
q(tt, ye, Le, "\u2720", "\\maltese");
var QF = '0123456789/@."';
for (var lk = 0; lk < QF.length; lk++) {
  var JF = QF.charAt(lk);
  q(H, ie, Le, JF, JF);
}
var ez = '0123456789!@*()-=+";:?/.,';
for (var ck = 0; ck < ez.length; ck++) {
  var tz = ez.charAt(ck);
  q(tt, ie, Le, tz, tz);
}
var bb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var uk = 0; uk < bb.length; uk++) {
  var vv = bb.charAt(uk);
  q(H, ie, qt, vv, vv), q(tt, ie, Le, vv, vv);
}
q(H, ye, Le, "C", "\u2102");
q(tt, ye, Le, "C", "\u2102");
q(H, ye, Le, "H", "\u210D");
q(tt, ye, Le, "H", "\u210D");
q(H, ye, Le, "N", "\u2115");
q(tt, ye, Le, "N", "\u2115");
q(H, ye, Le, "P", "\u2119");
q(tt, ye, Le, "P", "\u2119");
q(H, ye, Le, "Q", "\u211A");
q(tt, ye, Le, "Q", "\u211A");
q(H, ye, Le, "R", "\u211D");
q(tt, ye, Le, "R", "\u211D");
q(H, ye, Le, "Z", "\u2124");
q(tt, ye, Le, "Z", "\u2124");
q(H, ie, qt, "h", "\u210E");
q(tt, ie, qt, "h", "\u210E");
var Xt = "";
for (var Oi = 0; Oi < bb.length; Oi++) {
  var un = bb.charAt(Oi);
  Xt = String.fromCharCode(55349, 56320 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56372 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56424 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56580 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56684 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56736 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56788 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56840 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56944 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Oi < 26 && (Xt = String.fromCharCode(55349, 56632 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt), Xt = String.fromCharCode(55349, 56476 + Oi), q(H, ie, qt, un, Xt), q(tt, ie, Le, un, Xt));
}
Xt = "\u{1D55C}";
q(H, ie, qt, "k", Xt);
q(tt, ie, Le, "k", Xt);
for (var cu = 0; cu < 10; cu++) {
  var ql = cu.toString();
  Xt = String.fromCharCode(55349, 57294 + cu), q(H, ie, qt, ql, Xt), q(tt, ie, Le, ql, Xt), Xt = String.fromCharCode(55349, 57314 + cu), q(H, ie, qt, ql, Xt), q(tt, ie, Le, ql, Xt), Xt = String.fromCharCode(55349, 57324 + cu), q(H, ie, qt, ql, Xt), q(tt, ie, Le, ql, Xt), Xt = String.fromCharCode(55349, 57334 + cu), q(H, ie, qt, ql, Xt), q(tt, ie, Le, ql, Xt);
}
var nA = "\xD0\xDE\xFE";
for (var hk = 0; hk < nA.length; hk++) {
  var yv = nA.charAt(hk);
  q(H, ie, qt, yv, yv), q(tt, ie, Le, yv, yv);
}
var bv = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], rz = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Cke = function(e, r) {
  var n = e.charCodeAt(0), i = e.charCodeAt(1), a = (n - 55296) * 1024 + (i - 56320) + 65536, s = r === "math" ? 0 : 1;
  if (119808 <= a && a < 120484) {
    var o = Math.floor((a - 119808) / 26);
    return [bv[o][2], bv[o][s]];
  } else if (120782 <= a && a <= 120831) {
    var l = Math.floor((a - 120782) / 10);
    return [rz[l][2], rz[l][s]];
  } else {
    if (a === 120485 || a === 120486)
      return [bv[0][2], bv[0][s]];
    if (120486 < a && a < 120782)
      return ["", ""];
    throw new ot("Unsupported character: " + e);
  }
}, O4 = function(e, r, n) {
  return Gr[n][e] && Gr[n][e].replace && (e = Gr[n][e].replace), {
    value: e,
    metrics: OL(e, r, n)
  };
}, vs = function(e, r, n, i, a) {
  var s = O4(e, r, n), o = s.metrics;
  e = s.value;
  var l;
  if (o) {
    var u = o.italic;
    (n === "text" || i && i.font === "mathit") && (u = 0), l = new as(e, o.height, o.depth, u, o.skew, o.width, a);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + r + "' and mode '" + n + "'")), l = new as(e, 0, 0, 0, 0, 0, a);
  if (i) {
    l.maxFontSize = i.sizeMultiplier, i.style.isTight() && l.classes.push("mtight");
    var h = i.getColor();
    h && (l.style.color = h);
  }
  return l;
}, _ke = function(e, r, n, i) {
  return i === void 0 && (i = []), n.font === "boldsymbol" && O4(e, "Main-Bold", r).metrics ? vs(e, "Main-Bold", r, n, i.concat(["mathbf"])) : e === "\\" || Gr[r][e].font === "main" ? vs(e, "Main-Regular", r, n, i) : vs(e, "AMS-Regular", r, n, i.concat(["amsrm"]));
}, Ake = function(e, r, n, i, a) {
  return a !== "textord" && O4(e, "Math-BoldItalic", r).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Lke = function(e, r, n) {
  var i = e.mode, a = e.text, s = ["mord"], o = i === "math" || i === "text" && r.font, l = o ? r.font : r.fontFamily, u = "", h = "";
  if (a.charCodeAt(0) === 55349 && ([u, h] = Cke(a, i)), u.length > 0)
    return vs(a, u, i, r, s.concat(h));
  if (l) {
    var f, d;
    if (l === "boldsymbol") {
      var p = Ake(a, i, r, s, n);
      f = p.fontName, d = [p.fontClass];
    } else o ? (f = Xte[l].fontName, d = [l]) : (f = xv(l, r.fontWeight, r.fontShape), d = [l, r.fontWeight, r.fontShape]);
    if (O4(a, f, i).metrics)
      return vs(a, f, i, r, s.concat(d));
    if (Hte.hasOwnProperty(a) && f.slice(0, 10) === "Typewriter") {
      for (var g = [], m = 0; m < a.length; m++)
        g.push(vs(a[m], f, i, r, s.concat(d)));
      return Yte(g);
    }
  }
  if (n === "mathord")
    return vs(a, "Math-Italic", i, r, s.concat(["mathnormal"]));
  if (n === "textord") {
    var v = Gr[i][a] && Gr[i][a].font;
    if (v === "ams") {
      var y = xv("amsrm", r.fontWeight, r.fontShape);
      return vs(a, y, i, r, s.concat("amsrm", r.fontWeight, r.fontShape));
    } else if (v === "main" || !v) {
      var b = xv("textrm", r.fontWeight, r.fontShape);
      return vs(a, b, i, r, s.concat(r.fontWeight, r.fontShape));
    } else {
      var x = xv(v, r.fontWeight, r.fontShape);
      return vs(a, x, i, r, s.concat(x, r.fontWeight, r.fontShape));
    }
  } else
    throw new Error("unexpected type: " + n + " in makeOrd");
}, Rke = (t, e) => {
  if (gc(t.classes) !== gc(e.classes) || t.skew !== e.skew || t.maxFontSize !== e.maxFontSize)
    return !1;
  if (t.classes.length === 1) {
    var r = t.classes[0];
    if (r === "mbin" || r === "mord")
      return !1;
  }
  for (var n in t.style)
    if (t.style.hasOwnProperty(n) && t.style[n] !== e.style[n])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && t.style[i] !== e.style[i])
      return !1;
  return !0;
}, Ike = (t) => {
  for (var e = 0; e < t.length - 1; e++) {
    var r = t[e], n = t[e + 1];
    r instanceof as && n instanceof as && Rke(r, n) && (r.text += n.text, r.height = Math.max(r.height, n.height), r.depth = Math.max(r.depth, n.depth), r.italic = n.italic, t.splice(e + 1, 1), e--);
  }
  return t;
}, $L = function(e) {
  for (var r = 0, n = 0, i = 0, a = 0; a < e.children.length; a++) {
    var s = e.children[a];
    s.height > r && (r = s.height), s.depth > n && (n = s.depth), s.maxFontSize > i && (i = s.maxFontSize);
  }
  e.height = r, e.depth = n, e.maxFontSize = i;
}, na = function(e, r, n, i) {
  var a = new pm(e, r, n, i);
  return $L(a), a;
}, Wte = (t, e, r, n) => new pm(t, e, r, n), Mke = function(e, r, n) {
  var i = na([e], [], r);
  return i.height = Math.max(n || r.fontMetrics().defaultRuleThickness, r.minRuleThickness), i.style.borderBottomWidth = pt(i.height), i.maxFontSize = 1, i;
}, Nke = function(e, r, n, i) {
  var a = new PL(e, r, n, i);
  return $L(a), a;
}, Yte = function(e) {
  var r = new dm(e);
  return $L(r), r;
}, Dke = function(e, r) {
  return e instanceof dm ? na([], [e], r) : e;
}, Oke = function(e) {
  if (e.positionType === "individualShift") {
    for (var r = e.children, n = [r[0]], i = -r[0].shift - r[0].elem.depth, a = i, s = 1; s < r.length; s++) {
      var o = -r[s].shift - a - r[s].elem.depth, l = o - (r[s - 1].elem.height + r[s - 1].elem.depth);
      a = a + o, n.push({
        type: "kern",
        size: l
      }), n.push(r[s]);
    }
    return {
      children: n,
      depth: i
    };
  }
  var u;
  if (e.positionType === "top") {
    for (var h = e.positionData, f = 0; f < e.children.length; f++) {
      var d = e.children[f];
      h -= d.type === "kern" ? d.size : d.elem.height + d.elem.depth;
    }
    u = h;
  } else if (e.positionType === "bottom")
    u = -e.positionData;
  else {
    var p = e.children[0];
    if (p.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      u = -p.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      u = -p.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: u
  };
}, Pke = function(e, r) {
  for (var {
    children: n,
    depth: i
  } = Oke(e), a = 0, s = 0; s < n.length; s++) {
    var o = n[s];
    if (o.type === "elem") {
      var l = o.elem;
      a = Math.max(a, l.maxFontSize, l.height);
    }
  }
  a += 2;
  var u = na(["pstrut"], []);
  u.style.height = pt(a);
  for (var h = [], f = i, d = i, p = i, g = 0; g < n.length; g++) {
    var m = n[g];
    if (m.type === "kern")
      p += m.size;
    else {
      var v = m.elem, y = m.wrapperClasses || [], b = m.wrapperStyle || {}, x = na(y, [u, v], void 0, b);
      x.style.top = pt(-a - p - v.depth), m.marginLeft && (x.style.marginLeft = m.marginLeft), m.marginRight && (x.style.marginRight = m.marginRight), h.push(x), p += v.height + v.depth;
    }
    f = Math.min(f, p), d = Math.max(d, p);
  }
  var T = na(["vlist"], h);
  T.style.height = pt(d);
  var E;
  if (f < 0) {
    var A = na([], []), S = na(["vlist"], [A]);
    S.style.height = pt(-f);
    var k = na(["vlist-s"], [new as("\u200B")]);
    E = [na(["vlist-r"], [T, k]), na(["vlist-r"], [S])];
  } else
    E = [na(["vlist-r"], [T])];
  var _ = na(["vlist-t"], E);
  return E.length === 2 && _.classes.push("vlist-t2"), _.height = d, _.depth = -f, _;
}, $ke = (t, e) => {
  var r = na(["mspace"], [], e), n = an(t, e);
  return r.style.marginRight = pt(n), r;
}, xv = function(e, r, n) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var a;
  return r === "textbf" && n === "textit" ? a = "BoldItalic" : r === "textbf" ? a = "Bold" : r === "textit" ? a = "Italic" : a = "Regular", i + "-" + a;
}, Xte = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, jte = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, Bke = function(e, r) {
  var [n, i, a] = jte[e], s = new mc(n), o = new gl([s], {
    width: pt(i),
    height: pt(a),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + pt(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * a,
    preserveAspectRatio: "xMinYMin"
  }), l = Wte(["overlay"], [o], r);
  return l.height = a, l.style.height = pt(a), l.style.width = pt(i), l;
}, Be = {
  fontMap: Xte,
  makeSymbol: vs,
  mathsym: _ke,
  makeSpan: na,
  makeSvgSpan: Wte,
  makeLineSpan: Mke,
  makeAnchor: Nke,
  makeFragment: Yte,
  wrapFragment: Dke,
  makeVList: Pke,
  makeOrd: Lke,
  makeGlue: $ke,
  staticSvg: Bke,
  svgData: jte,
  tryCombineChars: Ike
}, nn = {
  number: 3,
  unit: "mu"
}, uu = {
  number: 4,
  unit: "mu"
}, Bo = {
  number: 5,
  unit: "mu"
}, Fke = {
  mord: {
    mop: nn,
    mbin: uu,
    mrel: Bo,
    minner: nn
  },
  mop: {
    mord: nn,
    mop: nn,
    mrel: Bo,
    minner: nn
  },
  mbin: {
    mord: uu,
    mop: uu,
    mopen: uu,
    minner: uu
  },
  mrel: {
    mord: Bo,
    mop: Bo,
    mopen: Bo,
    minner: Bo
  },
  mopen: {},
  mclose: {
    mop: nn,
    mbin: uu,
    mrel: Bo,
    minner: nn
  },
  mpunct: {
    mord: nn,
    mop: nn,
    mrel: Bo,
    mopen: nn,
    mclose: nn,
    mpunct: nn,
    minner: nn
  },
  minner: {
    mord: nn,
    mop: nn,
    mbin: uu,
    mrel: Bo,
    mopen: nn,
    mpunct: nn,
    minner: nn
  }
}, zke = {
  mord: {
    mop: nn
  },
  mop: {
    mord: nn,
    mop: nn
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: nn
  },
  mpunct: {},
  minner: {
    mop: nn
  }
}, Kte = {}, xb = {}, wb = {};
function Tt(t) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: s
  } = t, o = {
    type: e,
    numArgs: n.numArgs,
    argTypes: n.argTypes,
    allowedInArgument: !!n.allowedInArgument,
    allowedInText: !!n.allowedInText,
    allowedInMath: n.allowedInMath === void 0 ? !0 : n.allowedInMath,
    numOptionalArgs: n.numOptionalArgs || 0,
    infix: !!n.infix,
    primitive: !!n.primitive,
    handler: i
  }, l = 0; l < r.length; ++l)
    Kte[r[l]] = o;
  e && (a && (xb[e] = a), s && (wb[e] = s));
}
function Rh(t) {
  var {
    type: e,
    htmlBuilder: r,
    mathmlBuilder: n
  } = t;
  Tt({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: r,
    mathmlBuilder: n
  });
}
var Tb = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, Tn = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, ml = Be.makeSpan, qke = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], Gke = ["rightmost", "mrel", "mclose", "mpunct"], Uke = {
  display: Gt.DISPLAY,
  text: Gt.TEXT,
  script: Gt.SCRIPT,
  scriptscript: Gt.SCRIPTSCRIPT
}, Vke = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, Un = function(e, r, n, i) {
  i === void 0 && (i = [null, null]);
  for (var a = [], s = 0; s < e.length; s++) {
    var o = br(e[s], r);
    if (o instanceof dm) {
      var l = o.children;
      a.push(...l);
    } else
      a.push(o);
  }
  if (Be.tryCombineChars(a), !n)
    return a;
  var u = r;
  if (e.length === 1) {
    var h = e[0];
    h.type === "sizing" ? u = r.havingSize(h.size) : h.type === "styling" && (u = r.havingStyle(Uke[h.style]));
  }
  var f = ml([i[0] || "leftmost"], [], r), d = ml([i[1] || "rightmost"], [], r), p = n === "root";
  return nz(a, (g, m) => {
    var v = m.classes[0], y = g.classes[0];
    v === "mbin" && Bt.contains(Gke, y) ? m.classes[0] = "mord" : y === "mbin" && Bt.contains(qke, v) && (g.classes[0] = "mord");
  }, {
    node: f
  }, d, p), nz(a, (g, m) => {
    var v = iA(m), y = iA(g), b = v && y ? g.hasClass("mtight") ? zke[v][y] : Fke[v][y] : null;
    if (b)
      return Be.makeGlue(b, u);
  }, {
    node: f
  }, d, p), a;
}, nz = function t(e, r, n, i, a) {
  i && e.push(i);
  for (var s = 0; s < e.length; s++) {
    var o = e[s], l = Zte(o);
    if (l) {
      t(l.children, r, n, null, a);
      continue;
    }
    var u = !o.hasClass("mspace");
    if (u) {
      var h = r(o, n.node);
      h && (n.insertAfter ? n.insertAfter(h) : (e.unshift(h), s++));
    }
    u ? n.node = o : a && o.hasClass("newline") && (n.node = ml(["leftmost"])), n.insertAfter = /* @__PURE__ */ ((f) => (d) => {
      e.splice(f + 1, 0, d), s++;
    })(s);
  }
  i && e.pop();
}, Zte = function(e) {
  return e instanceof dm || e instanceof PL || e instanceof pm && e.hasClass("enclosing") ? e : null;
}, Hke = function t(e, r) {
  var n = Zte(e);
  if (n) {
    var i = n.children;
    if (i.length) {
      if (r === "right")
        return t(i[i.length - 1], "right");
      if (r === "left")
        return t(i[0], "left");
    }
  }
  return e;
}, iA = function(e, r) {
  return e ? (r && (e = Hke(e, r)), Vke[e.classes[0]] || null) : null;
}, y1 = function(e, r) {
  var n = ["nulldelimiter"].concat(e.baseSizingClasses());
  return ml(r.concat(n));
}, br = function(e, r, n) {
  if (!e)
    return ml();
  if (xb[e.type]) {
    var i = xb[e.type](e, r);
    if (n && r.size !== n.size) {
      i = ml(r.sizingClasses(n), [i], r);
      var a = r.sizeMultiplier / n.sizeMultiplier;
      i.height *= a, i.depth *= a;
    }
    return i;
  } else
    throw new ot("Got group of unknown type: '" + e.type + "'");
};
function wv(t, e) {
  var r = ml(["base"], t, e), n = ml(["strut"]);
  return n.style.height = pt(r.height + r.depth), r.depth && (n.style.verticalAlign = pt(-r.depth)), r.children.unshift(n), r;
}
function aA(t, e) {
  var r = null;
  t.length === 1 && t[0].type === "tag" && (r = t[0].tag, t = t[0].body);
  var n = Un(t, e, "root"), i;
  n.length === 2 && n[1].hasClass("tag") && (i = n.pop());
  for (var a = [], s = [], o = 0; o < n.length; o++)
    if (s.push(n[o]), n[o].hasClass("mbin") || n[o].hasClass("mrel") || n[o].hasClass("allowbreak")) {
      for (var l = !1; o < n.length - 1 && n[o + 1].hasClass("mspace") && !n[o + 1].hasClass("newline"); )
        o++, s.push(n[o]), n[o].hasClass("nobreak") && (l = !0);
      l || (a.push(wv(s, e)), s = []);
    } else n[o].hasClass("newline") && (s.pop(), s.length > 0 && (a.push(wv(s, e)), s = []), a.push(n[o]));
  s.length > 0 && a.push(wv(s, e));
  var u;
  r ? (u = wv(Un(r, e, !0)), u.classes = ["tag"], a.push(u)) : i && a.push(i);
  var h = ml(["katex-html"], a);
  if (h.setAttribute("aria-hidden", "true"), u) {
    var f = u.children[0];
    f.style.height = pt(h.height + h.depth), h.depth && (f.style.verticalAlign = pt(-h.depth));
  }
  return h;
}
function Qte(t) {
  return new dm(t);
}
class Ca {
  constructor(e, r, n) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = r || [], this.classes = n || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && e.setAttribute(r, this.attributes[r]);
    this.classes.length > 0 && (e.className = gc(this.classes));
    for (var n = 0; n < this.children.length; n++)
      if (this.children[n] instanceof no && this.children[n + 1] instanceof no) {
        for (var i = this.children[n].toText() + this.children[++n].toText(); this.children[n + 1] instanceof no; )
          i += this.children[++n].toText();
        e.appendChild(new no(i).toNode());
      } else
        e.appendChild(this.children[n].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="', e += Bt.escape(this.attributes[r]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + Bt.escape(gc(this.classes)) + '"'), e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class no {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return Bt.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class Wke {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = "\u200A" : e >= 0.1666 && e <= 0.1667 ? this.character = "\u2009" : e >= 0.2222 && e <= 0.2223 ? this.character = "\u2005" : e >= 0.2777 && e <= 0.2778 ? this.character = "\u2005\u200A" : e >= -0.05556 && e <= -0.05555 ? this.character = "\u200A\u2063" : e >= -0.1667 && e <= -0.1666 ? this.character = "\u2009\u2063" : e >= -0.2223 && e <= -0.2222 ? this.character = "\u205F\u2063" : e >= -0.2778 && e <= -0.2777 ? this.character = "\u2005\u2063" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", pt(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + pt(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var it = {
  MathNode: Ca,
  TextNode: no,
  SpaceNode: Wke,
  newDocumentFragment: Qte
}, ss = function(e, r, n) {
  return Gr[r][e] && Gr[r][e].replace && e.charCodeAt(0) !== 55349 && !(Hte.hasOwnProperty(e) && n && (n.fontFamily && n.fontFamily.slice(4, 6) === "tt" || n.font && n.font.slice(4, 6) === "tt")) && (e = Gr[r][e].replace), new it.TextNode(e);
}, BL = function(e) {
  return e.length === 1 ? e[0] : new it.MathNode("mrow", e);
}, FL = function(e, r) {
  if (r.fontFamily === "texttt")
    return "monospace";
  if (r.fontFamily === "textsf")
    return r.fontShape === "textit" && r.fontWeight === "textbf" ? "sans-serif-bold-italic" : r.fontShape === "textit" ? "sans-serif-italic" : r.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (r.fontShape === "textit" && r.fontWeight === "textbf")
    return "bold-italic";
  if (r.fontShape === "textit")
    return "italic";
  if (r.fontWeight === "textbf")
    return "bold";
  var n = r.font;
  if (!n || n === "mathnormal")
    return null;
  var i = e.mode;
  if (n === "mathit")
    return "italic";
  if (n === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (n === "mathbf")
    return "bold";
  if (n === "mathbb")
    return "double-struck";
  if (n === "mathsfit")
    return "sans-serif-italic";
  if (n === "mathfrak")
    return "fraktur";
  if (n === "mathscr" || n === "mathcal")
    return "script";
  if (n === "mathsf")
    return "sans-serif";
  if (n === "mathtt")
    return "monospace";
  var a = e.text;
  if (Bt.contains(["\\imath", "\\jmath"], a))
    return null;
  Gr[i][a] && Gr[i][a].replace && (a = Gr[i][a].replace);
  var s = Be.fontMap[n].fontName;
  return OL(a, s, i) ? Be.fontMap[n].variant : null;
};
function fk(t) {
  if (!t)
    return !1;
  if (t.type === "mi" && t.children.length === 1) {
    var e = t.children[0];
    return e instanceof no && e.text === ".";
  } else if (t.type === "mo" && t.children.length === 1 && t.getAttribute("separator") === "true" && t.getAttribute("lspace") === "0em" && t.getAttribute("rspace") === "0em") {
    var r = t.children[0];
    return r instanceof no && r.text === ",";
  } else
    return !1;
}
var ga = function(e, r, n) {
  if (e.length === 1) {
    var i = $r(e[0], r);
    return n && i instanceof Ca && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var a = [], s, o = 0; o < e.length; o++) {
    var l = $r(e[o], r);
    if (l instanceof Ca && s instanceof Ca) {
      if (l.type === "mtext" && s.type === "mtext" && l.getAttribute("mathvariant") === s.getAttribute("mathvariant")) {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && s.type === "mn") {
        s.children.push(...l.children);
        continue;
      } else if (fk(l) && s.type === "mn") {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && fk(s))
        l.children = [...s.children, ...l.children], a.pop();
      else if ((l.type === "msup" || l.type === "msub") && l.children.length >= 1 && (s.type === "mn" || fk(s))) {
        var u = l.children[0];
        u instanceof Ca && u.type === "mn" && (u.children = [...s.children, ...u.children], a.pop());
      } else if (s.type === "mi" && s.children.length === 1) {
        var h = s.children[0];
        if (h instanceof no && h.text === "\u0338" && (l.type === "mo" || l.type === "mi" || l.type === "mn")) {
          var f = l.children[0];
          f instanceof no && f.text.length > 0 && (f.text = f.text.slice(0, 1) + "\u0338" + f.text.slice(1), a.pop());
        }
      }
    }
    a.push(l), s = l;
  }
  return a;
}, vc = function(e, r, n) {
  return BL(ga(e, r, n));
}, $r = function(e, r) {
  if (!e)
    return new it.MathNode("mrow");
  if (wb[e.type]) {
    var n = wb[e.type](e, r);
    return n;
  } else
    throw new ot("Got group of unknown type: '" + e.type + "'");
};
function iz(t, e, r, n, i) {
  var a = ga(t, r), s;
  a.length === 1 && a[0] instanceof Ca && Bt.contains(["mrow", "mtable"], a[0].type) ? s = a[0] : s = new it.MathNode("mrow", a);
  var o = new it.MathNode("annotation", [new it.TextNode(e)]);
  o.setAttribute("encoding", "application/x-tex");
  var l = new it.MathNode("semantics", [s, o]), u = new it.MathNode("math", [l]);
  u.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), n && u.setAttribute("display", "block");
  var h = i ? "katex" : "katex-mathml";
  return Be.makeSpan([h], [u]);
}
var Jte = function(e) {
  return new Wo({
    style: e.displayMode ? Gt.DISPLAY : Gt.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, ere = function(e, r) {
  if (r.displayMode) {
    var n = ["katex-display"];
    r.leqno && n.push("leqno"), r.fleqn && n.push("fleqn"), e = Be.makeSpan(n, [e]);
  }
  return e;
}, Yke = function(e, r, n) {
  var i = Jte(n), a;
  if (n.output === "mathml")
    return iz(e, r, i, n.displayMode, !0);
  if (n.output === "html") {
    var s = aA(e, i);
    a = Be.makeSpan(["katex"], [s]);
  } else {
    var o = iz(e, r, i, n.displayMode, !1), l = aA(e, i);
    a = Be.makeSpan(["katex"], [o, l]);
  }
  return ere(a, n);
}, Xke = function(e, r, n) {
  var i = Jte(n), a = aA(e, i), s = Be.makeSpan(["katex"], [a]);
  return ere(s, n);
}, jke = {
  widehat: "^",
  widecheck: "\u02C7",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23DF",
  overbrace: "\u23DE",
  overgroup: "\u23E0",
  undergroup: "\u23E1",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21D2",
  xRightarrow: "\u21D2",
  overleftharpoon: "\u21BC",
  xleftharpoonup: "\u21BC",
  overrightharpoon: "\u21C0",
  xrightharpoonup: "\u21C0",
  xLeftarrow: "\u21D0",
  xLeftrightarrow: "\u21D4",
  xhookleftarrow: "\u21A9",
  xhookrightarrow: "\u21AA",
  xmapsto: "\u21A6",
  xrightharpoondown: "\u21C1",
  xleftharpoondown: "\u21BD",
  xrightleftharpoons: "\u21CC",
  xleftrightharpoons: "\u21CB",
  xtwoheadleftarrow: "\u219E",
  xtwoheadrightarrow: "\u21A0",
  xlongequal: "=",
  xtofrom: "\u21C4",
  xrightleftarrows: "\u21C4",
  xrightequilibrium: "\u21CC",
  // Not a perfect match.
  xleftequilibrium: "\u21CB",
  // None better available.
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
}, Kke = function(e) {
  var r = new it.MathNode("mo", [new it.TextNode(jke[e.replace(/^\\/, "")])]);
  return r.setAttribute("stretchy", "true"), r;
}, Zke = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, Qke = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, Jke = function(e, r) {
  function n() {
    var o = 4e5, l = e.label.slice(1);
    if (Bt.contains(["widehat", "widecheck", "widetilde", "utilde"], l)) {
      var u = e, h = Qke(u.base), f, d, p;
      if (h > 5)
        l === "widehat" || l === "widecheck" ? (f = 420, o = 2364, p = 0.42, d = l + "4") : (f = 312, o = 2340, p = 0.34, d = "tilde4");
      else {
        var g = [1, 1, 2, 2, 3, 3][h];
        l === "widehat" || l === "widecheck" ? (o = [0, 1062, 2364, 2364, 2364][g], f = [0, 239, 300, 360, 420][g], p = [0, 0.24, 0.3, 0.3, 0.36, 0.42][g], d = l + g) : (o = [0, 600, 1033, 2339, 2340][g], f = [0, 260, 286, 306, 312][g], p = [0, 0.26, 0.286, 0.3, 0.306, 0.34][g], d = "tilde" + g);
      }
      var m = new mc(d), v = new gl([m], {
        width: "100%",
        height: pt(p),
        viewBox: "0 0 " + o + " " + f,
        preserveAspectRatio: "none"
      });
      return {
        span: Be.makeSvgSpan([], [v], r),
        minWidth: 0,
        height: p
      };
    } else {
      var y = [], b = Zke[l], [x, T, E] = b, A = E / 1e3, S = x.length, k, _;
      if (S === 1) {
        var R = b[3];
        k = ["hide-tail"], _ = [R];
      } else if (S === 2)
        k = ["halfarrow-left", "halfarrow-right"], _ = ["xMinYMin", "xMaxYMin"];
      else if (S === 3)
        k = ["brace-left", "brace-center", "brace-right"], _ = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + S + " children.");
      for (var L = 0; L < S; L++) {
        var M = new mc(x[L]), P = new gl([M], {
          width: "400em",
          height: pt(A),
          viewBox: "0 0 " + o + " " + E,
          preserveAspectRatio: _[L] + " slice"
        }), C = Be.makeSvgSpan([k[L]], [P], r);
        if (S === 1)
          return {
            span: C,
            minWidth: T,
            height: A
          };
        C.style.height = pt(A), y.push(C);
      }
      return {
        span: Be.makeSpan(["stretchy"], y, r),
        minWidth: T,
        height: A
      };
    }
  }
  var {
    span: i,
    minWidth: a,
    height: s
  } = n();
  return i.height = s, i.style.height = pt(s), a > 0 && (i.style.minWidth = pt(a)), i;
}, eCe = function(e, r, n, i, a) {
  var s, o = e.height + e.depth + n + i;
  if (/fbox|color|angl/.test(r)) {
    if (s = Be.makeSpan(["stretchy", r], [], a), r === "fbox") {
      var l = a.color && a.getColor();
      l && (s.style.borderColor = l);
    }
  } else {
    var u = [];
    /^[bx]cancel$/.test(r) && u.push(new rA({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(r) && u.push(new rA({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var h = new gl(u, {
      width: "100%",
      height: pt(o)
    });
    s = Be.makeSvgSpan([], [h], a);
  }
  return s.height = o, s.style.height = pt(o), s;
}, vl = {
  encloseSpan: eCe,
  mathMLnode: Kke,
  svgSpan: Jke
};
function tr(t, e) {
  if (!t || t.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (t ? "node of type " + t.type : String(t)));
  return t;
}
function zL(t) {
  var e = P4(t);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (t ? "node of type " + t.type : String(t)));
  return e;
}
function P4(t) {
  return t && (t.type === "atom" || kke.hasOwnProperty(t.type)) ? t : null;
}
var qL = (t, e) => {
  var r, n, i;
  t && t.type === "supsub" ? (n = tr(t.base, "accent"), r = n.base, t.base = r, i = Eke(br(t, e)), t.base = n) : (n = tr(t, "accent"), r = n.base);
  var a = br(r, e.havingCrampedStyle()), s = n.isShifty && Bt.isCharacterBox(r), o = 0;
  if (s) {
    var l = Bt.getBaseElem(r), u = br(l, e.havingCrampedStyle());
    o = ZF(u).skew;
  }
  var h = n.label === "\\c", f = h ? a.height + a.depth : Math.min(a.height, e.fontMetrics().xHeight), d;
  if (n.isStretchy)
    d = vl.svgSpan(n, e), d = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "elem",
        elem: d,
        wrapperClasses: ["svg-align"],
        wrapperStyle: o > 0 ? {
          width: "calc(100% - " + pt(2 * o) + ")",
          marginLeft: pt(2 * o)
        } : void 0
      }]
    }, e);
  else {
    var p, g;
    n.label === "\\vec" ? (p = Be.staticSvg("vec", e), g = Be.svgData.vec[1]) : (p = Be.makeOrd({
      mode: n.mode,
      text: n.label
    }, e, "textord"), p = ZF(p), p.italic = 0, g = p.width, h && (f += p.depth)), d = Be.makeSpan(["accent-body"], [p]);
    var m = n.label === "\\textcircled";
    m && (d.classes.push("accent-full"), f = a.height);
    var v = o;
    m || (v -= g / 2), d.style.left = pt(v), n.label === "\\textcircled" && (d.style.top = ".2em"), d = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: -f
      }, {
        type: "elem",
        elem: d
      }]
    }, e);
  }
  var y = Be.makeSpan(["mord", "accent"], [d], e);
  return i ? (i.children[0] = y, i.height = Math.max(y.height, i.height), i.classes[0] = "mord", i) : y;
}, tre = (t, e) => {
  var r = t.isStretchy ? vl.mathMLnode(t.label) : new it.MathNode("mo", [ss(t.label, t.mode)]), n = new it.MathNode("mover", [$r(t.base, e), r]);
  return n.setAttribute("accent", "true"), n;
}, tCe = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((t) => "\\" + t).join("|"));
Tt({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var r = Tb(e[0]), n = !tCe.test(t.funcName), i = !n || t.funcName === "\\widehat" || t.funcName === "\\widetilde" || t.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: t.parser.mode,
      label: t.funcName,
      isStretchy: n,
      isShifty: i,
      base: r
    };
  },
  htmlBuilder: qL,
  mathmlBuilder: tre
});
Tt({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    var r = e[0], n = t.parser.mode;
    return n === "math" && (t.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + t.funcName + " works only in text mode"), n = "text"), {
      type: "accent",
      mode: n,
      label: t.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: r
    };
  },
  htmlBuilder: qL,
  mathmlBuilder: tre
});
Tt({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "accentUnder",
      mode: r.mode,
      label: n,
      base: i
    };
  },
  htmlBuilder: (t, e) => {
    var r = br(t.base, e), n = vl.svgSpan(t, e), i = t.label === "\\utilde" ? 0.12 : 0, a = Be.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "elem",
        elem: n,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return Be.makeSpan(["mord", "accentunder"], [a], e);
  },
  mathmlBuilder: (t, e) => {
    var r = vl.mathMLnode(t.label), n = new it.MathNode("munder", [$r(t.base, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
var Tv = (t) => {
  var e = new it.MathNode("mpadded", t ? [t] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
Tt({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: i
    } = t;
    return {
      type: "xArrow",
      mode: n.mode,
      label: i,
      body: e[0],
      below: r[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(t, e) {
    var r = e.style, n = e.havingStyle(r.sup()), i = Be.wrapFragment(br(t.body, n, e), e), a = t.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(a + "-arrow-pad");
    var s;
    t.below && (n = e.havingStyle(r.sub()), s = Be.wrapFragment(br(t.below, n, e), e), s.classes.push(a + "-arrow-pad"));
    var o = vl.svgSpan(t, e), l = -e.fontMetrics().axisHeight + 0.5 * o.height, u = -e.fontMetrics().axisHeight - 0.5 * o.height - 0.111;
    (i.depth > 0.25 || t.label === "\\xleftequilibrium") && (u -= i.depth);
    var h;
    if (s) {
      var f = -e.fontMetrics().axisHeight + s.height + 0.5 * o.height + 0.111;
      h = Be.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: l
        }, {
          type: "elem",
          elem: s,
          shift: f
        }]
      }, e);
    } else
      h = Be.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: l
        }]
      }, e);
    return h.children[0].children[0].children[1].classes.push("svg-align"), Be.makeSpan(["mrel", "x-arrow"], [h], e);
  },
  mathmlBuilder(t, e) {
    var r = vl.mathMLnode(t.label);
    r.setAttribute("minsize", t.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var n;
    if (t.body) {
      var i = Tv($r(t.body, e));
      if (t.below) {
        var a = Tv($r(t.below, e));
        n = new it.MathNode("munderover", [r, a, i]);
      } else
        n = new it.MathNode("mover", [r, i]);
    } else if (t.below) {
      var s = Tv($r(t.below, e));
      n = new it.MathNode("munder", [r, s]);
    } else
      n = Tv(), n = new it.MathNode("mover", [r, n]);
    return n;
  }
});
var rCe = Be.makeSpan;
function rre(t, e) {
  var r = Un(t.body, e, !0);
  return rCe([t.mclass], r, e);
}
function nre(t, e) {
  var r, n = ga(t.body, e);
  return t.mclass === "minner" ? r = new it.MathNode("mpadded", n) : t.mclass === "mord" ? t.isCharacterBox ? (r = n[0], r.type = "mi") : r = new it.MathNode("mi", n) : (t.isCharacterBox ? (r = n[0], r.type = "mo") : r = new it.MathNode("mo", n), t.mclass === "mbin" ? (r.attributes.lspace = "0.22em", r.attributes.rspace = "0.22em") : t.mclass === "mpunct" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0.17em") : t.mclass === "mopen" || t.mclass === "mclose" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0em") : t.mclass === "minner" && (r.attributes.lspace = "0.0556em", r.attributes.width = "+0.1111em")), r;
}
Tt({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "mclass",
      mode: r.mode,
      mclass: "m" + n.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: Tn(i),
      isCharacterBox: Bt.isCharacterBox(i)
    };
  },
  htmlBuilder: rre,
  mathmlBuilder: nre
});
var $4 = (t) => {
  var e = t.type === "ordgroup" && t.body.length ? t.body[0] : t;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
Tt({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "mclass",
      mode: r.mode,
      mclass: $4(e[0]),
      body: Tn(e[1]),
      isCharacterBox: Bt.isCharacterBox(e[1])
    };
  }
});
Tt({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[1], a = e[0], s;
    n !== "\\stackrel" ? s = $4(i) : s = "mrel";
    var o = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: n !== "\\stackrel",
      body: Tn(i)
    }, l = {
      type: "supsub",
      mode: a.mode,
      base: o,
      sup: n === "\\underset" ? null : a,
      sub: n === "\\underset" ? a : null
    };
    return {
      type: "mclass",
      mode: r.mode,
      mclass: s,
      body: [l],
      isCharacterBox: Bt.isCharacterBox(l)
    };
  },
  htmlBuilder: rre,
  mathmlBuilder: nre
});
Tt({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "pmb",
      mode: r.mode,
      mclass: $4(e[0]),
      body: Tn(e[0])
    };
  },
  htmlBuilder(t, e) {
    var r = Un(t.body, e, !0), n = Be.makeSpan([t.mclass], r, e);
    return n.style.textShadow = "0.02em 0.01em 0.04px", n;
  },
  mathmlBuilder(t, e) {
    var r = ga(t.body, e), n = new it.MathNode("mstyle", r);
    return n.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), n;
  }
});
var nCe = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, az = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), sz = (t) => t.type === "textord" && t.text === "@", iCe = (t, e) => (t.type === "mathord" || t.type === "atom") && t.text === e;
function aCe(t, e, r) {
  var n = nCe[t];
  switch (n) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return r.callFunction(n, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = r.callFunction("\\\\cdleft", [e[0]], []), a = {
        type: "atom",
        text: n,
        mode: "math",
        family: "rel"
      }, s = r.callFunction("\\Big", [a], []), o = r.callFunction("\\\\cdright", [e[1]], []), l = {
        type: "ordgroup",
        mode: "math",
        body: [i, s, o]
      };
      return r.callFunction("\\\\cdparent", [l], []);
    }
    case "\\\\cdlongequal":
      return r.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var u = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return r.callFunction("\\Big", [u], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function sCe(t) {
  var e = [];
  for (t.gullet.beginGroup(), t.gullet.macros.set("\\cr", "\\\\\\relax"), t.gullet.beginGroup(); ; ) {
    e.push(t.parseExpression(!1, "\\\\")), t.gullet.endGroup(), t.gullet.beginGroup();
    var r = t.fetch().text;
    if (r === "&" || r === "\\\\")
      t.consume();
    else if (r === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new ot("Expected \\\\ or \\cr or \\end", t.nextToken);
  }
  for (var n = [], i = [n], a = 0; a < e.length; a++) {
    for (var s = e[a], o = az(), l = 0; l < s.length; l++)
      if (!sz(s[l]))
        o.body.push(s[l]);
      else {
        n.push(o), l += 1;
        var u = zL(s[l]).text, h = new Array(2);
        if (h[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, h[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(u) > -1)) if ("<>AV".indexOf(u) > -1)
          for (var f = 0; f < 2; f++) {
            for (var d = !0, p = l + 1; p < s.length; p++) {
              if (iCe(s[p], u)) {
                d = !1, l = p;
                break;
              }
              if (sz(s[p]))
                throw new ot("Missing a " + u + " character to complete a CD arrow.", s[p]);
              h[f].body.push(s[p]);
            }
            if (d)
              throw new ot("Missing a " + u + " character to complete a CD arrow.", s[l]);
          }
        else
          throw new ot('Expected one of "<>AV=|." after @', s[l]);
        var g = aCe(u, h, t), m = {
          type: "styling",
          body: [g],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        n.push(m), o = az();
      }
    a % 2 === 0 ? n.push(o) : n.shift(), n = [], i.push(n);
  }
  t.gullet.endGroup(), t.gullet.endGroup();
  var v = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: v,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
Tt({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t;
    return {
      type: "cdlabel",
      mode: r.mode,
      side: n.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = e.havingStyle(e.style.sup()), n = Be.wrapFragment(br(t.label, r, e), e);
    return n.classes.push("cd-label-" + t.side), n.style.bottom = pt(0.8 - n.depth), n.height = 0, n.depth = 0, n;
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mrow", [$r(t.label, e)]);
    return r = new it.MathNode("mpadded", [r]), r.setAttribute("width", "0"), t.side === "left" && r.setAttribute("lspace", "-1width"), r.setAttribute("voffset", "0.7em"), r = new it.MathNode("mstyle", [r]), r.setAttribute("displaystyle", "false"), r.setAttribute("scriptlevel", "1"), r;
  }
});
Tt({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "cdlabelparent",
      mode: r.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = Be.wrapFragment(br(t.fragment, e), e);
    return r.classes.push("cd-vert-arrow"), r;
  },
  mathmlBuilder(t, e) {
    return new it.MathNode("mrow", [$r(t.fragment, e)]);
  }
});
Tt({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    for (var {
      parser: r
    } = t, n = tr(e[0], "ordgroup"), i = n.body, a = "", s = 0; s < i.length; s++) {
      var o = tr(i[s], "textord");
      a += o.text;
    }
    var l = parseInt(a), u;
    if (isNaN(l))
      throw new ot("\\@char has non-numeric argument " + a);
    if (l < 0 || l >= 1114111)
      throw new ot("\\@char with invalid code point " + a);
    return l <= 65535 ? u = String.fromCharCode(l) : (l -= 65536, u = String.fromCharCode((l >> 10) + 55296, (l & 1023) + 56320)), {
      type: "textord",
      mode: r.mode,
      text: u
    };
  }
});
var ire = (t, e) => {
  var r = Un(t.body, e.withColor(t.color), !1);
  return Be.makeFragment(r);
}, are = (t, e) => {
  var r = ga(t.body, e.withColor(t.color)), n = new it.MathNode("mstyle", r);
  return n.setAttribute("mathcolor", t.color), n;
};
Tt({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = tr(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: r.mode,
      color: n,
      body: Tn(i)
    };
  },
  htmlBuilder: ire,
  mathmlBuilder: are
});
Tt({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(t, e) {
    var {
      parser: r,
      breakOnTokenText: n
    } = t, i = tr(e[0], "color-token").color;
    r.gullet.macros.set("\\current@color", i);
    var a = r.parseExpression(!0, n);
    return {
      type: "color",
      mode: r.mode,
      color: i,
      body: a
    };
  },
  htmlBuilder: ire,
  mathmlBuilder: are
});
Tt({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, i = n.gullet.future().text === "[" ? n.parseSizeGroup(!0) : null, a = !n.settings.displayMode || !n.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: n.mode,
      newLine: a,
      size: i && tr(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(t, e) {
    var r = Be.makeSpan(["mspace"], [], e);
    return t.newLine && (r.classes.push("newline"), t.size && (r.style.marginTop = pt(an(t.size, e)))), r;
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mspace");
    return t.newLine && (r.setAttribute("linebreak", "newline"), t.size && r.setAttribute("height", pt(an(t.size, e)))), r;
  }
});
var sA = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, sre = (t) => {
  var e = t.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new ot("Expected a control sequence", t);
  return e;
}, oCe = (t) => {
  var e = t.gullet.popToken();
  return e.text === "=" && (e = t.gullet.popToken(), e.text === " " && (e = t.gullet.popToken())), e;
}, ore = (t, e, r, n) => {
  var i = t.gullet.macros.get(r.text);
  i == null && (r.noexpand = !0, i = {
    tokens: [r],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !t.gullet.isExpandable(r.text)
  }), t.gullet.macros.set(e, i, n);
};
Tt({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    e.consumeSpaces();
    var n = e.fetch();
    if (sA[n.text])
      return (r === "\\global" || r === "\\\\globallong") && (n.text = sA[n.text]), tr(e.parseFunction(), "internal");
    throw new ot("Invalid token after macro prefix", n);
  }
});
Tt({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = e.gullet.popToken(), i = n.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new ot("Expected a control sequence", n);
    for (var a = 0, s, o = [[]]; e.gullet.future().text !== "{"; )
      if (n = e.gullet.popToken(), n.text === "#") {
        if (e.gullet.future().text === "{") {
          s = e.gullet.future(), o[a].push("{");
          break;
        }
        if (n = e.gullet.popToken(), !/^[1-9]$/.test(n.text))
          throw new ot('Invalid argument number "' + n.text + '"');
        if (parseInt(n.text) !== a + 1)
          throw new ot('Argument number "' + n.text + '" out of order');
        a++, o.push([]);
      } else {
        if (n.text === "EOF")
          throw new ot("Expected a macro definition");
        o[a].push(n.text);
      }
    var {
      tokens: l
    } = e.gullet.consumeArg();
    return s && l.unshift(s), (r === "\\edef" || r === "\\xdef") && (l = e.gullet.expandTokens(l), l.reverse()), e.gullet.macros.set(i, {
      tokens: l,
      numArgs: a,
      delimiters: o
    }, r === sA[r]), {
      type: "internal",
      mode: e.mode
    };
  }
});
Tt({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = sre(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = oCe(e);
    return ore(e, n, i, r === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
Tt({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = sre(e.gullet.popToken()), i = e.gullet.popToken(), a = e.gullet.popToken();
    return ore(e, n, a, r === "\\\\globalfuture"), e.gullet.pushToken(a), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var zp = function(e, r, n) {
  var i = Gr.math[e] && Gr.math[e].replace, a = OL(i || e, r, n);
  if (!a)
    throw new Error("Unsupported symbol " + e + " and font size " + r + ".");
  return a;
}, GL = function(e, r, n, i) {
  var a = n.havingBaseStyle(r), s = Be.makeSpan(i.concat(a.sizingClasses(n)), [e], n), o = a.sizeMultiplier / n.sizeMultiplier;
  return s.height *= o, s.depth *= o, s.maxFontSize = a.sizeMultiplier, s;
}, lre = function(e, r, n) {
  var i = r.havingBaseStyle(n), a = (1 - r.sizeMultiplier / i.sizeMultiplier) * r.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = pt(a), e.height -= a, e.depth += a;
}, lCe = function(e, r, n, i, a, s) {
  var o = Be.makeSymbol(e, "Main-Regular", a, i), l = GL(o, r, i, s);
  return n && lre(l, i, r), l;
}, cCe = function(e, r, n, i) {
  return Be.makeSymbol(e, "Size" + r + "-Regular", n, i);
}, cre = function(e, r, n, i, a, s) {
  var o = cCe(e, r, a, i), l = GL(Be.makeSpan(["delimsizing", "size" + r], [o], i), Gt.TEXT, i, s);
  return n && lre(l, i, Gt.TEXT), l;
}, dk = function(e, r, n) {
  var i;
  r === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var a = Be.makeSpan(["delimsizinginner", i], [Be.makeSpan([], [Be.makeSymbol(e, r, n)])]);
  return {
    type: "elem",
    elem: a
  };
}, pk = function(e, r, n) {
  var i = ro["Size4-Regular"][e.charCodeAt(0)] ? ro["Size4-Regular"][e.charCodeAt(0)][4] : ro["Size1-Regular"][e.charCodeAt(0)][4], a = new mc("inner", gke(e, Math.round(1e3 * r))), s = new gl([a], {
    width: pt(i),
    height: pt(r),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + pt(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * r),
    preserveAspectRatio: "xMinYMin"
  }), o = Be.makeSvgSpan([], [s], n);
  return o.height = r, o.style.height = pt(r), o.style.width = pt(i), {
    type: "elem",
    elem: o
  };
}, oA = 8e-3, Ev = {
  type: "kern",
  size: -1 * oA
}, uCe = ["|", "\\lvert", "\\rvert", "\\vert"], hCe = ["\\|", "\\lVert", "\\rVert", "\\Vert"], ure = function(e, r, n, i, a, s) {
  var o, l, u, h, f = "", d = 0;
  o = u = h = e, l = null;
  var p = "Size1-Regular";
  e === "\\uparrow" ? u = h = "\u23D0" : e === "\\Uparrow" ? u = h = "\u2016" : e === "\\downarrow" ? o = u = "\u23D0" : e === "\\Downarrow" ? o = u = "\u2016" : e === "\\updownarrow" ? (o = "\\uparrow", u = "\u23D0", h = "\\downarrow") : e === "\\Updownarrow" ? (o = "\\Uparrow", u = "\u2016", h = "\\Downarrow") : Bt.contains(uCe, e) ? (u = "\u2223", f = "vert", d = 333) : Bt.contains(hCe, e) ? (u = "\u2225", f = "doublevert", d = 556) : e === "[" || e === "\\lbrack" ? (o = "\u23A1", u = "\u23A2", h = "\u23A3", p = "Size4-Regular", f = "lbrack", d = 667) : e === "]" || e === "\\rbrack" ? (o = "\u23A4", u = "\u23A5", h = "\u23A6", p = "Size4-Regular", f = "rbrack", d = 667) : e === "\\lfloor" || e === "\u230A" ? (u = o = "\u23A2", h = "\u23A3", p = "Size4-Regular", f = "lfloor", d = 667) : e === "\\lceil" || e === "\u2308" ? (o = "\u23A1", u = h = "\u23A2", p = "Size4-Regular", f = "lceil", d = 667) : e === "\\rfloor" || e === "\u230B" ? (u = o = "\u23A5", h = "\u23A6", p = "Size4-Regular", f = "rfloor", d = 667) : e === "\\rceil" || e === "\u2309" ? (o = "\u23A4", u = h = "\u23A5", p = "Size4-Regular", f = "rceil", d = 667) : e === "(" || e === "\\lparen" ? (o = "\u239B", u = "\u239C", h = "\u239D", p = "Size4-Regular", f = "lparen", d = 875) : e === ")" || e === "\\rparen" ? (o = "\u239E", u = "\u239F", h = "\u23A0", p = "Size4-Regular", f = "rparen", d = 875) : e === "\\{" || e === "\\lbrace" ? (o = "\u23A7", l = "\u23A8", h = "\u23A9", u = "\u23AA", p = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (o = "\u23AB", l = "\u23AC", h = "\u23AD", u = "\u23AA", p = "Size4-Regular") : e === "\\lgroup" || e === "\u27EE" ? (o = "\u23A7", h = "\u23A9", u = "\u23AA", p = "Size4-Regular") : e === "\\rgroup" || e === "\u27EF" ? (o = "\u23AB", h = "\u23AD", u = "\u23AA", p = "Size4-Regular") : e === "\\lmoustache" || e === "\u23B0" ? (o = "\u23A7", h = "\u23AD", u = "\u23AA", p = "Size4-Regular") : (e === "\\rmoustache" || e === "\u23B1") && (o = "\u23AB", h = "\u23A9", u = "\u23AA", p = "Size4-Regular");
  var g = zp(o, p, a), m = g.height + g.depth, v = zp(u, p, a), y = v.height + v.depth, b = zp(h, p, a), x = b.height + b.depth, T = 0, E = 1;
  if (l !== null) {
    var A = zp(l, p, a);
    T = A.height + A.depth, E = 2;
  }
  var S = m + x + T, k = Math.max(0, Math.ceil((r - S) / (E * y))), _ = S + k * E * y, R = i.fontMetrics().axisHeight;
  n && (R *= i.sizeMultiplier);
  var L = _ / 2 - R, M = [];
  if (f.length > 0) {
    var P = _ - m - x, C = Math.round(_ * 1e3), I = mke(f, Math.round(P * 1e3)), N = new mc(f, I), O = (d / 1e3).toFixed(3) + "em", D = (C / 1e3).toFixed(3) + "em", $ = new gl([N], {
      width: O,
      height: D,
      viewBox: "0 0 " + d + " " + C
    }), z = Be.makeSvgSpan([], [$], i);
    z.height = C / 1e3, z.style.width = O, z.style.height = D, M.push({
      type: "elem",
      elem: z
    });
  } else {
    if (M.push(dk(h, p, a)), M.push(Ev), l === null) {
      var B = _ - m - x + 2 * oA;
      M.push(pk(u, B, i));
    } else {
      var G = (_ - m - x - T) / 2 + 2 * oA;
      M.push(pk(u, G, i)), M.push(Ev), M.push(dk(l, p, a)), M.push(Ev), M.push(pk(u, G, i));
    }
    M.push(Ev), M.push(dk(o, p, a));
  }
  var W = i.havingBaseStyle(Gt.TEXT), V = Be.makeVList({
    positionType: "bottom",
    positionData: L,
    children: M
  }, W);
  return GL(Be.makeSpan(["delimsizing", "mult"], [V], W), Gt.TEXT, i, s);
}, gk = 80, mk = 0.08, vk = function(e, r, n, i, a) {
  var s = pke(e, i, n), o = new mc(e, s), l = new gl([o], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: pt(r),
    viewBox: "0 0 400000 " + n,
    preserveAspectRatio: "xMinYMin slice"
  });
  return Be.makeSvgSpan(["hide-tail"], [l], a);
}, fCe = function(e, r) {
  var n = r.havingBaseSizing(), i = pre("\\surd", e * n.sizeMultiplier, dre, n), a = n.sizeMultiplier, s = Math.max(0, r.minRuleThickness - r.fontMetrics().sqrtRuleThickness), o, l = 0, u = 0, h = 0, f;
  return i.type === "small" ? (h = 1e3 + 1e3 * s + gk, e < 1 ? a = 1 : e < 1.4 && (a = 0.7), l = (1 + s + mk) / a, u = (1 + s) / a, o = vk("sqrtMain", l, h, s, r), o.style.minWidth = "0.853em", f = 0.833 / a) : i.type === "large" ? (h = (1e3 + gk) * zg[i.size], u = (zg[i.size] + s) / a, l = (zg[i.size] + s + mk) / a, o = vk("sqrtSize" + i.size, l, h, s, r), o.style.minWidth = "1.02em", f = 1 / a) : (l = e + s + mk, u = e + s, h = Math.floor(1e3 * e + s) + gk, o = vk("sqrtTall", l, h, s, r), o.style.minWidth = "0.742em", f = 1.056), o.height = u, o.style.height = pt(l), {
    span: o,
    advanceWidth: f,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (r.fontMetrics().sqrtRuleThickness + s) * a
  };
}, hre = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"], dCe = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"], fre = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], zg = [0, 1.2, 1.8, 2.4, 3], pCe = function(e, r, n, i, a) {
  if (e === "<" || e === "\\lt" || e === "\u27E8" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "\u27E9") && (e = "\\rangle"), Bt.contains(hre, e) || Bt.contains(fre, e))
    return cre(e, r, !1, n, i, a);
  if (Bt.contains(dCe, e))
    return ure(e, zg[r], !1, n, i, a);
  throw new ot("Illegal delimiter: '" + e + "'");
}, gCe = [{
  type: "small",
  style: Gt.SCRIPTSCRIPT
}, {
  type: "small",
  style: Gt.SCRIPT
}, {
  type: "small",
  style: Gt.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], mCe = [{
  type: "small",
  style: Gt.SCRIPTSCRIPT
}, {
  type: "small",
  style: Gt.SCRIPT
}, {
  type: "small",
  style: Gt.TEXT
}, {
  type: "stack"
}], dre = [{
  type: "small",
  style: Gt.SCRIPTSCRIPT
}, {
  type: "small",
  style: Gt.SCRIPT
}, {
  type: "small",
  style: Gt.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], vCe = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, pre = function(e, r, n, i) {
  for (var a = Math.min(2, 3 - i.style.size), s = a; s < n.length && n[s].type !== "stack"; s++) {
    var o = zp(e, vCe(n[s]), "math"), l = o.height + o.depth;
    if (n[s].type === "small") {
      var u = i.havingBaseStyle(n[s].style);
      l *= u.sizeMultiplier;
    }
    if (l > r)
      return n[s];
  }
  return n[n.length - 1];
}, gre = function(e, r, n, i, a, s) {
  e === "<" || e === "\\lt" || e === "\u27E8" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "\u27E9") && (e = "\\rangle");
  var o;
  Bt.contains(fre, e) ? o = gCe : Bt.contains(hre, e) ? o = dre : o = mCe;
  var l = pre(e, r, o, i);
  return l.type === "small" ? lCe(e, l.style, n, i, a, s) : l.type === "large" ? cre(e, l.size, n, i, a, s) : ure(e, r, n, i, a, s);
}, yCe = function(e, r, n, i, a, s) {
  var o = i.fontMetrics().axisHeight * i.sizeMultiplier, l = 901, u = 5 / i.fontMetrics().ptPerEm, h = Math.max(r - o, n + o), f = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    h / 500 * l,
    2 * h - u
  );
  return gre(e, f, !0, i, a, s);
}, ol = {
  sqrtImage: fCe,
  sizedDelim: pCe,
  sizeToMaxHeight: zg,
  customSizedDelim: gre,
  leftRightDelim: yCe
}, oz = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, bCe = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function B4(t, e) {
  var r = P4(t);
  if (r && Bt.contains(bCe, r.text))
    return r;
  throw r ? new ot("Invalid delimiter '" + r.text + "' after '" + e.funcName + "'", t) : new ot("Invalid delimiter type '" + t.type + "'", t);
}
Tt({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    var r = B4(e[0], t);
    return {
      type: "delimsizing",
      mode: t.parser.mode,
      size: oz[t.funcName].size,
      mclass: oz[t.funcName].mclass,
      delim: r.text
    };
  },
  htmlBuilder: (t, e) => t.delim === "." ? Be.makeSpan([t.mclass]) : ol.sizedDelim(t.delim, t.size, e, t.mode, [t.mclass]),
  mathmlBuilder: (t) => {
    var e = [];
    t.delim !== "." && e.push(ss(t.delim, t.mode));
    var r = new it.MathNode("mo", e);
    t.mclass === "mopen" || t.mclass === "mclose" ? r.setAttribute("fence", "true") : r.setAttribute("fence", "false"), r.setAttribute("stretchy", "true");
    var n = pt(ol.sizeToMaxHeight[t.size]);
    return r.setAttribute("minsize", n), r.setAttribute("maxsize", n), r;
  }
});
function lz(t) {
  if (!t.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
Tt({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = t.parser.gullet.macros.get("\\current@color");
    if (r && typeof r != "string")
      throw new ot("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: t.parser.mode,
      delim: B4(e[0], t).text,
      color: r
      // undefined if not set via \color
    };
  }
});
Tt({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = B4(e[0], t), n = t.parser;
    ++n.leftrightDepth;
    var i = n.parseExpression(!1);
    --n.leftrightDepth, n.expect("\\right", !1);
    var a = tr(n.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: n.mode,
      body: i,
      left: r.text,
      right: a.delim,
      rightColor: a.color
    };
  },
  htmlBuilder: (t, e) => {
    lz(t);
    for (var r = Un(t.body, e, !0, ["mopen", "mclose"]), n = 0, i = 0, a = !1, s = 0; s < r.length; s++)
      r[s].isMiddle ? a = !0 : (n = Math.max(r[s].height, n), i = Math.max(r[s].depth, i));
    n *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var o;
    if (t.left === "." ? o = y1(e, ["mopen"]) : o = ol.leftRightDelim(t.left, n, i, e, t.mode, ["mopen"]), r.unshift(o), a)
      for (var l = 1; l < r.length; l++) {
        var u = r[l], h = u.isMiddle;
        h && (r[l] = ol.leftRightDelim(h.delim, n, i, h.options, t.mode, []));
      }
    var f;
    if (t.right === ".")
      f = y1(e, ["mclose"]);
    else {
      var d = t.rightColor ? e.withColor(t.rightColor) : e;
      f = ol.leftRightDelim(t.right, n, i, d, t.mode, ["mclose"]);
    }
    return r.push(f), Be.makeSpan(["minner"], r, e);
  },
  mathmlBuilder: (t, e) => {
    lz(t);
    var r = ga(t.body, e);
    if (t.left !== ".") {
      var n = new it.MathNode("mo", [ss(t.left, t.mode)]);
      n.setAttribute("fence", "true"), r.unshift(n);
    }
    if (t.right !== ".") {
      var i = new it.MathNode("mo", [ss(t.right, t.mode)]);
      i.setAttribute("fence", "true"), t.rightColor && i.setAttribute("mathcolor", t.rightColor), r.push(i);
    }
    return BL(r);
  }
});
Tt({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = B4(e[0], t);
    if (!t.parser.leftrightDepth)
      throw new ot("\\middle without preceding \\left", r);
    return {
      type: "middle",
      mode: t.parser.mode,
      delim: r.text
    };
  },
  htmlBuilder: (t, e) => {
    var r;
    if (t.delim === ".")
      r = y1(e, []);
    else {
      r = ol.sizedDelim(t.delim, 1, e, t.mode, []);
      var n = {
        delim: t.delim,
        options: e
      };
      r.isMiddle = n;
    }
    return r;
  },
  mathmlBuilder: (t, e) => {
    var r = t.delim === "\\vert" || t.delim === "|" ? ss("|", "text") : ss(t.delim, t.mode), n = new it.MathNode("mo", [r]);
    return n.setAttribute("fence", "true"), n.setAttribute("lspace", "0.05em"), n.setAttribute("rspace", "0.05em"), n;
  }
});
var UL = (t, e) => {
  var r = Be.wrapFragment(br(t.body, e), e), n = t.label.slice(1), i = e.sizeMultiplier, a, s = 0, o = Bt.isCharacterBox(t.body);
  if (n === "sout")
    a = Be.makeSpan(["stretchy", "sout"]), a.height = e.fontMetrics().defaultRuleThickness / i, s = -0.5 * e.fontMetrics().xHeight;
  else if (n === "phase") {
    var l = an({
      number: 0.6,
      unit: "pt"
    }, e), u = an({
      number: 0.35,
      unit: "ex"
    }, e), h = e.havingBaseSizing();
    i = i / h.sizeMultiplier;
    var f = r.height + r.depth + l + u;
    r.style.paddingLeft = pt(f / 2 + l);
    var d = Math.floor(1e3 * f * i), p = fke(d), g = new gl([new mc("phase", p)], {
      width: "400em",
      height: pt(d / 1e3),
      viewBox: "0 0 400000 " + d,
      preserveAspectRatio: "xMinYMin slice"
    });
    a = Be.makeSvgSpan(["hide-tail"], [g], e), a.style.height = pt(f), s = r.depth + l + u;
  } else {
    /cancel/.test(n) ? o || r.classes.push("cancel-pad") : n === "angl" ? r.classes.push("anglpad") : r.classes.push("boxpad");
    var m = 0, v = 0, y = 0;
    /box/.test(n) ? (y = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), m = e.fontMetrics().fboxsep + (n === "colorbox" ? 0 : y), v = m) : n === "angl" ? (y = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), m = 4 * y, v = Math.max(0, 0.25 - r.depth)) : (m = o ? 0.2 : 0, v = m), a = vl.encloseSpan(r, n, m, v, e), /fbox|boxed|fcolorbox/.test(n) ? (a.style.borderStyle = "solid", a.style.borderWidth = pt(y)) : n === "angl" && y !== 0.049 && (a.style.borderTopWidth = pt(y), a.style.borderRightWidth = pt(y)), s = r.depth + v, t.backgroundColor && (a.style.backgroundColor = t.backgroundColor, t.borderColor && (a.style.borderColor = t.borderColor));
  }
  var b;
  if (t.backgroundColor)
    b = Be.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: a,
          shift: s
        },
        {
          type: "elem",
          elem: r,
          shift: 0
        }
      ]
    }, e);
  else {
    var x = /cancel|phase/.test(n) ? ["svg-align"] : [];
    b = Be.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: r,
          shift: 0
        },
        {
          type: "elem",
          elem: a,
          shift: s,
          wrapperClasses: x
        }
      ]
    }, e);
  }
  return /cancel/.test(n) && (b.height = r.height, b.depth = r.depth), /cancel/.test(n) && !o ? Be.makeSpan(["mord", "cancel-lap"], [b], e) : Be.makeSpan(["mord"], [b], e);
}, VL = (t, e) => {
  var r = 0, n = new it.MathNode(t.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [$r(t.body, e)]);
  switch (t.label) {
    case "\\cancel":
      n.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      n.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      n.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      n.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      n.setAttribute("notation", "box");
      break;
    case "\\angl":
      n.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (r = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, n.setAttribute("width", "+" + 2 * r + "pt"), n.setAttribute("height", "+" + 2 * r + "pt"), n.setAttribute("lspace", r + "pt"), n.setAttribute("voffset", r + "pt"), t.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        n.setAttribute("style", "border: " + i + "em solid " + String(t.borderColor));
      }
      break;
    case "\\xcancel":
      n.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return t.backgroundColor && n.setAttribute("mathbackground", t.backgroundColor), n;
};
Tt({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: i
    } = t, a = tr(e[0], "color-token").color, s = e[1];
    return {
      type: "enclose",
      mode: n.mode,
      label: i,
      backgroundColor: a,
      body: s
    };
  },
  htmlBuilder: UL,
  mathmlBuilder: VL
});
Tt({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: i
    } = t, a = tr(e[0], "color-token").color, s = tr(e[1], "color-token").color, o = e[2];
    return {
      type: "enclose",
      mode: n.mode,
      label: i,
      backgroundColor: s,
      borderColor: a,
      body: o
    };
  },
  htmlBuilder: UL,
  mathmlBuilder: VL
});
Tt({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
Tt({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "enclose",
      mode: r.mode,
      label: n,
      body: i
    };
  },
  htmlBuilder: UL,
  mathmlBuilder: VL
});
Tt({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var mre = {};
function Eo(t) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: i,
    htmlBuilder: a,
    mathmlBuilder: s
  } = t, o = {
    type: e,
    numArgs: n.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, l = 0; l < r.length; ++l)
    mre[r[l]] = o;
  a && (xb[e] = a), s && (wb[e] = s);
}
var vre = {};
function le(t, e) {
  vre[t] = e;
}
function cz(t) {
  var e = [];
  t.consumeSpaces();
  var r = t.fetch().text;
  for (r === "\\relax" && (t.consume(), t.consumeSpaces(), r = t.fetch().text); r === "\\hline" || r === "\\hdashline"; )
    t.consume(), e.push(r === "\\hdashline"), t.consumeSpaces(), r = t.fetch().text;
  return e;
}
var F4 = (t) => {
  var e = t.parser.settings;
  if (!e.displayMode)
    throw new ot("{" + t.envName + "} can be used only in display mode.");
};
function HL(t) {
  if (t.indexOf("ed") === -1)
    return t.indexOf("*") === -1;
}
function qc(t, e, r) {
  var {
    hskipBeforeAndAfter: n,
    addJot: i,
    cols: a,
    arraystretch: s,
    colSeparationType: o,
    autoTag: l,
    singleRow: u,
    emptySingleRow: h,
    maxNumCols: f,
    leqno: d
  } = e;
  if (t.gullet.beginGroup(), u || t.gullet.macros.set("\\cr", "\\\\\\relax"), !s) {
    var p = t.gullet.expandMacroAsText("\\arraystretch");
    if (p == null)
      s = 1;
    else if (s = parseFloat(p), !s || s < 0)
      throw new ot("Invalid \\arraystretch: " + p);
  }
  t.gullet.beginGroup();
  var g = [], m = [g], v = [], y = [], b = l != null ? [] : void 0;
  function x() {
    l && t.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function T() {
    b && (t.gullet.macros.get("\\df@tag") ? (b.push(t.subparse([new es("\\df@tag")])), t.gullet.macros.set("\\df@tag", void 0, !0)) : b.push(!!l && t.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (x(), y.push(cz(t)); ; ) {
    var E = t.parseExpression(!1, u ? "\\end" : "\\\\");
    t.gullet.endGroup(), t.gullet.beginGroup(), E = {
      type: "ordgroup",
      mode: t.mode,
      body: E
    }, r && (E = {
      type: "styling",
      mode: t.mode,
      style: r,
      body: [E]
    }), g.push(E);
    var A = t.fetch().text;
    if (A === "&") {
      if (f && g.length === f) {
        if (u || o)
          throw new ot("Too many tab characters: &", t.nextToken);
        t.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      t.consume();
    } else if (A === "\\end") {
      T(), g.length === 1 && E.type === "styling" && E.body[0].body.length === 0 && (m.length > 1 || !h) && m.pop(), y.length < m.length + 1 && y.push([]);
      break;
    } else if (A === "\\\\") {
      t.consume();
      var S = void 0;
      t.gullet.future().text !== " " && (S = t.parseSizeGroup(!0)), v.push(S ? S.value : null), T(), y.push(cz(t)), g = [], m.push(g), x();
    } else
      throw new ot("Expected & or \\\\ or \\cr or \\end", t.nextToken);
  }
  return t.gullet.endGroup(), t.gullet.endGroup(), {
    type: "array",
    mode: t.mode,
    addJot: i,
    arraystretch: s,
    body: m,
    cols: a,
    rowGaps: v,
    hskipBeforeAndAfter: n,
    hLinesBeforeRow: y,
    colSeparationType: o,
    tags: b,
    leqno: d
  };
}
function WL(t) {
  return t.slice(0, 1) === "d" ? "display" : "text";
}
var So = function(e, r) {
  var n, i, a = e.body.length, s = e.hLinesBeforeRow, o = 0, l = new Array(a), u = [], h = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    r.fontMetrics().arrayRuleWidth,
    r.minRuleThickness
    // User override.
  ), f = 1 / r.fontMetrics().ptPerEm, d = 5 * f;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var p = r.havingStyle(Gt.SCRIPT).sizeMultiplier;
    d = 0.2778 * (p / r.sizeMultiplier);
  }
  var g = e.colSeparationType === "CD" ? an({
    number: 3,
    unit: "ex"
  }, r) : 12 * f, m = 3 * f, v = e.arraystretch * g, y = 0.7 * v, b = 0.3 * v, x = 0;
  function T(Y) {
    for (var Ne = 0; Ne < Y.length; ++Ne)
      Ne > 0 && (x += 0.25), u.push({
        pos: x,
        isDashed: Y[Ne]
      });
  }
  for (T(s[0]), n = 0; n < e.body.length; ++n) {
    var E = e.body[n], A = y, S = b;
    o < E.length && (o = E.length);
    var k = new Array(E.length);
    for (i = 0; i < E.length; ++i) {
      var _ = br(E[i], r);
      S < _.depth && (S = _.depth), A < _.height && (A = _.height), k[i] = _;
    }
    var R = e.rowGaps[n], L = 0;
    R && (L = an(R, r), L > 0 && (L += b, S < L && (S = L), L = 0)), e.addJot && (S += m), k.height = A, k.depth = S, x += A, k.pos = x, x += S + L, l[n] = k, T(s[n + 1]);
  }
  var M = x / 2 + r.fontMetrics().axisHeight, P = e.cols || [], C = [], I, N, O = [];
  if (e.tags && e.tags.some((Y) => Y))
    for (n = 0; n < a; ++n) {
      var D = l[n], $ = D.pos - M, z = e.tags[n], B = void 0;
      z === !0 ? B = Be.makeSpan(["eqn-num"], [], r) : z === !1 ? B = Be.makeSpan([], [], r) : B = Be.makeSpan([], Un(z, r, !0), r), B.depth = D.depth, B.height = D.height, O.push({
        type: "elem",
        elem: B,
        shift: $
      });
    }
  for (
    i = 0, N = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < o || N < P.length;
    ++i, ++N
  ) {
    for (var G = P[N] || {}, W = !0; G.type === "separator"; ) {
      if (W || (I = Be.makeSpan(["arraycolsep"], []), I.style.width = pt(r.fontMetrics().doubleRuleSep), C.push(I)), G.separator === "|" || G.separator === ":") {
        var V = G.separator === "|" ? "solid" : "dashed", U = Be.makeSpan(["vertical-separator"], [], r);
        U.style.height = pt(x), U.style.borderRightWidth = pt(h), U.style.borderRightStyle = V, U.style.margin = "0 " + pt(-h / 2);
        var Z = x - M;
        Z && (U.style.verticalAlign = pt(-Z)), C.push(U);
      } else
        throw new ot("Invalid separator type: " + G.separator);
      N++, G = P[N] || {}, W = !1;
    }
    if (!(i >= o)) {
      var K = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (K = Bt.deflt(G.pregap, d), K !== 0 && (I = Be.makeSpan(["arraycolsep"], []), I.style.width = pt(K), C.push(I)));
      var ce = [];
      for (n = 0; n < a; ++n) {
        var J = l[n], ee = J[i];
        if (ee) {
          var j = J.pos - M;
          ee.depth = J.depth, ee.height = J.height, ce.push({
            type: "elem",
            elem: ee,
            shift: j
          });
        }
      }
      ce = Be.makeVList({
        positionType: "individualShift",
        children: ce
      }, r), ce = Be.makeSpan(["col-align-" + (G.align || "c")], [ce]), C.push(ce), (i < o - 1 || e.hskipBeforeAndAfter) && (K = Bt.deflt(G.postgap, d), K !== 0 && (I = Be.makeSpan(["arraycolsep"], []), I.style.width = pt(K), C.push(I)));
    }
  }
  if (l = Be.makeSpan(["mtable"], C), u.length > 0) {
    for (var X = Be.makeLineSpan("hline", r, h), re = Be.makeLineSpan("hdashline", r, h), Q = [{
      type: "elem",
      elem: l,
      shift: 0
    }]; u.length > 0; ) {
      var ue = u.pop(), ne = ue.pos - M;
      ue.isDashed ? Q.push({
        type: "elem",
        elem: re,
        shift: ne
      }) : Q.push({
        type: "elem",
        elem: X,
        shift: ne
      });
    }
    l = Be.makeVList({
      positionType: "individualShift",
      children: Q
    }, r);
  }
  if (O.length === 0)
    return Be.makeSpan(["mord"], [l], r);
  var xe = Be.makeVList({
    positionType: "individualShift",
    children: O
  }, r);
  return xe = Be.makeSpan(["tag"], [xe], r), Be.makeFragment([l, xe]);
}, xCe = {
  c: "center ",
  l: "left ",
  r: "right "
}, ko = function(e, r) {
  for (var n = [], i = new it.MathNode("mtd", [], ["mtr-glue"]), a = new it.MathNode("mtd", [], ["mml-eqn-num"]), s = 0; s < e.body.length; s++) {
    for (var o = e.body[s], l = [], u = 0; u < o.length; u++)
      l.push(new it.MathNode("mtd", [$r(o[u], r)]));
    e.tags && e.tags[s] && (l.unshift(i), l.push(i), e.leqno ? l.unshift(a) : l.push(a)), n.push(new it.MathNode("mtr", l));
  }
  var h = new it.MathNode("mtable", n), f = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  h.setAttribute("rowspacing", pt(f));
  var d = "", p = "";
  if (e.cols && e.cols.length > 0) {
    var g = e.cols, m = "", v = !1, y = 0, b = g.length;
    g[0].type === "separator" && (d += "top ", y = 1), g[g.length - 1].type === "separator" && (d += "bottom ", b -= 1);
    for (var x = y; x < b; x++)
      g[x].type === "align" ? (p += xCe[g[x].align], v && (m += "none "), v = !0) : g[x].type === "separator" && v && (m += g[x].separator === "|" ? "solid " : "dashed ", v = !1);
    h.setAttribute("columnalign", p.trim()), /[sd]/.test(m) && h.setAttribute("columnlines", m.trim());
  }
  if (e.colSeparationType === "align") {
    for (var T = e.cols || [], E = "", A = 1; A < T.length; A++)
      E += A % 2 ? "0em " : "1em ";
    h.setAttribute("columnspacing", E.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? h.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? h.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? h.setAttribute("columnspacing", "0.5em") : h.setAttribute("columnspacing", "1em");
  var S = "", k = e.hLinesBeforeRow;
  d += k[0].length > 0 ? "left " : "", d += k[k.length - 1].length > 0 ? "right " : "";
  for (var _ = 1; _ < k.length - 1; _++)
    S += k[_].length === 0 ? "none " : k[_][0] ? "dashed " : "solid ";
  return /[sd]/.test(S) && h.setAttribute("rowlines", S.trim()), d !== "" && (h = new it.MathNode("menclose", [h]), h.setAttribute("notation", d.trim())), e.arraystretch && e.arraystretch < 1 && (h = new it.MathNode("mstyle", [h]), h.setAttribute("scriptlevel", "1")), h;
}, yre = function(e, r) {
  e.envName.indexOf("ed") === -1 && F4(e);
  var n = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", a = e.envName === "split", s = qc(e.parser, {
    cols: n,
    addJot: !0,
    autoTag: a ? void 0 : HL(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: a ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), o, l = 0, u = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (r[0] && r[0].type === "ordgroup") {
    for (var h = "", f = 0; f < r[0].body.length; f++) {
      var d = tr(r[0].body[f], "textord");
      h += d.text;
    }
    o = Number(h), l = o * 2;
  }
  var p = !l;
  s.body.forEach(function(y) {
    for (var b = 1; b < y.length; b += 2) {
      var x = tr(y[b], "styling"), T = tr(x.body[0], "ordgroup");
      T.body.unshift(u);
    }
    if (p)
      l < y.length && (l = y.length);
    else {
      var E = y.length / 2;
      if (o < E)
        throw new ot("Too many math in a row: " + ("expected " + o + ", but got " + E), y[0]);
    }
  });
  for (var g = 0; g < l; ++g) {
    var m = "r", v = 0;
    g % 2 === 1 ? m = "l" : g > 0 && p && (v = 1), n[g] = {
      type: "align",
      align: m,
      pregap: v,
      postgap: 0
    };
  }
  return s.colSeparationType = p ? "align" : "alignat", s;
};
Eo({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var r = P4(e[0]), n = r ? [e[0]] : tr(e[0], "ordgroup").body, i = n.map(function(s) {
      var o = zL(s), l = o.text;
      if ("lcr".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      if (l === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (l === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new ot("Unknown column alignment: " + l, s);
    }), a = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return qc(t.parser, a, WL(t.envName));
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[t.envName.replace("*", "")], r = "c", n = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: r
      }]
    };
    if (t.envName.charAt(t.envName.length - 1) === "*") {
      var i = t.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), r = i.fetch().text, "lcr".indexOf(r) === -1)
          throw new ot("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), n.cols = [{
          type: "align",
          align: r
        }];
      }
    }
    var a = qc(t.parser, n, WL(t.envName)), s = Math.max(0, ...a.body.map((o) => o.length));
    return a.cols = new Array(s).fill({
      type: "align",
      align: r
    }), e ? {
      type: "leftright",
      mode: t.mode,
      body: [a],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : a;
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      arraystretch: 0.5
    }, r = qc(t.parser, e, "script");
    return r.colSeparationType = "small", r;
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var r = P4(e[0]), n = r ? [e[0]] : tr(e[0], "ordgroup").body, i = n.map(function(s) {
      var o = zL(s), l = o.text;
      if ("lc".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      throw new ot("Unknown column alignment: " + l, s);
    });
    if (i.length > 1)
      throw new ot("{subarray} can contain only one column");
    var a = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (a = qc(t.parser, a, "script"), a.body.length > 0 && a.body[0].length > 1)
      throw new ot("{subarray} can contain only one column");
    return a;
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, r = qc(t.parser, e, WL(t.envName));
    return {
      type: "leftright",
      mode: t.mode,
      body: [r],
      left: t.envName.indexOf("r") > -1 ? "." : "\\{",
      right: t.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: yre,
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    Bt.contains(["gather", "gather*"], t.envName) && F4(t);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: HL(t.envName),
      emptySingleRow: !0,
      leqno: t.parser.settings.leqno
    };
    return qc(t.parser, e, "display");
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: yre,
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    F4(t);
    var e = {
      autoTag: HL(t.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: t.parser.settings.leqno
    };
    return qc(t.parser, e, "display");
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
Eo({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(t) {
    return F4(t), sCe(t.parser);
  },
  htmlBuilder: So,
  mathmlBuilder: ko
});
le("\\nonumber", "\\gdef\\@eqnsw{0}");
le("\\notag", "\\nonumber");
Tt({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(t, e) {
    throw new ot(t.funcName + " valid only within array environment");
  }
});
var uz = mre;
Tt({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    if (i.type !== "ordgroup")
      throw new ot("Invalid environment name", i);
    for (var a = "", s = 0; s < i.body.length; ++s)
      a += tr(i.body[s], "textord").text;
    if (n === "\\begin") {
      if (!uz.hasOwnProperty(a))
        throw new ot("No such environment: " + a, i);
      var o = uz[a], {
        args: l,
        optArgs: u
      } = r.parseArguments("\\begin{" + a + "}", o), h = {
        mode: r.mode,
        envName: a,
        parser: r
      }, f = o.handler(h, l, u);
      r.expect("\\end", !1);
      var d = r.nextToken, p = tr(r.parseFunction(), "environment");
      if (p.name !== a)
        throw new ot("Mismatch: \\begin{" + a + "} matched by \\end{" + p.name + "}", d);
      return f;
    }
    return {
      type: "environment",
      mode: r.mode,
      name: a,
      nameGroup: i
    };
  }
});
var bre = (t, e) => {
  var r = t.font, n = e.withFont(r);
  return br(t.body, n);
}, xre = (t, e) => {
  var r = t.font, n = e.withFont(r);
  return $r(t.body, n);
}, hz = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
Tt({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = Tb(e[0]), a = n;
    return a in hz && (a = hz[a]), {
      type: "font",
      mode: r.mode,
      font: a.slice(1),
      body: i
    };
  },
  htmlBuilder: bre,
  mathmlBuilder: xre
});
Tt({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0], i = Bt.isCharacterBox(n);
    return {
      type: "mclass",
      mode: r.mode,
      mclass: $4(n),
      body: [{
        type: "font",
        mode: r.mode,
        font: "boldsymbol",
        body: n
      }],
      isCharacterBox: i
    };
  }
});
Tt({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n,
      breakOnTokenText: i
    } = t, {
      mode: a
    } = r, s = r.parseExpression(!0, i), o = "math" + n.slice(1);
    return {
      type: "font",
      mode: a,
      font: o,
      body: {
        type: "ordgroup",
        mode: r.mode,
        body: s
      }
    };
  },
  htmlBuilder: bre,
  mathmlBuilder: xre
});
var wre = (t, e) => {
  var r = e;
  return t === "display" ? r = r.id >= Gt.SCRIPT.id ? r.text() : Gt.DISPLAY : t === "text" && r.size === Gt.DISPLAY.size ? r = Gt.TEXT : t === "script" ? r = Gt.SCRIPT : t === "scriptscript" && (r = Gt.SCRIPTSCRIPT), r;
}, YL = (t, e) => {
  var r = wre(t.size, e.style), n = r.fracNum(), i = r.fracDen(), a;
  a = e.havingStyle(n);
  var s = br(t.numer, a, e);
  if (t.continued) {
    var o = 8.5 / e.fontMetrics().ptPerEm, l = 3.5 / e.fontMetrics().ptPerEm;
    s.height = s.height < o ? o : s.height, s.depth = s.depth < l ? l : s.depth;
  }
  a = e.havingStyle(i);
  var u = br(t.denom, a, e), h, f, d;
  t.hasBarLine ? (t.barSize ? (f = an(t.barSize, e), h = Be.makeLineSpan("frac-line", e, f)) : h = Be.makeLineSpan("frac-line", e), f = h.height, d = h.height) : (h = null, f = 0, d = e.fontMetrics().defaultRuleThickness);
  var p, g, m;
  r.size === Gt.DISPLAY.size || t.size === "display" ? (p = e.fontMetrics().num1, f > 0 ? g = 3 * d : g = 7 * d, m = e.fontMetrics().denom1) : (f > 0 ? (p = e.fontMetrics().num2, g = d) : (p = e.fontMetrics().num3, g = 3 * d), m = e.fontMetrics().denom2);
  var v;
  if (h) {
    var b = e.fontMetrics().axisHeight;
    p - s.depth - (b + 0.5 * f) < g && (p += g - (p - s.depth - (b + 0.5 * f))), b - 0.5 * f - (u.height - m) < g && (m += g - (b - 0.5 * f - (u.height - m)));
    var x = -(b - 0.5 * f);
    v = Be.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: m
      }, {
        type: "elem",
        elem: h,
        shift: x
      }, {
        type: "elem",
        elem: s,
        shift: -p
      }]
    }, e);
  } else {
    var y = p - s.depth - (u.height - m);
    y < g && (p += 0.5 * (g - y), m += 0.5 * (g - y)), v = Be.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: m
      }, {
        type: "elem",
        elem: s,
        shift: -p
      }]
    }, e);
  }
  a = e.havingStyle(r), v.height *= a.sizeMultiplier / e.sizeMultiplier, v.depth *= a.sizeMultiplier / e.sizeMultiplier;
  var T;
  r.size === Gt.DISPLAY.size ? T = e.fontMetrics().delim1 : r.size === Gt.SCRIPTSCRIPT.size ? T = e.havingStyle(Gt.SCRIPT).fontMetrics().delim2 : T = e.fontMetrics().delim2;
  var E, A;
  return t.leftDelim == null ? E = y1(e, ["mopen"]) : E = ol.customSizedDelim(t.leftDelim, T, !0, e.havingStyle(r), t.mode, ["mopen"]), t.continued ? A = Be.makeSpan([]) : t.rightDelim == null ? A = y1(e, ["mclose"]) : A = ol.customSizedDelim(t.rightDelim, T, !0, e.havingStyle(r), t.mode, ["mclose"]), Be.makeSpan(["mord"].concat(a.sizingClasses(e)), [E, Be.makeSpan(["mfrac"], [v]), A], e);
}, XL = (t, e) => {
  var r = new it.MathNode("mfrac", [$r(t.numer, e), $r(t.denom, e)]);
  if (!t.hasBarLine)
    r.setAttribute("linethickness", "0px");
  else if (t.barSize) {
    var n = an(t.barSize, e);
    r.setAttribute("linethickness", pt(n));
  }
  var i = wre(t.size, e.style);
  if (i.size !== e.style.size) {
    r = new it.MathNode("mstyle", [r]);
    var a = i.size === Gt.DISPLAY.size ? "true" : "false";
    r.setAttribute("displaystyle", a), r.setAttribute("scriptlevel", "0");
  }
  if (t.leftDelim != null || t.rightDelim != null) {
    var s = [];
    if (t.leftDelim != null) {
      var o = new it.MathNode("mo", [new it.TextNode(t.leftDelim.replace("\\", ""))]);
      o.setAttribute("fence", "true"), s.push(o);
    }
    if (s.push(r), t.rightDelim != null) {
      var l = new it.MathNode("mo", [new it.TextNode(t.rightDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), s.push(l);
    }
    return BL(s);
  }
  return r;
};
Tt({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0], a = e[1], s, o = null, l = null, u = "auto";
    switch (n) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        s = !0;
        break;
      case "\\\\atopfrac":
        s = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        s = !1, o = "(", l = ")";
        break;
      case "\\\\bracefrac":
        s = !1, o = "\\{", l = "\\}";
        break;
      case "\\\\brackfrac":
        s = !1, o = "[", l = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (n) {
      case "\\dfrac":
      case "\\dbinom":
        u = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        u = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !1,
      numer: i,
      denom: a,
      hasBarLine: s,
      leftDelim: o,
      rightDelim: l,
      size: u,
      barSize: null
    };
  },
  htmlBuilder: YL,
  mathmlBuilder: XL
});
Tt({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0], a = e[1];
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !0,
      numer: i,
      denom: a,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
Tt({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r,
      token: n
    } = t, i;
    switch (r) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: n
    };
  }
});
var fz = ["display", "text", "script", "scriptscript"], dz = function(e) {
  var r = null;
  return e.length > 0 && (r = e, r = r === "." ? null : r), r;
};
Tt({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = e[4], i = e[5], a = Tb(e[0]), s = a.type === "atom" && a.family === "open" ? dz(a.text) : null, o = Tb(e[1]), l = o.type === "atom" && o.family === "close" ? dz(o.text) : null, u = tr(e[2], "size"), h, f = null;
    u.isBlank ? h = !0 : (f = u.value, h = f.number > 0);
    var d = "auto", p = e[3];
    if (p.type === "ordgroup") {
      if (p.body.length > 0) {
        var g = tr(p.body[0], "textord");
        d = fz[Number(g.text)];
      }
    } else
      p = tr(p, "textord"), d = fz[Number(p.text)];
    return {
      type: "genfrac",
      mode: r.mode,
      numer: n,
      denom: i,
      continued: !1,
      hasBarLine: h,
      barSize: f,
      leftDelim: s,
      rightDelim: l,
      size: d
    };
  },
  htmlBuilder: YL,
  mathmlBuilder: XL
});
Tt({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n,
      token: i
    } = t;
    return {
      type: "infix",
      mode: r.mode,
      replaceWith: "\\\\abovefrac",
      size: tr(e[0], "size").value,
      token: i
    };
  }
});
Tt({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0], a = ZSe(tr(e[1], "infix").size), s = e[2], o = a.number > 0;
    return {
      type: "genfrac",
      mode: r.mode,
      numer: i,
      denom: s,
      continued: !1,
      hasBarLine: o,
      barSize: a,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: YL,
  mathmlBuilder: XL
});
var Tre = (t, e) => {
  var r = e.style, n, i;
  t.type === "supsub" ? (n = t.sup ? br(t.sup, e.havingStyle(r.sup()), e) : br(t.sub, e.havingStyle(r.sub()), e), i = tr(t.base, "horizBrace")) : i = tr(t, "horizBrace");
  var a = br(i.base, e.havingBaseStyle(Gt.DISPLAY)), s = vl.svgSpan(i, e), o;
  if (i.isOver ? (o = Be.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: a
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), o.children[0].children[0].children[1].classes.push("svg-align")) : (o = Be.makeVList({
    positionType: "bottom",
    positionData: a.depth + 0.1 + s.height,
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: a
    }]
  }, e), o.children[0].children[0].children[0].classes.push("svg-align")), n) {
    var l = Be.makeSpan(["mord", i.isOver ? "mover" : "munder"], [o], e);
    i.isOver ? o = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: n
      }]
    }, e) : o = Be.makeVList({
      positionType: "bottom",
      positionData: l.depth + 0.2 + n.height + n.depth,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: l
      }]
    }, e);
  }
  return Be.makeSpan(["mord", i.isOver ? "mover" : "munder"], [o], e);
}, wCe = (t, e) => {
  var r = vl.mathMLnode(t.label);
  return new it.MathNode(t.isOver ? "mover" : "munder", [$r(t.base, e), r]);
};
Tt({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t;
    return {
      type: "horizBrace",
      mode: r.mode,
      label: n,
      isOver: /^\\over/.test(n),
      base: e[0]
    };
  },
  htmlBuilder: Tre,
  mathmlBuilder: wCe
});
Tt({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[1], i = tr(e[0], "url").url;
    return r.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: r.mode,
      href: i,
      body: Tn(n)
    } : r.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (t, e) => {
    var r = Un(t.body, e, !1);
    return Be.makeAnchor(t.href, [], r, e);
  },
  mathmlBuilder: (t, e) => {
    var r = vc(t.body, e);
    return r instanceof Ca || (r = new Ca("mrow", [r])), r.setAttribute("href", t.href), r;
  }
});
Tt({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = tr(e[0], "url").url;
    if (!r.settings.isTrusted({
      command: "\\url",
      url: n
    }))
      return r.formatUnsupportedCmd("\\url");
    for (var i = [], a = 0; a < n.length; a++) {
      var s = n[a];
      s === "~" && (s = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: s
      });
    }
    var o = {
      type: "text",
      mode: r.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: r.mode,
      href: n,
      body: Tn(o)
    };
  }
});
Tt({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "hbox",
      mode: r.mode,
      body: Tn(e[0])
    };
  },
  htmlBuilder(t, e) {
    var r = Un(t.body, e, !1);
    return Be.makeFragment(r);
  },
  mathmlBuilder(t, e) {
    return new it.MathNode("mrow", ga(t.body, e));
  }
});
Tt({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n,
      token: i
    } = t, a = tr(e[0], "raw").string, s = e[1];
    r.settings.strict && r.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var o, l = {};
    switch (n) {
      case "\\htmlClass":
        l.class = a, o = {
          command: "\\htmlClass",
          class: a
        };
        break;
      case "\\htmlId":
        l.id = a, o = {
          command: "\\htmlId",
          id: a
        };
        break;
      case "\\htmlStyle":
        l.style = a, o = {
          command: "\\htmlStyle",
          style: a
        };
        break;
      case "\\htmlData": {
        for (var u = a.split(","), h = 0; h < u.length; h++) {
          var f = u[h].split("=");
          if (f.length !== 2)
            throw new ot("Error parsing key-value for \\htmlData");
          l["data-" + f[0].trim()] = f[1].trim();
        }
        o = {
          command: "\\htmlData",
          attributes: l
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return r.settings.isTrusted(o) ? {
      type: "html",
      mode: r.mode,
      attributes: l,
      body: Tn(s)
    } : r.formatUnsupportedCmd(n);
  },
  htmlBuilder: (t, e) => {
    var r = Un(t.body, e, !1), n = ["enclosing"];
    t.attributes.class && n.push(...t.attributes.class.trim().split(/\s+/));
    var i = Be.makeSpan(n, r, e);
    for (var a in t.attributes)
      a !== "class" && t.attributes.hasOwnProperty(a) && i.setAttribute(a, t.attributes[a]);
    return i;
  },
  mathmlBuilder: (t, e) => vc(t.body, e)
});
Tt({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t;
    return {
      type: "htmlmathml",
      mode: r.mode,
      html: Tn(e[0]),
      mathml: Tn(e[1])
    };
  },
  htmlBuilder: (t, e) => {
    var r = Un(t.html, e, !1);
    return Be.makeFragment(r);
  },
  mathmlBuilder: (t, e) => vc(t.mathml, e)
});
var yk = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var r = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!r)
    throw new ot("Invalid size: '" + e + "' in \\includegraphics");
  var n = {
    number: +(r[1] + r[2]),
    // sign + magnitude, cast to number
    unit: r[3]
  };
  if (!qte(n))
    throw new ot("Invalid unit: '" + n.unit + "' in \\includegraphics.");
  return n;
};
Tt({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (t, e, r) => {
    var {
      parser: n
    } = t, i = {
      number: 0,
      unit: "em"
    }, a = {
      number: 0.9,
      unit: "em"
    }, s = {
      number: 0,
      unit: "em"
    }, o = "";
    if (r[0])
      for (var l = tr(r[0], "raw").string, u = l.split(","), h = 0; h < u.length; h++) {
        var f = u[h].split("=");
        if (f.length === 2) {
          var d = f[1].trim();
          switch (f[0].trim()) {
            case "alt":
              o = d;
              break;
            case "width":
              i = yk(d);
              break;
            case "height":
              a = yk(d);
              break;
            case "totalheight":
              s = yk(d);
              break;
            default:
              throw new ot("Invalid key: '" + f[0] + "' in \\includegraphics.");
          }
        }
      }
    var p = tr(e[0], "url").url;
    return o === "" && (o = p, o = o.replace(/^.*[\\/]/, ""), o = o.substring(0, o.lastIndexOf("."))), n.settings.isTrusted({
      command: "\\includegraphics",
      url: p
    }) ? {
      type: "includegraphics",
      mode: n.mode,
      alt: o,
      width: i,
      height: a,
      totalheight: s,
      src: p
    } : n.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (t, e) => {
    var r = an(t.height, e), n = 0;
    t.totalheight.number > 0 && (n = an(t.totalheight, e) - r);
    var i = 0;
    t.width.number > 0 && (i = an(t.width, e));
    var a = {
      height: pt(r + n)
    };
    i > 0 && (a.width = pt(i)), n > 0 && (a.verticalAlign = pt(-n));
    var s = new wke(t.src, t.alt, a);
    return s.height = r, s.depth = n, s;
  },
  mathmlBuilder: (t, e) => {
    var r = new it.MathNode("mglyph", []);
    r.setAttribute("alt", t.alt);
    var n = an(t.height, e), i = 0;
    if (t.totalheight.number > 0 && (i = an(t.totalheight, e) - n, r.setAttribute("valign", pt(-i))), r.setAttribute("height", pt(n + i)), t.width.number > 0) {
      var a = an(t.width, e);
      r.setAttribute("width", pt(a));
    }
    return r.setAttribute("src", t.src), r;
  }
});
Tt({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = tr(e[0], "size");
    if (r.settings.strict) {
      var a = n[1] === "m", s = i.value.unit === "mu";
      a ? (s || r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " supports only mu units, " + ("not " + i.value.unit + " units")), r.mode !== "math" && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " works only in math mode")) : s && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: r.mode,
      dimension: i.value
    };
  },
  htmlBuilder(t, e) {
    return Be.makeGlue(t.dimension, e);
  },
  mathmlBuilder(t, e) {
    var r = an(t.dimension, e);
    return new it.SpaceNode(r);
  }
});
Tt({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "lap",
      mode: r.mode,
      alignment: n.slice(5),
      body: i
    };
  },
  htmlBuilder: (t, e) => {
    var r;
    t.alignment === "clap" ? (r = Be.makeSpan([], [br(t.body, e)]), r = Be.makeSpan(["inner"], [r], e)) : r = Be.makeSpan(["inner"], [br(t.body, e)]);
    var n = Be.makeSpan(["fix"], []), i = Be.makeSpan([t.alignment], [r, n], e), a = Be.makeSpan(["strut"]);
    return a.style.height = pt(i.height + i.depth), i.depth && (a.style.verticalAlign = pt(-i.depth)), i.children.unshift(a), i = Be.makeSpan(["thinbox"], [i], e), Be.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (t, e) => {
    var r = new it.MathNode("mpadded", [$r(t.body, e)]);
    if (t.alignment !== "rlap") {
      var n = t.alignment === "llap" ? "-1" : "-0.5";
      r.setAttribute("lspace", n + "width");
    }
    return r.setAttribute("width", "0px"), r;
  }
});
Tt({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(t, e) {
    var {
      funcName: r,
      parser: n
    } = t, i = n.mode;
    n.switchMode("math");
    var a = r === "\\(" ? "\\)" : "$", s = n.parseExpression(!1, a);
    return n.expect(a), n.switchMode(i), {
      type: "styling",
      mode: n.mode,
      style: "text",
      body: s
    };
  }
});
Tt({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(t, e) {
    throw new ot("Mismatched " + t.funcName);
  }
});
var pz = (t, e) => {
  switch (e.style.size) {
    case Gt.DISPLAY.size:
      return t.display;
    case Gt.TEXT.size:
      return t.text;
    case Gt.SCRIPT.size:
      return t.script;
    case Gt.SCRIPTSCRIPT.size:
      return t.scriptscript;
    default:
      return t.text;
  }
};
Tt({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t;
    return {
      type: "mathchoice",
      mode: r.mode,
      display: Tn(e[0]),
      text: Tn(e[1]),
      script: Tn(e[2]),
      scriptscript: Tn(e[3])
    };
  },
  htmlBuilder: (t, e) => {
    var r = pz(t, e), n = Un(r, e, !1);
    return Be.makeFragment(n);
  },
  mathmlBuilder: (t, e) => {
    var r = pz(t, e);
    return vc(r, e);
  }
});
var Ere = (t, e, r, n, i, a, s) => {
  t = Be.makeSpan([], [t]);
  var o = r && Bt.isCharacterBox(r), l, u;
  if (e) {
    var h = br(e, n.havingStyle(i.sup()), n);
    u = {
      elem: h,
      kern: Math.max(n.fontMetrics().bigOpSpacing1, n.fontMetrics().bigOpSpacing3 - h.depth)
    };
  }
  if (r) {
    var f = br(r, n.havingStyle(i.sub()), n);
    l = {
      elem: f,
      kern: Math.max(n.fontMetrics().bigOpSpacing2, n.fontMetrics().bigOpSpacing4 - f.height)
    };
  }
  var d;
  if (u && l) {
    var p = n.fontMetrics().bigOpSpacing5 + l.elem.height + l.elem.depth + l.kern + t.depth + s;
    d = Be.makeVList({
      positionType: "bottom",
      positionData: p,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: pt(-a)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: pt(a)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else if (l) {
    var g = t.height - s;
    d = Be.makeVList({
      positionType: "top",
      positionData: g,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: pt(-a)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: t
      }]
    }, n);
  } else if (u) {
    var m = t.depth + s;
    d = Be.makeVList({
      positionType: "bottom",
      positionData: m,
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: pt(a)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else
    return t;
  var v = [d];
  if (l && a !== 0 && !o) {
    var y = Be.makeSpan(["mspace"], [], n);
    y.style.marginRight = pt(a), v.unshift(y);
  }
  return Be.makeSpan(["mop", "op-limits"], v, n);
}, Sre = ["\\smallint"], F0 = (t, e) => {
  var r, n, i = !1, a;
  t.type === "supsub" ? (r = t.sup, n = t.sub, a = tr(t.base, "op"), i = !0) : a = tr(t, "op");
  var s = e.style, o = !1;
  s.size === Gt.DISPLAY.size && a.symbol && !Bt.contains(Sre, a.name) && (o = !0);
  var l;
  if (a.symbol) {
    var u = o ? "Size2-Regular" : "Size1-Regular", h = "";
    if ((a.name === "\\oiint" || a.name === "\\oiiint") && (h = a.name.slice(1), a.name = h === "oiint" ? "\\iint" : "\\iiint"), l = Be.makeSymbol(a.name, u, "math", e, ["mop", "op-symbol", o ? "large-op" : "small-op"]), h.length > 0) {
      var f = l.italic, d = Be.staticSvg(h + "Size" + (o ? "2" : "1"), e);
      l = Be.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: l,
          shift: 0
        }, {
          type: "elem",
          elem: d,
          shift: o ? 0.08 : 0
        }]
      }, e), a.name = "\\" + h, l.classes.unshift("mop"), l.italic = f;
    }
  } else if (a.body) {
    var p = Un(a.body, e, !0);
    p.length === 1 && p[0] instanceof as ? (l = p[0], l.classes[0] = "mop") : l = Be.makeSpan(["mop"], p, e);
  } else {
    for (var g = [], m = 1; m < a.name.length; m++)
      g.push(Be.mathsym(a.name[m], a.mode, e));
    l = Be.makeSpan(["mop"], g, e);
  }
  var v = 0, y = 0;
  return (l instanceof as || a.name === "\\oiint" || a.name === "\\oiiint") && !a.suppressBaseShift && (v = (l.height - l.depth) / 2 - e.fontMetrics().axisHeight, y = l.italic), i ? Ere(l, r, n, e, s, y, v) : (v && (l.style.position = "relative", l.style.top = pt(v)), l);
}, gm = (t, e) => {
  var r;
  if (t.symbol)
    r = new Ca("mo", [ss(t.name, t.mode)]), Bt.contains(Sre, t.name) && r.setAttribute("largeop", "false");
  else if (t.body)
    r = new Ca("mo", ga(t.body, e));
  else {
    r = new Ca("mi", [new no(t.name.slice(1))]);
    var n = new Ca("mo", [ss("\u2061", "text")]);
    t.parentIsSupSub ? r = new Ca("mrow", [r, n]) : r = Qte([r, n]);
  }
  return r;
}, TCe = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22C0": "\\bigwedge",
  "\u22C1": "\\bigvee",
  "\u22C2": "\\bigcap",
  "\u22C3": "\\bigcup",
  "\u2A00": "\\bigodot",
  "\u2A01": "\\bigoplus",
  "\u2A02": "\\bigotimes",
  "\u2A04": "\\biguplus",
  "\u2A06": "\\bigsqcup"
};
Tt({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
  props: {
    numArgs: 0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = n;
    return i.length === 1 && (i = TCe[i]), {
      type: "op",
      mode: r.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: F0,
  mathmlBuilder: gm
});
Tt({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "op",
      mode: r.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: Tn(n)
    };
  },
  htmlBuilder: F0,
  mathmlBuilder: gm
});
var ECe = {
  "\u222B": "\\int",
  "\u222C": "\\iint",
  "\u222D": "\\iiint",
  "\u222E": "\\oint",
  "\u222F": "\\oiint",
  "\u2230": "\\oiiint"
};
Tt({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: F0,
  mathmlBuilder: gm
});
Tt({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: F0,
  mathmlBuilder: gm
});
Tt({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = r;
    return n.length === 1 && (n = ECe[n]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: n
    };
  },
  htmlBuilder: F0,
  mathmlBuilder: gm
});
var kre = (t, e) => {
  var r, n, i = !1, a;
  t.type === "supsub" ? (r = t.sup, n = t.sub, a = tr(t.base, "operatorname"), i = !0) : a = tr(t, "operatorname");
  var s;
  if (a.body.length > 0) {
    for (var o = a.body.map((f) => {
      var d = f.text;
      return typeof d == "string" ? {
        type: "textord",
        mode: f.mode,
        text: d
      } : f;
    }), l = Un(o, e.withFont("mathrm"), !0), u = 0; u < l.length; u++) {
      var h = l[u];
      h instanceof as && (h.text = h.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    s = Be.makeSpan(["mop"], l, e);
  } else
    s = Be.makeSpan(["mop"], [], e);
  return i ? Ere(s, r, n, e, e.style, 0, 0) : s;
}, SCe = (t, e) => {
  for (var r = ga(t.body, e.withFont("mathrm")), n = !0, i = 0; i < r.length; i++) {
    var a = r[i];
    if (!(a instanceof it.SpaceNode)) if (a instanceof it.MathNode)
      switch (a.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var s = a.children[0];
          a.children.length === 1 && s instanceof it.TextNode ? s.text = s.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : n = !1;
          break;
        }
        default:
          n = !1;
      }
    else
      n = !1;
  }
  if (n) {
    var o = r.map((h) => h.toText()).join("");
    r = [new it.TextNode(o)];
  }
  var l = new it.MathNode("mi", r);
  l.setAttribute("mathvariant", "normal");
  var u = new it.MathNode("mo", [ss("\u2061", "text")]);
  return t.parentIsSupSub ? new it.MathNode("mrow", [l, u]) : it.newDocumentFragment([l, u]);
};
Tt({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "operatorname",
      mode: r.mode,
      body: Tn(i),
      alwaysHandleSupSub: n === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: kre,
  mathmlBuilder: SCe
});
le("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
Rh({
  type: "ordgroup",
  htmlBuilder(t, e) {
    return t.semisimple ? Be.makeFragment(Un(t.body, e, !1)) : Be.makeSpan(["mord"], Un(t.body, e, !0), e);
  },
  mathmlBuilder(t, e) {
    return vc(t.body, e, !0);
  }
});
Tt({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "overline",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder(t, e) {
    var r = br(t.body, e.havingCrampedStyle()), n = Be.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, a = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return Be.makeSpan(["mord", "overline"], [a], e);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mo", [new it.TextNode("\u203E")]);
    r.setAttribute("stretchy", "true");
    var n = new it.MathNode("mover", [$r(t.body, e), r]);
    return n.setAttribute("accent", "true"), n;
  }
});
Tt({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "phantom",
      mode: r.mode,
      body: Tn(n)
    };
  },
  htmlBuilder: (t, e) => {
    var r = Un(t.body, e.withPhantom(), !1);
    return Be.makeFragment(r);
  },
  mathmlBuilder: (t, e) => {
    var r = ga(t.body, e);
    return new it.MathNode("mphantom", r);
  }
});
Tt({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "hphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (t, e) => {
    var r = Be.makeSpan([], [br(t.body, e.withPhantom())]);
    if (r.height = 0, r.depth = 0, r.children)
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0, r.children[n].depth = 0;
    return r = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e), Be.makeSpan(["mord"], [r], e);
  },
  mathmlBuilder: (t, e) => {
    var r = ga(Tn(t.body), e), n = new it.MathNode("mphantom", r), i = new it.MathNode("mpadded", [n]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
Tt({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "vphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (t, e) => {
    var r = Be.makeSpan(["inner"], [br(t.body, e.withPhantom())]), n = Be.makeSpan(["fix"], []);
    return Be.makeSpan(["mord", "rlap"], [r, n], e);
  },
  mathmlBuilder: (t, e) => {
    var r = ga(Tn(t.body), e), n = new it.MathNode("mphantom", r), i = new it.MathNode("mpadded", [n]);
    return i.setAttribute("width", "0px"), i;
  }
});
Tt({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = tr(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: r.mode,
      dy: n,
      body: i
    };
  },
  htmlBuilder(t, e) {
    var r = br(t.body, e), n = an(t.dy, e);
    return Be.makeVList({
      positionType: "shift",
      positionData: -n,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mpadded", [$r(t.body, e)]), n = t.dy.number + t.dy.unit;
    return r.setAttribute("voffset", n), r;
  }
});
Tt({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(t) {
    var {
      parser: e
    } = t;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
Tt({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, i = r[0], a = tr(e[0], "size"), s = tr(e[1], "size");
    return {
      type: "rule",
      mode: n.mode,
      shift: i && tr(i, "size").value,
      width: a.value,
      height: s.value
    };
  },
  htmlBuilder(t, e) {
    var r = Be.makeSpan(["mord", "rule"], [], e), n = an(t.width, e), i = an(t.height, e), a = t.shift ? an(t.shift, e) : 0;
    return r.style.borderRightWidth = pt(n), r.style.borderTopWidth = pt(i), r.style.bottom = pt(a), r.width = n, r.height = i + a, r.depth = -a, r.maxFontSize = i * 1.125 * e.sizeMultiplier, r;
  },
  mathmlBuilder(t, e) {
    var r = an(t.width, e), n = an(t.height, e), i = t.shift ? an(t.shift, e) : 0, a = e.color && e.getColor() || "black", s = new it.MathNode("mspace");
    s.setAttribute("mathbackground", a), s.setAttribute("width", pt(r)), s.setAttribute("height", pt(n));
    var o = new it.MathNode("mpadded", [s]);
    return i >= 0 ? o.setAttribute("height", pt(i)) : (o.setAttribute("height", pt(i)), o.setAttribute("depth", pt(-i))), o.setAttribute("voffset", pt(i)), o;
  }
});
function Cre(t, e, r) {
  for (var n = Un(t, e, !1), i = e.sizeMultiplier / r.sizeMultiplier, a = 0; a < n.length; a++) {
    var s = n[a].classes.indexOf("sizing");
    s < 0 ? Array.prototype.push.apply(n[a].classes, e.sizingClasses(r)) : n[a].classes[s + 1] === "reset-size" + e.size && (n[a].classes[s + 1] = "reset-size" + r.size), n[a].height *= i, n[a].depth *= i;
  }
  return Be.makeFragment(n);
}
var gz = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], kCe = (t, e) => {
  var r = e.havingSize(t.size);
  return Cre(t.body, r, e);
};
Tt({
  type: "sizing",
  names: gz,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: i
    } = t, a = i.parseExpression(!1, r);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: gz.indexOf(n) + 1,
      body: a
    };
  },
  htmlBuilder: kCe,
  mathmlBuilder: (t, e) => {
    var r = e.havingSize(t.size), n = ga(t.body, r), i = new it.MathNode("mstyle", n);
    return i.setAttribute("mathsize", pt(r.sizeMultiplier)), i;
  }
});
Tt({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (t, e, r) => {
    var {
      parser: n
    } = t, i = !1, a = !1, s = r[0] && tr(r[0], "ordgroup");
    if (s)
      for (var o = "", l = 0; l < s.body.length; ++l) {
        var u = s.body[l];
        if (o = u.text, o === "t")
          i = !0;
        else if (o === "b")
          a = !0;
        else {
          i = !1, a = !1;
          break;
        }
      }
    else
      i = !0, a = !0;
    var h = e[0];
    return {
      type: "smash",
      mode: n.mode,
      body: h,
      smashHeight: i,
      smashDepth: a
    };
  },
  htmlBuilder: (t, e) => {
    var r = Be.makeSpan([], [br(t.body, e)]);
    if (!t.smashHeight && !t.smashDepth)
      return r;
    if (t.smashHeight && (r.height = 0, r.children))
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0;
    if (t.smashDepth && (r.depth = 0, r.children))
      for (var i = 0; i < r.children.length; i++)
        r.children[i].depth = 0;
    var a = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
    return Be.makeSpan(["mord"], [a], e);
  },
  mathmlBuilder: (t, e) => {
    var r = new it.MathNode("mpadded", [$r(t.body, e)]);
    return t.smashHeight && r.setAttribute("height", "0px"), t.smashDepth && r.setAttribute("depth", "0px"), r;
  }
});
Tt({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, i = r[0], a = e[0];
    return {
      type: "sqrt",
      mode: n.mode,
      body: a,
      index: i
    };
  },
  htmlBuilder(t, e) {
    var r = br(t.body, e.havingCrampedStyle());
    r.height === 0 && (r.height = e.fontMetrics().xHeight), r = Be.wrapFragment(r, e);
    var n = e.fontMetrics(), i = n.defaultRuleThickness, a = i;
    e.style.id < Gt.TEXT.id && (a = e.fontMetrics().xHeight);
    var s = i + a / 4, o = r.height + r.depth + s + i, {
      span: l,
      ruleWidth: u,
      advanceWidth: h
    } = ol.sqrtImage(o, e), f = l.height - u;
    f > r.height + r.depth + s && (s = (s + f - r.height - r.depth) / 2);
    var d = l.height - r.height - s - u;
    r.style.paddingLeft = pt(h);
    var p = Be.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(r.height + d)
      }, {
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: u
      }]
    }, e);
    if (t.index) {
      var g = e.havingStyle(Gt.SCRIPTSCRIPT), m = br(t.index, g, e), v = 0.6 * (p.height - p.depth), y = Be.makeVList({
        positionType: "shift",
        positionData: -v,
        children: [{
          type: "elem",
          elem: m
        }]
      }, e), b = Be.makeSpan(["root"], [y]);
      return Be.makeSpan(["mord", "sqrt"], [b, p], e);
    } else
      return Be.makeSpan(["mord", "sqrt"], [p], e);
  },
  mathmlBuilder(t, e) {
    var {
      body: r,
      index: n
    } = t;
    return n ? new it.MathNode("mroot", [$r(r, e), $r(n, e)]) : new it.MathNode("msqrt", [$r(r, e)]);
  }
});
var mz = {
  display: Gt.DISPLAY,
  text: Gt.TEXT,
  script: Gt.SCRIPT,
  scriptscript: Gt.SCRIPTSCRIPT
};
Tt({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t, e) {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: i
    } = t, a = i.parseExpression(!0, r), s = n.slice(1, n.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: s,
      body: a
    };
  },
  htmlBuilder(t, e) {
    var r = mz[t.style], n = e.havingStyle(r).withFont("");
    return Cre(t.body, n, e);
  },
  mathmlBuilder(t, e) {
    var r = mz[t.style], n = e.havingStyle(r), i = ga(t.body, n), a = new it.MathNode("mstyle", i), s = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, o = s[t.style];
    return a.setAttribute("scriptlevel", o[0]), a.setAttribute("displaystyle", o[1]), a;
  }
});
var CCe = function(e, r) {
  var n = e.base;
  if (n)
    if (n.type === "op") {
      var i = n.limits && (r.style.size === Gt.DISPLAY.size || n.alwaysHandleSupSub);
      return i ? F0 : null;
    } else if (n.type === "operatorname") {
      var a = n.alwaysHandleSupSub && (r.style.size === Gt.DISPLAY.size || n.limits);
      return a ? kre : null;
    } else {
      if (n.type === "accent")
        return Bt.isCharacterBox(n.base) ? qL : null;
      if (n.type === "horizBrace") {
        var s = !e.sub;
        return s === n.isOver ? Tre : null;
      } else
        return null;
    }
  else return null;
};
Rh({
  type: "supsub",
  htmlBuilder(t, e) {
    var r = CCe(t, e);
    if (r)
      return r(t, e);
    var {
      base: n,
      sup: i,
      sub: a
    } = t, s = br(n, e), o, l, u = e.fontMetrics(), h = 0, f = 0, d = n && Bt.isCharacterBox(n);
    if (i) {
      var p = e.havingStyle(e.style.sup());
      o = br(i, p, e), d || (h = s.height - p.fontMetrics().supDrop * p.sizeMultiplier / e.sizeMultiplier);
    }
    if (a) {
      var g = e.havingStyle(e.style.sub());
      l = br(a, g, e), d || (f = s.depth + g.fontMetrics().subDrop * g.sizeMultiplier / e.sizeMultiplier);
    }
    var m;
    e.style === Gt.DISPLAY ? m = u.sup1 : e.style.cramped ? m = u.sup3 : m = u.sup2;
    var v = e.sizeMultiplier, y = pt(0.5 / u.ptPerEm / v), b = null;
    if (l) {
      var x = t.base && t.base.type === "op" && t.base.name && (t.base.name === "\\oiint" || t.base.name === "\\oiiint");
      (s instanceof as || x) && (b = pt(-s.italic));
    }
    var T;
    if (o && l) {
      h = Math.max(h, m, o.depth + 0.25 * u.xHeight), f = Math.max(f, u.sub2);
      var E = u.defaultRuleThickness, A = 4 * E;
      if (h - o.depth - (l.height - f) < A) {
        f = A - (h - o.depth) + l.height;
        var S = 0.8 * u.xHeight - (h - o.depth);
        S > 0 && (h += S, f -= S);
      }
      var k = [{
        type: "elem",
        elem: l,
        shift: f,
        marginRight: y,
        marginLeft: b
      }, {
        type: "elem",
        elem: o,
        shift: -h,
        marginRight: y
      }];
      T = Be.makeVList({
        positionType: "individualShift",
        children: k
      }, e);
    } else if (l) {
      f = Math.max(f, u.sub1, l.height - 0.8 * u.xHeight);
      var _ = [{
        type: "elem",
        elem: l,
        marginLeft: b,
        marginRight: y
      }];
      T = Be.makeVList({
        positionType: "shift",
        positionData: f,
        children: _
      }, e);
    } else if (o)
      h = Math.max(h, m, o.depth + 0.25 * u.xHeight), T = Be.makeVList({
        positionType: "shift",
        positionData: -h,
        children: [{
          type: "elem",
          elem: o,
          marginRight: y
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var R = iA(s, "right") || "mord";
    return Be.makeSpan([R], [s, Be.makeSpan(["msupsub"], [T])], e);
  },
  mathmlBuilder(t, e) {
    var r = !1, n, i;
    t.base && t.base.type === "horizBrace" && (i = !!t.sup, i === t.base.isOver && (r = !0, n = t.base.isOver)), t.base && (t.base.type === "op" || t.base.type === "operatorname") && (t.base.parentIsSupSub = !0);
    var a = [$r(t.base, e)];
    t.sub && a.push($r(t.sub, e)), t.sup && a.push($r(t.sup, e));
    var s;
    if (r)
      s = n ? "mover" : "munder";
    else if (t.sub)
      if (t.sup) {
        var u = t.base;
        u && u.type === "op" && u.limits && e.style === Gt.DISPLAY || u && u.type === "operatorname" && u.alwaysHandleSupSub && (e.style === Gt.DISPLAY || u.limits) ? s = "munderover" : s = "msubsup";
      } else {
        var l = t.base;
        l && l.type === "op" && l.limits && (e.style === Gt.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === Gt.DISPLAY) ? s = "munder" : s = "msub";
      }
    else {
      var o = t.base;
      o && o.type === "op" && o.limits && (e.style === Gt.DISPLAY || o.alwaysHandleSupSub) || o && o.type === "operatorname" && o.alwaysHandleSupSub && (o.limits || e.style === Gt.DISPLAY) ? s = "mover" : s = "msup";
    }
    return new it.MathNode(s, a);
  }
});
Rh({
  type: "atom",
  htmlBuilder(t, e) {
    return Be.mathsym(t.text, t.mode, e, ["m" + t.family]);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mo", [ss(t.text, t.mode)]);
    if (t.family === "bin") {
      var n = FL(t, e);
      n === "bold-italic" && r.setAttribute("mathvariant", n);
    } else t.family === "punct" ? r.setAttribute("separator", "true") : (t.family === "open" || t.family === "close") && r.setAttribute("stretchy", "false");
    return r;
  }
});
var _re = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
Rh({
  type: "mathord",
  htmlBuilder(t, e) {
    return Be.makeOrd(t, e, "mathord");
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mi", [ss(t.text, t.mode, e)]), n = FL(t, e) || "italic";
    return n !== _re[r.type] && r.setAttribute("mathvariant", n), r;
  }
});
Rh({
  type: "textord",
  htmlBuilder(t, e) {
    return Be.makeOrd(t, e, "textord");
  },
  mathmlBuilder(t, e) {
    var r = ss(t.text, t.mode, e), n = FL(t, e) || "normal", i;
    return t.mode === "text" ? i = new it.MathNode("mtext", [r]) : /[0-9]/.test(t.text) ? i = new it.MathNode("mn", [r]) : t.text === "\\prime" ? i = new it.MathNode("mo", [r]) : i = new it.MathNode("mi", [r]), n !== _re[i.type] && i.setAttribute("mathvariant", n), i;
  }
});
var bk = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, xk = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
Rh({
  type: "spacing",
  htmlBuilder(t, e) {
    if (xk.hasOwnProperty(t.text)) {
      var r = xk[t.text].className || "";
      if (t.mode === "text") {
        var n = Be.makeOrd(t, e, "textord");
        return n.classes.push(r), n;
      } else
        return Be.makeSpan(["mspace", r], [Be.mathsym(t.text, t.mode, e)], e);
    } else {
      if (bk.hasOwnProperty(t.text))
        return Be.makeSpan(["mspace", bk[t.text]], [], e);
      throw new ot('Unknown type of space "' + t.text + '"');
    }
  },
  mathmlBuilder(t, e) {
    var r;
    if (xk.hasOwnProperty(t.text))
      r = new it.MathNode("mtext", [new it.TextNode("\xA0")]);
    else {
      if (bk.hasOwnProperty(t.text))
        return new it.MathNode("mspace");
      throw new ot('Unknown type of space "' + t.text + '"');
    }
    return r;
  }
});
var vz = () => {
  var t = new it.MathNode("mtd", []);
  return t.setAttribute("width", "50%"), t;
};
Rh({
  type: "tag",
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mtable", [new it.MathNode("mtr", [vz(), new it.MathNode("mtd", [vc(t.body, e)]), vz(), new it.MathNode("mtd", [vc(t.tag, e)])])]);
    return r.setAttribute("width", "100%"), r;
  }
});
var yz = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, bz = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, _Ce = {
  "\\textit": "textit",
  "\\textup": "textup"
}, xz = (t, e) => {
  var r = t.font;
  if (r) {
    if (yz[r])
      return e.withTextFontFamily(yz[r]);
    if (bz[r])
      return e.withTextFontWeight(bz[r]);
    if (r === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(_Ce[r]);
};
Tt({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, i = e[0];
    return {
      type: "text",
      mode: r.mode,
      body: Tn(i),
      font: n
    };
  },
  htmlBuilder(t, e) {
    var r = xz(t, e), n = Un(t.body, r, !0);
    return Be.makeSpan(["mord", "text"], n, r);
  },
  mathmlBuilder(t, e) {
    var r = xz(t, e);
    return vc(t.body, r);
  }
});
Tt({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "underline",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = br(t.body, e), n = Be.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, a = Be.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return Be.makeSpan(["mord", "underline"], [a], e);
  },
  mathmlBuilder(t, e) {
    var r = new it.MathNode("mo", [new it.TextNode("\u203E")]);
    r.setAttribute("stretchy", "true");
    var n = new it.MathNode("munder", [$r(t.body, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
Tt({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "vcenter",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = br(t.body, e), n = e.fontMetrics().axisHeight, i = 0.5 * (r.height - n - (r.depth + n));
    return Be.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(t, e) {
    return new it.MathNode("mpadded", [$r(t.body, e)], ["vcenter"]);
  }
});
Tt({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(t, e, r) {
    throw new ot("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(t, e) {
    for (var r = wz(t), n = [], i = e.havingStyle(e.style.text()), a = 0; a < r.length; a++) {
      var s = r[a];
      s === "~" && (s = "\\textasciitilde"), n.push(Be.makeSymbol(s, "Typewriter-Regular", t.mode, i, ["mord", "texttt"]));
    }
    return Be.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), Be.tryCombineChars(n), i);
  },
  mathmlBuilder(t, e) {
    var r = new it.TextNode(wz(t)), n = new it.MathNode("mtext", [r]);
    return n.setAttribute("mathvariant", "monospace"), n;
  }
});
var wz = (t) => t.body.replace(/ /g, t.star ? "\u2423" : "\xA0"), Jl = Kte, Are = `[ \r
	]`, ACe = "\\\\[a-zA-Z@]+", LCe = "\\\\[^\uD800-\uDFFF]", RCe = "(" + ACe + ")" + Are + "*", ICe = `\\\\(
|[ \r	]+
?)[ \r	]*`, lA = "[\u0300-\u036F]", MCe = new RegExp(lA + "+$"), NCe = "(" + Are + "+)|" + // whitespace
(ICe + "|") + // \whitespace
"([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
(lA + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(lA + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + RCe) + // \macroName + spaces
("|" + LCe + ")");
let Tz = class {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, r) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = r, this.tokenRegex = new RegExp(NCe, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, r) {
    this.catcodes[e] = r;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, r = this.tokenRegex.lastIndex;
    if (r === e.length)
      return new es("EOF", new Ta(this, r, r));
    var n = this.tokenRegex.exec(e);
    if (n === null || n.index !== r)
      throw new ot("Unexpected character: '" + e[r] + "'", new es(e[r], new Ta(this, r, r + 1)));
    var i = n[6] || n[3] || (n[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var a = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return a === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = a + 1, this.lex();
    }
    return new es(i, new Ta(this, r, this.tokenRegex.lastIndex));
  }
};
class DCe {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, r) {
    e === void 0 && (e = {}), r === void 0 && (r = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = r, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new ot("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var r in e)
      e.hasOwnProperty(r) && (e[r] == null ? delete this.current[r] : this.current[r] = e[r]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, r, n) {
    if (n === void 0 && (n = !1), n) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = r);
    } else {
      var a = this.undefStack[this.undefStack.length - 1];
      a && !a.hasOwnProperty(e) && (a[e] = this.current[e]);
    }
    r == null ? delete this.current[e] : this.current[e] = r;
  }
}
var OCe = vre;
le("\\noexpand", function(t) {
  var e = t.popToken();
  return t.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
le("\\expandafter", function(t) {
  var e = t.popToken();
  return t.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
le("\\@firstoftwo", function(t) {
  var e = t.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
le("\\@secondoftwo", function(t) {
  var e = t.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
le("\\@ifnextchar", function(t) {
  var e = t.consumeArgs(3);
  t.consumeSpaces();
  var r = t.future();
  return e[0].length === 1 && e[0][0].text === r.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
le("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
le("\\TextOrMath", function(t) {
  var e = t.consumeArgs(2);
  return t.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var Ez = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
le("\\char", function(t) {
  var e = t.popToken(), r, n = "";
  if (e.text === "'")
    r = 8, e = t.popToken();
  else if (e.text === '"')
    r = 16, e = t.popToken();
  else if (e.text === "`")
    if (e = t.popToken(), e.text[0] === "\\")
      n = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new ot("\\char` missing argument");
      n = e.text.charCodeAt(0);
    }
  else
    r = 10;
  if (r) {
    if (n = Ez[e.text], n == null || n >= r)
      throw new ot("Invalid base-" + r + " digit " + e.text);
    for (var i; (i = Ez[t.future().text]) != null && i < r; )
      n *= r, n += i, t.popToken();
  }
  return "\\@char{" + n + "}";
});
var jL = (t, e, r, n) => {
  var i = t.consumeArg().tokens;
  if (i.length !== 1)
    throw new ot("\\newcommand's first argument must be a macro name");
  var a = i[0].text, s = t.isDefined(a);
  if (s && !e)
    throw new ot("\\newcommand{" + a + "} attempting to redefine " + (a + "; use \\renewcommand"));
  if (!s && !r)
    throw new ot("\\renewcommand{" + a + "} when command " + a + " does not yet exist; use \\newcommand");
  var o = 0;
  if (i = t.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var l = "", u = t.expandNextToken(); u.text !== "]" && u.text !== "EOF"; )
      l += u.text, u = t.expandNextToken();
    if (!l.match(/^\s*[0-9]+\s*$/))
      throw new ot("Invalid number of arguments: " + l);
    o = parseInt(l), i = t.consumeArg().tokens;
  }
  return s && n || t.macros.set(a, {
    tokens: i,
    numArgs: o
  }), "";
};
le("\\newcommand", (t) => jL(t, !1, !0, !1));
le("\\renewcommand", (t) => jL(t, !0, !1, !1));
le("\\providecommand", (t) => jL(t, !0, !0, !0));
le("\\message", (t) => {
  var e = t.consumeArgs(1)[0];
  return console.log(e.reverse().map((r) => r.text).join("")), "";
});
le("\\errmessage", (t) => {
  var e = t.consumeArgs(1)[0];
  return console.error(e.reverse().map((r) => r.text).join("")), "";
});
le("\\show", (t) => {
  var e = t.popToken(), r = e.text;
  return console.log(e, t.macros.get(r), Jl[r], Gr.math[r], Gr.text[r]), "";
});
le("\\bgroup", "{");
le("\\egroup", "}");
le("~", "\\nobreakspace");
le("\\lq", "`");
le("\\rq", "'");
le("\\aa", "\\r a");
le("\\AA", "\\r A");
le("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
le("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
le("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
le("\u212C", "\\mathscr{B}");
le("\u2130", "\\mathscr{E}");
le("\u2131", "\\mathscr{F}");
le("\u210B", "\\mathscr{H}");
le("\u2110", "\\mathscr{I}");
le("\u2112", "\\mathscr{L}");
le("\u2133", "\\mathscr{M}");
le("\u211B", "\\mathscr{R}");
le("\u212D", "\\mathfrak{C}");
le("\u210C", "\\mathfrak{H}");
le("\u2128", "\\mathfrak{Z}");
le("\\Bbbk", "\\Bbb{k}");
le("\xB7", "\\cdotp");
le("\\llap", "\\mathllap{\\textrm{#1}}");
le("\\rlap", "\\mathrlap{\\textrm{#1}}");
le("\\clap", "\\mathclap{\\textrm{#1}}");
le("\\mathstrut", "\\vphantom{(}");
le("\\underbar", "\\underline{\\text{#1}}");
le("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
le("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
le("\\ne", "\\neq");
le("\u2260", "\\neq");
le("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
le("\u2209", "\\notin");
le("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
le("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
le("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
le("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
le("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
le("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
le("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
le("\u27C2", "\\perp");
le("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
le("\u220C", "\\notni");
le("\u231C", "\\ulcorner");
le("\u231D", "\\urcorner");
le("\u231E", "\\llcorner");
le("\u231F", "\\lrcorner");
le("\xA9", "\\copyright");
le("\xAE", "\\textregistered");
le("\uFE0F", "\\textregistered");
le("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
le("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
le("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
le("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
le("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
le("\u22EE", "\\vdots");
le("\\varGamma", "\\mathit{\\Gamma}");
le("\\varDelta", "\\mathit{\\Delta}");
le("\\varTheta", "\\mathit{\\Theta}");
le("\\varLambda", "\\mathit{\\Lambda}");
le("\\varXi", "\\mathit{\\Xi}");
le("\\varPi", "\\mathit{\\Pi}");
le("\\varSigma", "\\mathit{\\Sigma}");
le("\\varUpsilon", "\\mathit{\\Upsilon}");
le("\\varPhi", "\\mathit{\\Phi}");
le("\\varPsi", "\\mathit{\\Psi}");
le("\\varOmega", "\\mathit{\\Omega}");
le("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
le("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
le("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
le("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
le("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
le("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
le("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
le("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var Sz = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
le("\\dots", function(t) {
  var e = "\\dotso", r = t.expandAfterFuture().text;
  return r in Sz ? e = Sz[r] : (r.slice(0, 4) === "\\not" || r in Gr.math && Bt.contains(["bin", "rel"], Gr.math[r].group)) && (e = "\\dotsb"), e;
});
var KL = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
le("\\dotso", function(t) {
  var e = t.future().text;
  return e in KL ? "\\ldots\\," : "\\ldots";
});
le("\\dotsc", function(t) {
  var e = t.future().text;
  return e in KL && e !== "," ? "\\ldots\\," : "\\ldots";
});
le("\\cdots", function(t) {
  var e = t.future().text;
  return e in KL ? "\\@cdots\\," : "\\@cdots";
});
le("\\dotsb", "\\cdots");
le("\\dotsm", "\\cdots");
le("\\dotsi", "\\!\\cdots");
le("\\dotsx", "\\ldots\\,");
le("\\DOTSI", "\\relax");
le("\\DOTSB", "\\relax");
le("\\DOTSX", "\\relax");
le("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
le("\\,", "\\tmspace+{3mu}{.1667em}");
le("\\thinspace", "\\,");
le("\\>", "\\mskip{4mu}");
le("\\:", "\\tmspace+{4mu}{.2222em}");
le("\\medspace", "\\:");
le("\\;", "\\tmspace+{5mu}{.2777em}");
le("\\thickspace", "\\;");
le("\\!", "\\tmspace-{3mu}{.1667em}");
le("\\negthinspace", "\\!");
le("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
le("\\negthickspace", "\\tmspace-{5mu}{.277em}");
le("\\enspace", "\\kern.5em ");
le("\\enskip", "\\hskip.5em\\relax");
le("\\quad", "\\hskip1em\\relax");
le("\\qquad", "\\hskip2em\\relax");
le("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
le("\\tag@paren", "\\tag@literal{({#1})}");
le("\\tag@literal", (t) => {
  if (t.macros.get("\\df@tag"))
    throw new ot("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
le("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
le("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
le("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
le("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
le("\\newline", "\\\\\\relax");
le("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var Lre = pt(ro["Main-Regular"][84][1] - 0.7 * ro["Main-Regular"][65][1]);
le("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + Lre + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
le("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + Lre + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
le("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
le("\\@hspace", "\\hskip #1\\relax");
le("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
le("\\ordinarycolon", ":");
le("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
le("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
le("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
le("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
le("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
le("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
le("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
le("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
le("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
le("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
le("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
le("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
le("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
le("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
le("\u2237", "\\dblcolon");
le("\u2239", "\\eqcolon");
le("\u2254", "\\coloneqq");
le("\u2255", "\\eqqcolon");
le("\u2A74", "\\Coloneqq");
le("\\ratio", "\\vcentcolon");
le("\\coloncolon", "\\dblcolon");
le("\\colonequals", "\\coloneqq");
le("\\coloncolonequals", "\\Coloneqq");
le("\\equalscolon", "\\eqqcolon");
le("\\equalscoloncolon", "\\Eqqcolon");
le("\\colonminus", "\\coloneq");
le("\\coloncolonminus", "\\Coloneq");
le("\\minuscolon", "\\eqcolon");
le("\\minuscoloncolon", "\\Eqcolon");
le("\\coloncolonapprox", "\\Colonapprox");
le("\\coloncolonsim", "\\Colonsim");
le("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
le("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
le("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
le("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
le("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
le("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
le("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
le("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
le("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
le("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
le("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
le("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
le("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
le("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
le("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
le("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
le("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
le("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
le("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
le("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
le("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
le("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
le("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
le("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
le("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
le("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
le("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
le("\\imath", "\\html@mathml{\\@imath}{\u0131}");
le("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
le("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
le("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
le("\u27E6", "\\llbracket");
le("\u27E7", "\\rrbracket");
le("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
le("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
le("\u2983", "\\lBrace");
le("\u2984", "\\rBrace");
le("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
le("\u29B5", "\\minuso");
le("\\darr", "\\downarrow");
le("\\dArr", "\\Downarrow");
le("\\Darr", "\\Downarrow");
le("\\lang", "\\langle");
le("\\rang", "\\rangle");
le("\\uarr", "\\uparrow");
le("\\uArr", "\\Uparrow");
le("\\Uarr", "\\Uparrow");
le("\\N", "\\mathbb{N}");
le("\\R", "\\mathbb{R}");
le("\\Z", "\\mathbb{Z}");
le("\\alef", "\\aleph");
le("\\alefsym", "\\aleph");
le("\\Alpha", "\\mathrm{A}");
le("\\Beta", "\\mathrm{B}");
le("\\bull", "\\bullet");
le("\\Chi", "\\mathrm{X}");
le("\\clubs", "\\clubsuit");
le("\\cnums", "\\mathbb{C}");
le("\\Complex", "\\mathbb{C}");
le("\\Dagger", "\\ddagger");
le("\\diamonds", "\\diamondsuit");
le("\\empty", "\\emptyset");
le("\\Epsilon", "\\mathrm{E}");
le("\\Eta", "\\mathrm{H}");
le("\\exist", "\\exists");
le("\\harr", "\\leftrightarrow");
le("\\hArr", "\\Leftrightarrow");
le("\\Harr", "\\Leftrightarrow");
le("\\hearts", "\\heartsuit");
le("\\image", "\\Im");
le("\\infin", "\\infty");
le("\\Iota", "\\mathrm{I}");
le("\\isin", "\\in");
le("\\Kappa", "\\mathrm{K}");
le("\\larr", "\\leftarrow");
le("\\lArr", "\\Leftarrow");
le("\\Larr", "\\Leftarrow");
le("\\lrarr", "\\leftrightarrow");
le("\\lrArr", "\\Leftrightarrow");
le("\\Lrarr", "\\Leftrightarrow");
le("\\Mu", "\\mathrm{M}");
le("\\natnums", "\\mathbb{N}");
le("\\Nu", "\\mathrm{N}");
le("\\Omicron", "\\mathrm{O}");
le("\\plusmn", "\\pm");
le("\\rarr", "\\rightarrow");
le("\\rArr", "\\Rightarrow");
le("\\Rarr", "\\Rightarrow");
le("\\real", "\\Re");
le("\\reals", "\\mathbb{R}");
le("\\Reals", "\\mathbb{R}");
le("\\Rho", "\\mathrm{P}");
le("\\sdot", "\\cdot");
le("\\sect", "\\S");
le("\\spades", "\\spadesuit");
le("\\sub", "\\subset");
le("\\sube", "\\subseteq");
le("\\supe", "\\supseteq");
le("\\Tau", "\\mathrm{T}");
le("\\thetasym", "\\vartheta");
le("\\weierp", "\\wp");
le("\\Zeta", "\\mathrm{Z}");
le("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
le("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
le("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
le("\\bra", "\\mathinner{\\langle{#1}|}");
le("\\ket", "\\mathinner{|{#1}\\rangle}");
le("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
le("\\Bra", "\\left\\langle#1\\right|");
le("\\Ket", "\\left|#1\\right\\rangle");
var Rre = (t) => (e) => {
  var r = e.consumeArg().tokens, n = e.consumeArg().tokens, i = e.consumeArg().tokens, a = e.consumeArg().tokens, s = e.macros.get("|"), o = e.macros.get("\\|");
  e.macros.beginGroup();
  var l = (f) => (d) => {
    t && (d.macros.set("|", s), i.length && d.macros.set("\\|", o));
    var p = f;
    if (!f && i.length) {
      var g = d.future();
      g.text === "|" && (d.popToken(), p = !0);
    }
    return {
      tokens: p ? i : n,
      numArgs: 0
    };
  };
  e.macros.set("|", l(!1)), i.length && e.macros.set("\\|", l(!0));
  var u = e.consumeArg().tokens, h = e.expandTokens([
    ...a,
    ...u,
    ...r
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: h.reverse(),
    numArgs: 0
  };
};
le("\\bra@ket", Rre(!1));
le("\\bra@set", Rre(!0));
le("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
le("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
le("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
le("\\angln", "{\\angl n}");
le("\\blue", "\\textcolor{##6495ed}{#1}");
le("\\orange", "\\textcolor{##ffa500}{#1}");
le("\\pink", "\\textcolor{##ff00af}{#1}");
le("\\red", "\\textcolor{##df0030}{#1}");
le("\\green", "\\textcolor{##28ae7b}{#1}");
le("\\gray", "\\textcolor{gray}{#1}");
le("\\purple", "\\textcolor{##9d38bd}{#1}");
le("\\blueA", "\\textcolor{##ccfaff}{#1}");
le("\\blueB", "\\textcolor{##80f6ff}{#1}");
le("\\blueC", "\\textcolor{##63d9ea}{#1}");
le("\\blueD", "\\textcolor{##11accd}{#1}");
le("\\blueE", "\\textcolor{##0c7f99}{#1}");
le("\\tealA", "\\textcolor{##94fff5}{#1}");
le("\\tealB", "\\textcolor{##26edd5}{#1}");
le("\\tealC", "\\textcolor{##01d1c1}{#1}");
le("\\tealD", "\\textcolor{##01a995}{#1}");
le("\\tealE", "\\textcolor{##208170}{#1}");
le("\\greenA", "\\textcolor{##b6ffb0}{#1}");
le("\\greenB", "\\textcolor{##8af281}{#1}");
le("\\greenC", "\\textcolor{##74cf70}{#1}");
le("\\greenD", "\\textcolor{##1fab54}{#1}");
le("\\greenE", "\\textcolor{##0d923f}{#1}");
le("\\goldA", "\\textcolor{##ffd0a9}{#1}");
le("\\goldB", "\\textcolor{##ffbb71}{#1}");
le("\\goldC", "\\textcolor{##ff9c39}{#1}");
le("\\goldD", "\\textcolor{##e07d10}{#1}");
le("\\goldE", "\\textcolor{##a75a05}{#1}");
le("\\redA", "\\textcolor{##fca9a9}{#1}");
le("\\redB", "\\textcolor{##ff8482}{#1}");
le("\\redC", "\\textcolor{##f9685d}{#1}");
le("\\redD", "\\textcolor{##e84d39}{#1}");
le("\\redE", "\\textcolor{##bc2612}{#1}");
le("\\maroonA", "\\textcolor{##ffbde0}{#1}");
le("\\maroonB", "\\textcolor{##ff92c6}{#1}");
le("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
le("\\maroonD", "\\textcolor{##ca337c}{#1}");
le("\\maroonE", "\\textcolor{##9e034e}{#1}");
le("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
le("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
le("\\purpleC", "\\textcolor{##aa87ff}{#1}");
le("\\purpleD", "\\textcolor{##7854ab}{#1}");
le("\\purpleE", "\\textcolor{##543b78}{#1}");
le("\\mintA", "\\textcolor{##f5f9e8}{#1}");
le("\\mintB", "\\textcolor{##edf2df}{#1}");
le("\\mintC", "\\textcolor{##e0e5cc}{#1}");
le("\\grayA", "\\textcolor{##f6f7f7}{#1}");
le("\\grayB", "\\textcolor{##f0f1f2}{#1}");
le("\\grayC", "\\textcolor{##e3e5e6}{#1}");
le("\\grayD", "\\textcolor{##d6d8da}{#1}");
le("\\grayE", "\\textcolor{##babec2}{#1}");
le("\\grayF", "\\textcolor{##888d93}{#1}");
le("\\grayG", "\\textcolor{##626569}{#1}");
le("\\grayH", "\\textcolor{##3b3e40}{#1}");
le("\\grayI", "\\textcolor{##21242c}{#1}");
le("\\kaBlue", "\\textcolor{##314453}{#1}");
le("\\kaGreen", "\\textcolor{##71B307}{#1}");
var Ire = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class PCe {
  constructor(e, r, n) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = r, this.expansionCount = 0, this.feed(e), this.macros = new DCe(OCe, r.macros), this.mode = n, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new Tz(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var r, n, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      r = this.popToken(), {
        tokens: i,
        end: n
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: r,
        end: n
      } = this.consumeArg());
    return this.pushToken(new es("EOF", n.loc)), this.pushTokens(i), r.range(n, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var r = [], n = e && e.length > 0;
    n || this.consumeSpaces();
    var i = this.future(), a, s = 0, o = 0;
    do {
      if (a = this.popToken(), r.push(a), a.text === "{")
        ++s;
      else if (a.text === "}") {
        if (--s, s === -1)
          throw new ot("Extra }", a);
      } else if (a.text === "EOF")
        throw new ot("Unexpected end of input in a macro argument, expected '" + (e && n ? e[o] : "}") + "'", a);
      if (e && n)
        if ((s === 0 || s === 1 && e[o] === "{") && a.text === e[o]) {
          if (++o, o === e.length) {
            r.splice(-o, o);
            break;
          }
        } else
          o = 0;
    } while (s !== 0 || n);
    return i.text === "{" && r[r.length - 1].text === "}" && (r.pop(), r.shift()), r.reverse(), {
      tokens: r,
      start: i,
      end: a
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, r) {
    if (r) {
      if (r.length !== e + 1)
        throw new ot("The length of delimiters doesn't match the number of args!");
      for (var n = r[0], i = 0; i < n.length; i++) {
        var a = this.popToken();
        if (n[i] !== a.text)
          throw new ot("Use of the macro doesn't match its definition", a);
      }
    }
    for (var s = [], o = 0; o < e; o++)
      s.push(this.consumeArg(r && r[o + 1]).tokens);
    return s;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new ot("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var r = this.popToken(), n = r.text, i = r.noexpand ? null : this._getExpansion(n);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && n[0] === "\\" && !this.isDefined(n))
        throw new ot("Undefined control sequence: " + n);
      return this.pushToken(r), !1;
    }
    this.countExpansion(1);
    var a = i.tokens, s = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      a = a.slice();
      for (var o = a.length - 1; o >= 0; --o) {
        var l = a[o];
        if (l.text === "#") {
          if (o === 0)
            throw new ot("Incomplete placeholder at end of macro body", l);
          if (l = a[--o], l.text === "#")
            a.splice(o + 1, 1);
          else if (/^[1-9]$/.test(l.text))
            a.splice(o, 2, ...s[+l.text - 1]);
          else
            throw new ot("Not a valid argument number", l);
        }
      }
    }
    return this.pushTokens(a), a.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new es(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var r = [], n = this.stack.length;
    for (this.pushTokens(e); this.stack.length > n; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), r.push(i);
      }
    return this.countExpansion(r.length), r;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var r = this.expandMacro(e);
    return r && r.map((n) => n.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var r = this.macros.get(e);
    if (r == null)
      return r;
    if (e.length === 1) {
      var n = this.lexer.catcodes[e];
      if (n != null && n !== 13)
        return;
    }
    var i = typeof r == "function" ? r(this) : r;
    if (typeof i == "string") {
      var a = 0;
      if (i.indexOf("#") !== -1)
        for (var s = i.replace(/##/g, ""); s.indexOf("#" + (a + 1)) !== -1; )
          ++a;
      for (var o = new Tz(i, this.settings), l = [], u = o.lex(); u.text !== "EOF"; )
        l.push(u), u = o.lex();
      l.reverse();
      var h = {
        tokens: l,
        numArgs: a
      };
      return h;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || Jl.hasOwnProperty(e) || Gr.math.hasOwnProperty(e) || Gr.text.hasOwnProperty(e) || Ire.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var r = this.macros.get(e);
    return r != null ? typeof r == "string" || typeof r == "function" || !r.unexpandable : Jl.hasOwnProperty(e) && !Jl[e].primitive;
  }
}
var kz = /^[]/, Sv = Object.freeze({
  "\u208A": "+",
  "\u208B": "-",
  "\u208C": "=",
  "\u208D": "(",
  "\u208E": ")",
  "\u2080": "0",
  "\u2081": "1",
  "\u2082": "2",
  "\u2083": "3",
  "\u2084": "4",
  "\u2085": "5",
  "\u2086": "6",
  "\u2087": "7",
  "\u2088": "8",
  "\u2089": "9",
  "\u2090": "a",
  "\u2091": "e",
  "\u2095": "h",
  "\u1D62": "i",
  "\u2C7C": "j",
  "\u2096": "k",
  "\u2097": "l",
  "\u2098": "m",
  "\u2099": "n",
  "\u2092": "o",
  "\u209A": "p",
  "\u1D63": "r",
  "\u209B": "s",
  "\u209C": "t",
  "\u1D64": "u",
  "\u1D65": "v",
  "\u2093": "x",
  "\u1D66": "\u03B2",
  "\u1D67": "\u03B3",
  "\u1D68": "\u03C1",
  "\u1D69": "\u03D5",
  "\u1D6A": "\u03C7",
  "\u207A": "+",
  "\u207B": "-",
  "\u207C": "=",
  "\u207D": "(",
  "\u207E": ")",
  "\u2070": "0",
  "\xB9": "1",
  "\xB2": "2",
  "\xB3": "3",
  "\u2074": "4",
  "\u2075": "5",
  "\u2076": "6",
  "\u2077": "7",
  "\u2078": "8",
  "\u2079": "9",
  "\u1D2C": "A",
  "\u1D2E": "B",
  "\u1D30": "D",
  "\u1D31": "E",
  "\u1D33": "G",
  "\u1D34": "H",
  "\u1D35": "I",
  "\u1D36": "J",
  "\u1D37": "K",
  "\u1D38": "L",
  "\u1D39": "M",
  "\u1D3A": "N",
  "\u1D3C": "O",
  "\u1D3E": "P",
  "\u1D3F": "R",
  "\u1D40": "T",
  "\u1D41": "U",
  "\u2C7D": "V",
  "\u1D42": "W",
  "\u1D43": "a",
  "\u1D47": "b",
  "\u1D9C": "c",
  "\u1D48": "d",
  "\u1D49": "e",
  "\u1DA0": "f",
  "\u1D4D": "g",
  \u02B0: "h",
  "\u2071": "i",
  \u02B2: "j",
  "\u1D4F": "k",
  \u02E1: "l",
  "\u1D50": "m",
  \u207F: "n",
  "\u1D52": "o",
  "\u1D56": "p",
  \u02B3: "r",
  \u02E2: "s",
  "\u1D57": "t",
  "\u1D58": "u",
  "\u1D5B": "v",
  \u02B7: "w",
  \u02E3: "x",
  \u02B8: "y",
  "\u1DBB": "z",
  "\u1D5D": "\u03B2",
  "\u1D5E": "\u03B3",
  "\u1D5F": "\u03B4",
  "\u1D60": "\u03D5",
  "\u1D61": "\u03C7",
  "\u1DBF": "\u03B8"
}), wk = {
  "\u0301": {
    text: "\\'",
    math: "\\acute"
  },
  "\u0300": {
    text: "\\`",
    math: "\\grave"
  },
  "\u0308": {
    text: '\\"',
    math: "\\ddot"
  },
  "\u0303": {
    text: "\\~",
    math: "\\tilde"
  },
  "\u0304": {
    text: "\\=",
    math: "\\bar"
  },
  "\u0306": {
    text: "\\u",
    math: "\\breve"
  },
  "\u030C": {
    text: "\\v",
    math: "\\check"
  },
  "\u0302": {
    text: "\\^",
    math: "\\hat"
  },
  "\u0307": {
    text: "\\.",
    math: "\\dot"
  },
  "\u030A": {
    text: "\\r",
    math: "\\mathring"
  },
  "\u030B": {
    text: "\\H"
  },
  "\u0327": {
    text: "\\c"
  }
}, Cz = {
  \u00E1: "a\u0301",
  \u00E0: "a\u0300",
  \u00E4: "a\u0308",
  \u01DF: "a\u0308\u0304",
  \u00E3: "a\u0303",
  \u0101: "a\u0304",
  \u0103: "a\u0306",
  \u1EAF: "a\u0306\u0301",
  \u1EB1: "a\u0306\u0300",
  \u1EB5: "a\u0306\u0303",
  \u01CE: "a\u030C",
  \u00E2: "a\u0302",
  \u1EA5: "a\u0302\u0301",
  \u1EA7: "a\u0302\u0300",
  \u1EAB: "a\u0302\u0303",
  \u0227: "a\u0307",
  \u01E1: "a\u0307\u0304",
  \u00E5: "a\u030A",
  \u01FB: "a\u030A\u0301",
  \u1E03: "b\u0307",
  \u0107: "c\u0301",
  \u1E09: "c\u0327\u0301",
  \u010D: "c\u030C",
  \u0109: "c\u0302",
  \u010B: "c\u0307",
  \u00E7: "c\u0327",
  \u010F: "d\u030C",
  \u1E0B: "d\u0307",
  \u1E11: "d\u0327",
  \u00E9: "e\u0301",
  \u00E8: "e\u0300",
  \u00EB: "e\u0308",
  \u1EBD: "e\u0303",
  \u0113: "e\u0304",
  \u1E17: "e\u0304\u0301",
  \u1E15: "e\u0304\u0300",
  \u0115: "e\u0306",
  \u1E1D: "e\u0327\u0306",
  \u011B: "e\u030C",
  \u00EA: "e\u0302",
  \u1EBF: "e\u0302\u0301",
  \u1EC1: "e\u0302\u0300",
  \u1EC5: "e\u0302\u0303",
  \u0117: "e\u0307",
  \u0229: "e\u0327",
  \u1E1F: "f\u0307",
  \u01F5: "g\u0301",
  \u1E21: "g\u0304",
  \u011F: "g\u0306",
  \u01E7: "g\u030C",
  \u011D: "g\u0302",
  \u0121: "g\u0307",
  \u0123: "g\u0327",
  \u1E27: "h\u0308",
  \u021F: "h\u030C",
  \u0125: "h\u0302",
  \u1E23: "h\u0307",
  \u1E29: "h\u0327",
  \u00ED: "i\u0301",
  \u00EC: "i\u0300",
  \u00EF: "i\u0308",
  \u1E2F: "i\u0308\u0301",
  \u0129: "i\u0303",
  \u012B: "i\u0304",
  \u012D: "i\u0306",
  \u01D0: "i\u030C",
  \u00EE: "i\u0302",
  \u01F0: "j\u030C",
  \u0135: "j\u0302",
  \u1E31: "k\u0301",
  \u01E9: "k\u030C",
  \u0137: "k\u0327",
  \u013A: "l\u0301",
  \u013E: "l\u030C",
  \u013C: "l\u0327",
  \u1E3F: "m\u0301",
  \u1E41: "m\u0307",
  \u0144: "n\u0301",
  \u01F9: "n\u0300",
  \u00F1: "n\u0303",
  \u0148: "n\u030C",
  \u1E45: "n\u0307",
  \u0146: "n\u0327",
  \u00F3: "o\u0301",
  \u00F2: "o\u0300",
  \u00F6: "o\u0308",
  \u022B: "o\u0308\u0304",
  \u00F5: "o\u0303",
  \u1E4D: "o\u0303\u0301",
  \u1E4F: "o\u0303\u0308",
  \u022D: "o\u0303\u0304",
  \u014D: "o\u0304",
  \u1E53: "o\u0304\u0301",
  \u1E51: "o\u0304\u0300",
  \u014F: "o\u0306",
  \u01D2: "o\u030C",
  \u00F4: "o\u0302",
  \u1ED1: "o\u0302\u0301",
  \u1ED3: "o\u0302\u0300",
  \u1ED7: "o\u0302\u0303",
  \u022F: "o\u0307",
  \u0231: "o\u0307\u0304",
  \u0151: "o\u030B",
  \u1E55: "p\u0301",
  \u1E57: "p\u0307",
  \u0155: "r\u0301",
  \u0159: "r\u030C",
  \u1E59: "r\u0307",
  \u0157: "r\u0327",
  \u015B: "s\u0301",
  \u1E65: "s\u0301\u0307",
  \u0161: "s\u030C",
  \u1E67: "s\u030C\u0307",
  \u015D: "s\u0302",
  \u1E61: "s\u0307",
  \u015F: "s\u0327",
  \u1E97: "t\u0308",
  \u0165: "t\u030C",
  \u1E6B: "t\u0307",
  \u0163: "t\u0327",
  \u00FA: "u\u0301",
  \u00F9: "u\u0300",
  \u00FC: "u\u0308",
  \u01D8: "u\u0308\u0301",
  \u01DC: "u\u0308\u0300",
  \u01D6: "u\u0308\u0304",
  \u01DA: "u\u0308\u030C",
  \u0169: "u\u0303",
  \u1E79: "u\u0303\u0301",
  \u016B: "u\u0304",
  \u1E7B: "u\u0304\u0308",
  \u016D: "u\u0306",
  \u01D4: "u\u030C",
  \u00FB: "u\u0302",
  \u016F: "u\u030A",
  \u0171: "u\u030B",
  \u1E7D: "v\u0303",
  \u1E83: "w\u0301",
  \u1E81: "w\u0300",
  \u1E85: "w\u0308",
  \u0175: "w\u0302",
  \u1E87: "w\u0307",
  \u1E98: "w\u030A",
  \u1E8D: "x\u0308",
  \u1E8B: "x\u0307",
  \u00FD: "y\u0301",
  \u1EF3: "y\u0300",
  \u00FF: "y\u0308",
  \u1EF9: "y\u0303",
  \u0233: "y\u0304",
  \u0177: "y\u0302",
  \u1E8F: "y\u0307",
  \u1E99: "y\u030A",
  \u017A: "z\u0301",
  \u017E: "z\u030C",
  \u1E91: "z\u0302",
  \u017C: "z\u0307",
  \u00C1: "A\u0301",
  \u00C0: "A\u0300",
  \u00C4: "A\u0308",
  \u01DE: "A\u0308\u0304",
  \u00C3: "A\u0303",
  \u0100: "A\u0304",
  \u0102: "A\u0306",
  \u1EAE: "A\u0306\u0301",
  \u1EB0: "A\u0306\u0300",
  \u1EB4: "A\u0306\u0303",
  \u01CD: "A\u030C",
  \u00C2: "A\u0302",
  \u1EA4: "A\u0302\u0301",
  \u1EA6: "A\u0302\u0300",
  \u1EAA: "A\u0302\u0303",
  \u0226: "A\u0307",
  \u01E0: "A\u0307\u0304",
  \u00C5: "A\u030A",
  \u01FA: "A\u030A\u0301",
  \u1E02: "B\u0307",
  \u0106: "C\u0301",
  \u1E08: "C\u0327\u0301",
  \u010C: "C\u030C",
  \u0108: "C\u0302",
  \u010A: "C\u0307",
  \u00C7: "C\u0327",
  \u010E: "D\u030C",
  \u1E0A: "D\u0307",
  \u1E10: "D\u0327",
  \u00C9: "E\u0301",
  \u00C8: "E\u0300",
  \u00CB: "E\u0308",
  \u1EBC: "E\u0303",
  \u0112: "E\u0304",
  \u1E16: "E\u0304\u0301",
  \u1E14: "E\u0304\u0300",
  \u0114: "E\u0306",
  \u1E1C: "E\u0327\u0306",
  \u011A: "E\u030C",
  \u00CA: "E\u0302",
  \u1EBE: "E\u0302\u0301",
  \u1EC0: "E\u0302\u0300",
  \u1EC4: "E\u0302\u0303",
  \u0116: "E\u0307",
  \u0228: "E\u0327",
  \u1E1E: "F\u0307",
  \u01F4: "G\u0301",
  \u1E20: "G\u0304",
  \u011E: "G\u0306",
  \u01E6: "G\u030C",
  \u011C: "G\u0302",
  \u0120: "G\u0307",
  \u0122: "G\u0327",
  \u1E26: "H\u0308",
  \u021E: "H\u030C",
  \u0124: "H\u0302",
  \u1E22: "H\u0307",
  \u1E28: "H\u0327",
  \u00CD: "I\u0301",
  \u00CC: "I\u0300",
  \u00CF: "I\u0308",
  \u1E2E: "I\u0308\u0301",
  \u0128: "I\u0303",
  \u012A: "I\u0304",
  \u012C: "I\u0306",
  \u01CF: "I\u030C",
  \u00CE: "I\u0302",
  \u0130: "I\u0307",
  \u0134: "J\u0302",
  \u1E30: "K\u0301",
  \u01E8: "K\u030C",
  \u0136: "K\u0327",
  \u0139: "L\u0301",
  \u013D: "L\u030C",
  \u013B: "L\u0327",
  \u1E3E: "M\u0301",
  \u1E40: "M\u0307",
  \u0143: "N\u0301",
  \u01F8: "N\u0300",
  \u00D1: "N\u0303",
  \u0147: "N\u030C",
  \u1E44: "N\u0307",
  \u0145: "N\u0327",
  \u00D3: "O\u0301",
  \u00D2: "O\u0300",
  \u00D6: "O\u0308",
  \u022A: "O\u0308\u0304",
  \u00D5: "O\u0303",
  \u1E4C: "O\u0303\u0301",
  \u1E4E: "O\u0303\u0308",
  \u022C: "O\u0303\u0304",
  \u014C: "O\u0304",
  \u1E52: "O\u0304\u0301",
  \u1E50: "O\u0304\u0300",
  \u014E: "O\u0306",
  \u01D1: "O\u030C",
  \u00D4: "O\u0302",
  \u1ED0: "O\u0302\u0301",
  \u1ED2: "O\u0302\u0300",
  \u1ED6: "O\u0302\u0303",
  \u022E: "O\u0307",
  \u0230: "O\u0307\u0304",
  \u0150: "O\u030B",
  \u1E54: "P\u0301",
  \u1E56: "P\u0307",
  \u0154: "R\u0301",
  \u0158: "R\u030C",
  \u1E58: "R\u0307",
  \u0156: "R\u0327",
  \u015A: "S\u0301",
  \u1E64: "S\u0301\u0307",
  \u0160: "S\u030C",
  \u1E66: "S\u030C\u0307",
  \u015C: "S\u0302",
  \u1E60: "S\u0307",
  \u015E: "S\u0327",
  \u0164: "T\u030C",
  \u1E6A: "T\u0307",
  \u0162: "T\u0327",
  \u00DA: "U\u0301",
  \u00D9: "U\u0300",
  \u00DC: "U\u0308",
  \u01D7: "U\u0308\u0301",
  \u01DB: "U\u0308\u0300",
  \u01D5: "U\u0308\u0304",
  \u01D9: "U\u0308\u030C",
  \u0168: "U\u0303",
  \u1E78: "U\u0303\u0301",
  \u016A: "U\u0304",
  \u1E7A: "U\u0304\u0308",
  \u016C: "U\u0306",
  \u01D3: "U\u030C",
  \u00DB: "U\u0302",
  \u016E: "U\u030A",
  \u0170: "U\u030B",
  \u1E7C: "V\u0303",
  \u1E82: "W\u0301",
  \u1E80: "W\u0300",
  \u1E84: "W\u0308",
  \u0174: "W\u0302",
  \u1E86: "W\u0307",
  \u1E8C: "X\u0308",
  \u1E8A: "X\u0307",
  \u00DD: "Y\u0301",
  \u1EF2: "Y\u0300",
  \u0178: "Y\u0308",
  \u1EF8: "Y\u0303",
  \u0232: "Y\u0304",
  \u0176: "Y\u0302",
  \u1E8E: "Y\u0307",
  \u0179: "Z\u0301",
  \u017D: "Z\u030C",
  \u1E90: "Z\u0302",
  \u017B: "Z\u0307",
  \u03AC: "\u03B1\u0301",
  \u1F70: "\u03B1\u0300",
  \u1FB1: "\u03B1\u0304",
  \u1FB0: "\u03B1\u0306",
  \u03AD: "\u03B5\u0301",
  \u1F72: "\u03B5\u0300",
  \u03AE: "\u03B7\u0301",
  \u1F74: "\u03B7\u0300",
  \u03AF: "\u03B9\u0301",
  \u1F76: "\u03B9\u0300",
  \u03CA: "\u03B9\u0308",
  \u0390: "\u03B9\u0308\u0301",
  \u1FD2: "\u03B9\u0308\u0300",
  \u1FD1: "\u03B9\u0304",
  \u1FD0: "\u03B9\u0306",
  \u03CC: "\u03BF\u0301",
  \u1F78: "\u03BF\u0300",
  \u03CD: "\u03C5\u0301",
  \u1F7A: "\u03C5\u0300",
  \u03CB: "\u03C5\u0308",
  \u03B0: "\u03C5\u0308\u0301",
  \u1FE2: "\u03C5\u0308\u0300",
  \u1FE1: "\u03C5\u0304",
  \u1FE0: "\u03C5\u0306",
  \u03CE: "\u03C9\u0301",
  \u1F7C: "\u03C9\u0300",
  \u038E: "\u03A5\u0301",
  \u1FEA: "\u03A5\u0300",
  \u03AB: "\u03A5\u0308",
  \u1FE9: "\u03A5\u0304",
  \u1FE8: "\u03A5\u0306",
  \u038F: "\u03A9\u0301",
  \u1FFA: "\u03A9\u0300"
};
let Mre = class Nre {
  constructor(e, r) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new PCe(e, r, this.mode), this.settings = r, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, r) {
    if (r === void 0 && (r = !0), this.fetch().text !== e)
      throw new ot("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    r && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var r = this.nextToken;
    this.consume(), this.gullet.pushToken(new es("}")), this.gullet.pushTokens(e);
    var n = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = r, n;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, r) {
    for (var n = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (Nre.endOfExpression.indexOf(i.text) !== -1 || r && i.text === r || e && Jl[i.text] && Jl[i.text].infix)
        break;
      var a = this.parseAtom(r);
      if (a) {
        if (a.type === "internal")
          continue;
      } else break;
      n.push(a);
    }
    return this.mode === "text" && this.formLigatures(n), this.handleInfixNodes(n);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var r = -1, n, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (r !== -1)
          throw new ot("only one infix operator per group", e[i].token);
        r = i, n = e[i].replaceWith;
      }
    if (r !== -1 && n) {
      var a, s, o = e.slice(0, r), l = e.slice(r + 1);
      o.length === 1 && o[0].type === "ordgroup" ? a = o[0] : a = {
        type: "ordgroup",
        mode: this.mode,
        body: o
      }, l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      };
      var u;
      return n === "\\\\abovefrac" ? u = this.callFunction(n, [a, e[r], s], []) : u = this.callFunction(n, [a, s], []), [u];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var r = this.fetch(), n = r.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var a;
      i = this.parseGroup(e);
    } while (((a = i) == null ? void 0 : a.type) === "internal");
    if (!i)
      throw new ot("Expected group after '" + n + "'", r);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var r = [], n = 0; n < e.length; n++)
      r.push({
        type: "textord",
        mode: "text",
        text: e[n]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: r
    }, a = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return a;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var r = this.parseGroup("atom", e);
    if (r?.type === "internal" || this.mode === "text")
      return r;
    for (var n, i; ; ) {
      this.consumeSpaces();
      var a = this.fetch();
      if (a.text === "\\limits" || a.text === "\\nolimits") {
        if (r && r.type === "op") {
          var s = a.text === "\\limits";
          r.limits = s, r.alwaysHandleSupSub = !0;
        } else if (r && r.type === "operatorname")
          r.alwaysHandleSupSub && (r.limits = a.text === "\\limits");
        else
          throw new ot("Limit controls must follow a math operator", a);
        this.consume();
      } else if (a.text === "^") {
        if (n)
          throw new ot("Double superscript", a);
        n = this.handleSupSubscript("superscript");
      } else if (a.text === "_") {
        if (i)
          throw new ot("Double subscript", a);
        i = this.handleSupSubscript("subscript");
      } else if (a.text === "'") {
        if (n)
          throw new ot("Double superscript", a);
        var o = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, l = [o];
        for (this.consume(); this.fetch().text === "'"; )
          l.push(o), this.consume();
        this.fetch().text === "^" && l.push(this.handleSupSubscript("superscript")), n = {
          type: "ordgroup",
          mode: this.mode,
          body: l
        };
      } else if (Sv[a.text]) {
        var u = kz.test(a.text), h = [];
        for (h.push(new es(Sv[a.text])), this.consume(); ; ) {
          var f = this.fetch().text;
          if (!Sv[f] || kz.test(f) !== u)
            break;
          h.unshift(new es(Sv[f])), this.consume();
        }
        var d = this.subparse(h);
        u ? i = {
          type: "ordgroup",
          mode: "math",
          body: d
        } : n = {
          type: "ordgroup",
          mode: "math",
          body: d
        };
      } else
        break;
    }
    return n || i ? {
      type: "supsub",
      mode: this.mode,
      base: r,
      sup: n,
      sub: i
    } : r;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, r) {
    var n = this.fetch(), i = n.text, a = Jl[i];
    if (!a)
      return null;
    if (this.consume(), r && r !== "atom" && !a.allowedInArgument)
      throw new ot("Got function '" + i + "' with no arguments" + (r ? " as " + r : ""), n);
    if (this.mode === "text" && !a.allowedInText)
      throw new ot("Can't use function '" + i + "' in text mode", n);
    if (this.mode === "math" && a.allowedInMath === !1)
      throw new ot("Can't use function '" + i + "' in math mode", n);
    var {
      args: s,
      optArgs: o
    } = this.parseArguments(i, a);
    return this.callFunction(i, s, o, n, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, r, n, i, a) {
    var s = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: a
    }, o = Jl[e];
    if (o && o.handler)
      return o.handler(s, r, n);
    throw new ot("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, r) {
    var n = r.numArgs + r.numOptionalArgs;
    if (n === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], a = [], s = 0; s < n; s++) {
      var o = r.argTypes && r.argTypes[s], l = s < r.numOptionalArgs;
      (r.primitive && o == null || // \sqrt expands into primitive if optional argument doesn't exist
      r.type === "sqrt" && s === 1 && a[0] == null) && (o = "primitive");
      var u = this.parseGroupOfType("argument to '" + e + "'", o, l);
      if (l)
        a.push(u);
      else if (u != null)
        i.push(u);
      else
        throw new ot("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: a
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, r, n) {
    switch (r) {
      case "color":
        return this.parseColorGroup(n);
      case "size":
        return this.parseSizeGroup(n);
      case "url":
        return this.parseUrlGroup(n);
      case "math":
      case "text":
        return this.parseArgumentGroup(n, r);
      case "hbox": {
        var i = this.parseArgumentGroup(n, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var a = this.parseStringGroup("raw", n);
        return a != null ? {
          type: "raw",
          mode: "text",
          string: a.text
        } : null;
      }
      case "primitive": {
        if (n)
          throw new ot("A primitive argument cannot be optional");
        var s = this.parseGroup(e);
        if (s == null)
          throw new ot("Expected group as " + e, this.fetch());
        return s;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(n);
      default:
        throw new ot("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, r) {
    var n = this.gullet.scanArgument(r);
    if (n == null)
      return null;
    for (var i = "", a; (a = this.fetch()).text !== "EOF"; )
      i += a.text, this.consume();
    return this.consume(), n.text = i, n;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, r) {
    for (var n = this.fetch(), i = n, a = "", s; (s = this.fetch()).text !== "EOF" && e.test(a + s.text); )
      i = s, a += i.text, this.consume();
    if (a === "")
      throw new ot("Invalid " + r + ": '" + n.text + "'", n);
    return n.range(i, a);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var r = this.parseStringGroup("color", e);
    if (r == null)
      return null;
    var n = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(r.text);
    if (!n)
      throw new ot("Invalid color: '" + r.text + "'", r);
    var i = n[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var r, n = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? r = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : r = this.parseStringGroup("size", e), !r)
      return null;
    !e && r.text.length === 0 && (r.text = "0pt", n = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(r.text);
    if (!i)
      throw new ot("Invalid size: '" + r.text + "'", r);
    var a = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!qte(a))
      throw new ot("Invalid unit: '" + a.unit + "'", r);
    return {
      type: "size",
      mode: this.mode,
      value: a,
      isBlank: n
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var r = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), r == null)
      return null;
    var n = r.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: n
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, r) {
    var n = this.gullet.scanArgument(e);
    if (n == null)
      return null;
    var i = this.mode;
    r && this.switchMode(r), this.gullet.beginGroup();
    var a = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var s = {
      type: "ordgroup",
      mode: this.mode,
      loc: n.loc,
      body: a
    };
    return r && this.switchMode(i), s;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, r) {
    var n = this.fetch(), i = n.text, a;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var s = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var o = this.parseExpression(!1, s), l = this.fetch();
      this.expect(s), this.gullet.endGroup(), a = {
        type: "ordgroup",
        mode: this.mode,
        loc: Ta.range(n, l),
        body: o,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (a = this.parseFunction(r, e) || this.parseSymbol(), a == null && i[0] === "\\" && !Ire.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new ot("Undefined control sequence: " + i, n);
      a = this.formatUnsupportedCmd(i), this.consume();
    }
    return a;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var r = e.length - 1, n = 0; n < r; ++n) {
      var i = e[n], a = i.text;
      a === "-" && e[n + 1].text === "-" && (n + 1 < r && e[n + 2].text === "-" ? (e.splice(n, 3, {
        type: "textord",
        mode: "text",
        loc: Ta.range(i, e[n + 2]),
        text: "---"
      }), r -= 2) : (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: Ta.range(i, e[n + 1]),
        text: "--"
      }), r -= 1)), (a === "'" || a === "`") && e[n + 1].text === a && (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: Ta.range(i, e[n + 1]),
        text: a + a
      }), r -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), r = e.text;
    if (/^\\verb[^a-zA-Z]/.test(r)) {
      this.consume();
      var n = r.slice(5), i = n.charAt(0) === "*";
      if (i && (n = n.slice(1)), n.length < 2 || n.charAt(0) !== n.slice(-1))
        throw new ot(`\\verb assertion failed --
                    please report what input caused this bug`);
      return n = n.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: n,
        star: i
      };
    }
    Cz.hasOwnProperty(r[0]) && !Gr[this.mode][r[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + r[0] + '" used in math mode', e), r = Cz[r[0]] + r.slice(1));
    var a = MCe.exec(r);
    a && (r = r.substring(0, a.index), r === "i" ? r = "\u0131" : r === "j" && (r = "\u0237"));
    var s;
    if (Gr[this.mode][r]) {
      this.settings.strict && this.mode === "math" && nA.indexOf(r) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + r[0] + '" used in math mode', e);
      var o = Gr[this.mode][r].group, l = Ta.range(e), u;
      if (Ske.hasOwnProperty(o)) {
        var h = o;
        u = {
          type: "atom",
          mode: this.mode,
          family: h,
          loc: l,
          text: r
        };
      } else
        u = {
          type: o,
          mode: this.mode,
          loc: l,
          text: r
        };
      s = u;
    } else if (r.charCodeAt(0) >= 128)
      this.settings.strict && (Fte(r.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + r[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + r[0] + '"' + (" (" + r.charCodeAt(0) + ")"), e)), s = {
        type: "textord",
        mode: "text",
        loc: Ta.range(e),
        text: r
      };
    else
      return null;
    if (this.consume(), a)
      for (var f = 0; f < a[0].length; f++) {
        var d = a[0][f];
        if (!wk[d])
          throw new ot("Unknown accent ' " + d + "'", e);
        var p = wk[d][this.mode] || wk[d].text;
        if (!p)
          throw new ot("Accent " + d + " unsupported in " + this.mode + " mode", e);
        s = {
          type: "accent",
          mode: this.mode,
          loc: Ta.range(e),
          label: p,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: s
        };
      }
    return s;
  }
};
Mre.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var ZL = function(e, r) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var n = new Mre(e, r);
  delete n.gullet.macros.current["\\df@tag"];
  var i = n.parse();
  if (delete n.gullet.macros.current["\\current@color"], delete n.gullet.macros.current["\\color"], n.gullet.macros.get("\\df@tag")) {
    if (!r.displayMode)
      throw new ot("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: n.subparse([new es("\\df@tag")])
    }];
  }
  return i;
}, QL = function(e, r, n) {
  r.textContent = "";
  var i = z4(e, n).toNode();
  r.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), QL = function() {
  throw new ot("KaTeX doesn't work in quirks mode.");
});
var Dre = function(e, r) {
  var n = z4(e, r).toMarkup();
  return n;
}, Ore = function(e, r) {
  var n = new NL(r);
  return ZL(e, n);
}, Pre = function(e, r, n) {
  if (n.throwOnError || !(e instanceof ot))
    throw e;
  var i = Be.makeSpan(["katex-error"], [new as(r)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + n.errorColor), i;
}, z4 = function(e, r) {
  var n = new NL(r);
  try {
    var i = ZL(e, n);
    return Yke(i, e, n);
  } catch (a) {
    return Pre(a, e, n);
  }
}, $re = function(e, r) {
  var n = new NL(r);
  try {
    var i = ZL(e, n);
    return Xke(i, e, n);
  } catch (a) {
    return Pre(a, e, n);
  }
}, Bre = "0.16.22", Fre = {
  Span: pm,
  Anchor: PL,
  SymbolNode: as,
  SvgNode: gl,
  PathNode: mc,
  LineNode: rA
}, $Ce = {
  /**
   * Current KaTeX version
   */
  version: Bre,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: QL,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: Dre,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: ot,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: Fg,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: Ore,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: z4,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: $re,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: zte,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: q,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: Tt,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: le,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: Fre
};
const BCe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ParseError: ot,
  SETTINGS_SCHEMA: Fg,
  __defineFunction: Tt,
  __defineMacro: le,
  __defineSymbol: q,
  __domTree: Fre,
  __parse: Ore,
  __renderToDomTree: z4,
  __renderToHTMLTree: $re,
  __setFontMetrics: zte,
  default: $Ce,
  get render() {
    return QL;
  },
  renderToString: Dre,
  version: Bre
}, Symbol.toStringTag, { value: "Module" }));
var FCe = "[object Symbol]";
function Qu(t) {
  return typeof t == "symbol" || go(t) && bh(t) == FCe;
}
function $f(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
var _z = ns ? ns.prototype : void 0, Az = _z ? _z.toString : void 0;
function zre(t) {
  if (typeof t == "string")
    return t;
  if (Rn(t))
    return $f(t, zre) + "";
  if (Qu(t))
    return Az ? Az.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var zCe = /\s/;
function qCe(t) {
  for (var e = t.length; e-- && zCe.test(t.charAt(e)); )
    ;
  return e;
}
var GCe = /^\s+/;
function UCe(t) {
  return t && t.slice(0, qCe(t) + 1).replace(GCe, "");
}
var Lz = NaN, VCe = /^[-+]0x[0-9a-f]+$/i, HCe = /^0b[01]+$/i, WCe = /^0o[0-7]+$/i, YCe = parseInt;
function XCe(t) {
  if (typeof t == "number")
    return t;
  if (Qu(t))
    return Lz;
  if (Ia(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Ia(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = UCe(t);
  var r = HCe.test(t);
  return r || WCe.test(t) ? YCe(t.slice(2), r ? 2 : 8) : VCe.test(t) ? Lz : +t;
}
var Rz = 1 / 0, jCe = 17976931348623157e292;
function Dy(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = XCe(t), t === Rz || t === -Rz) {
    var e = t < 0 ? -1 : 1;
    return e * jCe;
  }
  return t === t ? t : 0;
}
function KCe(t) {
  var e = Dy(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function ZCe() {
}
function qre(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
function Gre(t, e, r, n) {
  for (var i = t.length, a = r + -1; ++a < i; )
    if (e(t[a], a, t))
      return a;
  return -1;
}
function QCe(t) {
  return t !== t;
}
function JCe(t, e, r) {
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
function e7e(t, e, r) {
  return e === e ? JCe(t, e, r) : Gre(t, QCe, r);
}
function t7e(t, e) {
  var r = t == null ? 0 : t.length;
  return !!r && e7e(t, e, 0) > -1;
}
function ka(t) {
  return $c(t) ? xZ(t) : KJ(t);
}
var r7e = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n7e = /^\w*$/;
function JL(t, e) {
  if (Rn(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || Qu(t) ? !0 : n7e.test(t) || !r7e.test(t) || e != null && t in Object(e);
}
var i7e = 500;
function a7e(t) {
  var e = L0(t, function(n) {
    return r.size === i7e && r.clear(), n;
  }), r = e.cache;
  return e;
}
var s7e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, o7e = /\\(\\)?/g, l7e = a7e(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(s7e, function(r, n, i, a) {
    e.push(i ? a.replace(o7e, "$1") : n || r);
  }), e;
});
function Ure(t) {
  return t == null ? "" : zre(t);
}
function q4(t, e) {
  return Rn(t) ? t : JL(t, e) ? [t] : l7e(Ure(t));
}
function mm(t) {
  if (typeof t == "string" || Qu(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function G4(t, e) {
  e = q4(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[mm(e[r++])];
  return r && r == n ? t : void 0;
}
function c7e(t, e, r) {
  var n = t == null ? void 0 : G4(t, e);
  return n === void 0 ? r : n;
}
function eR(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n; )
    t[i + r] = e[r];
  return t;
}
var Iz = ns ? ns.isConcatSpreadable : void 0;
function u7e(t) {
  return Rn(t) || r0(t) || !!(Iz && t && t[Iz]);
}
function U4(t, e, r, n, i) {
  var a = -1, s = t.length;
  for (r || (r = u7e), i || (i = []); ++a < s; ) {
    var o = t[a];
    r(o) ? eR(i, o) : n || (i[i.length] = o);
  }
  return i;
}
function Ih(t) {
  var e = t == null ? 0 : t.length;
  return e ? U4(t) : [];
}
function h7e(t) {
  return EZ(TZ(t, void 0, Ih), t + "");
}
function f7e(t, e, r, n) {
  var i = -1, a = t == null ? 0 : t.length;
  for (n && a && (r = t[++i]); ++i < a; )
    r = e(r, t[i], i, t);
  return r;
}
function d7e(t, e) {
  return t && im(e, ka(e), t);
}
function p7e(t, e) {
  return t && im(e, Th(e), t);
}
function Vre(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n; ) {
    var s = t[r];
    e(s, r, t) && (a[i++] = s);
  }
  return a;
}
function Hre() {
  return [];
}
var g7e = Object.prototype, m7e = g7e.propertyIsEnumerable, Mz = Object.getOwnPropertySymbols, tR = Mz ? function(t) {
  return t == null ? [] : (t = Object(t), Vre(Mz(t), function(e) {
    return m7e.call(t, e);
  }));
} : Hre;
function v7e(t, e) {
  return im(t, tR(t), e);
}
var y7e = Object.getOwnPropertySymbols, Wre = y7e ? function(t) {
  for (var e = []; t; )
    eR(e, tR(t)), t = q9(t);
  return e;
} : Hre;
function b7e(t, e) {
  return im(t, Wre(t), e);
}
function Yre(t, e, r) {
  var n = e(t);
  return Rn(t) ? n : eR(n, r(t));
}
function cA(t) {
  return Yre(t, ka, tR);
}
function x7e(t) {
  return Yre(t, Th, Wre);
}
var w7e = Object.prototype, T7e = w7e.hasOwnProperty;
function E7e(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && T7e.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
function S7e(t, e) {
  var r = e ? z9(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var k7e = /\w*$/;
function C7e(t) {
  var e = new t.constructor(t.source, k7e.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var Nz = ns ? ns.prototype : void 0, Dz = Nz ? Nz.valueOf : void 0;
function _7e(t) {
  return Dz ? Object(Dz.call(t)) : {};
}
var A7e = "[object Boolean]", L7e = "[object Date]", R7e = "[object Map]", I7e = "[object Number]", M7e = "[object RegExp]", N7e = "[object Set]", D7e = "[object String]", O7e = "[object Symbol]", P7e = "[object ArrayBuffer]", $7e = "[object DataView]", B7e = "[object Float32Array]", F7e = "[object Float64Array]", z7e = "[object Int8Array]", q7e = "[object Int16Array]", G7e = "[object Int32Array]", U7e = "[object Uint8Array]", V7e = "[object Uint8ClampedArray]", H7e = "[object Uint16Array]", W7e = "[object Uint32Array]";
function Y7e(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case P7e:
      return z9(t);
    case A7e:
    case L7e:
      return new n(+t);
    case $7e:
      return S7e(t, r);
    case B7e:
    case F7e:
    case z7e:
    case q7e:
    case G7e:
    case U7e:
    case V7e:
    case H7e:
    case W7e:
      return hZ(t, r);
    case R7e:
      return new n();
    case I7e:
    case D7e:
      return new n(t);
    case M7e:
      return C7e(t);
    case N7e:
      return new n();
    case O7e:
      return _7e(t);
  }
}
var X7e = "[object Map]";
function j7e(t) {
  return go(t) && Ha(t) == X7e;
}
var Oz = i0 && i0.isMap, K7e = Oz ? t4(Oz) : j7e, Z7e = "[object Set]";
function Q7e(t) {
  return go(t) && Ha(t) == Z7e;
}
var Pz = i0 && i0.isSet, J7e = Pz ? t4(Pz) : Q7e, e_e = 1, t_e = 2, r_e = 4, Xre = "[object Arguments]", n_e = "[object Array]", i_e = "[object Boolean]", a_e = "[object Date]", s_e = "[object Error]", jre = "[object Function]", o_e = "[object GeneratorFunction]", l_e = "[object Map]", c_e = "[object Number]", Kre = "[object Object]", u_e = "[object RegExp]", h_e = "[object Set]", f_e = "[object String]", d_e = "[object Symbol]", p_e = "[object WeakMap]", g_e = "[object ArrayBuffer]", m_e = "[object DataView]", v_e = "[object Float32Array]", y_e = "[object Float64Array]", b_e = "[object Int8Array]", x_e = "[object Int16Array]", w_e = "[object Int32Array]", T_e = "[object Uint8Array]", E_e = "[object Uint8ClampedArray]", S_e = "[object Uint16Array]", k_e = "[object Uint32Array]", Fr = {};
Fr[Xre] = Fr[n_e] = Fr[g_e] = Fr[m_e] = Fr[i_e] = Fr[a_e] = Fr[v_e] = Fr[y_e] = Fr[b_e] = Fr[x_e] = Fr[w_e] = Fr[l_e] = Fr[c_e] = Fr[Kre] = Fr[u_e] = Fr[h_e] = Fr[f_e] = Fr[d_e] = Fr[T_e] = Fr[E_e] = Fr[S_e] = Fr[k_e] = !0;
Fr[s_e] = Fr[jre] = Fr[p_e] = !1;
function qg(t, e, r, n, i, a) {
  var s, o = e & e_e, l = e & t_e, u = e & r_e;
  if (s !== void 0)
    return s;
  if (!Ia(t))
    return t;
  var h = Rn(t);
  if (h) {
    if (s = E7e(t), !o)
      return fZ(t, s);
  } else {
    var f = Ha(t), d = f == jre || f == o_e;
    if (n0(t))
      return uZ(t, o);
    if (f == Kre || f == Xre || d && !i) {
      if (s = l || d ? {} : pZ(t), !o)
        return l ? b7e(t, p7e(s, t)) : v7e(t, d7e(s, t));
    } else {
      if (!Fr[f])
        return i ? t : {};
      s = Y7e(t, f, o);
    }
  }
  a || (a = new ks());
  var p = a.get(t);
  if (p)
    return p;
  a.set(t, s), J7e(t) ? t.forEach(function(v) {
    s.add(qg(v, e, r, v, t, a));
  }) : K7e(t) && t.forEach(function(v, y) {
    s.set(y, qg(v, e, r, y, t, a));
  });
  var g = u ? l ? x7e : cA : l ? Th : ka, m = h ? void 0 : g(t);
  return qre(m || t, function(v, y) {
    m && (y = v, v = t[y]), n4(s, y, qg(v, e, r, y, t, a));
  }), s;
}
var C_e = 4;
function Zre(t) {
  return qg(t, C_e);
}
var __e = 1, A_e = 4;
function L_e(t) {
  return qg(t, __e | A_e);
}
var R_e = "__lodash_hash_undefined__";
function I_e(t) {
  return this.__data__.set(t, R_e), this;
}
function M_e(t) {
  return this.__data__.has(t);
}
function b1(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new kl(); ++e < r; )
    this.add(t[e]);
}
b1.prototype.add = b1.prototype.push = I_e;
b1.prototype.has = M_e;
function N_e(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (e(t[r], r, t))
      return !0;
  return !1;
}
function Qre(t, e) {
  return t.has(e);
}
var D_e = 1, O_e = 2;
function Jre(t, e, r, n, i, a) {
  var s = r & D_e, o = t.length, l = e.length;
  if (o != l && !(s && l > o))
    return !1;
  var u = a.get(t), h = a.get(e);
  if (u && h)
    return u == e && h == t;
  var f = -1, d = !0, p = r & O_e ? new b1() : void 0;
  for (a.set(t, e), a.set(e, t); ++f < o; ) {
    var g = t[f], m = e[f];
    if (n)
      var v = s ? n(m, g, f, e, t, a) : n(g, m, f, t, e, a);
    if (v !== void 0) {
      if (v)
        continue;
      d = !1;
      break;
    }
    if (p) {
      if (!N_e(e, function(y, b) {
        if (!Qre(p, b) && (g === y || i(g, y, r, n, a)))
          return p.push(b);
      })) {
        d = !1;
        break;
      }
    } else if (!(g === m || i(g, m, r, n, a))) {
      d = !1;
      break;
    }
  }
  return a.delete(t), a.delete(e), d;
}
function P_e(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, i) {
    r[++e] = [i, n];
  }), r;
}
function rR(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var $_e = 1, B_e = 2, F_e = "[object Boolean]", z_e = "[object Date]", q_e = "[object Error]", G_e = "[object Map]", U_e = "[object Number]", V_e = "[object RegExp]", H_e = "[object Set]", W_e = "[object String]", Y_e = "[object Symbol]", X_e = "[object ArrayBuffer]", j_e = "[object DataView]", $z = ns ? ns.prototype : void 0, Tk = $z ? $z.valueOf : void 0;
function K_e(t, e, r, n, i, a, s) {
  switch (r) {
    case j_e:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case X_e:
      return !(t.byteLength != e.byteLength || !a(new nb(t), new nb(e)));
    case F_e:
    case z_e:
    case U_e:
      return A0(+t, +e);
    case q_e:
      return t.name == e.name && t.message == e.message;
    case V_e:
    case W_e:
      return t == e + "";
    case G_e:
      var o = P_e;
    case H_e:
      var l = n & $_e;
      if (o || (o = rR), t.size != e.size && !l)
        return !1;
      var u = s.get(t);
      if (u)
        return u == e;
      n |= B_e, s.set(t, e);
      var h = Jre(o(t), o(e), n, i, a, s);
      return s.delete(t), h;
    case Y_e:
      if (Tk)
        return Tk.call(t) == Tk.call(e);
  }
  return !1;
}
var Z_e = 1, Q_e = Object.prototype, J_e = Q_e.hasOwnProperty;
function eAe(t, e, r, n, i, a) {
  var s = r & Z_e, o = cA(t), l = o.length, u = cA(e), h = u.length;
  if (l != h && !s)
    return !1;
  for (var f = l; f--; ) {
    var d = o[f];
    if (!(s ? d in e : J_e.call(e, d)))
      return !1;
  }
  var p = a.get(t), g = a.get(e);
  if (p && g)
    return p == e && g == t;
  var m = !0;
  a.set(t, e), a.set(e, t);
  for (var v = s; ++f < l; ) {
    d = o[f];
    var y = t[d], b = e[d];
    if (n)
      var x = s ? n(b, y, d, e, t, a) : n(y, b, d, t, e, a);
    if (!(x === void 0 ? y === b || i(y, b, r, n, a) : x)) {
      m = !1;
      break;
    }
    v || (v = d == "constructor");
  }
  if (m && !v) {
    var T = t.constructor, E = e.constructor;
    T != E && "constructor" in t && "constructor" in e && !(typeof T == "function" && T instanceof T && typeof E == "function" && E instanceof E) && (m = !1);
  }
  return a.delete(t), a.delete(e), m;
}
var tAe = 1, Bz = "[object Arguments]", Fz = "[object Array]", kv = "[object Object]", rAe = Object.prototype, zz = rAe.hasOwnProperty;
function nAe(t, e, r, n, i, a) {
  var s = Rn(t), o = Rn(e), l = s ? Fz : Ha(t), u = o ? Fz : Ha(e);
  l = l == Bz ? kv : l, u = u == Bz ? kv : u;
  var h = l == kv, f = u == kv, d = l == u;
  if (d && n0(t)) {
    if (!n0(e))
      return !1;
    s = !0, h = !1;
  }
  if (d && !h)
    return a || (a = new ks()), s || r4(t) ? Jre(t, e, r, n, i, a) : K_e(t, e, l, r, n, i, a);
  if (!(r & tAe)) {
    var p = h && zz.call(t, "__wrapped__"), g = f && zz.call(e, "__wrapped__");
    if (p || g) {
      var m = p ? t.value() : t, v = g ? e.value() : e;
      return a || (a = new ks()), i(m, v, r, n, a);
    }
  }
  return d ? (a || (a = new ks()), eAe(t, e, r, n, i, a)) : !1;
}
function nR(t, e, r, n, i) {
  return t === e ? !0 : t == null || e == null || !go(t) && !go(e) ? t !== t && e !== e : nAe(t, e, r, n, nR, i);
}
var iAe = 1, aAe = 2;
function sAe(t, e, r, n) {
  var i = r.length, a = i;
  if (t == null)
    return !a;
  for (t = Object(t); i--; ) {
    var s = r[i];
    if (s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
      return !1;
  }
  for (; ++i < a; ) {
    s = r[i];
    var o = s[0], l = t[o], u = s[1];
    if (s[2]) {
      if (l === void 0 && !(o in t))
        return !1;
    } else {
      var h = new ks(), f;
      if (!(f === void 0 ? nR(u, l, iAe | aAe, n, h) : f))
        return !1;
    }
  }
  return !0;
}
function ene(t) {
  return t === t && !Ia(t);
}
function oAe(t) {
  for (var e = ka(t), r = e.length; r--; ) {
    var n = e[r], i = t[n];
    e[r] = [n, i, ene(i)];
  }
  return e;
}
function tne(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function lAe(t) {
  var e = oAe(t);
  return e.length == 1 && e[0][2] ? tne(e[0][0], e[0][1]) : function(r) {
    return r === t || sAe(r, t, e);
  };
}
function cAe(t, e) {
  return t != null && e in Object(t);
}
function rne(t, e, r) {
  e = q4(e, t);
  for (var n = -1, i = e.length, a = !1; ++n < i; ) {
    var s = mm(e[n]);
    if (!(a = t != null && r(t, s)))
      break;
    t = t[s];
  }
  return a || ++n != i ? a : (i = t == null ? 0 : t.length, !!i && G9(i) && i4(s, i) && (Rn(t) || r0(t)));
}
function nne(t, e) {
  return t != null && rne(t, e, cAe);
}
var uAe = 1, hAe = 2;
function fAe(t, e) {
  return JL(t) && ene(e) ? tne(mm(t), e) : function(r) {
    var n = c7e(r, t);
    return n === void 0 && n === e ? nne(r, t) : nR(e, n, uAe | hAe);
  };
}
function dAe(t) {
  return function(e) {
    return e?.[t];
  };
}
function pAe(t) {
  return function(e) {
    return G4(e, t);
  };
}
function gAe(t) {
  return JL(t) ? dAe(mm(t)) : pAe(t);
}
function Ll(t) {
  return typeof t == "function" ? t : t == null ? Eh : typeof t == "object" ? Rn(t) ? fAe(t[0], t[1]) : lAe(t) : gAe(t);
}
function iR(t, e) {
  return t && F9(t, e, ka);
}
function mAe(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!$c(r))
      return t(r, n);
    for (var i = r.length, a = -1, s = Object(r); ++a < i && n(s[a], a, s) !== !1; )
      ;
    return r;
  };
}
var V4 = mAe(iR), ine = Object.prototype, vAe = ine.hasOwnProperty, yAe = a4(function(t, e) {
  t = Object(t);
  var r = -1, n = e.length, i = n > 2 ? e[2] : void 0;
  for (i && f1(e[0], e[1], i) && (n = 1); ++r < n; )
    for (var a = e[r], s = Th(a), o = -1, l = s.length; ++o < l; ) {
      var u = s[o], h = t[u];
      (h === void 0 || A0(h, ine[u]) && !vAe.call(t, u)) && (t[u] = a[u]);
    }
  return t;
});
function Eb(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
function aR(t) {
  return typeof t == "function" ? t : Eh;
}
function Ye(t, e) {
  var r = Rn(t) ? qre : V4;
  return r(t, aR(e));
}
function bAe(t, e) {
  var r = [];
  return V4(t, function(n, i, a) {
    e(n, i, a) && r.push(n);
  }), r;
}
function io(t, e) {
  var r = Rn(t) ? Vre : bAe;
  return r(t, Ll(e));
}
function xAe(t) {
  return function(e, r, n) {
    var i = Object(e);
    if (!$c(e)) {
      var a = Ll(r);
      e = ka(e), r = function(o) {
        return a(i[o], o, i);
      };
    }
    var s = t(e, r, n);
    return s > -1 ? i[a ? e[s] : s] : void 0;
  };
}
var wAe = Math.max;
function TAe(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = r == null ? 0 : KCe(r);
  return i < 0 && (i = wAe(n + i, 0)), Gre(t, Ll(e), i);
}
var sR = xAe(TAe);
function ane(t, e) {
  var r = -1, n = $c(t) ? Array(t.length) : [];
  return V4(t, function(i, a, s) {
    n[++r] = e(i, a, s);
  }), n;
}
function Dr(t, e) {
  var r = Rn(t) ? $f : ane;
  return r(t, Ll(e));
}
function EAe(t, e) {
  return U4(Dr(t, e));
}
function SAe(t, e) {
  return t == null ? t : F9(t, aR(e), Th);
}
function kAe(t, e) {
  return t && iR(t, aR(e));
}
function CAe(t, e) {
  return t > e;
}
var _Ae = Object.prototype, AAe = _Ae.hasOwnProperty;
function LAe(t, e) {
  return t != null && AAe.call(t, e);
}
function sne(t, e) {
  return t != null && rne(t, e, LAe);
}
function RAe(t, e) {
  return $f(e, function(r) {
    return t[r];
  });
}
function ll(t) {
  return t == null ? [] : RAe(t, ka(t));
}
function wn(t) {
  return t === void 0;
}
function one(t, e) {
  return t < e;
}
function H4(t, e) {
  var r = {};
  return e = Ll(e), iR(t, function(n, i, a) {
    Jx(r, i, e(n, i, a));
  }), r;
}
function oR(t, e, r) {
  for (var n = -1, i = t.length; ++n < i; ) {
    var a = t[n], s = e(a);
    if (s != null && (o === void 0 ? s === s && !Qu(s) : r(s, o)))
      var o = s, l = a;
  }
  return l;
}
function Ju(t) {
  return t && t.length ? oR(t, Eh, CAe) : void 0;
}
function l0(t) {
  return t && t.length ? oR(t, Eh, one) : void 0;
}
function lR(t, e) {
  return t && t.length ? oR(t, Ll(e), one) : void 0;
}
function IAe(t, e, r, n) {
  if (!Ia(t))
    return t;
  e = q4(e, t);
  for (var i = -1, a = e.length, s = a - 1, o = t; o != null && ++i < a; ) {
    var l = mm(e[i]), u = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != s) {
      var h = o[l];
      u = void 0, u === void 0 && (u = Ia(h) ? h : i4(e[i + 1]) ? [] : {});
    }
    n4(o, l, u), o = o[l];
  }
  return t;
}
function MAe(t, e, r) {
  for (var n = -1, i = e.length, a = {}; ++n < i; ) {
    var s = e[n], o = G4(t, s);
    r(o, s) && IAe(a, q4(s, t), o);
  }
  return a;
}
function NAe(t, e) {
  var r = t.length;
  for (t.sort(e); r--; )
    t[r] = t[r].value;
  return t;
}
function DAe(t, e) {
  if (t !== e) {
    var r = t !== void 0, n = t === null, i = t === t, a = Qu(t), s = e !== void 0, o = e === null, l = e === e, u = Qu(e);
    if (!o && !u && !a && t > e || a && s && l && !o && !u || n && s && l || !r && l || !i)
      return 1;
    if (!n && !a && !u && t < e || u && r && i && !n && !a || o && r && i || !s && i || !l)
      return -1;
  }
  return 0;
}
function OAe(t, e, r) {
  for (var n = -1, i = t.criteria, a = e.criteria, s = i.length, o = r.length; ++n < s; ) {
    var l = DAe(i[n], a[n]);
    if (l) {
      if (n >= o)
        return l;
      var u = r[n];
      return l * (u == "desc" ? -1 : 1);
    }
  }
  return t.index - e.index;
}
function PAe(t, e, r) {
  e.length ? e = $f(e, function(a) {
    return Rn(a) ? function(s) {
      return G4(s, a.length === 1 ? a[0] : a);
    } : a;
  }) : e = [Eh];
  var n = -1;
  e = $f(e, t4(Ll));
  var i = ane(t, function(a, s, o) {
    var l = $f(e, function(u) {
      return u(a);
    });
    return { criteria: l, index: ++n, value: a };
  });
  return NAe(i, function(a, s) {
    return OAe(a, s, r);
  });
}
function $Ae(t, e) {
  return MAe(t, e, function(r, n) {
    return nne(t, n);
  });
}
var Sb = h7e(function(t, e) {
  return t == null ? {} : $Ae(t, e);
}), BAe = Math.ceil, FAe = Math.max;
function zAe(t, e, r, n) {
  for (var i = -1, a = FAe(BAe((e - t) / (r || 1)), 0), s = Array(a); a--; )
    s[++i] = t, t += r;
  return s;
}
function qAe(t) {
  return function(e, r, n) {
    return n && typeof n != "number" && f1(e, r, n) && (r = n = void 0), e = Dy(e), r === void 0 ? (r = e, e = 0) : r = Dy(r), n = n === void 0 ? e < r ? 1 : -1 : Dy(n), zAe(e, r, n);
  };
}
var c0 = qAe();
function GAe(t, e, r, n, i) {
  return i(t, function(a, s, o) {
    r = n ? (n = !1, a) : e(r, a, s, o);
  }), r;
}
function eh(t, e, r) {
  var n = Rn(t) ? f7e : GAe, i = arguments.length < 3;
  return n(t, Ll(e), r, i, V4);
}
var vm = a4(function(t, e) {
  if (t == null)
    return [];
  var r = e.length;
  return r > 1 && f1(t, e[0], e[1]) ? e = [] : r > 2 && f1(e[0], e[1], e[2]) && (e = [e[0]]), PAe(t, U4(e), []);
}), UAe = 1 / 0, VAe = Of && 1 / rR(new Of([, -0]))[1] == UAe ? function(t) {
  return new Of(t);
} : ZCe, HAe = 200;
function lne(t, e, r) {
  var n = -1, i = t7e, a = t.length, s = !0, o = [], l = o;
  if (a >= HAe) {
    var u = e ? null : VAe(t);
    if (u)
      return rR(u);
    s = !1, i = Qre, l = new b1();
  } else
    l = e ? [] : o;
  e:
    for (; ++n < a; ) {
      var h = t[n], f = e ? e(h) : h;
      if (h = h !== 0 ? h : 0, s && f === f) {
        for (var d = l.length; d--; )
          if (l[d] === f)
            continue e;
        e && l.push(f), o.push(h);
      } else i(l, f, r) || (l !== o && l.push(f), o.push(h));
    }
  return o;
}
var WAe = a4(function(t) {
  return lne(U4(t, 1, mZ, !0));
});
function YAe(t, e) {
  return t && t.length ? lne(t, Ll(e)) : [];
}
var XAe = 0;
function cR(t) {
  var e = ++XAe;
  return Ure(t) + e;
}
function jAe(t, e, r) {
  for (var n = -1, i = t.length, a = e.length, s = {}; ++n < i; ) {
    var o = n < a ? e[n] : void 0;
    r(s, t[n], o);
  }
  return s;
}
function KAe(t, e) {
  return jAe(t || [], e || [], n4);
}
var ZAe = "\0", hu = "\0", qz = "";
class ma {
  constructor(e = {}) {
    this._isDirected = Object.prototype.hasOwnProperty.call(e, "directed") ? e.directed : !0, this._isMultigraph = Object.prototype.hasOwnProperty.call(e, "multigraph") ? e.multigraph : !1, this._isCompound = Object.prototype.hasOwnProperty.call(e, "compound") ? e.compound : !1, this._label = void 0, this._defaultNodeLabelFn = Ef(void 0), this._defaultEdgeLabelFn = Ef(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[hu] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  /* === Graph functions ========= */
  isDirected() {
    return this._isDirected;
  }
  isMultigraph() {
    return this._isMultigraph;
  }
  isCompound() {
    return this._isCompound;
  }
  setGraph(e) {
    return this._label = e, this;
  }
  graph() {
    return this._label;
  }
  /* === Node functions ========== */
  setDefaultNodeLabel(e) {
    return c1(e) || (e = Ef(e)), this._defaultNodeLabelFn = e, this;
  }
  nodeCount() {
    return this._nodeCount;
  }
  nodes() {
    return ka(this._nodes);
  }
  sources() {
    var e = this;
    return io(this.nodes(), function(r) {
      return m1(e._in[r]);
    });
  }
  sinks() {
    var e = this;
    return io(this.nodes(), function(r) {
      return m1(e._out[r]);
    });
  }
  setNodes(e, r) {
    var n = arguments, i = this;
    return Ye(e, function(a) {
      n.length > 1 ? i.setNode(a, r) : i.setNode(a);
    }), this;
  }
  setNode(e, r) {
    return Object.prototype.hasOwnProperty.call(this._nodes, e) ? (arguments.length > 1 && (this._nodes[e] = r), this) : (this._nodes[e] = arguments.length > 1 ? r : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = hu, this._children[e] = {}, this._children[hu][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);
  }
  node(e) {
    return this._nodes[e];
  }
  hasNode(e) {
    return Object.prototype.hasOwnProperty.call(this._nodes, e);
  }
  removeNode(e) {
    if (Object.prototype.hasOwnProperty.call(this._nodes, e)) {
      var r = (n) => this.removeEdge(this._edgeObjs[n]);
      delete this._nodes[e], this._isCompound && (this._removeFromParentsChildList(e), delete this._parent[e], Ye(this.children(e), (n) => {
        this.setParent(n);
      }), delete this._children[e]), Ye(ka(this._in[e]), r), delete this._in[e], delete this._preds[e], Ye(ka(this._out[e]), r), delete this._out[e], delete this._sucs[e], --this._nodeCount;
    }
    return this;
  }
  setParent(e, r) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (wn(r))
      r = hu;
    else {
      r += "";
      for (var n = r; !wn(n); n = this.parent(n))
        if (n === e)
          throw new Error("Setting " + r + " as parent of " + e + " would create a cycle");
      this.setNode(r);
    }
    return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = r, this._children[r][e] = !0, this;
  }
  _removeFromParentsChildList(e) {
    delete this._children[this._parent[e]][e];
  }
  parent(e) {
    if (this._isCompound) {
      var r = this._parent[e];
      if (r !== hu)
        return r;
    }
  }
  children(e) {
    if (wn(e) && (e = hu), this._isCompound) {
      var r = this._children[e];
      if (r)
        return ka(r);
    } else {
      if (e === hu)
        return this.nodes();
      if (this.hasNode(e))
        return [];
    }
  }
  predecessors(e) {
    var r = this._preds[e];
    if (r)
      return ka(r);
  }
  successors(e) {
    var r = this._sucs[e];
    if (r)
      return ka(r);
  }
  neighbors(e) {
    var r = this.predecessors(e);
    if (r)
      return WAe(r, this.successors(e));
  }
  isLeaf(e) {
    var r;
    return this.isDirected() ? r = this.successors(e) : r = this.neighbors(e), r.length === 0;
  }
  filterNodes(e) {
    var r = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    r.setGraph(this.graph());
    var n = this;
    Ye(this._nodes, function(s, o) {
      e(o) && r.setNode(o, s);
    }), Ye(this._edgeObjs, function(s) {
      r.hasNode(s.v) && r.hasNode(s.w) && r.setEdge(s, n.edge(s));
    });
    var i = {};
    function a(s) {
      var o = n.parent(s);
      return o === void 0 || r.hasNode(o) ? (i[s] = o, o) : o in i ? i[o] : a(o);
    }
    return this._isCompound && Ye(r.nodes(), function(s) {
      r.setParent(s, a(s));
    }), r;
  }
  /* === Edge functions ========== */
  setDefaultEdgeLabel(e) {
    return c1(e) || (e = Ef(e)), this._defaultEdgeLabelFn = e, this;
  }
  edgeCount() {
    return this._edgeCount;
  }
  edges() {
    return ll(this._edgeObjs);
  }
  setPath(e, r) {
    var n = this, i = arguments;
    return eh(e, function(a, s) {
      return i.length > 1 ? n.setEdge(a, s, r) : n.setEdge(a, s), s;
    }), this;
  }
  /*
   * setEdge(v, w, [value, [name]])
   * setEdge({ v, w, [name] }, [value])
   */
  setEdge() {
    var e, r, n, i, a = !1, s = arguments[0];
    typeof s == "object" && s !== null && "v" in s ? (e = s.v, r = s.w, n = s.name, arguments.length === 2 && (i = arguments[1], a = !0)) : (e = s, r = arguments[1], n = arguments[3], arguments.length > 2 && (i = arguments[2], a = !0)), e = "" + e, r = "" + r, wn(n) || (n = "" + n);
    var o = qp(this._isDirected, e, r, n);
    if (Object.prototype.hasOwnProperty.call(this._edgeLabels, o))
      return a && (this._edgeLabels[o] = i), this;
    if (!wn(n) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(e), this.setNode(r), this._edgeLabels[o] = a ? i : this._defaultEdgeLabelFn(e, r, n);
    var l = QAe(this._isDirected, e, r, n);
    return e = l.v, r = l.w, Object.freeze(l), this._edgeObjs[o] = l, Gz(this._preds[r], e), Gz(this._sucs[e], r), this._in[r][o] = l, this._out[e][o] = l, this._edgeCount++, this;
  }
  edge(e, r, n) {
    var i = arguments.length === 1 ? Ek(this._isDirected, arguments[0]) : qp(this._isDirected, e, r, n);
    return this._edgeLabels[i];
  }
  hasEdge(e, r, n) {
    var i = arguments.length === 1 ? Ek(this._isDirected, arguments[0]) : qp(this._isDirected, e, r, n);
    return Object.prototype.hasOwnProperty.call(this._edgeLabels, i);
  }
  removeEdge(e, r, n) {
    var i = arguments.length === 1 ? Ek(this._isDirected, arguments[0]) : qp(this._isDirected, e, r, n), a = this._edgeObjs[i];
    return a && (e = a.v, r = a.w, delete this._edgeLabels[i], delete this._edgeObjs[i], Uz(this._preds[r], e), Uz(this._sucs[e], r), delete this._in[r][i], delete this._out[e][i], this._edgeCount--), this;
  }
  inEdges(e, r) {
    var n = this._in[e];
    if (n) {
      var i = ll(n);
      return r ? io(i, function(a) {
        return a.v === r;
      }) : i;
    }
  }
  outEdges(e, r) {
    var n = this._out[e];
    if (n) {
      var i = ll(n);
      return r ? io(i, function(a) {
        return a.w === r;
      }) : i;
    }
  }
  nodeEdges(e, r) {
    var n = this.inEdges(e, r);
    if (n)
      return n.concat(this.outEdges(e, r));
  }
}
ma.prototype._nodeCount = 0;
ma.prototype._edgeCount = 0;
function Gz(t, e) {
  t[e] ? t[e]++ : t[e] = 1;
}
function Uz(t, e) {
  --t[e] || delete t[e];
}
function qp(t, e, r, n) {
  var i = "" + e, a = "" + r;
  if (!t && i > a) {
    var s = i;
    i = a, a = s;
  }
  return i + qz + a + qz + (wn(n) ? ZAe : n);
}
function QAe(t, e, r, n) {
  var i = "" + e, a = "" + r;
  if (!t && i > a) {
    var s = i;
    i = a, a = s;
  }
  var o = { v: i, w: a };
  return n && (o.name = n), o;
}
function Ek(t, e) {
  return qp(t, e.v, e.w, e.name);
}
class JAe {
  constructor() {
    var e = {};
    e._next = e._prev = e, this._sentinel = e;
  }
  dequeue() {
    var e = this._sentinel, r = e._prev;
    if (r !== e)
      return Vz(r), r;
  }
  enqueue(e) {
    var r = this._sentinel;
    e._prev && e._next && Vz(e), e._next = r._next, r._next._prev = e, r._next = e, e._prev = r;
  }
  toString() {
    for (var e = [], r = this._sentinel, n = r._prev; n !== r; )
      e.push(JSON.stringify(n, e8e)), n = n._prev;
    return "[" + e.join(", ") + "]";
  }
}
function Vz(t) {
  t._prev._next = t._next, t._next._prev = t._prev, delete t._next, delete t._prev;
}
function e8e(t, e) {
  if (t !== "_next" && t !== "_prev")
    return e;
}
var t8e = Ef(1);
function r8e(t, e) {
  if (t.nodeCount() <= 1)
    return [];
  var r = i8e(t, e || t8e), n = n8e(r.graph, r.buckets, r.zeroIdx);
  return Ih(
    Dr(n, function(i) {
      return t.outEdges(i.v, i.w);
    })
  );
}
function n8e(t, e, r) {
  for (var n = [], i = e[e.length - 1], a = e[0], s; t.nodeCount(); ) {
    for (; s = a.dequeue(); )
      Sk(t, e, r, s);
    for (; s = i.dequeue(); )
      Sk(t, e, r, s);
    if (t.nodeCount()) {
      for (var o = e.length - 2; o > 0; --o)
        if (s = e[o].dequeue(), s) {
          n = n.concat(Sk(t, e, r, s, !0));
          break;
        }
    }
  }
  return n;
}
function Sk(t, e, r, n, i) {
  var a = i ? [] : void 0;
  return Ye(t.inEdges(n.v), function(s) {
    var o = t.edge(s), l = t.node(s.v);
    i && a.push({ v: s.v, w: s.w }), l.out -= o, uA(e, r, l);
  }), Ye(t.outEdges(n.v), function(s) {
    var o = t.edge(s), l = s.w, u = t.node(l);
    u.in -= o, uA(e, r, u);
  }), t.removeNode(n.v), a;
}
function i8e(t, e) {
  var r = new ma(), n = 0, i = 0;
  Ye(t.nodes(), function(o) {
    r.setNode(o, { v: o, in: 0, out: 0 });
  }), Ye(t.edges(), function(o) {
    var l = r.edge(o.v, o.w) || 0, u = e(o), h = l + u;
    r.setEdge(o.v, o.w, h), i = Math.max(i, r.node(o.v).out += u), n = Math.max(n, r.node(o.w).in += u);
  });
  var a = c0(i + n + 3).map(function() {
    return new JAe();
  }), s = n + 1;
  return Ye(r.nodes(), function(o) {
    uA(a, s, r.node(o));
  }), { graph: r, buckets: a, zeroIdx: s };
}
function uA(t, e, r) {
  r.out ? r.in ? t[r.out - r.in + e].enqueue(r) : t[t.length - 1].enqueue(r) : t[0].enqueue(r);
}
function a8e(t) {
  var e = t.graph().acyclicer === "greedy" ? r8e(t, r(t)) : s8e(t);
  Ye(e, function(n) {
    var i = t.edge(n);
    t.removeEdge(n), i.forwardName = n.name, i.reversed = !0, t.setEdge(n.w, n.v, i, cR("rev"));
  });
  function r(n) {
    return function(i) {
      return n.edge(i).weight;
    };
  }
}
function s8e(t) {
  var e = [], r = {}, n = {};
  function i(a) {
    Object.prototype.hasOwnProperty.call(n, a) || (n[a] = !0, r[a] = !0, Ye(t.outEdges(a), function(s) {
      Object.prototype.hasOwnProperty.call(r, s.w) ? e.push(s) : i(s.w);
    }), delete r[a]);
  }
  return Ye(t.nodes(), i), e;
}
function o8e(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.reversed) {
      t.removeEdge(e);
      var n = r.forwardName;
      delete r.reversed, delete r.forwardName, t.setEdge(e.w, e.v, r, n);
    }
  });
}
function z0(t, e, r, n) {
  var i;
  do
    i = cR(n);
  while (t.hasNode(i));
  return r.dummy = e, t.setNode(i, r), i;
}
function l8e(t) {
  var e = new ma().setGraph(t.graph());
  return Ye(t.nodes(), function(r) {
    e.setNode(r, t.node(r));
  }), Ye(t.edges(), function(r) {
    var n = e.edge(r.v, r.w) || { weight: 0, minlen: 1 }, i = t.edge(r);
    e.setEdge(r.v, r.w, {
      weight: n.weight + i.weight,
      minlen: Math.max(n.minlen, i.minlen)
    });
  }), e;
}
function cne(t) {
  var e = new ma({ multigraph: t.isMultigraph() }).setGraph(t.graph());
  return Ye(t.nodes(), function(r) {
    t.children(r).length || e.setNode(r, t.node(r));
  }), Ye(t.edges(), function(r) {
    e.setEdge(r, t.edge(r));
  }), e;
}
function Hz(t, e) {
  var r = t.x, n = t.y, i = e.x - r, a = e.y - n, s = t.width / 2, o = t.height / 2;
  if (!i && !a)
    throw new Error("Not possible to find intersection inside of the rectangle");
  var l, u;
  return Math.abs(a) * s > Math.abs(i) * o ? (a < 0 && (o = -o), l = o * i / a, u = o) : (i < 0 && (s = -s), l = s, u = s * a / i), { x: r + l, y: n + u };
}
function W4(t) {
  var e = Dr(c0(une(t) + 1), function() {
    return [];
  });
  return Ye(t.nodes(), function(r) {
    var n = t.node(r), i = n.rank;
    wn(i) || (e[i][n.order] = r);
  }), e;
}
function c8e(t) {
  var e = l0(
    Dr(t.nodes(), function(r) {
      return t.node(r).rank;
    })
  );
  Ye(t.nodes(), function(r) {
    var n = t.node(r);
    sne(n, "rank") && (n.rank -= e);
  });
}
function u8e(t) {
  var e = l0(
    Dr(t.nodes(), function(a) {
      return t.node(a).rank;
    })
  ), r = [];
  Ye(t.nodes(), function(a) {
    var s = t.node(a).rank - e;
    r[s] || (r[s] = []), r[s].push(a);
  });
  var n = 0, i = t.graph().nodeRankFactor;
  Ye(r, function(a, s) {
    wn(a) && s % i !== 0 ? --n : n && Ye(a, function(o) {
      t.node(o).rank += n;
    });
  });
}
function Wz(t, e, r, n) {
  var i = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (i.rank = r, i.order = n), z0(t, "border", i, e);
}
function une(t) {
  return Ju(
    Dr(t.nodes(), function(e) {
      var r = t.node(e).rank;
      if (!wn(r))
        return r;
    })
  );
}
function h8e(t, e) {
  var r = { lhs: [], rhs: [] };
  return Ye(t, function(n) {
    e(n) ? r.lhs.push(n) : r.rhs.push(n);
  }), r;
}
function f8e(t, e) {
  return e();
}
function d8e(t) {
  function e(r) {
    var n = t.children(r), i = t.node(r);
    if (n.length && Ye(n, e), Object.prototype.hasOwnProperty.call(i, "minRank")) {
      i.borderLeft = [], i.borderRight = [];
      for (var a = i.minRank, s = i.maxRank + 1; a < s; ++a)
        Yz(t, "borderLeft", "_bl", r, i, a), Yz(t, "borderRight", "_br", r, i, a);
    }
  }
  Ye(t.children(), e);
}
function Yz(t, e, r, n, i, a) {
  var s = { width: 0, height: 0, rank: a, borderType: e }, o = i[e][a - 1], l = z0(t, "border", s, r);
  i[e][a] = l, t.setParent(l, n), o && t.setEdge(o, l, { weight: 1 });
}
function p8e(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "lr" || e === "rl") && hne(t);
}
function g8e(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "bt" || e === "rl") && m8e(t), (e === "lr" || e === "rl") && (v8e(t), hne(t));
}
function hne(t) {
  Ye(t.nodes(), function(e) {
    Xz(t.node(e));
  }), Ye(t.edges(), function(e) {
    Xz(t.edge(e));
  });
}
function Xz(t) {
  var e = t.width;
  t.width = t.height, t.height = e;
}
function m8e(t) {
  Ye(t.nodes(), function(e) {
    kk(t.node(e));
  }), Ye(t.edges(), function(e) {
    var r = t.edge(e);
    Ye(r.points, kk), Object.prototype.hasOwnProperty.call(r, "y") && kk(r);
  });
}
function kk(t) {
  t.y = -t.y;
}
function v8e(t) {
  Ye(t.nodes(), function(e) {
    Ck(t.node(e));
  }), Ye(t.edges(), function(e) {
    var r = t.edge(e);
    Ye(r.points, Ck), Object.prototype.hasOwnProperty.call(r, "x") && Ck(r);
  });
}
function Ck(t) {
  var e = t.x;
  t.x = t.y, t.y = e;
}
function y8e(t) {
  t.graph().dummyChains = [], Ye(t.edges(), function(e) {
    b8e(t, e);
  });
}
function b8e(t, e) {
  var r = e.v, n = t.node(r).rank, i = e.w, a = t.node(i).rank, s = e.name, o = t.edge(e), l = o.labelRank;
  if (a !== n + 1) {
    t.removeEdge(e);
    var u = void 0, h, f;
    for (f = 0, ++n; n < a; ++f, ++n)
      o.points = [], u = {
        width: 0,
        height: 0,
        edgeLabel: o,
        edgeObj: e,
        rank: n
      }, h = z0(t, "edge", u, "_d"), n === l && (u.width = o.width, u.height = o.height, u.dummy = "edge-label", u.labelpos = o.labelpos), t.setEdge(r, h, { weight: o.weight }, s), f === 0 && t.graph().dummyChains.push(h), r = h;
    t.setEdge(r, i, { weight: o.weight }, s);
  }
}
function x8e(t) {
  Ye(t.graph().dummyChains, function(e) {
    var r = t.node(e), n = r.edgeLabel, i;
    for (t.setEdge(r.edgeObj, n); r.dummy; )
      i = t.successors(e)[0], t.removeNode(e), n.points.push({ x: r.x, y: r.y }), r.dummy === "edge-label" && (n.x = r.x, n.y = r.y, n.width = r.width, n.height = r.height), e = i, r = t.node(e);
  });
}
function uR(t) {
  var e = {};
  function r(n) {
    var i = t.node(n);
    if (Object.prototype.hasOwnProperty.call(e, n))
      return i.rank;
    e[n] = !0;
    var a = l0(
      Dr(t.outEdges(n), function(s) {
        return r(s.w) - t.edge(s).minlen;
      })
    );
    return (a === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
    a === void 0 || // return value of _.map([]) for Lodash 4
    a === null) && (a = 0), i.rank = a;
  }
  Ye(t.sources(), r);
}
function x1(t, e) {
  return t.node(e.w).rank - t.node(e.v).rank - t.edge(e).minlen;
}
function fne(t) {
  var e = new ma({ directed: !1 }), r = t.nodes()[0], n = t.nodeCount();
  e.setNode(r, {});
  for (var i, a; w8e(e, t) < n; )
    i = T8e(e, t), a = e.hasNode(i.v) ? x1(t, i) : -x1(t, i), E8e(e, t, a);
  return e;
}
function w8e(t, e) {
  function r(n) {
    Ye(e.nodeEdges(n), function(i) {
      var a = i.v, s = n === a ? i.w : a;
      !t.hasNode(s) && !x1(e, i) && (t.setNode(s, {}), t.setEdge(n, s, {}), r(s));
    });
  }
  return Ye(t.nodes(), r), t.nodeCount();
}
function T8e(t, e) {
  return lR(e.edges(), function(r) {
    if (t.hasNode(r.v) !== t.hasNode(r.w))
      return x1(e, r);
  });
}
function E8e(t, e, r) {
  Ye(t.nodes(), function(n) {
    e.node(n).rank += r;
  });
}
function S8e() {
}
S8e.prototype = new Error();
function dne(t, e, r) {
  Rn(e) || (e = [e]);
  var n = (t.isDirected() ? t.successors : t.neighbors).bind(t), i = [], a = {};
  return Ye(e, function(s) {
    if (!t.hasNode(s))
      throw new Error("Graph does not have node: " + s);
    pne(t, s, r === "post", a, n, i);
  }), i;
}
function pne(t, e, r, n, i, a) {
  Object.prototype.hasOwnProperty.call(n, e) || (n[e] = !0, r || a.push(e), Ye(i(e), function(s) {
    pne(t, s, r, n, i, a);
  }), r && a.push(e));
}
function k8e(t, e) {
  return dne(t, e, "post");
}
function C8e(t, e) {
  return dne(t, e, "pre");
}
Mh.initLowLimValues = fR;
Mh.initCutValues = hR;
Mh.calcCutValue = gne;
Mh.leaveEdge = vne;
Mh.enterEdge = yne;
Mh.exchangeEdges = bne;
function Mh(t) {
  t = l8e(t), uR(t);
  var e = fne(t);
  fR(e), hR(e, t);
  for (var r, n; r = vne(e); )
    n = yne(e, t, r), bne(e, t, r, n);
}
function hR(t, e) {
  var r = k8e(t, t.nodes());
  r = r.slice(0, r.length - 1), Ye(r, function(n) {
    _8e(t, e, n);
  });
}
function _8e(t, e, r) {
  var n = t.node(r), i = n.parent;
  t.edge(r, i).cutvalue = gne(t, e, r);
}
function gne(t, e, r) {
  var n = t.node(r), i = n.parent, a = !0, s = e.edge(r, i), o = 0;
  return s || (a = !1, s = e.edge(i, r)), o = s.weight, Ye(e.nodeEdges(r), function(l) {
    var u = l.v === r, h = u ? l.w : l.v;
    if (h !== i) {
      var f = u === a, d = e.edge(l).weight;
      if (o += f ? d : -d, L8e(t, r, h)) {
        var p = t.edge(r, h).cutvalue;
        o += f ? -p : p;
      }
    }
  }), o;
}
function fR(t, e) {
  arguments.length < 2 && (e = t.nodes()[0]), mne(t, {}, 1, e);
}
function mne(t, e, r, n, i) {
  var a = r, s = t.node(n);
  return e[n] = !0, Ye(t.neighbors(n), function(o) {
    Object.prototype.hasOwnProperty.call(e, o) || (r = mne(t, e, r, o, n));
  }), s.low = a, s.lim = r++, i ? s.parent = i : delete s.parent, r;
}
function vne(t) {
  return sR(t.edges(), function(e) {
    return t.edge(e).cutvalue < 0;
  });
}
function yne(t, e, r) {
  var n = r.v, i = r.w;
  e.hasEdge(n, i) || (n = r.w, i = r.v);
  var a = t.node(n), s = t.node(i), o = a, l = !1;
  a.lim > s.lim && (o = s, l = !0);
  var u = io(e.edges(), function(h) {
    return l === jz(t, t.node(h.v), o) && l !== jz(t, t.node(h.w), o);
  });
  return lR(u, function(h) {
    return x1(e, h);
  });
}
function bne(t, e, r, n) {
  var i = r.v, a = r.w;
  t.removeEdge(i, a), t.setEdge(n.v, n.w, {}), fR(t), hR(t, e), A8e(t, e);
}
function A8e(t, e) {
  var r = sR(t.nodes(), function(i) {
    return !e.node(i).parent;
  }), n = C8e(t, r);
  n = n.slice(1), Ye(n, function(i) {
    var a = t.node(i).parent, s = e.edge(i, a), o = !1;
    s || (s = e.edge(a, i), o = !0), e.node(i).rank = e.node(a).rank + (o ? s.minlen : -s.minlen);
  });
}
function L8e(t, e, r) {
  return t.hasEdge(e, r);
}
function jz(t, e, r) {
  return r.low <= e.lim && e.lim <= r.lim;
}
function R8e(t) {
  switch (t.graph().ranker) {
    case "network-simplex":
      Kz(t);
      break;
    case "tight-tree":
      M8e(t);
      break;
    case "longest-path":
      I8e(t);
      break;
    default:
      Kz(t);
  }
}
var I8e = uR;
function M8e(t) {
  uR(t), fne(t);
}
function Kz(t) {
  Mh(t);
}
function N8e(t) {
  var e = z0(t, "root", {}, "_root"), r = D8e(t), n = Ju(ll(r)) - 1, i = 2 * n + 1;
  t.graph().nestingRoot = e, Ye(t.edges(), function(s) {
    t.edge(s).minlen *= i;
  });
  var a = O8e(t) + 1;
  Ye(t.children(), function(s) {
    xne(t, e, i, a, n, r, s);
  }), t.graph().nodeRankFactor = i;
}
function xne(t, e, r, n, i, a, s) {
  var o = t.children(s);
  if (!o.length) {
    s !== e && t.setEdge(e, s, { weight: 0, minlen: r });
    return;
  }
  var l = Wz(t, "_bt"), u = Wz(t, "_bb"), h = t.node(s);
  t.setParent(l, s), h.borderTop = l, t.setParent(u, s), h.borderBottom = u, Ye(o, function(f) {
    xne(t, e, r, n, i, a, f);
    var d = t.node(f), p = d.borderTop ? d.borderTop : f, g = d.borderBottom ? d.borderBottom : f, m = d.borderTop ? n : 2 * n, v = p !== g ? 1 : i - a[s] + 1;
    t.setEdge(l, p, {
      weight: m,
      minlen: v,
      nestingEdge: !0
    }), t.setEdge(g, u, {
      weight: m,
      minlen: v,
      nestingEdge: !0
    });
  }), t.parent(s) || t.setEdge(e, l, { weight: 0, minlen: i + a[s] });
}
function D8e(t) {
  var e = {};
  function r(n, i) {
    var a = t.children(n);
    a && a.length && Ye(a, function(s) {
      r(s, i + 1);
    }), e[n] = i;
  }
  return Ye(t.children(), function(n) {
    r(n, 1);
  }), e;
}
function O8e(t) {
  return eh(
    t.edges(),
    function(e, r) {
      return e + t.edge(r).weight;
    },
    0
  );
}
function P8e(t) {
  var e = t.graph();
  t.removeNode(e.nestingRoot), delete e.nestingRoot, Ye(t.edges(), function(r) {
    var n = t.edge(r);
    n.nestingEdge && t.removeEdge(r);
  });
}
function $8e(t, e, r) {
  var n = {}, i;
  Ye(r, function(a) {
    for (var s = t.parent(a), o, l; s; ) {
      if (o = t.parent(s), o ? (l = n[o], n[o] = s) : (l = i, i = s), l && l !== s) {
        e.setEdge(l, s);
        return;
      }
      s = o;
    }
  });
}
function B8e(t, e, r) {
  var n = F8e(t), i = new ma({ compound: !0 }).setGraph({ root: n }).setDefaultNodeLabel(function(a) {
    return t.node(a);
  });
  return Ye(t.nodes(), function(a) {
    var s = t.node(a), o = t.parent(a);
    (s.rank === e || s.minRank <= e && e <= s.maxRank) && (i.setNode(a), i.setParent(a, o || n), Ye(t[r](a), function(l) {
      var u = l.v === a ? l.w : l.v, h = i.edge(u, a), f = wn(h) ? 0 : h.weight;
      i.setEdge(u, a, { weight: t.edge(l).weight + f });
    }), Object.prototype.hasOwnProperty.call(s, "minRank") && i.setNode(a, {
      borderLeft: s.borderLeft[e],
      borderRight: s.borderRight[e]
    }));
  }), i;
}
function F8e(t) {
  for (var e; t.hasNode(e = cR("_root")); ) ;
  return e;
}
function z8e(t, e) {
  for (var r = 0, n = 1; n < e.length; ++n)
    r += q8e(t, e[n - 1], e[n]);
  return r;
}
function q8e(t, e, r) {
  for (var n = KAe(
    r,
    Dr(r, function(u, h) {
      return h;
    })
  ), i = Ih(
    Dr(e, function(u) {
      return vm(
        Dr(t.outEdges(u), function(h) {
          return { pos: n[h.w], weight: t.edge(h).weight };
        }),
        "pos"
      );
    })
  ), a = 1; a < r.length; ) a <<= 1;
  var s = 2 * a - 1;
  a -= 1;
  var o = Dr(new Array(s), function() {
    return 0;
  }), l = 0;
  return Ye(
    // @ts-expect-error
    i.forEach(function(u) {
      var h = u.pos + a;
      o[h] += u.weight;
      for (var f = 0; h > 0; )
        h % 2 && (f += o[h + 1]), h = h - 1 >> 1, o[h] += u.weight;
      l += u.weight * f;
    })
  ), l;
}
function G8e(t) {
  var e = {}, r = io(t.nodes(), function(o) {
    return !t.children(o).length;
  }), n = Ju(
    Dr(r, function(o) {
      return t.node(o).rank;
    })
  ), i = Dr(c0(n + 1), function() {
    return [];
  });
  function a(o) {
    if (!sne(e, o)) {
      e[o] = !0;
      var l = t.node(o);
      i[l.rank].push(o), Ye(t.successors(o), a);
    }
  }
  var s = vm(r, function(o) {
    return t.node(o).rank;
  });
  return Ye(s, a), i;
}
function U8e(t, e) {
  return Dr(e, function(r) {
    var n = t.inEdges(r);
    if (n.length) {
      var i = eh(
        n,
        function(a, s) {
          var o = t.edge(s), l = t.node(s.v);
          return {
            sum: a.sum + o.weight * l.order,
            weight: a.weight + o.weight
          };
        },
        { sum: 0, weight: 0 }
      );
      return {
        v: r,
        barycenter: i.sum / i.weight,
        weight: i.weight
      };
    } else
      return { v: r };
  });
}
function V8e(t, e) {
  var r = {};
  Ye(t, function(i, a) {
    var s = r[i.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [i.v],
      i: a
    };
    wn(i.barycenter) || (s.barycenter = i.barycenter, s.weight = i.weight);
  }), Ye(e.edges(), function(i) {
    var a = r[i.v], s = r[i.w];
    !wn(a) && !wn(s) && (s.indegree++, a.out.push(r[i.w]));
  });
  var n = io(r, function(i) {
    return !i.indegree;
  });
  return H8e(n);
}
function H8e(t) {
  var e = [];
  function r(a) {
    return function(s) {
      s.merged || (wn(s.barycenter) || wn(a.barycenter) || s.barycenter >= a.barycenter) && W8e(a, s);
    };
  }
  function n(a) {
    return function(s) {
      s.in.push(a), --s.indegree === 0 && t.push(s);
    };
  }
  for (; t.length; ) {
    var i = t.pop();
    e.push(i), Ye(i.in.reverse(), r(i)), Ye(i.out, n(i));
  }
  return Dr(
    io(e, function(a) {
      return !a.merged;
    }),
    function(a) {
      return Sb(a, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function W8e(t, e) {
  var r = 0, n = 0;
  t.weight && (r += t.barycenter * t.weight, n += t.weight), e.weight && (r += e.barycenter * e.weight, n += e.weight), t.vs = e.vs.concat(t.vs), t.barycenter = r / n, t.weight = n, t.i = Math.min(e.i, t.i), e.merged = !0;
}
function Y8e(t, e) {
  var r = h8e(t, function(h) {
    return Object.prototype.hasOwnProperty.call(h, "barycenter");
  }), n = r.lhs, i = vm(r.rhs, function(h) {
    return -h.i;
  }), a = [], s = 0, o = 0, l = 0;
  n.sort(X8e(!!e)), l = Zz(a, i, l), Ye(n, function(h) {
    l += h.vs.length, a.push(h.vs), s += h.barycenter * h.weight, o += h.weight, l = Zz(a, i, l);
  });
  var u = { vs: Ih(a) };
  return o && (u.barycenter = s / o, u.weight = o), u;
}
function Zz(t, e, r) {
  for (var n; e.length && (n = Eb(e)).i <= r; )
    e.pop(), t.push(n.vs), r++;
  return r;
}
function X8e(t) {
  return function(e, r) {
    return e.barycenter < r.barycenter ? -1 : e.barycenter > r.barycenter ? 1 : t ? r.i - e.i : e.i - r.i;
  };
}
function wne(t, e, r, n) {
  var i = t.children(e), a = t.node(e), s = a ? a.borderLeft : void 0, o = a ? a.borderRight : void 0, l = {};
  s && (i = io(i, function(g) {
    return g !== s && g !== o;
  }));
  var u = U8e(t, i);
  Ye(u, function(g) {
    if (t.children(g.v).length) {
      var m = wne(t, g.v, r, n);
      l[g.v] = m, Object.prototype.hasOwnProperty.call(m, "barycenter") && K8e(g, m);
    }
  });
  var h = V8e(u, r);
  j8e(h, l);
  var f = Y8e(h, n);
  if (s && (f.vs = Ih([s, f.vs, o]), t.predecessors(s).length)) {
    var d = t.node(t.predecessors(s)[0]), p = t.node(t.predecessors(o)[0]);
    Object.prototype.hasOwnProperty.call(f, "barycenter") || (f.barycenter = 0, f.weight = 0), f.barycenter = (f.barycenter * f.weight + d.order + p.order) / (f.weight + 2), f.weight += 2;
  }
  return f;
}
function j8e(t, e) {
  Ye(t, function(r) {
    r.vs = Ih(
      r.vs.map(function(n) {
        return e[n] ? e[n].vs : n;
      })
    );
  });
}
function K8e(t, e) {
  wn(t.barycenter) ? (t.barycenter = e.barycenter, t.weight = e.weight) : (t.barycenter = (t.barycenter * t.weight + e.barycenter * e.weight) / (t.weight + e.weight), t.weight += e.weight);
}
function Z8e(t) {
  var e = une(t), r = Qz(t, c0(1, e + 1), "inEdges"), n = Qz(t, c0(e - 1, -1, -1), "outEdges"), i = G8e(t);
  Jz(t, i);
  for (var a = Number.POSITIVE_INFINITY, s, o = 0, l = 0; l < 4; ++o, ++l) {
    Q8e(o % 2 ? r : n, o % 4 >= 2), i = W4(t);
    var u = z8e(t, i);
    u < a && (l = 0, s = L_e(i), a = u);
  }
  Jz(t, s);
}
function Qz(t, e, r) {
  return Dr(e, function(n) {
    return B8e(t, n, r);
  });
}
function Q8e(t, e) {
  var r = new ma();
  Ye(t, function(n) {
    var i = n.graph().root, a = wne(n, i, r, e);
    Ye(a.vs, function(s, o) {
      n.node(s).order = o;
    }), $8e(n, r, a.vs);
  });
}
function Jz(t, e) {
  Ye(e, function(r) {
    Ye(r, function(n, i) {
      t.node(n).order = i;
    });
  });
}
function J8e(t) {
  var e = t9e(t);
  Ye(t.graph().dummyChains, function(r) {
    for (var n = t.node(r), i = n.edgeObj, a = e9e(t, e, i.v, i.w), s = a.path, o = a.lca, l = 0, u = s[l], h = !0; r !== i.w; ) {
      if (n = t.node(r), h) {
        for (; (u = s[l]) !== o && t.node(u).maxRank < n.rank; )
          l++;
        u === o && (h = !1);
      }
      if (!h) {
        for (; l < s.length - 1 && t.node(u = s[l + 1]).minRank <= n.rank; )
          l++;
        u = s[l];
      }
      t.setParent(r, u), r = t.successors(r)[0];
    }
  });
}
function e9e(t, e, r, n) {
  var i = [], a = [], s = Math.min(e[r].low, e[n].low), o = Math.max(e[r].lim, e[n].lim), l, u;
  l = r;
  do
    l = t.parent(l), i.push(l);
  while (l && (e[l].low > s || o > e[l].lim));
  for (u = l, l = n; (l = t.parent(l)) !== u; )
    a.push(l);
  return { path: i.concat(a.reverse()), lca: u };
}
function t9e(t) {
  var e = {}, r = 0;
  function n(i) {
    var a = r;
    Ye(t.children(i), n), e[i] = { low: a, lim: r++ };
  }
  return Ye(t.children(), n), e;
}
function r9e(t, e) {
  var r = {};
  function n(i, a) {
    var s = 0, o = 0, l = i.length, u = Eb(a);
    return Ye(a, function(h, f) {
      var d = i9e(t, h), p = d ? t.node(d).order : l;
      (d || h === u) && (Ye(a.slice(o, f + 1), function(g) {
        Ye(t.predecessors(g), function(m) {
          var v = t.node(m), y = v.order;
          (y < s || p < y) && !(v.dummy && t.node(g).dummy) && Tne(r, m, g);
        });
      }), o = f + 1, s = p);
    }), a;
  }
  return eh(e, n), r;
}
function n9e(t, e) {
  var r = {};
  function n(a, s, o, l, u) {
    var h;
    Ye(c0(s, o), function(f) {
      h = a[f], t.node(h).dummy && Ye(t.predecessors(h), function(d) {
        var p = t.node(d);
        p.dummy && (p.order < l || p.order > u) && Tne(r, d, h);
      });
    });
  }
  function i(a, s) {
    var o = -1, l, u = 0;
    return Ye(s, function(h, f) {
      if (t.node(h).dummy === "border") {
        var d = t.predecessors(h);
        d.length && (l = t.node(d[0]).order, n(s, u, f, o, l), u = f, o = l);
      }
      n(s, u, s.length, l, a.length);
    }), s;
  }
  return eh(e, i), r;
}
function i9e(t, e) {
  if (t.node(e).dummy)
    return sR(t.predecessors(e), function(r) {
      return t.node(r).dummy;
    });
}
function Tne(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  Object.prototype.hasOwnProperty.call(t, e) || Object.defineProperty(t, e, {
    enumerable: !0,
    configurable: !0,
    value: {},
    writable: !0
  });
  var i = t[e];
  Object.defineProperty(i, r, {
    enumerable: !0,
    configurable: !0,
    value: !0,
    writable: !0
  });
}
function a9e(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  return !!t[e] && Object.prototype.hasOwnProperty.call(t[e], r);
}
function s9e(t, e, r, n) {
  var i = {}, a = {}, s = {};
  return Ye(e, function(o) {
    Ye(o, function(l, u) {
      i[l] = l, a[l] = l, s[l] = u;
    });
  }), Ye(e, function(o) {
    var l = -1;
    Ye(o, function(u) {
      var h = n(u);
      if (h.length) {
        h = vm(h, function(m) {
          return s[m];
        });
        for (var f = (h.length - 1) / 2, d = Math.floor(f), p = Math.ceil(f); d <= p; ++d) {
          var g = h[d];
          a[u] === u && l < s[g] && !a9e(r, u, g) && (a[g] = u, a[u] = i[u] = i[g], l = s[g]);
        }
      }
    });
  }), { root: i, align: a };
}
function o9e(t, e, r, n, i) {
  var a = {}, s = l9e(t, e, r, i), o = i ? "borderLeft" : "borderRight";
  function l(f, d) {
    for (var p = s.nodes(), g = p.pop(), m = {}; g; )
      m[g] ? f(g) : (m[g] = !0, p.push(g), p = p.concat(d(g))), g = p.pop();
  }
  function u(f) {
    a[f] = s.inEdges(f).reduce(function(d, p) {
      return Math.max(d, a[p.v] + s.edge(p));
    }, 0);
  }
  function h(f) {
    var d = s.outEdges(f).reduce(function(g, m) {
      return Math.min(g, a[m.w] - s.edge(m));
    }, Number.POSITIVE_INFINITY), p = t.node(f);
    d !== Number.POSITIVE_INFINITY && p.borderType !== o && (a[f] = Math.max(a[f], d));
  }
  return l(u, s.predecessors.bind(s)), l(h, s.successors.bind(s)), Ye(n, function(f) {
    a[f] = a[r[f]];
  }), a;
}
function l9e(t, e, r, n) {
  var i = new ma(), a = t.graph(), s = d9e(a.nodesep, a.edgesep, n);
  return Ye(e, function(o) {
    var l;
    Ye(o, function(u) {
      var h = r[u];
      if (i.setNode(h), l) {
        var f = r[l], d = i.edge(f, h);
        i.setEdge(f, h, Math.max(s(t, u, l), d || 0));
      }
      l = u;
    });
  }), i;
}
function c9e(t, e) {
  return lR(ll(e), function(r) {
    var n = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    return SAe(r, function(a, s) {
      var o = p9e(t, s) / 2;
      n = Math.max(a + o, n), i = Math.min(a - o, i);
    }), n - i;
  });
}
function u9e(t, e) {
  var r = ll(e), n = l0(r), i = Ju(r);
  Ye(["u", "d"], function(a) {
    Ye(["l", "r"], function(s) {
      var o = a + s, l = t[o], u;
      if (l !== e) {
        var h = ll(l);
        u = s === "l" ? n - l0(h) : i - Ju(h), u && (t[o] = H4(l, function(f) {
          return f + u;
        }));
      }
    });
  });
}
function h9e(t, e) {
  return H4(t.ul, function(r, n) {
    if (e)
      return t[e.toLowerCase()][n];
    var i = vm(Dr(t, n));
    return (i[1] + i[2]) / 2;
  });
}
function f9e(t) {
  var e = W4(t), r = ib(r9e(t, e), n9e(t, e)), n = {}, i;
  Ye(["u", "d"], function(s) {
    i = s === "u" ? e : ll(e).reverse(), Ye(["l", "r"], function(o) {
      o === "r" && (i = Dr(i, function(f) {
        return ll(f).reverse();
      }));
      var l = (s === "u" ? t.predecessors : t.successors).bind(t), u = s9e(t, i, r, l), h = o9e(t, i, u.root, u.align, o === "r");
      o === "r" && (h = H4(h, function(f) {
        return -f;
      })), n[s + o] = h;
    });
  });
  var a = c9e(t, n);
  return u9e(n, a), h9e(n, t.graph().align);
}
function d9e(t, e, r) {
  return function(n, i, a) {
    var s = n.node(i), o = n.node(a), l = 0, u;
    if (l += s.width / 2, Object.prototype.hasOwnProperty.call(s, "labelpos"))
      switch (s.labelpos.toLowerCase()) {
        case "l":
          u = -s.width / 2;
          break;
        case "r":
          u = s.width / 2;
          break;
      }
    if (u && (l += r ? u : -u), u = 0, l += (s.dummy ? e : t) / 2, l += (o.dummy ? e : t) / 2, l += o.width / 2, Object.prototype.hasOwnProperty.call(o, "labelpos"))
      switch (o.labelpos.toLowerCase()) {
        case "l":
          u = o.width / 2;
          break;
        case "r":
          u = -o.width / 2;
          break;
      }
    return u && (l += r ? u : -u), u = 0, l;
  };
}
function p9e(t, e) {
  return t.node(e).width;
}
function g9e(t) {
  t = cne(t), m9e(t), kAe(f9e(t), function(e, r) {
    t.node(r).x = e;
  });
}
function m9e(t) {
  var e = W4(t), r = t.graph().ranksep, n = 0;
  Ye(e, function(i) {
    var a = Ju(
      Dr(i, function(s) {
        return t.node(s).height;
      })
    );
    Ye(i, function(s) {
      t.node(s).y = n + a / 2;
    }), n += a + r;
  });
}
function Ene(t, e) {
  var r = f8e;
  r("layout", () => {
    var n = r("  buildLayoutGraph", () => _9e(t));
    r("  runLayout", () => v9e(n, r)), r("  updateInputGraph", () => y9e(t, n));
  });
}
function v9e(t, e) {
  e("    makeSpaceForEdgeLabels", () => A9e(t)), e("    removeSelfEdges", () => $9e(t)), e("    acyclic", () => a8e(t)), e("    nestingGraph.run", () => N8e(t)), e("    rank", () => R8e(cne(t))), e("    injectEdgeLabelProxies", () => L9e(t)), e("    removeEmptyRanks", () => u8e(t)), e("    nestingGraph.cleanup", () => P8e(t)), e("    normalizeRanks", () => c8e(t)), e("    assignRankMinMax", () => R9e(t)), e("    removeEdgeLabelProxies", () => I9e(t)), e("    normalize.run", () => y8e(t)), e("    parentDummyChains", () => J8e(t)), e("    addBorderSegments", () => d8e(t)), e("    order", () => Z8e(t)), e("    insertSelfEdges", () => B9e(t)), e("    adjustCoordinateSystem", () => p8e(t)), e("    position", () => g9e(t)), e("    positionSelfEdges", () => F9e(t)), e("    removeBorderNodes", () => P9e(t)), e("    normalize.undo", () => x8e(t)), e("    fixupEdgeLabelCoords", () => D9e(t)), e("    undoCoordinateSystem", () => g8e(t)), e("    translateGraph", () => M9e(t)), e("    assignNodeIntersects", () => N9e(t)), e("    reversePoints", () => O9e(t)), e("    acyclic.undo", () => o8e(t));
}
function y9e(t, e) {
  Ye(t.nodes(), function(r) {
    var n = t.node(r), i = e.node(r);
    n && (n.x = i.x, n.y = i.y, e.children(r).length && (n.width = i.width, n.height = i.height));
  }), Ye(t.edges(), function(r) {
    var n = t.edge(r), i = e.edge(r);
    n.points = i.points, Object.prototype.hasOwnProperty.call(i, "x") && (n.x = i.x, n.y = i.y);
  }), t.graph().width = e.graph().width, t.graph().height = e.graph().height;
}
var b9e = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], x9e = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, w9e = ["acyclicer", "ranker", "rankdir", "align"], T9e = ["width", "height"], E9e = { width: 0, height: 0 }, S9e = ["minlen", "weight", "width", "height", "labeloffset"], k9e = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, C9e = ["labelpos"];
function _9e(t) {
  var e = new ma({ multigraph: !0, compound: !0 }), r = Ak(t.graph());
  return e.setGraph(
    ib({}, x9e, _k(r, b9e), Sb(r, w9e))
  ), Ye(t.nodes(), function(n) {
    var i = Ak(t.node(n));
    e.setNode(n, yAe(_k(i, T9e), E9e)), e.setParent(n, t.parent(n));
  }), Ye(t.edges(), function(n) {
    var i = Ak(t.edge(n));
    e.setEdge(
      n,
      ib({}, k9e, _k(i, S9e), Sb(i, C9e))
    );
  }), e;
}
function A9e(t) {
  var e = t.graph();
  e.ranksep /= 2, Ye(t.edges(), function(r) {
    var n = t.edge(r);
    n.minlen *= 2, n.labelpos.toLowerCase() !== "c" && (e.rankdir === "TB" || e.rankdir === "BT" ? n.width += n.labeloffset : n.height += n.labeloffset);
  });
}
function L9e(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.width && r.height) {
      var n = t.node(e.v), i = t.node(e.w), a = { rank: (i.rank - n.rank) / 2 + n.rank, e };
      z0(t, "edge-proxy", a, "_ep");
    }
  });
}
function R9e(t) {
  var e = 0;
  Ye(t.nodes(), function(r) {
    var n = t.node(r);
    n.borderTop && (n.minRank = t.node(n.borderTop).rank, n.maxRank = t.node(n.borderBottom).rank, e = Ju(e, n.maxRank));
  }), t.graph().maxRank = e;
}
function I9e(t) {
  Ye(t.nodes(), function(e) {
    var r = t.node(e);
    r.dummy === "edge-proxy" && (t.edge(r.e).labelRank = r.rank, t.removeNode(e));
  });
}
function M9e(t) {
  var e = Number.POSITIVE_INFINITY, r = 0, n = Number.POSITIVE_INFINITY, i = 0, a = t.graph(), s = a.marginx || 0, o = a.marginy || 0;
  function l(u) {
    var h = u.x, f = u.y, d = u.width, p = u.height;
    e = Math.min(e, h - d / 2), r = Math.max(r, h + d / 2), n = Math.min(n, f - p / 2), i = Math.max(i, f + p / 2);
  }
  Ye(t.nodes(), function(u) {
    l(t.node(u));
  }), Ye(t.edges(), function(u) {
    var h = t.edge(u);
    Object.prototype.hasOwnProperty.call(h, "x") && l(h);
  }), e -= s, n -= o, Ye(t.nodes(), function(u) {
    var h = t.node(u);
    h.x -= e, h.y -= n;
  }), Ye(t.edges(), function(u) {
    var h = t.edge(u);
    Ye(h.points, function(f) {
      f.x -= e, f.y -= n;
    }), Object.prototype.hasOwnProperty.call(h, "x") && (h.x -= e), Object.prototype.hasOwnProperty.call(h, "y") && (h.y -= n);
  }), a.width = r - e + s, a.height = i - n + o;
}
function N9e(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e), n = t.node(e.v), i = t.node(e.w), a, s;
    r.points ? (a = r.points[0], s = r.points[r.points.length - 1]) : (r.points = [], a = i, s = n), r.points.unshift(Hz(n, a)), r.points.push(Hz(i, s));
  });
}
function D9e(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    if (Object.prototype.hasOwnProperty.call(r, "x"))
      switch ((r.labelpos === "l" || r.labelpos === "r") && (r.width -= r.labeloffset), r.labelpos) {
        case "l":
          r.x -= r.width / 2 + r.labeloffset;
          break;
        case "r":
          r.x += r.width / 2 + r.labeloffset;
          break;
      }
  });
}
function O9e(t) {
  Ye(t.edges(), function(e) {
    var r = t.edge(e);
    r.reversed && r.points.reverse();
  });
}
function P9e(t) {
  Ye(t.nodes(), function(e) {
    if (t.children(e).length) {
      var r = t.node(e), n = t.node(r.borderTop), i = t.node(r.borderBottom), a = t.node(Eb(r.borderLeft)), s = t.node(Eb(r.borderRight));
      r.width = Math.abs(s.x - a.x), r.height = Math.abs(i.y - n.y), r.x = a.x + r.width / 2, r.y = n.y + r.height / 2;
    }
  }), Ye(t.nodes(), function(e) {
    t.node(e).dummy === "border" && t.removeNode(e);
  });
}
function $9e(t) {
  Ye(t.edges(), function(e) {
    if (e.v === e.w) {
      var r = t.node(e.v);
      r.selfEdges || (r.selfEdges = []), r.selfEdges.push({ e, label: t.edge(e) }), t.removeEdge(e);
    }
  });
}
function B9e(t) {
  var e = W4(t);
  Ye(e, function(r) {
    var n = 0;
    Ye(r, function(i, a) {
      var s = t.node(i);
      s.order = a + n, Ye(s.selfEdges, function(o) {
        z0(
          t,
          "selfedge",
          {
            width: o.label.width,
            height: o.label.height,
            rank: s.rank,
            order: a + ++n,
            e: o.e,
            label: o.label
          },
          "_se"
        );
      }), delete s.selfEdges;
    });
  });
}
function F9e(t) {
  Ye(t.nodes(), function(e) {
    var r = t.node(e);
    if (r.dummy === "selfedge") {
      var n = t.node(r.e.v), i = n.x + n.width / 2, a = n.y, s = r.x - i, o = n.height / 2;
      t.setEdge(r.e, r.label), t.removeNode(e), r.label.points = [
        { x: i + 2 * s / 3, y: a - o },
        { x: i + 5 * s / 6, y: a - o },
        { x: i + s, y: a },
        { x: i + 5 * s / 6, y: a + o },
        { x: i + 2 * s / 3, y: a + o }
      ], r.label.x = r.x, r.label.y = r.y;
    }
  });
}
function _k(t, e) {
  return H4(Sb(t, e), Number);
}
function Ak(t) {
  var e = {};
  return Ye(t, function(r, n) {
    e[n.toLowerCase()] = r;
  }), e;
}
function ao(t) {
  var e = {
    options: {
      directed: t.isDirected(),
      multigraph: t.isMultigraph(),
      compound: t.isCompound()
    },
    nodes: z9e(t),
    edges: q9e(t)
  };
  return wn(t.graph()) || (e.value = Zre(t.graph())), e;
}
function z9e(t) {
  return Dr(t.nodes(), function(e) {
    var r = t.node(e), n = t.parent(e), i = { v: e };
    return wn(r) || (i.value = r), wn(n) || (i.parent = n), i;
  });
}
function q9e(t) {
  return Dr(t.edges(), function(e) {
    var r = t.edge(e), n = { v: e.v, w: e.w };
    return wn(e.name) || (n.name = e.name), wn(r) || (n.value = r), n;
  });
}
var nr = /* @__PURE__ */ new Map(), Nu = /* @__PURE__ */ new Map(), Sne = /* @__PURE__ */ new Map(), G9e = /* @__PURE__ */ w(() => {
  Nu.clear(), Sne.clear(), nr.clear();
}, "clear"), kb = /* @__PURE__ */ w((t, e) => {
  const r = Nu.get(e) || [];
  return ae.trace("In isDescendant", e, " ", t, " = ", r.includes(t)), r.includes(t);
}, "isDescendant"), U9e = /* @__PURE__ */ w((t, e) => {
  const r = Nu.get(e) || [];
  return ae.info("Descendants of ", e, " is ", r), ae.info("Edge is ", t), t.v === e || t.w === e ? !1 : r ? r.includes(t.v) || kb(t.v, e) || kb(t.w, e) || r.includes(t.w) : (ae.debug("Tilt, ", e, ",not in descendants"), !1);
}, "edgeInCluster"), kne = /* @__PURE__ */ w((t, e, r, n) => {
  ae.warn(
    "Copying children of ",
    t,
    "root",
    n,
    "data",
    e.node(t),
    n
  );
  const i = e.children(t) || [];
  t !== n && i.push(t), ae.warn("Copying (nodes) clusterId", t, "nodes", i), i.forEach((a) => {
    if (e.children(a).length > 0)
      kne(a, e, r, n);
    else {
      const s = e.node(a);
      ae.info("cp ", a, " to ", n, " with parent ", t), r.setNode(a, s), n !== e.parent(a) && (ae.warn("Setting parent", a, e.parent(a)), r.setParent(a, e.parent(a))), t !== n && a !== t ? (ae.debug("Setting parent", a, t), r.setParent(a, t)) : (ae.info("In copy ", t, "root", n, "data", e.node(t), n), ae.debug(
        "Not Setting parent for node=",
        a,
        "cluster!==rootId",
        t !== n,
        "node!==clusterId",
        a !== t
      ));
      const o = e.edges(a);
      ae.debug("Copying Edges", o), o.forEach((l) => {
        ae.info("Edge", l);
        const u = e.edge(l.v, l.w, l.name);
        ae.info("Edge data", u, n);
        try {
          U9e(l, n) ? (ae.info("Copying as ", l.v, l.w, u, l.name), r.setEdge(l.v, l.w, u, l.name), ae.info("newGraph edges ", r.edges(), r.edge(r.edges()[0]))) : ae.info(
            "Skipping copy of edge ",
            l.v,
            "-->",
            l.w,
            " rootId: ",
            n,
            " clusterId:",
            t
          );
        } catch (h) {
          ae.error(h);
        }
      });
    }
    ae.debug("Removing node", a), e.removeNode(a);
  });
}, "copy"), Cne = /* @__PURE__ */ w((t, e) => {
  const r = e.children(t);
  let n = [...r];
  for (const i of r)
    Sne.set(i, t), n = [...n, ...Cne(i, e)];
  return n;
}, "extractDescendants"), V9e = /* @__PURE__ */ w((t, e, r) => {
  const n = t.edges().filter((l) => l.v === e || l.w === e), i = t.edges().filter((l) => l.v === r || l.w === r), a = n.map((l) => ({ v: l.v === e ? r : l.v, w: l.w === e ? e : l.w })), s = i.map((l) => ({ v: l.v, w: l.w }));
  return a.filter((l) => s.some((u) => l.v === u.v && l.w === u.w));
}, "findCommonEdges"), w1 = /* @__PURE__ */ w((t, e, r) => {
  const n = e.children(t);
  if (ae.trace("Searching children of id ", t, n), n.length < 1)
    return t;
  let i;
  for (const a of n) {
    const s = w1(a, e, r), o = V9e(e, r, s);
    if (s)
      if (o.length > 0)
        i = s;
      else
        return s;
  }
  return i;
}, "findNonClusterChild"), eq = /* @__PURE__ */ w((t) => !nr.has(t) || !nr.get(t).externalConnections ? t : nr.has(t) ? nr.get(t).id : t, "getAnchorId"), H9e = /* @__PURE__ */ w((t, e) => {
  if (!t || e > 10) {
    ae.debug("Opting out, no graph ");
    return;
  } else
    ae.debug("Opting in, graph ");
  t.nodes().forEach(function(r) {
    t.children(r).length > 0 && (ae.warn(
      "Cluster identified",
      r,
      " Replacement id in edges: ",
      w1(r, t, r)
    ), Nu.set(r, Cne(r, t)), nr.set(r, { id: w1(r, t, r), clusterData: t.node(r) }));
  }), t.nodes().forEach(function(r) {
    const n = t.children(r), i = t.edges();
    n.length > 0 ? (ae.debug("Cluster identified", r, Nu), i.forEach((a) => {
      const s = kb(a.v, r), o = kb(a.w, r);
      s ^ o && (ae.warn("Edge: ", a, " leaves cluster ", r), ae.warn("Descendants of XXX ", r, ": ", Nu.get(r)), nr.get(r).externalConnections = !0);
    })) : ae.debug("Not a cluster ", r, Nu);
  });
  for (let r of nr.keys()) {
    const n = nr.get(r).id, i = t.parent(n);
    i !== r && nr.has(i) && !nr.get(i).externalConnections && (nr.get(r).id = i);
  }
  t.edges().forEach(function(r) {
    const n = t.edge(r);
    ae.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(r)), ae.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(t.edge(r)));
    let i = r.v, a = r.w;
    if (ae.warn(
      "Fix XXX",
      nr,
      "ids:",
      r.v,
      r.w,
      "Translating: ",
      nr.get(r.v),
      " --- ",
      nr.get(r.w)
    ), nr.get(r.v) || nr.get(r.w)) {
      if (ae.warn("Fixing and trying - removing XXX", r.v, r.w, r.name), i = eq(r.v), a = eq(r.w), t.removeEdge(r.v, r.w, r.name), i !== r.v) {
        const s = t.parent(i);
        nr.get(s).externalConnections = !0, n.fromCluster = r.v;
      }
      if (a !== r.w) {
        const s = t.parent(a);
        nr.get(s).externalConnections = !0, n.toCluster = r.w;
      }
      ae.warn("Fix Replacing with XXX", i, a, r.name), t.setEdge(i, a, n, r.name);
    }
  }), ae.warn("Adjusted Graph", ao(t)), _ne(t, 0), ae.trace(nr);
}, "adjustClustersAndEdges"), _ne = /* @__PURE__ */ w((t, e) => {
  if (ae.warn("extractor - ", e, ao(t), t.children("D")), e > 10) {
    ae.error("Bailing out");
    return;
  }
  let r = t.nodes(), n = !1;
  for (const i of r) {
    const a = t.children(i);
    n = n || a.length > 0;
  }
  if (!n) {
    ae.debug("Done, no node has children", t.nodes());
    return;
  }
  ae.debug("Nodes = ", r, e);
  for (const i of r)
    if (ae.debug(
      "Extracting node",
      i,
      nr,
      nr.has(i) && !nr.get(i).externalConnections,
      !t.parent(i),
      t.node(i),
      t.children("D"),
      " Depth ",
      e
    ), !nr.has(i))
      ae.debug("Not a cluster", i, e);
    else if (!nr.get(i).externalConnections && t.children(i) && t.children(i).length > 0) {
      ae.warn(
        "Cluster without external connections, without a parent and with children",
        i,
        e
      );
      let s = t.graph().rankdir === "TB" ? "LR" : "TB";
      nr.get(i)?.clusterData?.dir && (s = nr.get(i).clusterData.dir, ae.warn("Fixing dir", nr.get(i).clusterData.dir, s));
      const o = new ma({
        multigraph: !0,
        compound: !0
      }).setGraph({
        rankdir: s,
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      ae.warn("Old graph before copy", ao(t)), kne(i, t, o, i), t.setNode(i, {
        clusterNode: !0,
        id: i,
        clusterData: nr.get(i).clusterData,
        label: nr.get(i).label,
        graph: o
      }), ae.warn("New graph after copy node: (", i, ")", ao(o)), ae.debug("Old graph after copy", ao(t));
    } else
      ae.warn(
        "Cluster ** ",
        i,
        " **not meeting the criteria !externalConnections:",
        !nr.get(i).externalConnections,
        " no parent: ",
        !t.parent(i),
        " children ",
        t.children(i) && t.children(i).length > 0,
        t.children("D"),
        e
      ), ae.debug(nr);
  r = t.nodes(), ae.warn("New list of nodes", r);
  for (const i of r) {
    const a = t.node(i);
    ae.warn(" Now next level", i, a), a?.clusterNode && _ne(a.graph, e + 1);
  }
}, "extractor"), Ane = /* @__PURE__ */ w((t, e) => {
  if (e.length === 0)
    return [];
  let r = Object.assign([], e);
  return e.forEach((n) => {
    const i = t.children(n), a = Ane(t, i);
    r = [...r, ...a];
  }), r;
}, "sorter"), W9e = /* @__PURE__ */ w((t) => Ane(t, t.children()), "sortNodesByHierarchy"), Lne = /* @__PURE__ */ w(async (t, e, r, n, i, a) => {
  ae.warn("Graph in recursive render:XAX", ao(e), i);
  const s = e.graph().rankdir;
  ae.trace("Dir in recursive render - dir:", s);
  const o = t.insert("g").attr("class", "root");
  e.nodes() ? ae.info("Recursive render XXX", e.nodes()) : ae.info("No nodes found for", e), e.edges().length > 0 && ae.info("Recursive edges", e.edge(e.edges()[0]));
  const l = o.insert("g").attr("class", "clusters"), u = o.insert("g").attr("class", "edgePaths"), h = o.insert("g").attr("class", "edgeLabels"), f = o.insert("g").attr("class", "nodes");
  await Promise.all(
    e.nodes().map(async function(m) {
      const v = e.node(m);
      if (i !== void 0) {
        const y = JSON.parse(JSON.stringify(i.clusterData));
        ae.trace(
          `Setting data for parent cluster XXX
 Node.id = `,
          m,
          `
 data=`,
          y.height,
          `
Parent cluster`,
          i.height
        ), e.setNode(i.id, y), e.parent(m) || (ae.trace("Setting parent", m, i.id), e.setParent(m, i.id, y));
      }
      if (ae.info("(Insert) Node XXX" + m + ": " + JSON.stringify(e.node(m))), v?.clusterNode) {
        ae.info("Cluster identified XBX", m, v.width, e.node(m));
        const { ranksep: y, nodesep: b } = e.graph();
        v.graph.setGraph({
          ...v.graph.graph(),
          ranksep: y + 25,
          nodesep: b
        });
        const x = await Lne(
          f,
          v.graph,
          r,
          n,
          e.node(m),
          a
        ), T = x.elem;
        It(v, T), v.diff = x.diff || 0, ae.info(
          "New compound node after recursive render XAX",
          m,
          "width",
          // node,
          v.width,
          "height",
          v.height
          // node.x,
          // node.y
        ), D4e(T, v);
      } else
        e.children(m).length > 0 ? (ae.trace(
          "Cluster - the non recursive path XBX",
          m,
          v.id,
          v,
          v.width,
          "Graph:",
          e
        ), ae.trace(w1(v.id, e)), nr.set(v.id, { id: w1(v.id, e), node: v })) : (ae.trace("Node - the non recursive path XAX", m, f, e.node(m), s), await d4(f, e.node(m), { config: a, dir: s }));
    })
  ), await (/* @__PURE__ */ w(async () => {
    const m = e.edges().map(async function(v) {
      const y = e.edge(v.v, v.w, v.name);
      ae.info("Edge " + v.v + " -> " + v.w + ": " + JSON.stringify(v)), ae.info("Edge " + v.v + " -> " + v.w + ": ", v, " ", JSON.stringify(e.edge(v))), ae.info(
        "Fix",
        nr,
        "ids:",
        v.v,
        v.w,
        "Translating: ",
        nr.get(v.v),
        nr.get(v.w)
      ), await PJ(h, y);
    });
    await Promise.all(m);
  }, "processEdges"))(), ae.info("Graph before layout:", JSON.stringify(ao(e))), ae.info("############################################# XXX"), ae.info("###                Layout                 ### XXX"), ae.info("############################################# XXX"), Ene(e), ae.info("Graph after layout:", JSON.stringify(ao(e)));
  let p = 0, { subGraphTitleTotalMargin: g } = nm(a);
  return await Promise.all(
    W9e(e).map(async function(m) {
      const v = e.node(m);
      if (ae.info(
        "Position XBX => " + m + ": (" + v.x,
        "," + v.y,
        ") width: ",
        v.width,
        " height: ",
        v.height
      ), v?.clusterNode)
        v.y += g, ae.info(
          "A tainted cluster node XBX1",
          m,
          v.id,
          v.width,
          v.height,
          v.x,
          v.y,
          e.parent(m)
        ), nr.get(v.id).node = v, H_(v);
      else if (e.children(m).length > 0) {
        ae.info(
          "A pure cluster node XBX1",
          m,
          v.id,
          v.x,
          v.y,
          v.width,
          v.height,
          e.parent(m)
        ), v.height += g, e.node(v.parentId);
        const y = v?.padding / 2 || 0, b = v?.labelBBox?.height || 0, x = b - y || 0;
        ae.debug("OffsetY", x, "labelHeight", b, "halfPadding", y), await lL(l, v), nr.get(v.id).node = v;
      } else {
        const y = e.node(v.parentId);
        v.y += g / 2, ae.info(
          "A regular node XBX1 - using the padding",
          v.id,
          "parent",
          v.parentId,
          v.width,
          v.height,
          v.x,
          v.y,
          "offsetY",
          v.offsetY,
          "parent",
          y,
          y?.offsetY,
          v
        ), H_(v);
      }
    })
  ), e.edges().forEach(function(m) {
    const v = e.edge(m);
    ae.info("Edge " + m.v + " -> " + m.w + ": " + JSON.stringify(v), v), v.points.forEach((T) => T.y += g / 2);
    const y = e.node(m.v);
    var b = e.node(m.w);
    const x = FJ(u, v, nr, r, y, b, n);
    $J(v, x);
  }), e.nodes().forEach(function(m) {
    const v = e.node(m);
    ae.info(m, v.type, v.diff), v.isGroup && (p = v.diff);
  }), ae.warn("Returning from recursive render XAX", o, p), { elem: o, diff: p };
}, "recursiveRender"), Y9e = /* @__PURE__ */ w(async (t, e) => {
  const r = new ma({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: t.direction,
    nodesep: t.config?.nodeSpacing || t.config?.flowchart?.nodeSpacing || t.nodeSpacing,
    ranksep: t.config?.rankSpacing || t.config?.flowchart?.rankSpacing || t.rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  }), n = e.select("g");
  GJ(n, t.markers, t.type, t.diagramId), O4e(), B4e(), m4e(), G9e(), t.nodes.forEach((a) => {
    r.setNode(a.id, { ...a }), a.parentId && r.setParent(a.id, a.parentId);
  }), ae.debug("Edges:", t.edges), t.edges.forEach((a) => {
    if (a.start === a.end) {
      const s = a.start, o = s + "---" + s + "---1", l = s + "---" + s + "---2", u = r.node(s);
      r.setNode(o, {
        domId: o,
        id: o,
        parentId: u.parentId,
        labelStyle: "",
        label: "",
        padding: 0,
        shape: "labelRect",
        // shape: 'rect',
        style: "",
        width: 10,
        height: 10
      }), r.setParent(o, u.parentId), r.setNode(l, {
        domId: l,
        id: l,
        parentId: u.parentId,
        labelStyle: "",
        padding: 0,
        // shape: 'rect',
        shape: "labelRect",
        label: "",
        style: "",
        width: 10,
        height: 10
      }), r.setParent(l, u.parentId);
      const h = structuredClone(a), f = structuredClone(a), d = structuredClone(a);
      h.label = "", h.arrowTypeEnd = "none", h.id = s + "-cyclic-special-1", f.arrowTypeStart = "none", f.arrowTypeEnd = "none", f.id = s + "-cyclic-special-mid", d.label = "", u.isGroup && (h.fromCluster = s, d.toCluster = s), d.id = s + "-cyclic-special-2", d.arrowTypeStart = "none", r.setEdge(s, o, h, s + "-cyclic-special-0"), r.setEdge(o, l, f, s + "-cyclic-special-1"), r.setEdge(l, s, d, s + "-cyc<lic-special-2");
    } else
      r.setEdge(a.start, a.end, { ...a }, a.id);
  }), ae.warn("Graph at first:", JSON.stringify(ao(r))), H9e(r), ae.warn("Graph after XAX:", JSON.stringify(ao(r)));
  const i = Te();
  await Lne(
    n,
    r,
    t.type,
    t.diagramId,
    void 0,
    i
  );
}, "render");
const X9e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: Y9e
}, Symbol.toStringTag, { value: "Module" }));
function hA(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function j9e(t) {
  if (Array.isArray(t)) return t;
}
function K9e(t) {
  if (Array.isArray(t)) return hA(t);
}
function Gc(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function Z9e(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, Ine(n.key), n);
  }
}
function Uc(t, e, r) {
  return e && Z9e(t.prototype, e), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function ca(t, e) {
  var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (!r) {
    if (Array.isArray(t) || (r = dR(t)) || e) {
      r && (t = r);
      var n = 0, i = function() {
      };
      return {
        s: i,
        n: function() {
          return n >= t.length ? {
            done: !0
          } : {
            done: !1,
            value: t[n++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: i
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a, s = !0, o = !1;
  return {
    s: function() {
      r = r.call(t);
    },
    n: function() {
      var l = r.next();
      return s = l.done, l;
    },
    e: function(l) {
      o = !0, a = l;
    },
    f: function() {
      try {
        s || r.return == null || r.return();
      } finally {
        if (o) throw a;
      }
    }
  };
}
function Rne(t, e, r) {
  return (e = Ine(e)) in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function Q9e(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function J9e(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var n, i, a, s, o = [], l = !0, u = !1;
    try {
      if (a = (r = r.call(t)).next, e === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = a.call(r)).done) && (o.push(n.value), o.length !== e); l = !0) ;
    } catch (h) {
      u = !0, i = h;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw i;
      }
    }
    return o;
  }
}
function eLe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function tLe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Cn(t, e) {
  return j9e(t) || J9e(t, e) || dR(t, e) || eLe();
}
function Cb(t) {
  return K9e(t) || Q9e(t) || dR(t) || tLe();
}
function rLe(t, e) {
  if (typeof t != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function Ine(t) {
  var e = rLe(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Vn(t) {
  "@babel/helpers - typeof";
  return Vn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Vn(t);
}
function dR(t, e) {
  if (t) {
    if (typeof t == "string") return hA(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? hA(t, e) : void 0;
  }
}
var Bn = typeof window > "u" ? null : window, tq = Bn ? Bn.navigator : null;
Bn && Bn.document;
var nLe = Vn(""), Mne = Vn({}), iLe = Vn(function() {
}), aLe = typeof HTMLElement > "u" ? "undefined" : Vn(HTMLElement), ym = function(e) {
  return e && e.instanceString && ln(e.instanceString) ? e.instanceString() : null;
}, Pt = function(e) {
  return e != null && Vn(e) == nLe;
}, ln = function(e) {
  return e != null && Vn(e) === iLe;
}, Pr = function(e) {
  return !La(e) && (Array.isArray ? Array.isArray(e) : e != null && e instanceof Array);
}, yr = function(e) {
  return e != null && Vn(e) === Mne && !Pr(e) && e.constructor === Object;
}, sLe = function(e) {
  return e != null && Vn(e) === Mne;
}, mt = function(e) {
  return e != null && Vn(e) === Vn(1) && !isNaN(e);
}, oLe = function(e) {
  return mt(e) && Math.floor(e) === e;
}, _b = function(e) {
  if (aLe !== "undefined")
    return e != null && e instanceof HTMLElement;
}, La = function(e) {
  return bm(e) || Nne(e);
}, bm = function(e) {
  return ym(e) === "collection" && e._private.single;
}, Nne = function(e) {
  return ym(e) === "collection" && !e._private.single;
}, pR = function(e) {
  return ym(e) === "core";
}, Dne = function(e) {
  return ym(e) === "stylesheet";
}, lLe = function(e) {
  return ym(e) === "event";
}, yc = function(e) {
  return e == null ? !0 : !!(e === "" || e.match(/^\s+$/));
}, cLe = function(e) {
  return typeof HTMLElement > "u" ? !1 : e instanceof HTMLElement;
}, uLe = function(e) {
  return yr(e) && mt(e.x1) && mt(e.x2) && mt(e.y1) && mt(e.y2);
}, hLe = function(e) {
  return sLe(e) && ln(e.then);
}, fLe = function() {
  return tq && tq.userAgent.match(/msie|trident|edge/i);
}, u0 = function(e, r) {
  r || (r = function() {
    if (arguments.length === 1)
      return arguments[0];
    if (arguments.length === 0)
      return "undefined";
    for (var a = [], s = 0; s < arguments.length; s++)
      a.push(arguments[s]);
    return a.join("$");
  });
  var n = function() {
    var a = this, s = arguments, o, l = r.apply(a, s), u = n.cache;
    return (o = u[l]) || (o = u[l] = e.apply(a, s)), o;
  };
  return n.cache = {}, n;
}, gR = u0(function(t) {
  return t.replace(/([A-Z])/g, function(e) {
    return "-" + e.toLowerCase();
  });
}), Y4 = u0(function(t) {
  return t.replace(/(-\w)/g, function(e) {
    return e[1].toUpperCase();
  });
}), One = u0(function(t, e) {
  return t + e[0].toUpperCase() + e.substring(1);
}, function(t, e) {
  return t + "$" + e;
}), rq = function(e) {
  return yc(e) ? e : e.charAt(0).toUpperCase() + e.substring(1);
}, ec = function(e, r) {
  return e.slice(-1 * r.length) === r;
}, Gn = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))", dLe = "rgb[a]?\\((" + Gn + "[%]?)\\s*,\\s*(" + Gn + "[%]?)\\s*,\\s*(" + Gn + "[%]?)(?:\\s*,\\s*(" + Gn + "))?\\)", pLe = "rgb[a]?\\((?:" + Gn + "[%]?)\\s*,\\s*(?:" + Gn + "[%]?)\\s*,\\s*(?:" + Gn + "[%]?)(?:\\s*,\\s*(?:" + Gn + "))?\\)", gLe = "hsl[a]?\\((" + Gn + ")\\s*,\\s*(" + Gn + "[%])\\s*,\\s*(" + Gn + "[%])(?:\\s*,\\s*(" + Gn + "))?\\)", mLe = "hsl[a]?\\((?:" + Gn + ")\\s*,\\s*(?:" + Gn + "[%])\\s*,\\s*(?:" + Gn + "[%])(?:\\s*,\\s*(?:" + Gn + "))?\\)", vLe = "\\#[0-9a-fA-F]{3}", yLe = "\\#[0-9a-fA-F]{6}", Pne = function(e, r) {
  return e < r ? -1 : e > r ? 1 : 0;
}, bLe = function(e, r) {
  return -1 * Pne(e, r);
}, Ut = Object.assign != null ? Object.assign.bind(Object) : function(t) {
  for (var e = arguments, r = 1; r < e.length; r++) {
    var n = e[r];
    if (n != null)
      for (var i = Object.keys(n), a = 0; a < i.length; a++) {
        var s = i[a];
        t[s] = n[s];
      }
  }
  return t;
}, xLe = function(e) {
  if (!(!(e.length === 4 || e.length === 7) || e[0] !== "#")) {
    var r = e.length === 4, n, i, a, s = 16;
    return r ? (n = parseInt(e[1] + e[1], s), i = parseInt(e[2] + e[2], s), a = parseInt(e[3] + e[3], s)) : (n = parseInt(e[1] + e[2], s), i = parseInt(e[3] + e[4], s), a = parseInt(e[5] + e[6], s)), [n, i, a];
  }
}, wLe = function(e) {
  var r, n, i, a, s, o, l, u;
  function h(g, m, v) {
    return v < 0 && (v += 1), v > 1 && (v -= 1), v < 1 / 6 ? g + (m - g) * 6 * v : v < 1 / 2 ? m : v < 2 / 3 ? g + (m - g) * (2 / 3 - v) * 6 : g;
  }
  var f = new RegExp("^" + gLe + "$").exec(e);
  if (f) {
    if (n = parseInt(f[1]), n < 0 ? n = (360 - -1 * n % 360) % 360 : n > 360 && (n = n % 360), n /= 360, i = parseFloat(f[2]), i < 0 || i > 100 || (i = i / 100, a = parseFloat(f[3]), a < 0 || a > 100) || (a = a / 100, s = f[4], s !== void 0 && (s = parseFloat(s), s < 0 || s > 1)))
      return;
    if (i === 0)
      o = l = u = Math.round(a * 255);
    else {
      var d = a < 0.5 ? a * (1 + i) : a + i - a * i, p = 2 * a - d;
      o = Math.round(255 * h(p, d, n + 1 / 3)), l = Math.round(255 * h(p, d, n)), u = Math.round(255 * h(p, d, n - 1 / 3));
    }
    r = [o, l, u, s];
  }
  return r;
}, TLe = function(e) {
  var r, n = new RegExp("^" + dLe + "$").exec(e);
  if (n) {
    r = [];
    for (var i = [], a = 1; a <= 3; a++) {
      var s = n[a];
      if (s[s.length - 1] === "%" && (i[a] = !0), s = parseFloat(s), i[a] && (s = s / 100 * 255), s < 0 || s > 255)
        return;
      r.push(Math.floor(s));
    }
    var o = i[1] || i[2] || i[3], l = i[1] && i[2] && i[3];
    if (o && !l)
      return;
    var u = n[4];
    if (u !== void 0) {
      if (u = parseFloat(u), u < 0 || u > 1)
        return;
      r.push(u);
    }
  }
  return r;
}, ELe = function(e) {
  return SLe[e.toLowerCase()];
}, $ne = function(e) {
  return (Pr(e) ? e : null) || ELe(e) || xLe(e) || TLe(e) || wLe(e);
}, SLe = {
  // special colour names
  transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, Bne = function(e) {
  for (var r = e.map, n = e.keys, i = n.length, a = 0; a < i; a++) {
    var s = n[a];
    if (yr(s))
      throw Error("Tried to set map with object key");
    a < n.length - 1 ? (r[s] == null && (r[s] = {}), r = r[s]) : r[s] = e.value;
  }
}, Fne = function(e) {
  for (var r = e.map, n = e.keys, i = n.length, a = 0; a < i; a++) {
    var s = n[a];
    if (yr(s))
      throw Error("Tried to get map with object key");
    if (r = r[s], r == null)
      return r;
  }
  return r;
}, Cv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xm(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Lk, nq;
function wm() {
  if (nq) return Lk;
  nq = 1;
  function t(e) {
    var r = typeof e;
    return e != null && (r == "object" || r == "function");
  }
  return Lk = t, Lk;
}
var Rk, iq;
function kLe() {
  if (iq) return Rk;
  iq = 1;
  var t = typeof Cv == "object" && Cv && Cv.Object === Object && Cv;
  return Rk = t, Rk;
}
var Ik, aq;
function X4() {
  if (aq) return Ik;
  aq = 1;
  var t = kLe(), e = typeof self == "object" && self && self.Object === Object && self, r = t || e || Function("return this")();
  return Ik = r, Ik;
}
var Mk, sq;
function CLe() {
  if (sq) return Mk;
  sq = 1;
  var t = X4(), e = function() {
    return t.Date.now();
  };
  return Mk = e, Mk;
}
var Nk, oq;
function _Le() {
  if (oq) return Nk;
  oq = 1;
  var t = /\s/;
  function e(r) {
    for (var n = r.length; n-- && t.test(r.charAt(n)); )
      ;
    return n;
  }
  return Nk = e, Nk;
}
var Dk, lq;
function ALe() {
  if (lq) return Dk;
  lq = 1;
  var t = _Le(), e = /^\s+/;
  function r(n) {
    return n && n.slice(0, t(n) + 1).replace(e, "");
  }
  return Dk = r, Dk;
}
var Ok, cq;
function mR() {
  if (cq) return Ok;
  cq = 1;
  var t = X4(), e = t.Symbol;
  return Ok = e, Ok;
}
var Pk, uq;
function LLe() {
  if (uq) return Pk;
  uq = 1;
  var t = mR(), e = Object.prototype, r = e.hasOwnProperty, n = e.toString, i = t ? t.toStringTag : void 0;
  function a(s) {
    var o = r.call(s, i), l = s[i];
    try {
      s[i] = void 0;
      var u = !0;
    } catch {
    }
    var h = n.call(s);
    return u && (o ? s[i] = l : delete s[i]), h;
  }
  return Pk = a, Pk;
}
var $k, hq;
function RLe() {
  if (hq) return $k;
  hq = 1;
  var t = Object.prototype, e = t.toString;
  function r(n) {
    return e.call(n);
  }
  return $k = r, $k;
}
var Bk, fq;
function zne() {
  if (fq) return Bk;
  fq = 1;
  var t = mR(), e = LLe(), r = RLe(), n = "[object Null]", i = "[object Undefined]", a = t ? t.toStringTag : void 0;
  function s(o) {
    return o == null ? o === void 0 ? i : n : a && a in Object(o) ? e(o) : r(o);
  }
  return Bk = s, Bk;
}
var Fk, dq;
function ILe() {
  if (dq) return Fk;
  dq = 1;
  function t(e) {
    return e != null && typeof e == "object";
  }
  return Fk = t, Fk;
}
var zk, pq;
function Tm() {
  if (pq) return zk;
  pq = 1;
  var t = zne(), e = ILe(), r = "[object Symbol]";
  function n(i) {
    return typeof i == "symbol" || e(i) && t(i) == r;
  }
  return zk = n, zk;
}
var qk, gq;
function MLe() {
  if (gq) return qk;
  gq = 1;
  var t = ALe(), e = wm(), r = Tm(), n = NaN, i = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, s = /^0o[0-7]+$/i, o = parseInt;
  function l(u) {
    if (typeof u == "number")
      return u;
    if (r(u))
      return n;
    if (e(u)) {
      var h = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(h) ? h + "" : h;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = t(u);
    var f = a.test(u);
    return f || s.test(u) ? o(u.slice(2), f ? 2 : 8) : i.test(u) ? n : +u;
  }
  return qk = l, qk;
}
var Gk, mq;
function NLe() {
  if (mq) return Gk;
  mq = 1;
  var t = wm(), e = CLe(), r = MLe(), n = "Expected a function", i = Math.max, a = Math.min;
  function s(o, l, u) {
    var h, f, d, p, g, m, v = 0, y = !1, b = !1, x = !0;
    if (typeof o != "function")
      throw new TypeError(n);
    l = r(l) || 0, t(u) && (y = !!u.leading, b = "maxWait" in u, d = b ? i(r(u.maxWait) || 0, l) : d, x = "trailing" in u ? !!u.trailing : x);
    function T(P) {
      var C = h, I = f;
      return h = f = void 0, v = P, p = o.apply(I, C), p;
    }
    function E(P) {
      return v = P, g = setTimeout(k, l), y ? T(P) : p;
    }
    function A(P) {
      var C = P - m, I = P - v, N = l - C;
      return b ? a(N, d - I) : N;
    }
    function S(P) {
      var C = P - m, I = P - v;
      return m === void 0 || C >= l || C < 0 || b && I >= d;
    }
    function k() {
      var P = e();
      if (S(P))
        return _(P);
      g = setTimeout(k, A(P));
    }
    function _(P) {
      return g = void 0, x && h ? T(P) : (h = f = void 0, p);
    }
    function R() {
      g !== void 0 && clearTimeout(g), v = 0, h = m = f = g = void 0;
    }
    function L() {
      return g === void 0 ? p : _(e());
    }
    function M() {
      var P = e(), C = S(P);
      if (h = arguments, f = this, m = P, C) {
        if (g === void 0)
          return E(m);
        if (b)
          return clearTimeout(g), g = setTimeout(k, l), T(m);
      }
      return g === void 0 && (g = setTimeout(k, l)), p;
    }
    return M.cancel = R, M.flush = L, M;
  }
  return Gk = s, Gk;
}
var DLe = NLe(), Em = /* @__PURE__ */ xm(DLe), Uk = Bn ? Bn.performance : null, qne = Uk && Uk.now ? function() {
  return Uk.now();
} : function() {
  return Date.now();
}, OLe = (function() {
  if (Bn) {
    if (Bn.requestAnimationFrame)
      return function(t) {
        Bn.requestAnimationFrame(t);
      };
    if (Bn.mozRequestAnimationFrame)
      return function(t) {
        Bn.mozRequestAnimationFrame(t);
      };
    if (Bn.webkitRequestAnimationFrame)
      return function(t) {
        Bn.webkitRequestAnimationFrame(t);
      };
    if (Bn.msRequestAnimationFrame)
      return function(t) {
        Bn.msRequestAnimationFrame(t);
      };
  }
  return function(t) {
    t && setTimeout(function() {
      t(qne());
    }, 1e3 / 60);
  };
})(), Ab = function(e) {
  return OLe(e);
}, yl = qne, Eu = 9261, Gne = 65599, gf = 5381, Une = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Eu, n = r, i; i = e.next(), !i.done; )
    n = n * Gne + i.value | 0;
  return n;
}, T1 = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Eu;
  return r * Gne + e | 0;
}, E1 = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : gf;
  return (r << 5) + r + e | 0;
}, PLe = function(e, r) {
  return e * 2097152 + r;
}, Gl = function(e) {
  return e[0] * 2097152 + e[1];
}, _v = function(e, r) {
  return [T1(e[0], r[0]), E1(e[1], r[1])];
}, vq = function(e, r) {
  var n = {
    value: 0,
    done: !1
  }, i = 0, a = e.length, s = {
    next: function() {
      return i < a ? n.value = e[i++] : n.done = !0, n;
    }
  };
  return Une(s, r);
}, th = function(e, r) {
  var n = {
    value: 0,
    done: !1
  }, i = 0, a = e.length, s = {
    next: function() {
      return i < a ? n.value = e.charCodeAt(i++) : n.done = !0, n;
    }
  };
  return Une(s, r);
}, Vne = function() {
  return $Le(arguments);
}, $Le = function(e) {
  for (var r, n = 0; n < e.length; n++) {
    var i = e[n];
    n === 0 ? r = th(i) : r = th(i, r);
  }
  return r;
};
function BLe(t, e, r, n, i) {
  var a = i * Math.PI / 180, s = Math.cos(a) * (t - r) - Math.sin(a) * (e - n) + r, o = Math.sin(a) * (t - r) + Math.cos(a) * (e - n) + n;
  return {
    x: s,
    y: o
  };
}
var FLe = function(e, r, n, i, a, s) {
  return {
    x: (e - n) * a + n,
    y: (r - i) * s + i
  };
};
function zLe(t, e, r) {
  if (r === 0) return t;
  var n = (e.x1 + e.x2) / 2, i = (e.y1 + e.y2) / 2, a = e.w / e.h, s = 1 / a, o = BLe(t.x, t.y, n, i, r), l = FLe(o.x, o.y, n, i, a, s);
  return {
    x: l.x,
    y: l.y
  };
}
var yq = !0, qLe = console.warn != null, GLe = console.trace != null, vR = Number.MAX_SAFE_INTEGER || 9007199254740991, Hne = function() {
  return !0;
}, Lb = function() {
  return !1;
}, bq = function() {
  return 0;
}, yR = function() {
}, Jr = function(e) {
  throw new Error(e);
}, Wne = function(e) {
  if (e !== void 0)
    yq = !!e;
  else
    return yq;
}, Rr = function(e) {
  Wne() && (qLe ? console.warn(e) : (console.log(e), GLe && console.trace()));
}, ULe = function(e) {
  return Ut({}, e);
}, so = function(e) {
  return e == null ? e : Pr(e) ? e.slice() : yr(e) ? ULe(e) : e;
}, VLe = function(e) {
  return e.slice();
}, Yne = function(e, r) {
  for (
    // loop :)
    r = e = "";
    // b - result , a - numeric letiable
    e++ < 36;
    //
    r += e * 51 & 52 ? (
      //  return a random number or 4
      (e ^ 15 ? (
        // generate a random number from 0 to 15
        8 ^ Math.random() * (e ^ 20 ? 16 : 4)
      ) : 4).toString(16)
    ) : "-"
  ) ;
  return r;
}, HLe = {}, Xne = function() {
  return HLe;
}, vi = function(e) {
  var r = Object.keys(e);
  return function(n) {
    for (var i = {}, a = 0; a < r.length; a++) {
      var s = r[a], o = n?.[s];
      i[s] = o === void 0 ? e[s] : o;
    }
    return i;
  };
}, bc = function(e, r, n) {
  for (var i = e.length - 1; i >= 0; i--)
    e[i] === r && e.splice(i, 1);
}, bR = function(e) {
  e.splice(0, e.length);
}, WLe = function(e, r) {
  for (var n = 0; n < r.length; n++) {
    var i = r[n];
    e.push(i);
  }
}, aa = function(e, r, n) {
  return n && (r = One(n, r)), e[r];
}, Yo = function(e, r, n, i) {
  n && (r = One(n, r)), e[r] = i;
}, YLe = /* @__PURE__ */ (function() {
  function t() {
    Gc(this, t), this._obj = {};
  }
  return Uc(t, [{
    key: "set",
    value: function(r, n) {
      return this._obj[r] = n, this;
    }
  }, {
    key: "delete",
    value: function(r) {
      return this._obj[r] = void 0, this;
    }
  }, {
    key: "clear",
    value: function() {
      this._obj = {};
    }
  }, {
    key: "has",
    value: function(r) {
      return this._obj[r] !== void 0;
    }
  }, {
    key: "get",
    value: function(r) {
      return this._obj[r];
    }
  }]);
})(), el = typeof Map < "u" ? Map : YLe, XLe = "undefined", jLe = /* @__PURE__ */ (function() {
  function t(e) {
    if (Gc(this, t), this._obj = /* @__PURE__ */ Object.create(null), this.size = 0, e != null) {
      var r;
      e.instanceString != null && e.instanceString() === this.instanceString() ? r = e.toArray() : r = e;
      for (var n = 0; n < r.length; n++)
        this.add(r[n]);
    }
  }
  return Uc(t, [{
    key: "instanceString",
    value: function() {
      return "set";
    }
  }, {
    key: "add",
    value: function(r) {
      var n = this._obj;
      n[r] !== 1 && (n[r] = 1, this.size++);
    }
  }, {
    key: "delete",
    value: function(r) {
      var n = this._obj;
      n[r] === 1 && (n[r] = 0, this.size--);
    }
  }, {
    key: "clear",
    value: function() {
      this._obj = /* @__PURE__ */ Object.create(null);
    }
  }, {
    key: "has",
    value: function(r) {
      return this._obj[r] === 1;
    }
  }, {
    key: "toArray",
    value: function() {
      var r = this;
      return Object.keys(this._obj).filter(function(n) {
        return r.has(n);
      });
    }
  }, {
    key: "forEach",
    value: function(r, n) {
      return this.toArray().forEach(r, n);
    }
  }]);
})(), q0 = (typeof Set > "u" ? "undefined" : Vn(Set)) !== XLe ? Set : jLe, j4 = function(e, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (e === void 0 || r === void 0 || !pR(e)) {
    Jr("An element must have a core reference and parameters set");
    return;
  }
  var i = r.group;
  if (i == null && (r.data && r.data.source != null && r.data.target != null ? i = "edges" : i = "nodes"), i !== "nodes" && i !== "edges") {
    Jr("An element must be of type `nodes` or `edges`; you specified `" + i + "`");
    return;
  }
  this.length = 1, this[0] = this;
  var a = this._private = {
    cy: e,
    single: !0,
    // indicates this is an element
    data: r.data || {},
    // data object
    position: r.position || {
      x: 0,
      y: 0
    },
    // (x, y) position pair
    autoWidth: void 0,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: void 0,
    autoPadding: void 0,
    compoundBoundsClean: !1,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [],
    // array of bound listeners
    group: i,
    // string; 'nodes' or 'edges'
    style: {},
    // properties as set by the style
    rstyle: {},
    // properties for style sent from the renderer to the core
    styleCxts: [],
    // applied style contexts from the styler
    styleKeys: {},
    // per-group keys of style property values
    removed: !0,
    // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: !!r.selected,
    // whether it's selected
    selectable: r.selectable === void 0 ? !0 : !!r.selectable,
    // whether it's selectable
    locked: !!r.locked,
    // whether the element is locked (cannot be moved)
    grabbed: !1,
    // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: r.grabbable === void 0 ? !0 : !!r.grabbable,
    // whether the element can be grabbed
    pannable: r.pannable === void 0 ? i === "edges" : !!r.pannable,
    // whether the element has passthrough panning enabled
    active: !1,
    // whether the element is active from user interaction
    classes: new q0(),
    // map ( className => true )
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {},
    // object in which the renderer can store information
    scratch: r.scratch || {},
    // scratch objects
    edges: [],
    // array of connected edges
    children: [],
    // array of children
    parent: r.parent && r.parent.isNode() ? r.parent : null,
    // parent ref
    traversalCache: {},
    // cache of output of traversal functions
    backgrounding: !1,
    // whether background images are loading
    bbCache: null,
    // cache of the current bounding box
    bbCacheShift: {
      x: 0,
      y: 0
    },
    // shift applied to cached bb to be applied on next get
    bodyBounds: null,
    // bounds cache of element body, w/o overlay
    overlayBounds: null,
    // bounds cache of element body, including overlay
    labelBounds: {
      // bounds cache of labels
      all: null,
      source: null,
      target: null,
      main: null
    },
    arrowBounds: {
      // bounds cache of edge arrows
      source: null,
      target: null,
      "mid-source": null,
      "mid-target": null
    }
  };
  if (a.position.x == null && (a.position.x = 0), a.position.y == null && (a.position.y = 0), r.renderedPosition) {
    var s = r.renderedPosition, o = e.pan(), l = e.zoom();
    a.position = {
      x: (s.x - o.x) / l,
      y: (s.y - o.y) / l
    };
  }
  var u = [];
  Pr(r.classes) ? u = r.classes : Pt(r.classes) && (u = r.classes.split(/\s+/));
  for (var h = 0, f = u.length; h < f; h++) {
    var d = u[h];
    !d || d === "" || a.classes.add(d);
  }
  this.createEmitter(), (n === void 0 || n) && this.restore();
  var p = r.style || r.css;
  p && (Rr("Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead."), this.style(p));
}, xq = function(e) {
  return e = {
    bfs: e.bfs || !e.dfs,
    dfs: e.dfs || !e.bfs
  }, function(n, i, a) {
    var s;
    yr(n) && !La(n) && (s = n, n = s.roots || s.root, i = s.visit, a = s.directed), a = arguments.length === 2 && !ln(i) ? i : a, i = ln(i) ? i : function() {
    };
    for (var o = this._private.cy, l = n = Pt(n) ? this.filter(n) : n, u = [], h = [], f = {}, d = {}, p = {}, g = 0, m, v = this.byGroup(), y = v.nodes, b = v.edges, x = 0; x < l.length; x++) {
      var T = l[x], E = T.id();
      T.isNode() && (u.unshift(T), e.bfs && (p[E] = !0, h.push(T)), d[E] = 0);
    }
    for (var A = function() {
      var P = e.bfs ? u.shift() : u.pop(), C = P.id();
      if (e.dfs) {
        if (p[C])
          return 0;
        p[C] = !0, h.push(P);
      }
      var I = d[C], N = f[C], O = N != null ? N.source() : null, D = N != null ? N.target() : null, $ = N == null ? void 0 : P.same(O) ? D[0] : O[0], z;
      if (z = i(P, N, $, g++, I), z === !0)
        return m = P, 1;
      if (z === !1)
        return 1;
      for (var B = P.connectedEdges().filter(function(Z) {
        return (!a || Z.source().same(P)) && b.has(Z);
      }), G = 0; G < B.length; G++) {
        var W = B[G], V = W.connectedNodes().filter(function(Z) {
          return !Z.same(P) && y.has(Z);
        }), U = V.id();
        V.length !== 0 && !p[U] && (V = V[0], u.push(V), e.bfs && (p[U] = !0, h.push(V)), f[U] = W, d[U] = d[C] + 1);
      }
    }, S; u.length !== 0 && (S = A(), !(S !== 0 && S === 1)); )
      ;
    for (var k = o.collection(), _ = 0; _ < h.length; _++) {
      var R = h[_], L = f[R.id()];
      L != null && k.push(L), k.push(R);
    }
    return {
      path: o.collection(k),
      found: o.collection(m)
    };
  };
}, S1 = {
  breadthFirstSearch: xq({
    bfs: !0
  }),
  depthFirstSearch: xq({
    dfs: !0
  })
};
S1.bfs = S1.breadthFirstSearch;
S1.dfs = S1.depthFirstSearch;
var Oy = { exports: {} }, KLe = Oy.exports, wq;
function ZLe() {
  return wq || (wq = 1, (function(t, e) {
    (function() {
      var r, n, i, a, s, o, l, u, h, f, d, p, g, m, v;
      i = Math.floor, f = Math.min, n = function(y, b) {
        return y < b ? -1 : y > b ? 1 : 0;
      }, h = function(y, b, x, T, E) {
        var A;
        if (x == null && (x = 0), E == null && (E = n), x < 0)
          throw new Error("lo must be non-negative");
        for (T == null && (T = y.length); x < T; )
          A = i((x + T) / 2), E(b, y[A]) < 0 ? T = A : x = A + 1;
        return [].splice.apply(y, [x, x - x].concat(b)), b;
      }, o = function(y, b, x) {
        return x == null && (x = n), y.push(b), m(y, 0, y.length - 1, x);
      }, s = function(y, b) {
        var x, T;
        return b == null && (b = n), x = y.pop(), y.length ? (T = y[0], y[0] = x, v(y, 0, b)) : T = x, T;
      }, u = function(y, b, x) {
        var T;
        return x == null && (x = n), T = y[0], y[0] = b, v(y, 0, x), T;
      }, l = function(y, b, x) {
        var T;
        return x == null && (x = n), y.length && x(y[0], b) < 0 && (T = [y[0], b], b = T[0], y[0] = T[1], v(y, 0, x)), b;
      }, a = function(y, b) {
        var x, T, E, A, S, k;
        for (b == null && (b = n), A = (function() {
          k = [];
          for (var _ = 0, R = i(y.length / 2); 0 <= R ? _ < R : _ > R; 0 <= R ? _++ : _--)
            k.push(_);
          return k;
        }).apply(this).reverse(), S = [], T = 0, E = A.length; T < E; T++)
          x = A[T], S.push(v(y, x, b));
        return S;
      }, g = function(y, b, x) {
        var T;
        if (x == null && (x = n), T = y.indexOf(b), T !== -1)
          return m(y, 0, T, x), v(y, T, x);
      }, d = function(y, b, x) {
        var T, E, A, S, k;
        if (x == null && (x = n), E = y.slice(0, b), !E.length)
          return E;
        for (a(E, x), k = y.slice(b), A = 0, S = k.length; A < S; A++)
          T = k[A], l(E, T, x);
        return E.sort(x).reverse();
      }, p = function(y, b, x) {
        var T, E, A, S, k, _, R, L, M;
        if (x == null && (x = n), b * 10 <= y.length) {
          if (A = y.slice(0, b).sort(x), !A.length)
            return A;
          for (E = A[A.length - 1], R = y.slice(b), S = 0, _ = R.length; S < _; S++)
            T = R[S], x(T, E) < 0 && (h(A, T, 0, null, x), A.pop(), E = A[A.length - 1]);
          return A;
        }
        for (a(y, x), M = [], k = 0, L = f(b, y.length); 0 <= L ? k < L : k > L; 0 <= L ? ++k : --k)
          M.push(s(y, x));
        return M;
      }, m = function(y, b, x, T) {
        var E, A, S;
        for (T == null && (T = n), E = y[x]; x > b; ) {
          if (S = x - 1 >> 1, A = y[S], T(E, A) < 0) {
            y[x] = A, x = S;
            continue;
          }
          break;
        }
        return y[x] = E;
      }, v = function(y, b, x) {
        var T, E, A, S, k;
        for (x == null && (x = n), E = y.length, k = b, A = y[b], T = 2 * b + 1; T < E; )
          S = T + 1, S < E && !(x(y[T], y[S]) < 0) && (T = S), y[b] = y[T], b = T, T = 2 * b + 1;
        return y[b] = A, m(y, k, b, x);
      }, r = (function() {
        y.push = o, y.pop = s, y.replace = u, y.pushpop = l, y.heapify = a, y.updateItem = g, y.nlargest = d, y.nsmallest = p;
        function y(b) {
          this.cmp = b ?? n, this.nodes = [];
        }
        return y.prototype.push = function(b) {
          return o(this.nodes, b, this.cmp);
        }, y.prototype.pop = function() {
          return s(this.nodes, this.cmp);
        }, y.prototype.peek = function() {
          return this.nodes[0];
        }, y.prototype.contains = function(b) {
          return this.nodes.indexOf(b) !== -1;
        }, y.prototype.replace = function(b) {
          return u(this.nodes, b, this.cmp);
        }, y.prototype.pushpop = function(b) {
          return l(this.nodes, b, this.cmp);
        }, y.prototype.heapify = function() {
          return a(this.nodes, this.cmp);
        }, y.prototype.updateItem = function(b) {
          return g(this.nodes, b, this.cmp);
        }, y.prototype.clear = function() {
          return this.nodes = [];
        }, y.prototype.empty = function() {
          return this.nodes.length === 0;
        }, y.prototype.size = function() {
          return this.nodes.length;
        }, y.prototype.clone = function() {
          var b;
          return b = new y(), b.nodes = this.nodes.slice(0), b;
        }, y.prototype.toArray = function() {
          return this.nodes.slice(0);
        }, y.prototype.insert = y.prototype.push, y.prototype.top = y.prototype.peek, y.prototype.front = y.prototype.peek, y.prototype.has = y.prototype.contains, y.prototype.copy = y.prototype.clone, y;
      })(), (function(y, b) {
        return t.exports = b();
      })(this, function() {
        return r;
      });
    }).call(KLe);
  })(Oy)), Oy.exports;
}
var Vk, Tq;
function QLe() {
  return Tq || (Tq = 1, Vk = ZLe()), Vk;
}
var JLe = QLe(), Sm = /* @__PURE__ */ xm(JLe), eRe = vi({
  root: null,
  weight: function(e) {
    return 1;
  },
  directed: !1
}), tRe = {
  dijkstra: function(e) {
    if (!yr(e)) {
      var r = arguments;
      e = {
        root: r[0],
        weight: r[1],
        directed: r[2]
      };
    }
    var n = eRe(e), i = n.root, a = n.weight, s = n.directed, o = this, l = a, u = Pt(i) ? this.filter(i)[0] : i[0], h = {}, f = {}, d = {}, p = this.byGroup(), g = p.nodes, m = p.edges;
    m.unmergeBy(function(I) {
      return I.isLoop();
    });
    for (var v = function(N) {
      return h[N.id()];
    }, y = function(N, O) {
      h[N.id()] = O, b.updateItem(N);
    }, b = new Sm(function(I, N) {
      return v(I) - v(N);
    }), x = 0; x < g.length; x++) {
      var T = g[x];
      h[T.id()] = T.same(u) ? 0 : 1 / 0, b.push(T);
    }
    for (var E = function(N, O) {
      for (var D = (s ? N.edgesTo(O) : N.edgesWith(O)).intersect(m), $ = 1 / 0, z, B = 0; B < D.length; B++) {
        var G = D[B], W = l(G);
        (W < $ || !z) && ($ = W, z = G);
      }
      return {
        edge: z,
        dist: $
      };
    }; b.size() > 0; ) {
      var A = b.pop(), S = v(A), k = A.id();
      if (d[k] = S, S !== 1 / 0)
        for (var _ = A.neighborhood().intersect(g), R = 0; R < _.length; R++) {
          var L = _[R], M = L.id(), P = E(A, L), C = S + P.dist;
          C < v(L) && (y(L, C), f[M] = {
            node: A,
            edge: P.edge
          });
        }
    }
    return {
      distanceTo: function(N) {
        var O = Pt(N) ? g.filter(N)[0] : N[0];
        return d[O.id()];
      },
      pathTo: function(N) {
        var O = Pt(N) ? g.filter(N)[0] : N[0], D = [], $ = O, z = $.id();
        if (O.length > 0)
          for (D.unshift(O); f[z]; ) {
            var B = f[z];
            D.unshift(B.edge), D.unshift(B.node), $ = B.node, z = $.id();
          }
        return o.spawn(D);
      }
    };
  }
}, rRe = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function(e) {
    e = e || function(x) {
      return 1;
    };
    for (var r = this.byGroup(), n = r.nodes, i = r.edges, a = n.length, s = new Array(a), o = n, l = function(T) {
      for (var E = 0; E < s.length; E++) {
        var A = s[E];
        if (A.has(T))
          return E;
      }
    }, u = 0; u < a; u++)
      s[u] = this.spawn(n[u]);
    for (var h = i.sort(function(x, T) {
      return e(x) - e(T);
    }), f = 0; f < h.length; f++) {
      var d = h[f], p = d.source()[0], g = d.target()[0], m = l(p), v = l(g), y = s[m], b = s[v];
      m !== v && (o.merge(d), y.merge(b), s.splice(v, 1));
    }
    return o;
  }
}, nRe = vi({
  root: null,
  goal: null,
  weight: function(e) {
    return 1;
  },
  heuristic: function(e) {
    return 0;
  },
  directed: !1
}), iRe = {
  // Implemented from pseudocode from wikipedia
  aStar: function(e) {
    var r = this.cy(), n = nRe(e), i = n.root, a = n.goal, s = n.heuristic, o = n.directed, l = n.weight;
    i = r.collection(i)[0], a = r.collection(a)[0];
    var u = i.id(), h = a.id(), f = {}, d = {}, p = {}, g = new Sm(function(z, B) {
      return d[z.id()] - d[B.id()];
    }), m = new q0(), v = {}, y = {}, b = function(B, G) {
      g.push(B), m.add(G);
    }, x, T, E = function() {
      x = g.pop(), T = x.id(), m.delete(T);
    }, A = function(B) {
      return m.has(B);
    };
    b(i, u), f[u] = 0, d[u] = s(i);
    for (var S = 0; g.size() > 0; ) {
      if (E(), S++, T === h) {
        for (var k = [], _ = a, R = h, L = y[R]; k.unshift(_), L != null && k.unshift(L), _ = v[R], _ != null; )
          R = _.id(), L = y[R];
        return {
          found: !0,
          distance: f[T],
          path: this.spawn(k),
          steps: S
        };
      }
      p[T] = !0;
      for (var M = x._private.edges, P = 0; P < M.length; P++) {
        var C = M[P];
        if (this.hasElementWithId(C.id()) && !(o && C.data("source") !== T)) {
          var I = C.source(), N = C.target(), O = I.id() !== T ? I : N, D = O.id();
          if (this.hasElementWithId(D) && !p[D]) {
            var $ = f[T] + l(C);
            if (!A(D)) {
              f[D] = $, d[D] = $ + s(O), b(O, D), v[D] = x, y[D] = C;
              continue;
            }
            $ < f[D] && (f[D] = $, d[D] = $ + s(O), v[D] = x, y[D] = C);
          }
        }
      }
    }
    return {
      found: !1,
      distance: void 0,
      path: void 0,
      steps: S
    };
  }
}, aRe = vi({
  weight: function(e) {
    return 1;
  },
  directed: !1
}), sRe = {
  // Implemented from pseudocode from wikipedia
  floydWarshall: function(e) {
    for (var r = this.cy(), n = aRe(e), i = n.weight, a = n.directed, s = i, o = this.byGroup(), l = o.nodes, u = o.edges, h = l.length, f = h * h, d = function(W) {
      return l.indexOf(W);
    }, p = function(W) {
      return l[W];
    }, g = new Array(f), m = 0; m < f; m++) {
      var v = m % h, y = (m - v) / h;
      y === v ? g[m] = 0 : g[m] = 1 / 0;
    }
    for (var b = new Array(f), x = new Array(f), T = 0; T < u.length; T++) {
      var E = u[T], A = E.source()[0], S = E.target()[0];
      if (A !== S) {
        var k = d(A), _ = d(S), R = k * h + _, L = s(E);
        if (g[R] > L && (g[R] = L, b[R] = _, x[R] = E), !a) {
          var M = _ * h + k;
          !a && g[M] > L && (g[M] = L, b[M] = k, x[M] = E);
        }
      }
    }
    for (var P = 0; P < h; P++)
      for (var C = 0; C < h; C++)
        for (var I = C * h + P, N = 0; N < h; N++) {
          var O = C * h + N, D = P * h + N;
          g[I] + g[D] < g[O] && (g[O] = g[I] + g[D], b[O] = b[I]);
        }
    var $ = function(W) {
      return (Pt(W) ? r.filter(W) : W)[0];
    }, z = function(W) {
      return d($(W));
    }, B = {
      distance: function(W, V) {
        var U = z(W), Z = z(V);
        return g[U * h + Z];
      },
      path: function(W, V) {
        var U = z(W), Z = z(V), K = p(U);
        if (U === Z)
          return K.collection();
        if (b[U * h + Z] == null)
          return r.collection();
        var ce = r.collection(), J = U, ee;
        for (ce.merge(K); U !== Z; )
          J = U, U = b[U * h + Z], ee = x[J * h + U], ce.merge(ee), ce.merge(p(U));
        return ce;
      }
    };
    return B;
  }
  // floydWarshall
}, oRe = vi({
  weight: function(e) {
    return 1;
  },
  directed: !1,
  root: null
}), lRe = {
  // Implemented from pseudocode from wikipedia
  bellmanFord: function(e) {
    var r = this, n = oRe(e), i = n.weight, a = n.directed, s = n.root, o = i, l = this, u = this.cy(), h = this.byGroup(), f = h.edges, d = h.nodes, p = d.length, g = new el(), m = !1, v = [];
    s = u.collection(s)[0], f.unmergeBy(function(xe) {
      return xe.isLoop();
    });
    for (var y = f.length, b = function(Y) {
      var Ne = g.get(Y.id());
      return Ne || (Ne = {}, g.set(Y.id(), Ne)), Ne;
    }, x = function(Y) {
      return (Pt(Y) ? u.$(Y) : Y)[0];
    }, T = function(Y) {
      return b(x(Y)).dist;
    }, E = function(Y) {
      for (var Ne = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s, fe = x(Y), qe = [], ze = fe; ; ) {
        if (ze == null)
          return r.spawn();
        var Ge = b(ze), Ee = Ge.edge, Oe = Ge.pred;
        if (qe.unshift(ze[0]), ze.same(Ne) && qe.length > 0)
          break;
        Ee != null && qe.unshift(Ee), ze = Oe;
      }
      return l.spawn(qe);
    }, A = 0; A < p; A++) {
      var S = d[A], k = b(S);
      S.same(s) ? k.dist = 0 : k.dist = 1 / 0, k.pred = null, k.edge = null;
    }
    for (var _ = !1, R = function(Y, Ne, fe, qe, ze, Ge) {
      var Ee = qe.dist + Ge;
      Ee < ze.dist && !fe.same(qe.edge) && (ze.dist = Ee, ze.pred = Y, ze.edge = fe, _ = !0);
    }, L = 1; L < p; L++) {
      _ = !1;
      for (var M = 0; M < y; M++) {
        var P = f[M], C = P.source(), I = P.target(), N = o(P), O = b(C), D = b(I);
        R(C, I, P, O, D, N), a || R(I, C, P, D, O, N);
      }
      if (!_)
        break;
    }
    if (_)
      for (var $ = [], z = 0; z < y; z++) {
        var B = f[z], G = B.source(), W = B.target(), V = o(B), U = b(G).dist, Z = b(W).dist;
        if (U + V < Z || !a && Z + V < U)
          if (m || (Rr("Graph contains a negative weight cycle for Bellman-Ford"), m = !0), e.findNegativeWeightCycles !== !1) {
            var K = [];
            U + V < Z && K.push(G), !a && Z + V < U && K.push(W);
            for (var ce = K.length, J = 0; J < ce; J++) {
              var ee = K[J], j = [ee];
              j.push(b(ee).edge);
              for (var X = b(ee).pred; j.indexOf(X) === -1; )
                j.push(X), j.push(b(X).edge), X = b(X).pred;
              j = j.slice(j.indexOf(X));
              for (var re = j[0].id(), Q = 0, ue = 2; ue < j.length; ue += 2)
                j[ue].id() < re && (re = j[ue].id(), Q = ue);
              j = j.slice(Q).concat(j.slice(0, Q)), j.push(j[0]);
              var ne = j.map(function(xe) {
                return xe.id();
              }).join(",");
              $.indexOf(ne) === -1 && (v.push(l.spawn(j)), $.push(ne));
            }
          } else
            break;
      }
    return {
      distanceTo: T,
      pathTo: E,
      hasNegativeWeightCycle: m,
      negativeWeightCycles: v
    };
  }
  // bellmanFord
}, cRe = Math.sqrt(2), uRe = function(e, r, n) {
  n.length === 0 && Jr("Karger-Stein must be run on a connected (sub)graph");
  for (var i = n[e], a = i[1], s = i[2], o = r[a], l = r[s], u = n, h = u.length - 1; h >= 0; h--) {
    var f = u[h], d = f[1], p = f[2];
    (r[d] === o && r[p] === l || r[d] === l && r[p] === o) && u.splice(h, 1);
  }
  for (var g = 0; g < u.length; g++) {
    var m = u[g];
    m[1] === l ? (u[g] = m.slice(), u[g][1] = o) : m[2] === l && (u[g] = m.slice(), u[g][2] = o);
  }
  for (var v = 0; v < r.length; v++)
    r[v] === l && (r[v] = o);
  return u;
}, Hk = function(e, r, n, i) {
  for (; n > i; ) {
    var a = Math.floor(Math.random() * r.length);
    r = uRe(a, e, r), n--;
  }
  return r;
}, hRe = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function() {
    var e = this, r = this.byGroup(), n = r.nodes, i = r.edges;
    i.unmergeBy(function(D) {
      return D.isLoop();
    });
    var a = n.length, s = i.length, o = Math.ceil(Math.pow(Math.log(a) / Math.LN2, 2)), l = Math.floor(a / cRe);
    if (a < 2) {
      Jr("At least 2 nodes are required for Karger-Stein algorithm");
      return;
    }
    for (var u = [], h = 0; h < s; h++) {
      var f = i[h];
      u.push([h, n.indexOf(f.source()), n.indexOf(f.target())]);
    }
    for (var d = 1 / 0, p = [], g = new Array(a), m = new Array(a), v = new Array(a), y = function($, z) {
      for (var B = 0; B < a; B++)
        z[B] = $[B];
    }, b = 0; b <= o; b++) {
      for (var x = 0; x < a; x++)
        m[x] = x;
      var T = Hk(m, u.slice(), a, l), E = T.slice();
      y(m, v);
      var A = Hk(m, T, l, 2), S = Hk(v, E, l, 2);
      A.length <= S.length && A.length < d ? (d = A.length, p = A, y(m, g)) : S.length <= A.length && S.length < d && (d = S.length, p = S, y(v, g));
    }
    for (var k = this.spawn(p.map(function(D) {
      return i[D[0]];
    })), _ = this.spawn(), R = this.spawn(), L = g[0], M = 0; M < g.length; M++) {
      var P = g[M], C = n[M];
      P === L ? _.merge(C) : R.merge(C);
    }
    var I = function($) {
      var z = e.spawn();
      return $.forEach(function(B) {
        z.merge(B), B.connectedEdges().forEach(function(G) {
          e.contains(G) && !k.contains(G) && z.merge(G);
        });
      }), z;
    }, N = [I(_), I(R)], O = {
      cut: k,
      components: N,
      // n.b. partitions are included to be compatible with the old api spec
      // (could be removed in a future major version)
      partition1: _,
      partition2: R
    };
    return O;
  }
}, Wk, fRe = function(e) {
  return {
    x: e.x,
    y: e.y
  };
}, K4 = function(e, r, n) {
  return {
    x: e.x * r + n.x,
    y: e.y * r + n.y
  };
}, jne = function(e, r, n) {
  return {
    x: (e.x - n.x) / r,
    y: (e.y - n.y) / r
  };
}, Sf = function(e) {
  return {
    x: e[0],
    y: e[1]
  };
}, dRe = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = 1 / 0, a = r; a < n; a++) {
    var s = e[a];
    isFinite(s) && (i = Math.min(s, i));
  }
  return i;
}, pRe = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = -1 / 0, a = r; a < n; a++) {
    var s = e[a];
    isFinite(s) && (i = Math.max(s, i));
  }
  return i;
}, gRe = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = 0, a = 0, s = r; s < n; s++) {
    var o = e[s];
    isFinite(o) && (i += o, a++);
  }
  return i / a;
}, mRe = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0;
  i ? e = e.slice(r, n) : (n < e.length && e.splice(n, e.length - n), r > 0 && e.splice(0, r));
  for (var o = 0, l = e.length - 1; l >= 0; l--) {
    var u = e[l];
    s ? isFinite(u) || (e[l] = -1 / 0, o++) : e.splice(l, 1);
  }
  a && e.sort(function(d, p) {
    return d - p;
  });
  var h = e.length, f = Math.floor(h / 2);
  return h % 2 !== 0 ? e[f + 1 + o] : (e[f - 1 + o] + e[f + o]) / 2;
}, vRe = function(e) {
  return Math.PI * e / 180;
}, Av = function(e, r) {
  return Math.atan2(r, e) - Math.PI / 2;
}, xR = Math.log2 || function(t) {
  return Math.log(t) / Math.log(2);
}, wR = function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, rh = function(e, r) {
  return Math.sqrt(bu(e, r));
}, bu = function(e, r) {
  var n = r.x - e.x, i = r.y - e.y;
  return n * n + i * i;
}, yRe = function(e) {
  for (var r = e.length, n = 0, i = 0; i < r; i++)
    n += e[i];
  for (var a = 0; a < r; a++)
    e[a] = e[a] / n;
  return e;
}, Zn = function(e, r, n, i) {
  return (1 - i) * (1 - i) * e + 2 * (1 - i) * i * r + i * i * n;
}, Bf = function(e, r, n, i) {
  return {
    x: Zn(e.x, r.x, n.x, i),
    y: Zn(e.y, r.y, n.y, i)
  };
}, bRe = function(e, r, n, i) {
  var a = {
    x: r.x - e.x,
    y: r.y - e.y
  }, s = rh(e, r), o = {
    x: a.x / s,
    y: a.y / s
  };
  return n = n ?? 0, i = i ?? n * s, {
    x: e.x + o.x * i,
    y: e.y + o.y * i
  };
}, k1 = function(e, r, n) {
  return Math.max(e, Math.min(n, r));
}, ji = function(e) {
  if (e == null)
    return {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0,
      w: 0,
      h: 0
    };
  if (e.x1 != null && e.y1 != null) {
    if (e.x2 != null && e.y2 != null && e.x2 >= e.x1 && e.y2 >= e.y1)
      return {
        x1: e.x1,
        y1: e.y1,
        x2: e.x2,
        y2: e.y2,
        w: e.x2 - e.x1,
        h: e.y2 - e.y1
      };
    if (e.w != null && e.h != null && e.w >= 0 && e.h >= 0)
      return {
        x1: e.x1,
        y1: e.y1,
        x2: e.x1 + e.w,
        y2: e.y1 + e.h,
        w: e.w,
        h: e.h
      };
  }
}, xRe = function(e) {
  return {
    x1: e.x1,
    x2: e.x2,
    w: e.w,
    y1: e.y1,
    y2: e.y2,
    h: e.h
  };
}, wRe = function(e) {
  e.x1 = 1 / 0, e.y1 = 1 / 0, e.x2 = -1 / 0, e.y2 = -1 / 0, e.w = 0, e.h = 0;
}, TRe = function(e, r) {
  e.x1 = Math.min(e.x1, r.x1), e.x2 = Math.max(e.x2, r.x2), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, r.y1), e.y2 = Math.max(e.y2, r.y2), e.h = e.y2 - e.y1;
}, Kne = function(e, r, n) {
  e.x1 = Math.min(e.x1, r), e.x2 = Math.max(e.x2, r), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, n), e.y2 = Math.max(e.y2, n), e.h = e.y2 - e.y1;
}, Py = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.x1 -= r, e.x2 += r, e.y1 -= r, e.y2 += r, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, $y = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0], n, i, a, s;
  if (r.length === 1)
    n = i = a = s = r[0];
  else if (r.length === 2)
    n = a = r[0], s = i = r[1];
  else if (r.length === 4) {
    var o = Cn(r, 4);
    n = o[0], i = o[1], a = o[2], s = o[3];
  }
  return e.x1 -= s, e.x2 += i, e.y1 -= n, e.y2 += a, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, Eq = function(e, r) {
  e.x1 = r.x1, e.y1 = r.y1, e.x2 = r.x2, e.y2 = r.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1;
}, TR = function(e, r) {
  return !(e.x1 > r.x2 || r.x1 > e.x2 || e.x2 < r.x1 || r.x2 < e.x1 || e.y2 < r.y1 || r.y2 < e.y1 || e.y1 > r.y2 || r.y1 > e.y2);
}, tc = function(e, r, n) {
  return e.x1 <= r && r <= e.x2 && e.y1 <= n && n <= e.y2;
}, Sq = function(e, r) {
  return tc(e, r.x, r.y);
}, Zne = function(e, r) {
  return tc(e, r.x1, r.y1) && tc(e, r.x2, r.y2);
}, ERe = (Wk = Math.hypot) !== null && Wk !== void 0 ? Wk : function(t, e) {
  return Math.sqrt(t * t + e * e);
};
function SRe(t, e) {
  if (t.length < 3)
    throw new Error("Need at least 3 vertices");
  var r = function(k, _) {
    return {
      x: k.x + _.x,
      y: k.y + _.y
    };
  }, n = function(k, _) {
    return {
      x: k.x - _.x,
      y: k.y - _.y
    };
  }, i = function(k, _) {
    return {
      x: k.x * _,
      y: k.y * _
    };
  }, a = function(k, _) {
    return k.x * _.y - k.y * _.x;
  }, s = function(k) {
    var _ = ERe(k.x, k.y);
    return _ === 0 ? {
      x: 0,
      y: 0
    } : {
      x: k.x / _,
      y: k.y / _
    };
  }, o = function(k) {
    for (var _ = 0, R = 0; R < k.length; R++) {
      var L = k[R], M = k[(R + 1) % k.length];
      _ += L.x * M.y - M.x * L.y;
    }
    return _ / 2;
  }, l = function(k, _, R, L) {
    var M = n(_, k), P = n(L, R), C = a(M, P);
    if (Math.abs(C) < 1e-9)
      return r(k, i(M, 0.5));
    var I = a(n(R, k), P) / C;
    return r(k, i(M, I));
  }, u = t.map(function(S) {
    return {
      x: S.x,
      y: S.y
    };
  });
  o(u) < 0 && u.reverse();
  for (var h = u.length, f = [], d = 0; d < h; d++) {
    var p = u[d], g = u[(d + 1) % h], m = n(g, p), v = s({
      x: m.y,
      y: -m.x
    });
    f.push(v);
  }
  for (var y = f.map(function(S, k) {
    var _ = r(u[k], i(S, e)), R = r(u[(k + 1) % h], i(S, e));
    return {
      p1: _,
      p2: R
    };
  }), b = [], x = 0; x < h; x++) {
    var T = y[(x - 1 + h) % h], E = y[x], A = l(T.p1, T.p2, E.p1, E.p2);
    b.push(A);
  }
  return b;
}
function kRe(t, e, r, n, i, a) {
  var s = DRe(t, e, r, n, i), o = SRe(s, a), l = ji();
  return o.forEach(function(u) {
    return Kne(l, u.x, u.y);
  }), l;
}
var Qne = function(e, r, n, i, a, s, o) {
  var l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "auto", u = l === "auto" ? xc(a, s) : l, h = a / 2, f = s / 2;
  u = Math.min(u, h, f);
  var d = u !== h, p = u !== f, g;
  if (d) {
    var m = n - h + u - o, v = i - f - o, y = n + h - u + o, b = v;
    if (g = rc(e, r, n, i, m, v, y, b, !1), g.length > 0)
      return g;
  }
  if (p) {
    var x = n + h + o, T = i - f + u - o, E = x, A = i + f - u + o;
    if (g = rc(e, r, n, i, x, T, E, A, !1), g.length > 0)
      return g;
  }
  if (d) {
    var S = n - h + u - o, k = i + f + o, _ = n + h - u + o, R = k;
    if (g = rc(e, r, n, i, S, k, _, R, !1), g.length > 0)
      return g;
  }
  if (p) {
    var L = n - h - o, M = i - f + u - o, P = L, C = i + f - u + o;
    if (g = rc(e, r, n, i, L, M, P, C, !1), g.length > 0)
      return g;
  }
  var I;
  {
    var N = n - h + u, O = i - f + u;
    if (I = Gp(e, r, n, i, N, O, u + o), I.length > 0 && I[0] <= N && I[1] <= O)
      return [I[0], I[1]];
  }
  {
    var D = n + h - u, $ = i - f + u;
    if (I = Gp(e, r, n, i, D, $, u + o), I.length > 0 && I[0] >= D && I[1] <= $)
      return [I[0], I[1]];
  }
  {
    var z = n + h - u, B = i + f - u;
    if (I = Gp(e, r, n, i, z, B, u + o), I.length > 0 && I[0] >= z && I[1] >= B)
      return [I[0], I[1]];
  }
  {
    var G = n - h + u, W = i + f - u;
    if (I = Gp(e, r, n, i, G, W, u + o), I.length > 0 && I[0] <= G && I[1] >= W)
      return [I[0], I[1]];
  }
  return [];
}, CRe = function(e, r, n, i, a, s, o) {
  var l = o, u = Math.min(n, a), h = Math.max(n, a), f = Math.min(i, s), d = Math.max(i, s);
  return u - l <= e && e <= h + l && f - l <= r && r <= d + l;
}, _Re = function(e, r, n, i, a, s, o, l, u) {
  var h = {
    x1: Math.min(n, o, a) - u,
    x2: Math.max(n, o, a) + u,
    y1: Math.min(i, l, s) - u,
    y2: Math.max(i, l, s) + u
  };
  return !(e < h.x1 || e > h.x2 || r < h.y1 || r > h.y2);
}, ARe = function(e, r, n, i) {
  n -= i;
  var a = r * r - 4 * e * n;
  if (a < 0)
    return [];
  var s = Math.sqrt(a), o = 2 * e, l = (-r + s) / o, u = (-r - s) / o;
  return [l, u];
}, LRe = function(e, r, n, i, a) {
  var s = 1e-5;
  e === 0 && (e = s), r /= e, n /= e, i /= e;
  var o, l, u, h, f, d, p, g;
  if (l = (3 * n - r * r) / 9, u = -(27 * i) + r * (9 * n - 2 * (r * r)), u /= 54, o = l * l * l + u * u, a[1] = 0, p = r / 3, o > 0) {
    f = u + Math.sqrt(o), f = f < 0 ? -Math.pow(-f, 1 / 3) : Math.pow(f, 1 / 3), d = u - Math.sqrt(o), d = d < 0 ? -Math.pow(-d, 1 / 3) : Math.pow(d, 1 / 3), a[0] = -p + f + d, p += (f + d) / 2, a[4] = a[2] = -p, p = Math.sqrt(3) * (-d + f) / 2, a[3] = p, a[5] = -p;
    return;
  }
  if (a[5] = a[3] = 0, o === 0) {
    g = u < 0 ? -Math.pow(-u, 1 / 3) : Math.pow(u, 1 / 3), a[0] = -p + 2 * g, a[4] = a[2] = -(g + p);
    return;
  }
  l = -l, h = l * l * l, h = Math.acos(u / Math.sqrt(h)), g = 2 * Math.sqrt(l), a[0] = -p + g * Math.cos(h / 3), a[2] = -p + g * Math.cos((h + 2 * Math.PI) / 3), a[4] = -p + g * Math.cos((h + 4 * Math.PI) / 3);
}, RRe = function(e, r, n, i, a, s, o, l) {
  var u = 1 * n * n - 4 * n * a + 2 * n * o + 4 * a * a - 4 * a * o + o * o + i * i - 4 * i * s + 2 * i * l + 4 * s * s - 4 * s * l + l * l, h = 9 * n * a - 3 * n * n - 3 * n * o - 6 * a * a + 3 * a * o + 9 * i * s - 3 * i * i - 3 * i * l - 6 * s * s + 3 * s * l, f = 3 * n * n - 6 * n * a + n * o - n * e + 2 * a * a + 2 * a * e - o * e + 3 * i * i - 6 * i * s + i * l - i * r + 2 * s * s + 2 * s * r - l * r, d = 1 * n * a - n * n + n * e - a * e + i * s - i * i + i * r - s * r, p = [];
  LRe(u, h, f, d, p);
  for (var g = 1e-7, m = [], v = 0; v < 6; v += 2)
    Math.abs(p[v + 1]) < g && p[v] >= 0 && p[v] <= 1 && m.push(p[v]);
  m.push(1), m.push(0);
  for (var y = -1, b, x, T, E = 0; E < m.length; E++)
    b = Math.pow(1 - m[E], 2) * n + 2 * (1 - m[E]) * m[E] * a + m[E] * m[E] * o, x = Math.pow(1 - m[E], 2) * i + 2 * (1 - m[E]) * m[E] * s + m[E] * m[E] * l, T = Math.pow(b - e, 2) + Math.pow(x - r, 2), y >= 0 ? T < y && (y = T) : y = T;
  return y;
}, IRe = function(e, r, n, i, a, s) {
  var o = [e - n, r - i], l = [a - n, s - i], u = l[0] * l[0] + l[1] * l[1], h = o[0] * o[0] + o[1] * o[1], f = o[0] * l[0] + o[1] * l[1], d = f * f / u;
  return f < 0 ? h : d > u ? (e - a) * (e - a) + (r - s) * (r - s) : h - d;
}, sa = function(e, r, n) {
  for (var i, a, s, o, l, u = 0, h = 0; h < n.length / 2; h++)
    if (i = n[h * 2], a = n[h * 2 + 1], h + 1 < n.length / 2 ? (s = n[(h + 1) * 2], o = n[(h + 1) * 2 + 1]) : (s = n[(h + 1 - n.length / 2) * 2], o = n[(h + 1 - n.length / 2) * 2 + 1]), !(i == e && s == e)) if (i >= e && e >= s || i <= e && e <= s)
      l = (e - i) / (s - i) * (o - a) + a, l > r && u++;
    else
      continue;
  return u % 2 !== 0;
}, bl = function(e, r, n, i, a, s, o, l, u) {
  var h = new Array(n.length), f;
  l[0] != null ? (f = Math.atan(l[1] / l[0]), l[0] < 0 ? f = f + Math.PI / 2 : f = -f - Math.PI / 2) : f = l;
  for (var d = Math.cos(-f), p = Math.sin(-f), g = 0; g < h.length / 2; g++)
    h[g * 2] = s / 2 * (n[g * 2] * d - n[g * 2 + 1] * p), h[g * 2 + 1] = o / 2 * (n[g * 2 + 1] * d + n[g * 2] * p), h[g * 2] += i, h[g * 2 + 1] += a;
  var m;
  if (u > 0) {
    var v = Ib(h, -u);
    m = Rb(v);
  } else
    m = h;
  return sa(e, r, m);
}, MRe = function(e, r, n, i, a, s, o, l) {
  for (var u = new Array(n.length * 2), h = 0; h < l.length; h++) {
    var f = l[h];
    u[h * 4 + 0] = f.startX, u[h * 4 + 1] = f.startY, u[h * 4 + 2] = f.stopX, u[h * 4 + 3] = f.stopY;
    var d = Math.pow(f.cx - e, 2) + Math.pow(f.cy - r, 2);
    if (d <= Math.pow(f.radius, 2))
      return !0;
  }
  return sa(e, r, u);
}, Rb = function(e) {
  for (var r = new Array(e.length / 2), n, i, a, s, o, l, u, h, f = 0; f < e.length / 4; f++) {
    n = e[f * 4], i = e[f * 4 + 1], a = e[f * 4 + 2], s = e[f * 4 + 3], f < e.length / 4 - 1 ? (o = e[(f + 1) * 4], l = e[(f + 1) * 4 + 1], u = e[(f + 1) * 4 + 2], h = e[(f + 1) * 4 + 3]) : (o = e[0], l = e[1], u = e[2], h = e[3]);
    var d = rc(n, i, a, s, o, l, u, h, !0);
    r[f * 2] = d[0], r[f * 2 + 1] = d[1];
  }
  return r;
}, Ib = function(e, r) {
  for (var n = new Array(e.length * 2), i, a, s, o, l = 0; l < e.length / 2; l++) {
    i = e[l * 2], a = e[l * 2 + 1], l < e.length / 2 - 1 ? (s = e[(l + 1) * 2], o = e[(l + 1) * 2 + 1]) : (s = e[0], o = e[1]);
    var u = o - a, h = -(s - i), f = Math.sqrt(u * u + h * h), d = u / f, p = h / f;
    n[l * 4] = i + d * r, n[l * 4 + 1] = a + p * r, n[l * 4 + 2] = s + d * r, n[l * 4 + 3] = o + p * r;
  }
  return n;
}, NRe = function(e, r, n, i, a, s) {
  var o = n - e, l = i - r;
  o /= a, l /= s;
  var u = Math.sqrt(o * o + l * l), h = u - 1;
  if (h < 0)
    return [];
  var f = h / u;
  return [(n - e) * f + e, (i - r) * f + r];
}, Du = function(e, r, n, i, a, s, o) {
  return e -= a, r -= s, e /= n / 2 + o, r /= i / 2 + o, e * e + r * r <= 1;
}, Gp = function(e, r, n, i, a, s, o) {
  var l = [n - e, i - r], u = [e - a, r - s], h = l[0] * l[0] + l[1] * l[1], f = 2 * (u[0] * l[0] + u[1] * l[1]), d = u[0] * u[0] + u[1] * u[1] - o * o, p = f * f - 4 * h * d;
  if (p < 0)
    return [];
  var g = (-f + Math.sqrt(p)) / (2 * h), m = (-f - Math.sqrt(p)) / (2 * h), v = Math.min(g, m), y = Math.max(g, m), b = [];
  if (v >= 0 && v <= 1 && b.push(v), y >= 0 && y <= 1 && b.push(y), b.length === 0)
    return [];
  var x = b[0] * l[0] + e, T = b[0] * l[1] + r;
  if (b.length > 1) {
    if (b[0] == b[1])
      return [x, T];
    var E = b[1] * l[0] + e, A = b[1] * l[1] + r;
    return [x, T, E, A];
  } else
    return [x, T];
}, Yk = function(e, r, n) {
  return r <= e && e <= n || n <= e && e <= r ? e : e <= r && r <= n || n <= r && r <= e ? r : n;
}, rc = function(e, r, n, i, a, s, o, l, u) {
  var h = e - a, f = n - e, d = o - a, p = r - s, g = i - r, m = l - s, v = d * p - m * h, y = f * p - g * h, b = m * f - d * g;
  if (b !== 0) {
    var x = v / b, T = y / b, E = 1e-3, A = 0 - E, S = 1 + E;
    return A <= x && x <= S && A <= T && T <= S ? [e + x * f, r + x * g] : u ? [e + x * f, r + x * g] : [];
  } else
    return v === 0 || y === 0 ? Yk(e, n, o) === o ? [o, l] : Yk(e, n, a) === a ? [a, s] : Yk(a, o, n) === n ? [n, i] : [] : [];
}, DRe = function(e, r, n, i, a) {
  var s = [], o = i / 2, l = a / 2, u = r, h = n;
  s.push({
    x: u + o * e[0],
    y: h + l * e[1]
  });
  for (var f = 1; f < e.length / 2; f++)
    s.push({
      x: u + o * e[f * 2],
      y: h + l * e[f * 2 + 1]
    });
  return s;
}, C1 = function(e, r, n, i, a, s, o, l) {
  var u = [], h, f = new Array(n.length), d = !0;
  s == null && (d = !1);
  var p;
  if (d) {
    for (var g = 0; g < f.length / 2; g++)
      f[g * 2] = n[g * 2] * s + i, f[g * 2 + 1] = n[g * 2 + 1] * o + a;
    if (l > 0) {
      var m = Ib(f, -l);
      p = Rb(m);
    } else
      p = f;
  } else
    p = n;
  for (var v, y, b, x, T = 0; T < p.length / 2; T++)
    v = p[T * 2], y = p[T * 2 + 1], T < p.length / 2 - 1 ? (b = p[(T + 1) * 2], x = p[(T + 1) * 2 + 1]) : (b = p[0], x = p[1]), h = rc(e, r, i, a, v, y, b, x), h.length !== 0 && u.push(h[0], h[1]);
  return u;
}, ORe = function(e, r, n, i, a, s, o, l, u) {
  var h = [], f, d = new Array(n.length * 2);
  u.forEach(function(b, x) {
    x === 0 ? (d[d.length - 2] = b.startX, d[d.length - 1] = b.startY) : (d[x * 4 - 2] = b.startX, d[x * 4 - 1] = b.startY), d[x * 4] = b.stopX, d[x * 4 + 1] = b.stopY, f = Gp(e, r, i, a, b.cx, b.cy, b.radius), f.length !== 0 && h.push(f[0], f[1]);
  });
  for (var p = 0; p < d.length / 4; p++)
    f = rc(e, r, i, a, d[p * 4], d[p * 4 + 1], d[p * 4 + 2], d[p * 4 + 3], !1), f.length !== 0 && h.push(f[0], f[1]);
  if (h.length > 2) {
    for (var g = [h[0], h[1]], m = Math.pow(g[0] - e, 2) + Math.pow(g[1] - r, 2), v = 1; v < h.length / 2; v++) {
      var y = Math.pow(h[v * 2] - e, 2) + Math.pow(h[v * 2 + 1] - r, 2);
      y <= m && (g[0] = h[v * 2], g[1] = h[v * 2 + 1], m = y);
    }
    return g;
  }
  return h;
}, Lv = function(e, r, n) {
  var i = [e[0] - r[0], e[1] - r[1]], a = Math.sqrt(i[0] * i[0] + i[1] * i[1]), s = (a - n) / a;
  return s < 0 && (s = 1e-5), [r[0] + s * i[0], r[1] + s * i[1]];
}, Bi = function(e, r) {
  var n = fA(e, r);
  return n = Jne(n), n;
}, Jne = function(e) {
  for (var r, n, i = e.length / 2, a = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0, u = 0; u < i; u++)
    r = e[2 * u], n = e[2 * u + 1], a = Math.min(a, r), o = Math.max(o, r), s = Math.min(s, n), l = Math.max(l, n);
  for (var h = 2 / (o - a), f = 2 / (l - s), d = 0; d < i; d++)
    r = e[2 * d] = e[2 * d] * h, n = e[2 * d + 1] = e[2 * d + 1] * f, a = Math.min(a, r), o = Math.max(o, r), s = Math.min(s, n), l = Math.max(l, n);
  if (s < -1)
    for (var p = 0; p < i; p++)
      n = e[2 * p + 1] = e[2 * p + 1] + (-1 - s);
  return e;
}, fA = function(e, r) {
  var n = 1 / e * 2 * Math.PI, i = e % 2 === 0 ? Math.PI / 2 + n / 2 : Math.PI / 2;
  i += r;
  for (var a = new Array(e * 2), s, o = 0; o < e; o++)
    s = o * n + i, a[2 * o] = Math.cos(s), a[2 * o + 1] = Math.sin(-s);
  return a;
}, xc = function(e, r) {
  return Math.min(e / 4, r / 4, 8);
}, eie = function(e, r) {
  return Math.min(e / 10, r / 10, 8);
}, ER = function() {
  return 8;
}, PRe = function(e, r, n) {
  return [e - 2 * r + n, 2 * (r - e), e];
}, dA = function(e, r) {
  return {
    heightOffset: Math.min(15, 0.05 * r),
    widthOffset: Math.min(100, 0.25 * e),
    ctrlPtOffsetPct: 0.05
  };
};
function Xk(t, e) {
  function r(f) {
    for (var d = [], p = 0; p < f.length; p++) {
      var g = f[p], m = f[(p + 1) % f.length], v = {
        x: m.x - g.x,
        y: m.y - g.y
      }, y = {
        x: -v.y,
        y: v.x
      }, b = Math.sqrt(y.x * y.x + y.y * y.y);
      d.push({
        x: y.x / b,
        y: y.y / b
      });
    }
    return d;
  }
  function n(f, d) {
    var p = 1 / 0, g = -1 / 0, m = ca(f), v;
    try {
      for (m.s(); !(v = m.n()).done; ) {
        var y = v.value, b = y.x * d.x + y.y * d.y;
        p = Math.min(p, b), g = Math.max(g, b);
      }
    } catch (x) {
      m.e(x);
    } finally {
      m.f();
    }
    return {
      min: p,
      max: g
    };
  }
  function i(f, d) {
    return !(f.max < d.min || d.max < f.min);
  }
  var a = [].concat(Cb(r(t)), Cb(r(e))), s = ca(a), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var l = o.value, u = n(t, l), h = n(e, l);
      if (!i(u, h))
        return !1;
    }
  } catch (f) {
    s.e(f);
  } finally {
    s.f();
  }
  return !0;
}
var $Re = vi({
  dampingFactor: 0.8,
  precision: 1e-6,
  iterations: 200,
  weight: function(e) {
    return 1;
  }
}), BRe = {
  pageRank: function(e) {
    for (var r = $Re(e), n = r.dampingFactor, i = r.precision, a = r.iterations, s = r.weight, o = this._private.cy, l = this.byGroup(), u = l.nodes, h = l.edges, f = u.length, d = f * f, p = h.length, g = new Array(d), m = new Array(f), v = (1 - n) / f, y = 0; y < f; y++) {
      for (var b = 0; b < f; b++) {
        var x = y * f + b;
        g[x] = 0;
      }
      m[y] = 0;
    }
    for (var T = 0; T < p; T++) {
      var E = h[T], A = E.data("source"), S = E.data("target");
      if (A !== S) {
        var k = u.indexOfId(A), _ = u.indexOfId(S), R = s(E), L = _ * f + k;
        g[L] += R, m[k] += R;
      }
    }
    for (var M = 1 / f + v, P = 0; P < f; P++)
      if (m[P] === 0)
        for (var C = 0; C < f; C++) {
          var I = C * f + P;
          g[I] = M;
        }
      else
        for (var N = 0; N < f; N++) {
          var O = N * f + P;
          g[O] = g[O] / m[P] + v;
        }
    for (var D = new Array(f), $ = new Array(f), z, B = 0; B < f; B++)
      D[B] = 1;
    for (var G = 0; G < a; G++) {
      for (var W = 0; W < f; W++)
        $[W] = 0;
      for (var V = 0; V < f; V++)
        for (var U = 0; U < f; U++) {
          var Z = V * f + U;
          $[V] += g[Z] * D[U];
        }
      yRe($), z = D, D = $, $ = z;
      for (var K = 0, ce = 0; ce < f; ce++) {
        var J = z[ce] - D[ce];
        K += J * J;
      }
      if (K < i)
        break;
    }
    var ee = {
      rank: function(X) {
        return X = o.collection(X)[0], D[u.indexOf(X)];
      }
    };
    return ee;
  }
  // pageRank
}, kq = vi({
  root: null,
  weight: function(e) {
    return 1;
  },
  directed: !1,
  alpha: 0
}), Ff = {
  degreeCentralityNormalized: function(e) {
    e = kq(e);
    var r = this.cy(), n = this.nodes(), i = n.length;
    if (e.directed) {
      for (var h = {}, f = {}, d = 0, p = 0, g = 0; g < i; g++) {
        var m = n[g], v = m.id();
        e.root = m;
        var y = this.degreeCentrality(e);
        d < y.indegree && (d = y.indegree), p < y.outdegree && (p = y.outdegree), h[v] = y.indegree, f[v] = y.outdegree;
      }
      return {
        indegree: function(x) {
          return d == 0 ? 0 : (Pt(x) && (x = r.filter(x)), h[x.id()] / d);
        },
        outdegree: function(x) {
          return p === 0 ? 0 : (Pt(x) && (x = r.filter(x)), f[x.id()] / p);
        }
      };
    } else {
      for (var a = {}, s = 0, o = 0; o < i; o++) {
        var l = n[o];
        e.root = l;
        var u = this.degreeCentrality(e);
        s < u.degree && (s = u.degree), a[l.id()] = u.degree;
      }
      return {
        degree: function(x) {
          return s === 0 ? 0 : (Pt(x) && (x = r.filter(x)), a[x.id()] / s);
        }
      };
    }
  },
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function(e) {
    e = kq(e);
    var r = this.cy(), n = this, i = e, a = i.root, s = i.weight, o = i.directed, l = i.alpha;
    if (a = r.collection(a)[0], o) {
      for (var p = a.connectedEdges(), g = p.filter(function(A) {
        return A.target().same(a) && n.has(A);
      }), m = p.filter(function(A) {
        return A.source().same(a) && n.has(A);
      }), v = g.length, y = m.length, b = 0, x = 0, T = 0; T < g.length; T++)
        b += s(g[T]);
      for (var E = 0; E < m.length; E++)
        x += s(m[E]);
      return {
        indegree: Math.pow(v, 1 - l) * Math.pow(b, l),
        outdegree: Math.pow(y, 1 - l) * Math.pow(x, l)
      };
    } else {
      for (var u = a.connectedEdges().intersection(n), h = u.length, f = 0, d = 0; d < u.length; d++)
        f += s(u[d]);
      return {
        degree: Math.pow(h, 1 - l) * Math.pow(f, l)
      };
    }
  }
  // degreeCentrality
};
Ff.dc = Ff.degreeCentrality;
Ff.dcn = Ff.degreeCentralityNormalised = Ff.degreeCentralityNormalized;
var Cq = vi({
  harmonic: !0,
  weight: function() {
    return 1;
  },
  directed: !1,
  root: null
}), zf = {
  closenessCentralityNormalized: function(e) {
    for (var r = Cq(e), n = r.harmonic, i = r.weight, a = r.directed, s = this.cy(), o = {}, l = 0, u = this.nodes(), h = this.floydWarshall({
      weight: i,
      directed: a
    }), f = 0; f < u.length; f++) {
      for (var d = 0, p = u[f], g = 0; g < u.length; g++)
        if (f !== g) {
          var m = h.distance(p, u[g]);
          n ? d += 1 / m : d += m;
        }
      n || (d = 1 / d), l < d && (l = d), o[p.id()] = d;
    }
    return {
      closeness: function(y) {
        return l == 0 ? 0 : (Pt(y) ? y = s.filter(y)[0].id() : y = y.id(), o[y] / l);
      }
    };
  },
  // Implemented from pseudocode from wikipedia
  closenessCentrality: function(e) {
    var r = Cq(e), n = r.root, i = r.weight, a = r.directed, s = r.harmonic;
    n = this.filter(n)[0];
    for (var o = this.dijkstra({
      root: n,
      weight: i,
      directed: a
    }), l = 0, u = this.nodes(), h = 0; h < u.length; h++) {
      var f = u[h];
      if (!f.same(n)) {
        var d = o.distanceTo(f);
        s ? l += 1 / d : l += d;
      }
    }
    return s ? l : 1 / l;
  }
  // closenessCentrality
};
zf.cc = zf.closenessCentrality;
zf.ccn = zf.closenessCentralityNormalised = zf.closenessCentralityNormalized;
var FRe = vi({
  weight: null,
  directed: !1
}), pA = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function(e) {
    for (var r = FRe(e), n = r.directed, i = r.weight, a = i != null, s = this.cy(), o = this.nodes(), l = {}, u = {}, h = 0, f = {
      set: function(x, T) {
        u[x] = T, T > h && (h = T);
      },
      get: function(x) {
        return u[x];
      }
    }, d = 0; d < o.length; d++) {
      var p = o[d], g = p.id();
      n ? l[g] = p.outgoers().nodes() : l[g] = p.openNeighborhood().nodes(), f.set(g, 0);
    }
    for (var m = function() {
      for (var x = o[v].id(), T = [], E = {}, A = {}, S = {}, k = new Sm(function(V, U) {
        return S[V] - S[U];
      }), _ = 0; _ < o.length; _++) {
        var R = o[_].id();
        E[R] = [], A[R] = 0, S[R] = 1 / 0;
      }
      for (A[x] = 1, S[x] = 0, k.push(x); !k.empty(); ) {
        var L = k.pop();
        if (T.push(L), a)
          for (var M = 0; M < l[L].length; M++) {
            var P = l[L][M], C = s.getElementById(L), I = void 0;
            C.edgesTo(P).length > 0 ? I = C.edgesTo(P)[0] : I = P.edgesTo(C)[0];
            var N = i(I);
            P = P.id(), S[P] > S[L] + N && (S[P] = S[L] + N, k.nodes.indexOf(P) < 0 ? k.push(P) : k.updateItem(P), A[P] = 0, E[P] = []), S[P] == S[L] + N && (A[P] = A[P] + A[L], E[P].push(L));
          }
        else
          for (var O = 0; O < l[L].length; O++) {
            var D = l[L][O].id();
            S[D] == 1 / 0 && (k.push(D), S[D] = S[L] + 1), S[D] == S[L] + 1 && (A[D] = A[D] + A[L], E[D].push(L));
          }
      }
      for (var $ = {}, z = 0; z < o.length; z++)
        $[o[z].id()] = 0;
      for (; T.length > 0; ) {
        for (var B = T.pop(), G = 0; G < E[B].length; G++) {
          var W = E[B][G];
          $[W] = $[W] + A[W] / A[B] * (1 + $[B]);
        }
        B != o[v].id() && f.set(B, f.get(B) + $[B]);
      }
    }, v = 0; v < o.length; v++)
      m();
    var y = {
      betweenness: function(x) {
        var T = s.collection(x).id();
        return f.get(T);
      },
      betweennessNormalized: function(x) {
        if (h == 0)
          return 0;
        var T = s.collection(x).id();
        return f.get(T) / h;
      }
    };
    return y.betweennessNormalised = y.betweennessNormalized, y;
  }
  // betweennessCentrality
};
pA.bc = pA.betweennessCentrality;
var zRe = vi({
  expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
  inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
  multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
  maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
  attributes: [
    // attributes/features used to group nodes, ie. similarity values between nodes
    function(t) {
      return 1;
    }
  ]
}), qRe = function(e) {
  return zRe(e);
}, GRe = function(e, r) {
  for (var n = 0, i = 0; i < r.length; i++)
    n += r[i](e);
  return n;
}, URe = function(e, r, n) {
  for (var i = 0; i < r; i++)
    e[i * r + i] = n;
}, tie = function(e, r) {
  for (var n, i = 0; i < r; i++) {
    n = 0;
    for (var a = 0; a < r; a++)
      n += e[a * r + i];
    for (var s = 0; s < r; s++)
      e[s * r + i] = e[s * r + i] / n;
  }
}, VRe = function(e, r, n) {
  for (var i = new Array(n * n), a = 0; a < n; a++) {
    for (var s = 0; s < n; s++)
      i[a * n + s] = 0;
    for (var o = 0; o < n; o++)
      for (var l = 0; l < n; l++)
        i[a * n + l] += e[a * n + o] * r[o * n + l];
  }
  return i;
}, HRe = function(e, r, n) {
  for (var i = e.slice(0), a = 1; a < n; a++)
    e = VRe(e, i, r);
  return e;
}, WRe = function(e, r, n) {
  for (var i = new Array(r * r), a = 0; a < r * r; a++)
    i[a] = Math.pow(e[a], n);
  return tie(i, r), i;
}, YRe = function(e, r, n, i) {
  for (var a = 0; a < n; a++) {
    var s = Math.round(e[a] * Math.pow(10, i)) / Math.pow(10, i), o = Math.round(r[a] * Math.pow(10, i)) / Math.pow(10, i);
    if (s !== o)
      return !1;
  }
  return !0;
}, XRe = function(e, r, n, i) {
  for (var a = [], s = 0; s < r; s++) {
    for (var o = [], l = 0; l < r; l++)
      Math.round(e[s * r + l] * 1e3) / 1e3 > 0 && o.push(n[l]);
    o.length !== 0 && a.push(i.collection(o));
  }
  return a;
}, jRe = function(e, r) {
  for (var n = 0; n < e.length; n++)
    if (!r[n] || e[n].id() !== r[n].id())
      return !1;
  return !0;
}, KRe = function(e) {
  for (var r = 0; r < e.length; r++)
    for (var n = 0; n < e.length; n++)
      r != n && jRe(e[r], e[n]) && e.splice(n, 1);
  return e;
}, _q = function(e) {
  for (var r = this.nodes(), n = this.edges(), i = this.cy(), a = qRe(e), s = {}, o = 0; o < r.length; o++)
    s[r[o].id()] = o;
  for (var l = r.length, u = l * l, h = new Array(u), f, d = 0; d < u; d++)
    h[d] = 0;
  for (var p = 0; p < n.length; p++) {
    var g = n[p], m = s[g.source().id()], v = s[g.target().id()], y = GRe(g, a.attributes);
    h[m * l + v] += y, h[v * l + m] += y;
  }
  URe(h, l, a.multFactor), tie(h, l);
  for (var b = !0, x = 0; b && x < a.maxIterations; )
    b = !1, f = HRe(h, l, a.expandFactor), h = WRe(f, l, a.inflateFactor), YRe(h, f, u, 4) || (b = !0), x++;
  var T = XRe(h, l, r, i);
  return T = KRe(T), T;
}, ZRe = {
  markovClustering: _q,
  mcl: _q
}, QRe = function(e) {
  return e;
}, rie = function(e, r) {
  return Math.abs(r - e);
}, Aq = function(e, r, n) {
  return e + rie(r, n);
}, Lq = function(e, r, n) {
  return e + Math.pow(n - r, 2);
}, JRe = function(e) {
  return Math.sqrt(e);
}, eIe = function(e, r, n) {
  return Math.max(e, rie(r, n));
}, pp = function(e, r, n, i, a) {
  for (var s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : QRe, o = i, l, u, h = 0; h < e; h++)
    l = r(h), u = n(h), o = a(o, l, u);
  return s(o);
}, h0 = {
  euclidean: function(e, r, n) {
    return e >= 2 ? pp(e, r, n, 0, Lq, JRe) : pp(e, r, n, 0, Aq);
  },
  squaredEuclidean: function(e, r, n) {
    return pp(e, r, n, 0, Lq);
  },
  manhattan: function(e, r, n) {
    return pp(e, r, n, 0, Aq);
  },
  max: function(e, r, n) {
    return pp(e, r, n, -1 / 0, eIe);
  }
};
h0["squared-euclidean"] = h0.squaredEuclidean;
h0.squaredeuclidean = h0.squaredEuclidean;
function Z4(t, e, r, n, i, a) {
  var s;
  return ln(t) ? s = t : s = h0[t] || h0.euclidean, e === 0 && ln(t) ? s(i, a) : s(e, r, n, i, a);
}
var tIe = vi({
  k: 2,
  m: 2,
  sensitivityThreshold: 1e-4,
  distance: "euclidean",
  maxIterations: 10,
  attributes: [],
  testMode: !1,
  testCentroids: null
}), SR = function(e) {
  return tIe(e);
}, Mb = function(e, r, n, i, a) {
  var s = a !== "kMedoids", o = s ? function(f) {
    return n[f];
  } : function(f) {
    return i[f](n);
  }, l = function(d) {
    return i[d](r);
  }, u = n, h = r;
  return Z4(e, i.length, o, l, u, h);
}, jk = function(e, r, n) {
  for (var i = n.length, a = new Array(i), s = new Array(i), o = new Array(r), l = null, u = 0; u < i; u++)
    a[u] = e.min(n[u]).value, s[u] = e.max(n[u]).value;
  for (var h = 0; h < r; h++) {
    l = [];
    for (var f = 0; f < i; f++)
      l[f] = Math.random() * (s[f] - a[f]) + a[f];
    o[h] = l;
  }
  return o;
}, nie = function(e, r, n, i, a) {
  for (var s = 1 / 0, o = 0, l = 0; l < r.length; l++) {
    var u = Mb(n, e, r[l], i, a);
    u < s && (s = u, o = l);
  }
  return o;
}, iie = function(e, r, n) {
  for (var i = [], a = null, s = 0; s < r.length; s++)
    a = r[s], n[a.id()] === e && i.push(a);
  return i;
}, rIe = function(e, r, n) {
  return Math.abs(r - e) <= n;
}, nIe = function(e, r, n) {
  for (var i = 0; i < e.length; i++)
    for (var a = 0; a < e[i].length; a++) {
      var s = Math.abs(e[i][a] - r[i][a]);
      if (s > n)
        return !1;
    }
  return !0;
}, iIe = function(e, r, n) {
  for (var i = 0; i < n; i++)
    if (e === r[i]) return !0;
  return !1;
}, Rq = function(e, r) {
  var n = new Array(r);
  if (e.length < 50)
    for (var i = 0; i < r; i++) {
      for (var a = e[Math.floor(Math.random() * e.length)]; iIe(a, n, i); )
        a = e[Math.floor(Math.random() * e.length)];
      n[i] = a;
    }
  else
    for (var s = 0; s < r; s++)
      n[s] = e[Math.floor(Math.random() * e.length)];
  return n;
}, Iq = function(e, r, n) {
  for (var i = 0, a = 0; a < r.length; a++)
    i += Mb("manhattan", r[a], e, n, "kMedoids");
  return i;
}, aIe = function(e) {
  var r = this.cy(), n = this.nodes(), i = null, a = SR(e), s = new Array(a.k), o = {}, l;
  a.testMode ? typeof a.testCentroids == "number" ? (a.testCentroids, l = jk(n, a.k, a.attributes)) : Vn(a.testCentroids) === "object" ? l = a.testCentroids : l = jk(n, a.k, a.attributes) : l = jk(n, a.k, a.attributes);
  for (var u = !0, h = 0; u && h < a.maxIterations; ) {
    for (var f = 0; f < n.length; f++)
      i = n[f], o[i.id()] = nie(i, l, a.distance, a.attributes, "kMeans");
    u = !1;
    for (var d = 0; d < a.k; d++) {
      var p = iie(d, n, o);
      if (p.length !== 0) {
        for (var g = a.attributes.length, m = l[d], v = new Array(g), y = new Array(g), b = 0; b < g; b++) {
          y[b] = 0;
          for (var x = 0; x < p.length; x++)
            i = p[x], y[b] += a.attributes[b](i);
          v[b] = y[b] / p.length, rIe(v[b], m[b], a.sensitivityThreshold) || (u = !0);
        }
        l[d] = v, s[d] = r.collection(p);
      }
    }
    h++;
  }
  return s;
}, sIe = function(e) {
  var r = this.cy(), n = this.nodes(), i = null, a = SR(e), s = new Array(a.k), o, l = {}, u, h = new Array(a.k);
  a.testMode ? typeof a.testCentroids == "number" || (Vn(a.testCentroids) === "object" ? o = a.testCentroids : o = Rq(n, a.k)) : o = Rq(n, a.k);
  for (var f = !0, d = 0; f && d < a.maxIterations; ) {
    for (var p = 0; p < n.length; p++)
      i = n[p], l[i.id()] = nie(i, o, a.distance, a.attributes, "kMedoids");
    f = !1;
    for (var g = 0; g < o.length; g++) {
      var m = iie(g, n, l);
      if (m.length !== 0) {
        h[g] = Iq(o[g], m, a.attributes);
        for (var v = 0; v < m.length; v++)
          u = Iq(m[v], m, a.attributes), u < h[g] && (h[g] = u, o[g] = m[v], f = !0);
        s[g] = r.collection(m);
      }
    }
    d++;
  }
  return s;
}, oIe = function(e, r, n, i, a) {
  for (var s, o, l = 0; l < r.length; l++)
    for (var u = 0; u < e.length; u++)
      i[l][u] = Math.pow(n[l][u], a.m);
  for (var h = 0; h < e.length; h++)
    for (var f = 0; f < a.attributes.length; f++) {
      s = 0, o = 0;
      for (var d = 0; d < r.length; d++)
        s += i[d][h] * a.attributes[f](r[d]), o += i[d][h];
      e[h][f] = s / o;
    }
}, lIe = function(e, r, n, i, a) {
  for (var s = 0; s < e.length; s++)
    r[s] = e[s].slice();
  for (var o, l, u, h = 2 / (a.m - 1), f = 0; f < n.length; f++)
    for (var d = 0; d < i.length; d++) {
      o = 0;
      for (var p = 0; p < n.length; p++)
        l = Mb(a.distance, i[d], n[f], a.attributes, "cmeans"), u = Mb(a.distance, i[d], n[p], a.attributes, "cmeans"), o += Math.pow(l / u, h);
      e[d][f] = 1 / o;
    }
}, cIe = function(e, r, n, i) {
  for (var a = new Array(n.k), s = 0; s < a.length; s++)
    a[s] = [];
  for (var o, l, u = 0; u < r.length; u++) {
    o = -1 / 0, l = -1;
    for (var h = 0; h < r[0].length; h++)
      r[u][h] > o && (o = r[u][h], l = h);
    a[l].push(e[u]);
  }
  for (var f = 0; f < a.length; f++)
    a[f] = i.collection(a[f]);
  return a;
}, Mq = function(e) {
  var r = this.cy(), n = this.nodes(), i = SR(e), a, s, o, l, u;
  l = new Array(n.length);
  for (var h = 0; h < n.length; h++)
    l[h] = new Array(i.k);
  o = new Array(n.length);
  for (var f = 0; f < n.length; f++)
    o[f] = new Array(i.k);
  for (var d = 0; d < n.length; d++) {
    for (var p = 0, g = 0; g < i.k; g++)
      o[d][g] = Math.random(), p += o[d][g];
    for (var m = 0; m < i.k; m++)
      o[d][m] = o[d][m] / p;
  }
  s = new Array(i.k);
  for (var v = 0; v < i.k; v++)
    s[v] = new Array(i.attributes.length);
  u = new Array(n.length);
  for (var y = 0; y < n.length; y++)
    u[y] = new Array(i.k);
  for (var b = !0, x = 0; b && x < i.maxIterations; )
    b = !1, oIe(s, n, o, u, i), lIe(o, l, s, n, i), nIe(o, l, i.sensitivityThreshold) || (b = !0), x++;
  return a = cIe(n, o, i, r), {
    clusters: a,
    degreeOfMembership: o
  };
}, uIe = {
  kMeans: aIe,
  kMedoids: sIe,
  fuzzyCMeans: Mq,
  fcm: Mq
}, hIe = vi({
  distance: "euclidean",
  // distance metric to compare nodes
  linkage: "min",
  // linkage criterion : how to determine the distance between clusters of nodes
  mode: "threshold",
  // mode:'threshold' => clusters must be threshold distance apart
  threshold: 1 / 0,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
  addDendrogram: !1,
  // whether to add the dendrogram to the graph for viz
  dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
  attributes: []
  // array of attr functions
}), fIe = {
  single: "min",
  complete: "max"
}, dIe = function(e) {
  var r = hIe(e), n = fIe[r.linkage];
  return n != null && (r.linkage = n), r;
}, Nq = function(e, r, n, i, a) {
  for (var s = 0, o = 1 / 0, l, u = a.attributes, h = function(_, R) {
    return Z4(a.distance, u.length, function(L) {
      return u[L](_);
    }, function(L) {
      return u[L](R);
    }, _, R);
  }, f = 0; f < e.length; f++) {
    var d = e[f].key, p = n[d][i[d]];
    p < o && (s = d, o = p);
  }
  if (a.mode === "threshold" && o >= a.threshold || a.mode === "dendrogram" && e.length === 1)
    return !1;
  var g = r[s], m = r[i[s]], v;
  a.mode === "dendrogram" ? v = {
    left: g,
    right: m,
    key: g.key
  } : v = {
    value: g.value.concat(m.value),
    key: g.key
  }, e[g.index] = v, e.splice(m.index, 1), r[g.key] = v;
  for (var y = 0; y < e.length; y++) {
    var b = e[y];
    g.key === b.key ? l = 1 / 0 : a.linkage === "min" ? (l = n[g.key][b.key], n[g.key][b.key] > n[m.key][b.key] && (l = n[m.key][b.key])) : a.linkage === "max" ? (l = n[g.key][b.key], n[g.key][b.key] < n[m.key][b.key] && (l = n[m.key][b.key])) : a.linkage === "mean" ? l = (n[g.key][b.key] * g.size + n[m.key][b.key] * m.size) / (g.size + m.size) : a.mode === "dendrogram" ? l = h(b.value, g.value) : l = h(b.value[0], g.value[0]), n[g.key][b.key] = n[b.key][g.key] = l;
  }
  for (var x = 0; x < e.length; x++) {
    var T = e[x].key;
    if (i[T] === g.key || i[T] === m.key) {
      for (var E = T, A = 0; A < e.length; A++) {
        var S = e[A].key;
        n[T][S] < n[T][E] && (E = S);
      }
      i[T] = E;
    }
    e[x].index = x;
  }
  return g.key = m.key = g.index = m.index = null, !0;
}, kf = function(e, r, n) {
  e && (e.value ? r.push(e.value) : (e.left && kf(e.left, r), e.right && kf(e.right, r)));
}, gA = function(e, r) {
  if (!e) return "";
  if (e.left && e.right) {
    var n = gA(e.left, r), i = gA(e.right, r), a = r.add({
      group: "nodes",
      data: {
        id: n + "," + i
      }
    });
    return r.add({
      group: "edges",
      data: {
        source: n,
        target: a.id()
      }
    }), r.add({
      group: "edges",
      data: {
        source: i,
        target: a.id()
      }
    }), a.id();
  } else if (e.value)
    return e.value.id();
}, mA = function(e, r, n) {
  if (!e) return [];
  var i = [], a = [], s = [];
  return r === 0 ? (e.left && kf(e.left, i), e.right && kf(e.right, a), s = i.concat(a), [n.collection(s)]) : r === 1 ? e.value ? [n.collection(e.value)] : (e.left && kf(e.left, i), e.right && kf(e.right, a), [n.collection(i), n.collection(a)]) : e.value ? [n.collection(e.value)] : (e.left && (i = mA(e.left, r - 1, n)), e.right && (a = mA(e.right, r - 1, n)), i.concat(a));
}, Dq = function(e) {
  for (var r = this.cy(), n = this.nodes(), i = dIe(e), a = i.attributes, s = function(x, T) {
    return Z4(i.distance, a.length, function(E) {
      return a[E](x);
    }, function(E) {
      return a[E](T);
    }, x, T);
  }, o = [], l = [], u = [], h = [], f = 0; f < n.length; f++) {
    var d = {
      value: i.mode === "dendrogram" ? n[f] : [n[f]],
      key: f,
      index: f
    };
    o[f] = d, h[f] = d, l[f] = [], u[f] = 0;
  }
  for (var p = 0; p < o.length; p++)
    for (var g = 0; g <= p; g++) {
      var m = void 0;
      i.mode === "dendrogram" ? m = p === g ? 1 / 0 : s(o[p].value, o[g].value) : m = p === g ? 1 / 0 : s(o[p].value[0], o[g].value[0]), l[p][g] = m, l[g][p] = m, m < l[p][u[p]] && (u[p] = g);
    }
  for (var v = Nq(o, h, l, u, i); v; )
    v = Nq(o, h, l, u, i);
  var y;
  return i.mode === "dendrogram" ? (y = mA(o[0], i.dendrogramDepth, r), i.addDendrogram && gA(o[0], r)) : (y = new Array(o.length), o.forEach(function(b, x) {
    b.key = b.index = null, y[x] = r.collection(b.value);
  })), y;
}, pIe = {
  hierarchicalClustering: Dq,
  hca: Dq
}, gIe = vi({
  distance: "euclidean",
  // distance metric to compare attributes between two nodes
  preference: "median",
  // suitability of a data point to serve as an exemplar
  damping: 0.8,
  // damping factor between [0.5, 1)
  maxIterations: 1e3,
  // max number of iterations to run
  minIterations: 100,
  // min number of iterations to run in order for clustering to stop
  attributes: [
    // functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
  ]
}), mIe = function(e) {
  var r = e.damping, n = e.preference;
  0.5 <= r && r < 1 || Jr("Damping must range on [0.5, 1).  Got: ".concat(r));
  var i = ["median", "mean", "min", "max"];
  return i.some(function(a) {
    return a === n;
  }) || mt(n) || Jr("Preference must be one of [".concat(i.map(function(a) {
    return "'".concat(a, "'");
  }).join(", "), "] or a number.  Got: ").concat(n)), gIe(e);
}, vIe = function(e, r, n, i) {
  var a = function(o, l) {
    return i[l](o);
  };
  return -Z4(e, i.length, function(s) {
    return a(r, s);
  }, function(s) {
    return a(n, s);
  }, r, n);
}, yIe = function(e, r) {
  var n = null;
  return r === "median" ? n = mRe(e) : r === "mean" ? n = gRe(e) : r === "min" ? n = dRe(e) : r === "max" ? n = pRe(e) : n = r, n;
}, bIe = function(e, r, n) {
  for (var i = [], a = 0; a < e; a++)
    r[a * e + a] + n[a * e + a] > 0 && i.push(a);
  return i;
}, Oq = function(e, r, n) {
  for (var i = [], a = 0; a < e; a++) {
    for (var s = -1, o = -1 / 0, l = 0; l < n.length; l++) {
      var u = n[l];
      r[a * e + u] > o && (s = u, o = r[a * e + u]);
    }
    s > 0 && i.push(s);
  }
  for (var h = 0; h < n.length; h++)
    i[n[h]] = n[h];
  return i;
}, xIe = function(e, r, n) {
  for (var i = Oq(e, r, n), a = 0; a < n.length; a++) {
    for (var s = [], o = 0; o < i.length; o++)
      i[o] === n[a] && s.push(o);
    for (var l = -1, u = -1 / 0, h = 0; h < s.length; h++) {
      for (var f = 0, d = 0; d < s.length; d++)
        f += r[s[d] * e + s[h]];
      f > u && (l = h, u = f);
    }
    n[a] = s[l];
  }
  return i = Oq(e, r, n), i;
}, Pq = function(e) {
  for (var r = this.cy(), n = this.nodes(), i = mIe(e), a = {}, s = 0; s < n.length; s++)
    a[n[s].id()] = s;
  var o, l, u, h, f, d;
  o = n.length, l = o * o, u = new Array(l);
  for (var p = 0; p < l; p++)
    u[p] = -1 / 0;
  for (var g = 0; g < o; g++)
    for (var m = 0; m < o; m++)
      g !== m && (u[g * o + m] = vIe(i.distance, n[g], n[m], i.attributes));
  h = yIe(u, i.preference);
  for (var v = 0; v < o; v++)
    u[v * o + v] = h;
  f = new Array(l);
  for (var y = 0; y < l; y++)
    f[y] = 0;
  d = new Array(l);
  for (var b = 0; b < l; b++)
    d[b] = 0;
  for (var x = new Array(o), T = new Array(o), E = new Array(o), A = 0; A < o; A++)
    x[A] = 0, T[A] = 0, E[A] = 0;
  for (var S = new Array(o * i.minIterations), k = 0; k < S.length; k++)
    S[k] = 0;
  var _;
  for (_ = 0; _ < i.maxIterations; _++) {
    for (var R = 0; R < o; R++) {
      for (var L = -1 / 0, M = -1 / 0, P = -1, C = 0, I = 0; I < o; I++)
        x[I] = f[R * o + I], C = d[R * o + I] + u[R * o + I], C >= L ? (M = L, L = C, P = I) : C > M && (M = C);
      for (var N = 0; N < o; N++)
        f[R * o + N] = (1 - i.damping) * (u[R * o + N] - L) + i.damping * x[N];
      f[R * o + P] = (1 - i.damping) * (u[R * o + P] - M) + i.damping * x[P];
    }
    for (var O = 0; O < o; O++) {
      for (var D = 0, $ = 0; $ < o; $++)
        x[$] = d[$ * o + O], T[$] = Math.max(0, f[$ * o + O]), D += T[$];
      D -= T[O], T[O] = f[O * o + O], D += T[O];
      for (var z = 0; z < o; z++)
        d[z * o + O] = (1 - i.damping) * Math.min(0, D - T[z]) + i.damping * x[z];
      d[O * o + O] = (1 - i.damping) * (D - T[O]) + i.damping * x[O];
    }
    for (var B = 0, G = 0; G < o; G++) {
      var W = d[G * o + G] + f[G * o + G] > 0 ? 1 : 0;
      S[_ % i.minIterations * o + G] = W, B += W;
    }
    if (B > 0 && (_ >= i.minIterations - 1 || _ == i.maxIterations - 1)) {
      for (var V = 0, U = 0; U < o; U++) {
        E[U] = 0;
        for (var Z = 0; Z < i.minIterations; Z++)
          E[U] += S[Z * o + U];
        (E[U] === 0 || E[U] === i.minIterations) && V++;
      }
      if (V === o)
        break;
    }
  }
  for (var K = bIe(o, f, d), ce = xIe(o, u, K), J = {}, ee = 0; ee < K.length; ee++)
    J[K[ee]] = [];
  for (var j = 0; j < n.length; j++) {
    var X = a[n[j].id()], re = ce[X];
    re != null && J[re].push(n[j]);
  }
  for (var Q = new Array(K.length), ue = 0; ue < K.length; ue++)
    Q[ue] = r.collection(J[K[ue]]);
  return Q;
}, wIe = {
  affinityPropagation: Pq,
  ap: Pq
}, TIe = vi({
  root: void 0,
  directed: !1
}), EIe = {
  hierholzer: function(e) {
    if (!yr(e)) {
      var r = arguments;
      e = {
        root: r[0],
        directed: r[1]
      };
    }
    var n = TIe(e), i = n.root, a = n.directed, s = this, o = !1, l, u, h;
    i && (h = Pt(i) ? this.filter(i)[0].id() : i[0].id());
    var f = {}, d = {};
    a ? s.forEach(function(b) {
      var x = b.id();
      if (b.isNode()) {
        var T = b.indegree(!0), E = b.outdegree(!0), A = T - E, S = E - T;
        A == 1 ? l ? o = !0 : l = x : S == 1 ? u ? o = !0 : u = x : (S > 1 || A > 1) && (o = !0), f[x] = [], b.outgoers().forEach(function(k) {
          k.isEdge() && f[x].push(k.id());
        });
      } else
        d[x] = [void 0, b.target().id()];
    }) : s.forEach(function(b) {
      var x = b.id();
      if (b.isNode()) {
        var T = b.degree(!0);
        T % 2 && (l ? u ? o = !0 : u = x : l = x), f[x] = [], b.connectedEdges().forEach(function(E) {
          return f[x].push(E.id());
        });
      } else
        d[x] = [b.source().id(), b.target().id()];
    });
    var p = {
      found: !1,
      trail: void 0
    };
    if (o) return p;
    if (u && l)
      if (a) {
        if (h && u != h)
          return p;
        h = u;
      } else {
        if (h && u != h && l != h)
          return p;
        h || (h = u);
      }
    else
      h || (h = s[0].id());
    var g = function(x) {
      for (var T = x, E = [x], A, S, k; f[T].length; )
        A = f[T].shift(), S = d[A][0], k = d[A][1], T != k ? (f[k] = f[k].filter(function(_) {
          return _ != A;
        }), T = k) : !a && T != S && (f[S] = f[S].filter(function(_) {
          return _ != A;
        }), T = S), E.unshift(A), E.unshift(T);
      return E;
    }, m = [], v = [];
    for (v = g(h); v.length != 1; )
      f[v[0]].length == 0 ? (m.unshift(s.getElementById(v.shift())), m.unshift(s.getElementById(v.shift()))) : v = g(v.shift()).concat(v);
    m.unshift(s.getElementById(v.shift()));
    for (var y in f)
      if (f[y].length)
        return p;
    return p.found = !0, p.trail = this.spawn(m, !0), p;
  }
}, Rv = function() {
  var e = this, r = {}, n = 0, i = 0, a = [], s = [], o = {}, l = function(d, p) {
    for (var g = s.length - 1, m = [], v = e.spawn(); s[g].x != d || s[g].y != p; )
      m.push(s.pop().edge), g--;
    m.push(s.pop().edge), m.forEach(function(y) {
      var b = y.connectedNodes().intersection(e);
      v.merge(y), b.forEach(function(x) {
        var T = x.id(), E = x.connectedEdges().intersection(e);
        v.merge(x), r[T].cutVertex ? v.merge(E.filter(function(A) {
          return A.isLoop();
        })) : v.merge(E);
      });
    }), a.push(v);
  }, u = function(d, p, g) {
    d === g && (i += 1), r[p] = {
      id: n,
      low: n++,
      cutVertex: !1
    };
    var m = e.getElementById(p).connectedEdges().intersection(e);
    if (m.size() === 0)
      a.push(e.spawn(e.getElementById(p)));
    else {
      var v, y, b, x;
      m.forEach(function(T) {
        v = T.source().id(), y = T.target().id(), b = v === p ? y : v, b !== g && (x = T.id(), o[x] || (o[x] = !0, s.push({
          x: p,
          y: b,
          edge: T
        })), b in r ? r[p].low = Math.min(r[p].low, r[b].id) : (u(d, b, p), r[p].low = Math.min(r[p].low, r[b].low), r[p].id <= r[b].low && (r[p].cutVertex = !0, l(p, b))));
      });
    }
  };
  e.forEach(function(f) {
    if (f.isNode()) {
      var d = f.id();
      d in r || (i = 0, u(d, d), r[d].cutVertex = i > 1);
    }
  });
  var h = Object.keys(r).filter(function(f) {
    return r[f].cutVertex;
  }).map(function(f) {
    return e.getElementById(f);
  });
  return {
    cut: e.spawn(h),
    components: a
  };
}, SIe = {
  hopcroftTarjanBiconnected: Rv,
  htbc: Rv,
  htb: Rv,
  hopcroftTarjanBiconnectedComponents: Rv
}, Iv = function() {
  var e = this, r = {}, n = 0, i = [], a = [], s = e.spawn(e), o = function(u) {
    a.push(u), r[u] = {
      index: n,
      low: n++,
      explored: !1
    };
    var h = e.getElementById(u).connectedEdges().intersection(e);
    if (h.forEach(function(m) {
      var v = m.target().id();
      v !== u && (v in r || o(v), r[v].explored || (r[u].low = Math.min(r[u].low, r[v].low)));
    }), r[u].index === r[u].low) {
      for (var f = e.spawn(); ; ) {
        var d = a.pop();
        if (f.merge(e.getElementById(d)), r[d].low = r[u].index, r[d].explored = !0, d === u)
          break;
      }
      var p = f.edgesWith(f), g = f.merge(p);
      i.push(g), s = s.difference(g);
    }
  };
  return e.forEach(function(l) {
    if (l.isNode()) {
      var u = l.id();
      u in r || o(u);
    }
  }), {
    cut: s,
    components: i
  };
}, kIe = {
  tarjanStronglyConnected: Iv,
  tsc: Iv,
  tscc: Iv,
  tarjanStronglyConnectedComponents: Iv
}, aie = {};
[S1, tRe, rRe, iRe, sRe, lRe, hRe, BRe, Ff, zf, pA, ZRe, uIe, pIe, wIe, EIe, SIe, kIe].forEach(function(t) {
  Ut(aie, t);
});
/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/
var sie = 0, oie = 1, lie = 2, Ns = function(e) {
  if (!(this instanceof Ns)) return new Ns(e);
  this.id = "Thenable/1.0.7", this.state = sie, this.fulfillValue = void 0, this.rejectReason = void 0, this.onFulfilled = [], this.onRejected = [], this.proxy = {
    then: this.then.bind(this)
  }, typeof e == "function" && e.call(this, this.fulfill.bind(this), this.reject.bind(this));
};
Ns.prototype = {
  /*  promise resolving methods  */
  fulfill: function(e) {
    return $q(this, oie, "fulfillValue", e);
  },
  reject: function(e) {
    return $q(this, lie, "rejectReason", e);
  },
  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function(e, r) {
    var n = this, i = new Ns();
    return n.onFulfilled.push(Fq(e, i, "fulfill")), n.onRejected.push(Fq(r, i, "reject")), cie(n), i.proxy;
  }
};
var $q = function(e, r, n, i) {
  return e.state === sie && (e.state = r, e[n] = i, cie(e)), e;
}, cie = function(e) {
  e.state === oie ? Bq(e, "onFulfilled", e.fulfillValue) : e.state === lie && Bq(e, "onRejected", e.rejectReason);
}, Bq = function(e, r, n) {
  if (e[r].length !== 0) {
    var i = e[r];
    e[r] = [];
    var a = function() {
      for (var o = 0; o < i.length; o++) i[o](n);
    };
    typeof setImmediate == "function" ? setImmediate(a) : setTimeout(a, 0);
  }
}, Fq = function(e, r, n) {
  return function(i) {
    if (typeof e != "function")
      r[n].call(r, i);
    else {
      var a;
      try {
        a = e(i);
      } catch (s) {
        r.reject(s);
        return;
      }
      uie(r, a);
    }
  };
}, uie = function(e, r) {
  if (e === r || e.proxy === r) {
    e.reject(new TypeError("cannot resolve promise with itself"));
    return;
  }
  var n;
  if (Vn(r) === "object" && r !== null || typeof r == "function")
    try {
      n = r.then;
    } catch (a) {
      e.reject(a);
      return;
    }
  if (typeof n == "function") {
    var i = !1;
    try {
      n.call(
        r,
        /*  resolvePromise  */
        /*  [Promises/A+ 2.3.3.3.1]  */
        function(a) {
          i || (i = !0, a === r ? e.reject(new TypeError("circular thenable chain")) : uie(e, a));
        },
        /*  rejectPromise  */
        /*  [Promises/A+ 2.3.3.3.2]  */
        function(a) {
          i || (i = !0, e.reject(a));
        }
      );
    } catch (a) {
      i || e.reject(a);
    }
    return;
  }
  e.fulfill(r);
};
Ns.all = function(t) {
  return new Ns(function(e, r) {
    for (var n = new Array(t.length), i = 0, a = function(l, u) {
      n[l] = u, i++, i === t.length && e(n);
    }, s = 0; s < t.length; s++)
      (function(o) {
        var l = t[o], u = l != null && l.then != null;
        if (u)
          l.then(function(f) {
            a(o, f);
          }, function(f) {
            r(f);
          });
        else {
          var h = l;
          a(o, h);
        }
      })(s);
  });
};
Ns.resolve = function(t) {
  return new Ns(function(e, r) {
    e(t);
  });
};
Ns.reject = function(t) {
  return new Ns(function(e, r) {
    r(t);
  });
};
var G0 = typeof Promise < "u" ? Promise : Ns, vA = function(e, r, n) {
  var i = pR(e), a = !i, s = this._private = Ut({
    duration: 1e3
  }, r, n);
  if (s.target = e, s.style = s.style || s.css, s.started = !1, s.playing = !1, s.hooked = !1, s.applying = !1, s.progress = 0, s.completes = [], s.frames = [], s.complete && ln(s.complete) && s.completes.push(s.complete), a) {
    var o = e.position();
    s.startPosition = s.startPosition || {
      x: o.x,
      y: o.y
    }, s.startStyle = s.startStyle || e.cy().style().getAnimationStartStyle(e, s.style);
  }
  if (i) {
    var l = e.pan();
    s.startPan = {
      x: l.x,
      y: l.y
    }, s.startZoom = e.zoom();
  }
  this.length = 1, this[0] = this;
}, nh = vA.prototype;
Ut(nh, {
  instanceString: function() {
    return "animation";
  },
  hook: function() {
    var e = this._private;
    if (!e.hooked) {
      var r, n = e.target._private.animation;
      e.queue ? r = n.queue : r = n.current, r.push(this), La(e.target) && e.target.cy().addToAnimationPool(e.target), e.hooked = !0;
    }
    return this;
  },
  play: function() {
    var e = this._private;
    return e.progress === 1 && (e.progress = 0), e.playing = !0, e.started = !1, e.stopped = !1, this.hook(), this;
  },
  playing: function() {
    return this._private.playing;
  },
  apply: function() {
    var e = this._private;
    return e.applying = !0, e.started = !1, e.stopped = !1, this.hook(), this;
  },
  applying: function() {
    return this._private.applying;
  },
  pause: function() {
    var e = this._private;
    return e.playing = !1, e.started = !1, this;
  },
  stop: function() {
    var e = this._private;
    return e.playing = !1, e.started = !1, e.stopped = !0, this;
  },
  rewind: function() {
    return this.progress(0);
  },
  fastforward: function() {
    return this.progress(1);
  },
  time: function(e) {
    var r = this._private;
    return e === void 0 ? r.progress * r.duration : this.progress(e / r.duration);
  },
  progress: function(e) {
    var r = this._private, n = r.playing;
    return e === void 0 ? r.progress : (n && this.pause(), r.progress = e, r.started = !1, n && this.play(), this);
  },
  completed: function() {
    return this._private.progress === 1;
  },
  reverse: function() {
    var e = this._private, r = e.playing;
    r && this.pause(), e.progress = 1 - e.progress, e.started = !1;
    var n = function(u, h) {
      var f = e[u];
      f != null && (e[u] = e[h], e[h] = f);
    };
    if (n("zoom", "startZoom"), n("pan", "startPan"), n("position", "startPosition"), e.style)
      for (var i = 0; i < e.style.length; i++) {
        var a = e.style[i], s = a.name, o = e.startStyle[s];
        e.startStyle[s] = a, e.style[i] = o;
      }
    return r && this.play(), this;
  },
  promise: function(e) {
    var r = this._private, n;
    switch (e) {
      case "frame":
        n = r.frames;
        break;
      default:
      case "complete":
      case "completed":
        n = r.completes;
    }
    return new G0(function(i, a) {
      n.push(function() {
        i();
      });
    });
  }
});
nh.complete = nh.completed;
nh.run = nh.play;
nh.running = nh.playing;
var CIe = {
  animated: function() {
    return function() {
      var r = this, n = r.length !== void 0, i = n ? r : [r], a = this._private.cy || this;
      if (!a.styleEnabled())
        return !1;
      var s = i[0];
      if (s)
        return s._private.animation.current.length > 0;
    };
  },
  // animated
  clearQueue: function() {
    return function() {
      var r = this, n = r.length !== void 0, i = n ? r : [r], a = this._private.cy || this;
      if (!a.styleEnabled())
        return this;
      for (var s = 0; s < i.length; s++) {
        var o = i[s];
        o._private.animation.queue = [];
      }
      return this;
    };
  },
  // clearQueue
  delay: function() {
    return function(r, n) {
      var i = this._private.cy || this;
      return i.styleEnabled() ? this.animate({
        delay: r,
        duration: r,
        complete: n
      }) : this;
    };
  },
  // delay
  delayAnimation: function() {
    return function(r, n) {
      var i = this._private.cy || this;
      return i.styleEnabled() ? this.animation({
        delay: r,
        duration: r,
        complete: n
      }) : this;
    };
  },
  // delay
  animation: function() {
    return function(r, n) {
      var i = this, a = i.length !== void 0, s = a ? i : [i], o = this._private.cy || this, l = !a, u = !l;
      if (!o.styleEnabled())
        return this;
      var h = o.style();
      r = Ut({}, r, n);
      var f = Object.keys(r).length === 0;
      if (f)
        return new vA(s[0], r);
      switch (r.duration === void 0 && (r.duration = 400), r.duration) {
        case "slow":
          r.duration = 600;
          break;
        case "fast":
          r.duration = 200;
          break;
      }
      if (u && (r.style = h.getPropsList(r.style || r.css), r.css = void 0), u && r.renderedPosition != null) {
        var d = r.renderedPosition, p = o.pan(), g = o.zoom();
        r.position = jne(d, g, p);
      }
      if (l && r.panBy != null) {
        var m = r.panBy, v = o.pan();
        r.pan = {
          x: v.x + m.x,
          y: v.y + m.y
        };
      }
      var y = r.center || r.centre;
      if (l && y != null) {
        var b = o.getCenterPan(y.eles, r.zoom);
        b != null && (r.pan = b);
      }
      if (l && r.fit != null) {
        var x = r.fit, T = o.getFitViewport(x.eles || x.boundingBox, x.padding);
        T != null && (r.pan = T.pan, r.zoom = T.zoom);
      }
      if (l && yr(r.zoom)) {
        var E = o.getZoomedViewport(r.zoom);
        E != null ? (E.zoomed && (r.zoom = E.zoom), E.panned && (r.pan = E.pan)) : r.zoom = null;
      }
      return new vA(s[0], r);
    };
  },
  // animate
  animate: function() {
    return function(r, n) {
      var i = this, a = i.length !== void 0, s = a ? i : [i], o = this._private.cy || this;
      if (!o.styleEnabled())
        return this;
      n && (r = Ut({}, r, n));
      for (var l = 0; l < s.length; l++) {
        var u = s[l], h = u.animated() && (r.queue === void 0 || r.queue), f = u.animation(r, h ? {
          queue: !0
        } : void 0);
        f.play();
      }
      return this;
    };
  },
  // animate
  stop: function() {
    return function(r, n) {
      var i = this, a = i.length !== void 0, s = a ? i : [i], o = this._private.cy || this;
      if (!o.styleEnabled())
        return this;
      for (var l = 0; l < s.length; l++) {
        for (var u = s[l], h = u._private, f = h.animation.current, d = 0; d < f.length; d++) {
          var p = f[d], g = p._private;
          n && (g.duration = 0);
        }
        r && (h.animation.queue = []), n || (h.animation.current = []);
      }
      return o.notify("draw"), this;
    };
  }
  // stop
}, Kk, zq;
function Q4() {
  if (zq) return Kk;
  zq = 1;
  var t = Array.isArray;
  return Kk = t, Kk;
}
var Zk, qq;
function _Ie() {
  if (qq) return Zk;
  qq = 1;
  var t = Q4(), e = Tm(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
  function i(a, s) {
    if (t(a))
      return !1;
    var o = typeof a;
    return o == "number" || o == "symbol" || o == "boolean" || a == null || e(a) ? !0 : n.test(a) || !r.test(a) || s != null && a in Object(s);
  }
  return Zk = i, Zk;
}
var Qk, Gq;
function AIe() {
  if (Gq) return Qk;
  Gq = 1;
  var t = zne(), e = wm(), r = "[object AsyncFunction]", n = "[object Function]", i = "[object GeneratorFunction]", a = "[object Proxy]";
  function s(o) {
    if (!e(o))
      return !1;
    var l = t(o);
    return l == n || l == i || l == r || l == a;
  }
  return Qk = s, Qk;
}
var Jk, Uq;
function LIe() {
  if (Uq) return Jk;
  Uq = 1;
  var t = X4(), e = t["__core-js_shared__"];
  return Jk = e, Jk;
}
var eC, Vq;
function RIe() {
  if (Vq) return eC;
  Vq = 1;
  var t = LIe(), e = (function() {
    var n = /[^.]+$/.exec(t && t.keys && t.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  })();
  function r(n) {
    return !!e && e in n;
  }
  return eC = r, eC;
}
var tC, Hq;
function IIe() {
  if (Hq) return tC;
  Hq = 1;
  var t = Function.prototype, e = t.toString;
  function r(n) {
    if (n != null) {
      try {
        return e.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  return tC = r, tC;
}
var rC, Wq;
function MIe() {
  if (Wq) return rC;
  Wq = 1;
  var t = AIe(), e = RIe(), r = wm(), n = IIe(), i = /[\\^$.*+?()[\]{}|]/g, a = /^\[object .+?Constructor\]$/, s = Function.prototype, o = Object.prototype, l = s.toString, u = o.hasOwnProperty, h = RegExp(
    "^" + l.call(u).replace(i, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function f(d) {
    if (!r(d) || e(d))
      return !1;
    var p = t(d) ? h : a;
    return p.test(n(d));
  }
  return rC = f, rC;
}
var nC, Yq;
function NIe() {
  if (Yq) return nC;
  Yq = 1;
  function t(e, r) {
    return e?.[r];
  }
  return nC = t, nC;
}
var iC, Xq;
function kR() {
  if (Xq) return iC;
  Xq = 1;
  var t = MIe(), e = NIe();
  function r(n, i) {
    var a = e(n, i);
    return t(a) ? a : void 0;
  }
  return iC = r, iC;
}
var aC, jq;
function J4() {
  if (jq) return aC;
  jq = 1;
  var t = kR(), e = t(Object, "create");
  return aC = e, aC;
}
var sC, Kq;
function DIe() {
  if (Kq) return sC;
  Kq = 1;
  var t = J4();
  function e() {
    this.__data__ = t ? t(null) : {}, this.size = 0;
  }
  return sC = e, sC;
}
var oC, Zq;
function OIe() {
  if (Zq) return oC;
  Zq = 1;
  function t(e) {
    var r = this.has(e) && delete this.__data__[e];
    return this.size -= r ? 1 : 0, r;
  }
  return oC = t, oC;
}
var lC, Qq;
function PIe() {
  if (Qq) return lC;
  Qq = 1;
  var t = J4(), e = "__lodash_hash_undefined__", r = Object.prototype, n = r.hasOwnProperty;
  function i(a) {
    var s = this.__data__;
    if (t) {
      var o = s[a];
      return o === e ? void 0 : o;
    }
    return n.call(s, a) ? s[a] : void 0;
  }
  return lC = i, lC;
}
var cC, Jq;
function $Ie() {
  if (Jq) return cC;
  Jq = 1;
  var t = J4(), e = Object.prototype, r = e.hasOwnProperty;
  function n(i) {
    var a = this.__data__;
    return t ? a[i] !== void 0 : r.call(a, i);
  }
  return cC = n, cC;
}
var uC, eG;
function BIe() {
  if (eG) return uC;
  eG = 1;
  var t = J4(), e = "__lodash_hash_undefined__";
  function r(n, i) {
    var a = this.__data__;
    return this.size += this.has(n) ? 0 : 1, a[n] = t && i === void 0 ? e : i, this;
  }
  return uC = r, uC;
}
var hC, tG;
function FIe() {
  if (tG) return hC;
  tG = 1;
  var t = DIe(), e = OIe(), r = PIe(), n = $Ie(), i = BIe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, hC = a, hC;
}
var fC, rG;
function zIe() {
  if (rG) return fC;
  rG = 1;
  function t() {
    this.__data__ = [], this.size = 0;
  }
  return fC = t, fC;
}
var dC, nG;
function hie() {
  if (nG) return dC;
  nG = 1;
  function t(e, r) {
    return e === r || e !== e && r !== r;
  }
  return dC = t, dC;
}
var pC, iG;
function e3() {
  if (iG) return pC;
  iG = 1;
  var t = hie();
  function e(r, n) {
    for (var i = r.length; i--; )
      if (t(r[i][0], n))
        return i;
    return -1;
  }
  return pC = e, pC;
}
var gC, aG;
function qIe() {
  if (aG) return gC;
  aG = 1;
  var t = e3(), e = Array.prototype, r = e.splice;
  function n(i) {
    var a = this.__data__, s = t(a, i);
    if (s < 0)
      return !1;
    var o = a.length - 1;
    return s == o ? a.pop() : r.call(a, s, 1), --this.size, !0;
  }
  return gC = n, gC;
}
var mC, sG;
function GIe() {
  if (sG) return mC;
  sG = 1;
  var t = e3();
  function e(r) {
    var n = this.__data__, i = t(n, r);
    return i < 0 ? void 0 : n[i][1];
  }
  return mC = e, mC;
}
var vC, oG;
function UIe() {
  if (oG) return vC;
  oG = 1;
  var t = e3();
  function e(r) {
    return t(this.__data__, r) > -1;
  }
  return vC = e, vC;
}
var yC, lG;
function VIe() {
  if (lG) return yC;
  lG = 1;
  var t = e3();
  function e(r, n) {
    var i = this.__data__, a = t(i, r);
    return a < 0 ? (++this.size, i.push([r, n])) : i[a][1] = n, this;
  }
  return yC = e, yC;
}
var bC, cG;
function HIe() {
  if (cG) return bC;
  cG = 1;
  var t = zIe(), e = qIe(), r = GIe(), n = UIe(), i = VIe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, bC = a, bC;
}
var xC, uG;
function WIe() {
  if (uG) return xC;
  uG = 1;
  var t = kR(), e = X4(), r = t(e, "Map");
  return xC = r, xC;
}
var wC, hG;
function YIe() {
  if (hG) return wC;
  hG = 1;
  var t = FIe(), e = HIe(), r = WIe();
  function n() {
    this.size = 0, this.__data__ = {
      hash: new t(),
      map: new (r || e)(),
      string: new t()
    };
  }
  return wC = n, wC;
}
var TC, fG;
function XIe() {
  if (fG) return TC;
  fG = 1;
  function t(e) {
    var r = typeof e;
    return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? e !== "__proto__" : e === null;
  }
  return TC = t, TC;
}
var EC, dG;
function t3() {
  if (dG) return EC;
  dG = 1;
  var t = XIe();
  function e(r, n) {
    var i = r.__data__;
    return t(n) ? i[typeof n == "string" ? "string" : "hash"] : i.map;
  }
  return EC = e, EC;
}
var SC, pG;
function jIe() {
  if (pG) return SC;
  pG = 1;
  var t = t3();
  function e(r) {
    var n = t(this, r).delete(r);
    return this.size -= n ? 1 : 0, n;
  }
  return SC = e, SC;
}
var kC, gG;
function KIe() {
  if (gG) return kC;
  gG = 1;
  var t = t3();
  function e(r) {
    return t(this, r).get(r);
  }
  return kC = e, kC;
}
var CC, mG;
function ZIe() {
  if (mG) return CC;
  mG = 1;
  var t = t3();
  function e(r) {
    return t(this, r).has(r);
  }
  return CC = e, CC;
}
var _C, vG;
function QIe() {
  if (vG) return _C;
  vG = 1;
  var t = t3();
  function e(r, n) {
    var i = t(this, r), a = i.size;
    return i.set(r, n), this.size += i.size == a ? 0 : 1, this;
  }
  return _C = e, _C;
}
var AC, yG;
function JIe() {
  if (yG) return AC;
  yG = 1;
  var t = YIe(), e = jIe(), r = KIe(), n = ZIe(), i = QIe();
  function a(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return a.prototype.clear = t, a.prototype.delete = e, a.prototype.get = r, a.prototype.has = n, a.prototype.set = i, AC = a, AC;
}
var LC, bG;
function eMe() {
  if (bG) return LC;
  bG = 1;
  var t = JIe(), e = "Expected a function";
  function r(n, i) {
    if (typeof n != "function" || i != null && typeof i != "function")
      throw new TypeError(e);
    var a = function() {
      var s = arguments, o = i ? i.apply(this, s) : s[0], l = a.cache;
      if (l.has(o))
        return l.get(o);
      var u = n.apply(this, s);
      return a.cache = l.set(o, u) || l, u;
    };
    return a.cache = new (r.Cache || t)(), a;
  }
  return r.Cache = t, LC = r, LC;
}
var RC, xG;
function tMe() {
  if (xG) return RC;
  xG = 1;
  var t = eMe(), e = 500;
  function r(n) {
    var i = t(n, function(s) {
      return a.size === e && a.clear(), s;
    }), a = i.cache;
    return i;
  }
  return RC = r, RC;
}
var IC, wG;
function fie() {
  if (wG) return IC;
  wG = 1;
  var t = tMe(), e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g, n = t(function(i) {
    var a = [];
    return i.charCodeAt(0) === 46 && a.push(""), i.replace(e, function(s, o, l, u) {
      a.push(l ? u.replace(r, "$1") : o || s);
    }), a;
  });
  return IC = n, IC;
}
var MC, TG;
function die() {
  if (TG) return MC;
  TG = 1;
  function t(e, r) {
    for (var n = -1, i = e == null ? 0 : e.length, a = Array(i); ++n < i; )
      a[n] = r(e[n], n, e);
    return a;
  }
  return MC = t, MC;
}
var NC, EG;
function rMe() {
  if (EG) return NC;
  EG = 1;
  var t = mR(), e = die(), r = Q4(), n = Tm(), i = t ? t.prototype : void 0, a = i ? i.toString : void 0;
  function s(o) {
    if (typeof o == "string")
      return o;
    if (r(o))
      return e(o, s) + "";
    if (n(o))
      return a ? a.call(o) : "";
    var l = o + "";
    return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
  }
  return NC = s, NC;
}
var DC, SG;
function pie() {
  if (SG) return DC;
  SG = 1;
  var t = rMe();
  function e(r) {
    return r == null ? "" : t(r);
  }
  return DC = e, DC;
}
var OC, kG;
function gie() {
  if (kG) return OC;
  kG = 1;
  var t = Q4(), e = _Ie(), r = fie(), n = pie();
  function i(a, s) {
    return t(a) ? a : e(a, s) ? [a] : r(n(a));
  }
  return OC = i, OC;
}
var PC, CG;
function CR() {
  if (CG) return PC;
  CG = 1;
  var t = Tm();
  function e(r) {
    if (typeof r == "string" || t(r))
      return r;
    var n = r + "";
    return n == "0" && 1 / r == -1 / 0 ? "-0" : n;
  }
  return PC = e, PC;
}
var $C, _G;
function nMe() {
  if (_G) return $C;
  _G = 1;
  var t = gie(), e = CR();
  function r(n, i) {
    i = t(i, n);
    for (var a = 0, s = i.length; n != null && a < s; )
      n = n[e(i[a++])];
    return a && a == s ? n : void 0;
  }
  return $C = r, $C;
}
var BC, AG;
function iMe() {
  if (AG) return BC;
  AG = 1;
  var t = nMe();
  function e(r, n, i) {
    var a = r == null ? void 0 : t(r, n);
    return a === void 0 ? i : a;
  }
  return BC = e, BC;
}
var aMe = iMe(), sMe = /* @__PURE__ */ xm(aMe), FC, LG;
function oMe() {
  if (LG) return FC;
  LG = 1;
  var t = kR(), e = (function() {
    try {
      var r = t(Object, "defineProperty");
      return r({}, "", {}), r;
    } catch {
    }
  })();
  return FC = e, FC;
}
var zC, RG;
function lMe() {
  if (RG) return zC;
  RG = 1;
  var t = oMe();
  function e(r, n, i) {
    n == "__proto__" && t ? t(r, n, {
      configurable: !0,
      enumerable: !0,
      value: i,
      writable: !0
    }) : r[n] = i;
  }
  return zC = e, zC;
}
var qC, IG;
function cMe() {
  if (IG) return qC;
  IG = 1;
  var t = lMe(), e = hie(), r = Object.prototype, n = r.hasOwnProperty;
  function i(a, s, o) {
    var l = a[s];
    (!(n.call(a, s) && e(l, o)) || o === void 0 && !(s in a)) && t(a, s, o);
  }
  return qC = i, qC;
}
var GC, MG;
function uMe() {
  if (MG) return GC;
  MG = 1;
  var t = 9007199254740991, e = /^(?:0|[1-9]\d*)$/;
  function r(n, i) {
    var a = typeof n;
    return i = i ?? t, !!i && (a == "number" || a != "symbol" && e.test(n)) && n > -1 && n % 1 == 0 && n < i;
  }
  return GC = r, GC;
}
var UC, NG;
function hMe() {
  if (NG) return UC;
  NG = 1;
  var t = cMe(), e = gie(), r = uMe(), n = wm(), i = CR();
  function a(s, o, l, u) {
    if (!n(s))
      return s;
    o = e(o, s);
    for (var h = -1, f = o.length, d = f - 1, p = s; p != null && ++h < f; ) {
      var g = i(o[h]), m = l;
      if (g === "__proto__" || g === "constructor" || g === "prototype")
        return s;
      if (h != d) {
        var v = p[g];
        m = u ? u(v, g, p) : void 0, m === void 0 && (m = n(v) ? v : r(o[h + 1]) ? [] : {});
      }
      t(p, g, m), p = p[g];
    }
    return s;
  }
  return UC = a, UC;
}
var VC, DG;
function fMe() {
  if (DG) return VC;
  DG = 1;
  var t = hMe();
  function e(r, n, i) {
    return r == null ? r : t(r, n, i);
  }
  return VC = e, VC;
}
var dMe = fMe(), pMe = /* @__PURE__ */ xm(dMe), HC, OG;
function gMe() {
  if (OG) return HC;
  OG = 1;
  function t(e, r) {
    var n = -1, i = e.length;
    for (r || (r = Array(i)); ++n < i; )
      r[n] = e[n];
    return r;
  }
  return HC = t, HC;
}
var WC, PG;
function mMe() {
  if (PG) return WC;
  PG = 1;
  var t = die(), e = gMe(), r = Q4(), n = Tm(), i = fie(), a = CR(), s = pie();
  function o(l) {
    return r(l) ? t(l, a) : n(l) ? [l] : e(i(s(l)));
  }
  return WC = o, WC;
}
var vMe = mMe(), yMe = /* @__PURE__ */ xm(vMe), bMe = {
  // access data field
  data: function(e) {
    var r = {
      field: "data",
      bindingEvent: "data",
      allowBinding: !1,
      allowSetting: !1,
      allowGetting: !1,
      settingEvent: "data",
      settingTriggersEvent: !1,
      triggerFnName: "trigger",
      immutableKeys: {},
      // key => true if immutable
      updateStyle: !1,
      beforeGet: function(i) {
      },
      beforeSet: function(i, a) {
      },
      onSet: function(i) {
      },
      canSet: function(i) {
        return !0;
      }
    };
    return e = Ut({}, r, e), function(i, a) {
      var s = e, o = this, l = o.length !== void 0, u = l ? o : [o], h = l ? o[0] : o;
      if (Pt(i)) {
        var f = i.indexOf(".") !== -1, d = f && yMe(i);
        if (s.allowGetting && a === void 0) {
          var p;
          return h && (s.beforeGet(h), d && h._private[s.field][i] === void 0 ? p = sMe(h._private[s.field], d) : p = h._private[s.field][i]), p;
        } else if (s.allowSetting && a !== void 0) {
          var g = !s.immutableKeys[i];
          if (g) {
            var m = Rne({}, i, a);
            s.beforeSet(o, m);
            for (var v = 0, y = u.length; v < y; v++) {
              var b = u[v];
              s.canSet(b) && (d && h._private[s.field][i] === void 0 ? pMe(b._private[s.field], d, a) : b._private[s.field][i] = a);
            }
            s.updateStyle && o.updateStyle(), s.onSet(o), s.settingTriggersEvent && o[s.triggerFnName](s.settingEvent);
          }
        }
      } else if (s.allowSetting && yr(i)) {
        var x = i, T, E, A = Object.keys(x);
        s.beforeSet(o, x);
        for (var S = 0; S < A.length; S++) {
          T = A[S], E = x[T];
          var k = !s.immutableKeys[T];
          if (k)
            for (var _ = 0; _ < u.length; _++) {
              var R = u[_];
              s.canSet(R) && (R._private[s.field][T] = E);
            }
        }
        s.updateStyle && o.updateStyle(), s.onSet(o), s.settingTriggersEvent && o[s.triggerFnName](s.settingEvent);
      } else if (s.allowBinding && ln(i)) {
        var L = i;
        o.on(s.bindingEvent, L);
      } else if (s.allowGetting && i === void 0) {
        var M;
        return h && (s.beforeGet(h), M = h._private[s.field]), M;
      }
      return o;
    };
  },
  // data
  // remove data field
  removeData: function(e) {
    var r = {
      field: "data",
      event: "data",
      triggerFnName: "trigger",
      triggerEvent: !1,
      immutableKeys: {}
      // key => true if immutable
    };
    return e = Ut({}, r, e), function(i) {
      var a = e, s = this, o = s.length !== void 0, l = o ? s : [s];
      if (Pt(i)) {
        for (var u = i.split(/\s+/), h = u.length, f = 0; f < h; f++) {
          var d = u[f];
          if (!yc(d)) {
            var p = !a.immutableKeys[d];
            if (p)
              for (var g = 0, m = l.length; g < m; g++)
                l[g]._private[a.field][d] = void 0;
          }
        }
        a.triggerEvent && s[a.triggerFnName](a.event);
      } else if (i === void 0) {
        for (var v = 0, y = l.length; v < y; v++)
          for (var b = l[v]._private[a.field], x = Object.keys(b), T = 0; T < x.length; T++) {
            var E = x[T], A = !a.immutableKeys[E];
            A && (b[E] = void 0);
          }
        a.triggerEvent && s[a.triggerFnName](a.event);
      }
      return s;
    };
  }
  // removeData
}, xMe = {
  eventAliasesOn: function(e) {
    var r = e;
    r.addListener = r.listen = r.bind = r.on, r.unlisten = r.unbind = r.off = r.removeListener, r.trigger = r.emit, r.pon = r.promiseOn = function(n, i) {
      var a = this, s = Array.prototype.slice.call(arguments, 0);
      return new G0(function(o, l) {
        var u = function(p) {
          a.off.apply(a, f), o(p);
        }, h = s.concat([u]), f = h.concat([]);
        a.on.apply(a, h);
      });
    };
  }
}, Ar = {};
[CIe, bMe, xMe].forEach(function(t) {
  Ut(Ar, t);
});
var wMe = {
  animate: Ar.animate(),
  animation: Ar.animation(),
  animated: Ar.animated(),
  clearQueue: Ar.clearQueue(),
  delay: Ar.delay(),
  delayAnimation: Ar.delayAnimation(),
  stop: Ar.stop()
}, By = {
  classes: function(e) {
    var r = this;
    if (e === void 0) {
      var n = [];
      return r[0]._private.classes.forEach(function(g) {
        return n.push(g);
      }), n;
    } else Pr(e) || (e = (e || "").match(/\S+/g) || []);
    for (var i = [], a = new q0(e), s = 0; s < r.length; s++) {
      for (var o = r[s], l = o._private, u = l.classes, h = !1, f = 0; f < e.length; f++) {
        var d = e[f], p = u.has(d);
        if (!p) {
          h = !0;
          break;
        }
      }
      h || (h = u.size !== e.length), h && (l.classes = a, i.push(o));
    }
    return i.length > 0 && this.spawn(i).updateStyle().emit("class"), r;
  },
  addClass: function(e) {
    return this.toggleClass(e, !0);
  },
  hasClass: function(e) {
    var r = this[0];
    return r != null && r._private.classes.has(e);
  },
  toggleClass: function(e, r) {
    Pr(e) || (e = e.match(/\S+/g) || []);
    for (var n = this, i = r === void 0, a = [], s = 0, o = n.length; s < o; s++)
      for (var l = n[s], u = l._private.classes, h = !1, f = 0; f < e.length; f++) {
        var d = e[f], p = u.has(d), g = !1;
        r || i && !p ? (u.add(d), g = !0) : (!r || i && p) && (u.delete(d), g = !0), !h && g && (a.push(l), h = !0);
      }
    return a.length > 0 && this.spawn(a).updateStyle().emit("class"), n;
  },
  removeClass: function(e) {
    return this.toggleClass(e, !1);
  },
  flashClass: function(e, r) {
    var n = this;
    if (r == null)
      r = 250;
    else if (r === 0)
      return n;
    return n.addClass(e), setTimeout(function() {
      n.removeClass(e);
    }, r), n;
  }
};
By.className = By.classNames = By.classes;
var vr = {
  metaChar: "[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",
  // chars we need to escape in let names, etc
  comparatorOp: "=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",
  // binary comparison op (used in data selectors)
  boolOp: "\\?|\\!|\\^",
  // boolean (unary) operators (used in data selectors)
  string: `"(?:\\\\"|[^"])*"|'(?:\\\\'|[^'])*'`,
  // string literals (used in data selectors) -- doublequotes | singlequotes
  number: Gn,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: "degree|indegree|outdegree",
  // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: "\\s*,\\s*",
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: "\\s+",
  child: "\\s+>\\s+",
  subject: "\\$",
  group: "node|edge|\\*",
  directedEdge: "\\s+->\\s+",
  undirectedEdge: "\\s+<->\\s+"
};
vr.variable = "(?:[\\w-.]|(?:\\\\" + vr.metaChar + "))+";
vr.className = "(?:[\\w-]|(?:\\\\" + vr.metaChar + "))+";
vr.value = vr.string + "|" + vr.number;
vr.id = vr.variable;
(function() {
  var t, e, r;
  for (t = vr.comparatorOp.split("|"), r = 0; r < t.length; r++)
    e = t[r], vr.comparatorOp += "|@" + e;
  for (t = vr.comparatorOp.split("|"), r = 0; r < t.length; r++)
    e = t[r], !(e.indexOf("!") >= 0) && e !== "=" && (vr.comparatorOp += "|\\!" + e);
})();
var Or = function() {
  return {
    checks: []
  };
}, At = {
  /** E.g. node */
  GROUP: 0,
  /** A collection of elements */
  COLLECTION: 1,
  /** A filter(ele) function */
  FILTER: 2,
  /** E.g. [foo > 1] */
  DATA_COMPARE: 3,
  /** E.g. [foo] */
  DATA_EXIST: 4,
  /** E.g. [?foo] */
  DATA_BOOL: 5,
  /** E.g. [[degree > 2]] */
  META_COMPARE: 6,
  /** E.g. :selected */
  STATE: 7,
  /** E.g. #foo */
  ID: 8,
  /** E.g. .foo */
  CLASS: 9,
  /** E.g. #foo <-> #bar */
  UNDIRECTED_EDGE: 10,
  /** E.g. #foo -> #bar */
  DIRECTED_EDGE: 11,
  /** E.g. $#foo -> #bar */
  NODE_SOURCE: 12,
  /** E.g. #foo -> $#bar */
  NODE_TARGET: 13,
  /** E.g. $#foo <-> #bar */
  NODE_NEIGHBOR: 14,
  /** E.g. #foo > #bar */
  CHILD: 15,
  /** E.g. #foo #bar */
  DESCENDANT: 16,
  /** E.g. $#foo > #bar */
  PARENT: 17,
  /** E.g. $#foo #bar */
  ANCESTOR: 18,
  /** E.g. #foo > $bar > #baz */
  COMPOUND_SPLIT: 19,
  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
  TRUE: 20
}, yA = [{
  selector: ":selected",
  matches: function(e) {
    return e.selected();
  }
}, {
  selector: ":unselected",
  matches: function(e) {
    return !e.selected();
  }
}, {
  selector: ":selectable",
  matches: function(e) {
    return e.selectable();
  }
}, {
  selector: ":unselectable",
  matches: function(e) {
    return !e.selectable();
  }
}, {
  selector: ":locked",
  matches: function(e) {
    return e.locked();
  }
}, {
  selector: ":unlocked",
  matches: function(e) {
    return !e.locked();
  }
}, {
  selector: ":visible",
  matches: function(e) {
    return e.visible();
  }
}, {
  selector: ":hidden",
  matches: function(e) {
    return !e.visible();
  }
}, {
  selector: ":transparent",
  matches: function(e) {
    return e.transparent();
  }
}, {
  selector: ":grabbed",
  matches: function(e) {
    return e.grabbed();
  }
}, {
  selector: ":free",
  matches: function(e) {
    return !e.grabbed();
  }
}, {
  selector: ":removed",
  matches: function(e) {
    return e.removed();
  }
}, {
  selector: ":inside",
  matches: function(e) {
    return !e.removed();
  }
}, {
  selector: ":grabbable",
  matches: function(e) {
    return e.grabbable();
  }
}, {
  selector: ":ungrabbable",
  matches: function(e) {
    return !e.grabbable();
  }
}, {
  selector: ":animated",
  matches: function(e) {
    return e.animated();
  }
}, {
  selector: ":unanimated",
  matches: function(e) {
    return !e.animated();
  }
}, {
  selector: ":parent",
  matches: function(e) {
    return e.isParent();
  }
}, {
  selector: ":childless",
  matches: function(e) {
    return e.isChildless();
  }
}, {
  selector: ":child",
  matches: function(e) {
    return e.isChild();
  }
}, {
  selector: ":orphan",
  matches: function(e) {
    return e.isOrphan();
  }
}, {
  selector: ":nonorphan",
  matches: function(e) {
    return e.isChild();
  }
}, {
  selector: ":compound",
  matches: function(e) {
    return e.isNode() ? e.isParent() : e.source().isParent() || e.target().isParent();
  }
}, {
  selector: ":loop",
  matches: function(e) {
    return e.isLoop();
  }
}, {
  selector: ":simple",
  matches: function(e) {
    return e.isSimple();
  }
}, {
  selector: ":active",
  matches: function(e) {
    return e.active();
  }
}, {
  selector: ":inactive",
  matches: function(e) {
    return !e.active();
  }
}, {
  selector: ":backgrounding",
  matches: function(e) {
    return e.backgrounding();
  }
}, {
  selector: ":nonbackgrounding",
  matches: function(e) {
    return !e.backgrounding();
  }
}].sort(function(t, e) {
  return bLe(t.selector, e.selector);
}), TMe = (function() {
  for (var t = {}, e, r = 0; r < yA.length; r++)
    e = yA[r], t[e.selector] = e.matches;
  return t;
})(), EMe = function(e, r) {
  return TMe[e](r);
}, SMe = "(" + yA.map(function(t) {
  return t.selector;
}).join("|") + ")", ef = function(e) {
  return e.replace(new RegExp("\\\\(" + vr.metaChar + ")", "g"), function(r, n) {
    return n;
  });
}, Ul = function(e, r, n) {
  e[e.length - 1] = n;
}, bA = [{
  name: "group",
  // just used for identifying when debugging
  query: !0,
  regex: "(" + vr.group + ")",
  populate: function(e, r, n) {
    var i = Cn(n, 1), a = i[0];
    r.checks.push({
      type: At.GROUP,
      value: a === "*" ? a : a + "s"
    });
  }
}, {
  name: "state",
  query: !0,
  regex: SMe,
  populate: function(e, r, n) {
    var i = Cn(n, 1), a = i[0];
    r.checks.push({
      type: At.STATE,
      value: a
    });
  }
}, {
  name: "id",
  query: !0,
  regex: "\\#(" + vr.id + ")",
  populate: function(e, r, n) {
    var i = Cn(n, 1), a = i[0];
    r.checks.push({
      type: At.ID,
      value: ef(a)
    });
  }
}, {
  name: "className",
  query: !0,
  regex: "\\.(" + vr.className + ")",
  populate: function(e, r, n) {
    var i = Cn(n, 1), a = i[0];
    r.checks.push({
      type: At.CLASS,
      value: ef(a)
    });
  }
}, {
  name: "dataExists",
  query: !0,
  regex: "\\[\\s*(" + vr.variable + ")\\s*\\]",
  populate: function(e, r, n) {
    var i = Cn(n, 1), a = i[0];
    r.checks.push({
      type: At.DATA_EXIST,
      field: ef(a)
    });
  }
}, {
  name: "dataCompare",
  query: !0,
  regex: "\\[\\s*(" + vr.variable + ")\\s*(" + vr.comparatorOp + ")\\s*(" + vr.value + ")\\s*\\]",
  populate: function(e, r, n) {
    var i = Cn(n, 3), a = i[0], s = i[1], o = i[2], l = new RegExp("^" + vr.string + "$").exec(o) != null;
    l ? o = o.substring(1, o.length - 1) : o = parseFloat(o), r.checks.push({
      type: At.DATA_COMPARE,
      field: ef(a),
      operator: s,
      value: o
    });
  }
}, {
  name: "dataBool",
  query: !0,
  regex: "\\[\\s*(" + vr.boolOp + ")\\s*(" + vr.variable + ")\\s*\\]",
  populate: function(e, r, n) {
    var i = Cn(n, 2), a = i[0], s = i[1];
    r.checks.push({
      type: At.DATA_BOOL,
      field: ef(s),
      operator: a
    });
  }
}, {
  name: "metaCompare",
  query: !0,
  regex: "\\[\\[\\s*(" + vr.meta + ")\\s*(" + vr.comparatorOp + ")\\s*(" + vr.number + ")\\s*\\]\\]",
  populate: function(e, r, n) {
    var i = Cn(n, 3), a = i[0], s = i[1], o = i[2];
    r.checks.push({
      type: At.META_COMPARE,
      field: ef(a),
      operator: s,
      value: parseFloat(o)
    });
  }
}, {
  name: "nextQuery",
  separator: !0,
  regex: vr.separator,
  populate: function(e, r) {
    var n = e.currentSubject, i = e.edgeCount, a = e.compoundCount, s = e[e.length - 1];
    n != null && (s.subject = n, e.currentSubject = null), s.edgeCount = i, s.compoundCount = a, e.edgeCount = 0, e.compoundCount = 0;
    var o = e[e.length++] = Or();
    return o;
  }
}, {
  name: "directedEdge",
  separator: !0,
  regex: vr.directedEdge,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Or(), i = r, a = Or();
      return n.checks.push({
        type: At.DIRECTED_EDGE,
        source: i,
        target: a
      }), Ul(e, r, n), e.edgeCount++, a;
    } else {
      var s = Or(), o = r, l = Or();
      return s.checks.push({
        type: At.NODE_SOURCE,
        source: o,
        target: l
      }), Ul(e, r, s), e.edgeCount++, l;
    }
  }
}, {
  name: "undirectedEdge",
  separator: !0,
  regex: vr.undirectedEdge,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Or(), i = r, a = Or();
      return n.checks.push({
        type: At.UNDIRECTED_EDGE,
        nodes: [i, a]
      }), Ul(e, r, n), e.edgeCount++, a;
    } else {
      var s = Or(), o = r, l = Or();
      return s.checks.push({
        type: At.NODE_NEIGHBOR,
        node: o,
        neighbor: l
      }), Ul(e, r, s), l;
    }
  }
}, {
  name: "child",
  separator: !0,
  regex: vr.child,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Or(), i = Or(), a = e[e.length - 1];
      return n.checks.push({
        type: At.CHILD,
        parent: a,
        child: i
      }), Ul(e, r, n), e.compoundCount++, i;
    } else if (e.currentSubject === r) {
      var s = Or(), o = e[e.length - 1], l = Or(), u = Or(), h = Or(), f = Or();
      return s.checks.push({
        type: At.COMPOUND_SPLIT,
        left: o,
        right: l,
        subject: u
      }), u.checks = r.checks, r.checks = [{
        type: At.TRUE
      }], f.checks.push({
        type: At.TRUE
      }), l.checks.push({
        type: At.PARENT,
        // type is swapped on right side queries
        parent: f,
        child: h
        // empty for now
      }), Ul(e, o, s), e.currentSubject = u, e.compoundCount++, h;
    } else {
      var d = Or(), p = Or(), g = [{
        type: At.PARENT,
        parent: d,
        child: p
      }];
      return d.checks = r.checks, r.checks = g, e.compoundCount++, p;
    }
  }
}, {
  name: "descendant",
  separator: !0,
  regex: vr.descendant,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = Or(), i = Or(), a = e[e.length - 1];
      return n.checks.push({
        type: At.DESCENDANT,
        ancestor: a,
        descendant: i
      }), Ul(e, r, n), e.compoundCount++, i;
    } else if (e.currentSubject === r) {
      var s = Or(), o = e[e.length - 1], l = Or(), u = Or(), h = Or(), f = Or();
      return s.checks.push({
        type: At.COMPOUND_SPLIT,
        left: o,
        right: l,
        subject: u
      }), u.checks = r.checks, r.checks = [{
        type: At.TRUE
      }], f.checks.push({
        type: At.TRUE
      }), l.checks.push({
        type: At.ANCESTOR,
        // type is swapped on right side queries
        ancestor: f,
        descendant: h
        // empty for now
      }), Ul(e, o, s), e.currentSubject = u, e.compoundCount++, h;
    } else {
      var d = Or(), p = Or(), g = [{
        type: At.ANCESTOR,
        ancestor: d,
        descendant: p
      }];
      return d.checks = r.checks, r.checks = g, e.compoundCount++, p;
    }
  }
}, {
  name: "subject",
  modifier: !0,
  regex: vr.subject,
  populate: function(e, r) {
    if (e.currentSubject != null && e.currentSubject !== r)
      return Rr("Redefinition of subject in selector `" + e.toString() + "`"), !1;
    e.currentSubject = r;
    var n = e[e.length - 1], i = n.checks[0], a = i == null ? null : i.type;
    a === At.DIRECTED_EDGE ? i.type = At.NODE_TARGET : a === At.UNDIRECTED_EDGE && (i.type = At.NODE_NEIGHBOR, i.node = i.nodes[1], i.neighbor = i.nodes[0], i.nodes = null);
  }
}];
bA.forEach(function(t) {
  return t.regexObj = new RegExp("^" + t.regex);
});
var kMe = function(e) {
  for (var r, n, i, a = 0; a < bA.length; a++) {
    var s = bA[a], o = s.name, l = e.match(s.regexObj);
    if (l != null) {
      n = l, r = s, i = o;
      var u = l[0];
      e = e.substring(u.length);
      break;
    }
  }
  return {
    expr: r,
    match: n,
    name: i,
    remaining: e
  };
}, CMe = function(e) {
  var r = e.match(/^\s+/);
  if (r) {
    var n = r[0];
    e = e.substring(n.length);
  }
  return e;
}, _Me = function(e) {
  var r = this, n = r.inputText = e, i = r[0] = Or();
  for (r.length = 1, n = CMe(n); ; ) {
    var a = kMe(n);
    if (a.expr == null)
      return Rr("The selector `" + e + "`is invalid"), !1;
    var s = a.match.slice(1), o = a.expr.populate(r, i, s);
    if (o === !1)
      return !1;
    if (o != null && (i = o), n = a.remaining, n.match(/^\s*$/))
      break;
  }
  var l = r[r.length - 1];
  r.currentSubject != null && (l.subject = r.currentSubject), l.edgeCount = r.edgeCount, l.compoundCount = r.compoundCount;
  for (var u = 0; u < r.length; u++) {
    var h = r[u];
    if (h.compoundCount > 0 && h.edgeCount > 0)
      return Rr("The selector `" + e + "` is invalid because it uses both a compound selector and an edge selector"), !1;
    if (h.edgeCount > 1)
      return Rr("The selector `" + e + "` is invalid because it uses multiple edge selectors"), !1;
    h.edgeCount === 1 && Rr("The selector `" + e + "` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.");
  }
  return !0;
}, AMe = function() {
  if (this.toStringCache != null)
    return this.toStringCache;
  for (var e = function(h) {
    return h ?? "";
  }, r = function(h) {
    return Pt(h) ? '"' + h + '"' : e(h);
  }, n = function(h) {
    return " " + h + " ";
  }, i = function(h, f) {
    var d = h.type, p = h.value;
    switch (d) {
      case At.GROUP: {
        var g = e(p);
        return g.substring(0, g.length - 1);
      }
      case At.DATA_COMPARE: {
        var m = h.field, v = h.operator;
        return "[" + m + n(e(v)) + r(p) + "]";
      }
      case At.DATA_BOOL: {
        var y = h.operator, b = h.field;
        return "[" + e(y) + b + "]";
      }
      case At.DATA_EXIST: {
        var x = h.field;
        return "[" + x + "]";
      }
      case At.META_COMPARE: {
        var T = h.operator, E = h.field;
        return "[[" + E + n(e(T)) + r(p) + "]]";
      }
      case At.STATE:
        return p;
      case At.ID:
        return "#" + p;
      case At.CLASS:
        return "." + p;
      case At.PARENT:
      case At.CHILD:
        return a(h.parent, f) + n(">") + a(h.child, f);
      case At.ANCESTOR:
      case At.DESCENDANT:
        return a(h.ancestor, f) + " " + a(h.descendant, f);
      case At.COMPOUND_SPLIT: {
        var A = a(h.left, f), S = a(h.subject, f), k = a(h.right, f);
        return A + (A.length > 0 ? " " : "") + S + k;
      }
      case At.TRUE:
        return "";
    }
  }, a = function(h, f) {
    return h.checks.reduce(function(d, p, g) {
      return d + (f === h && g === 0 ? "$" : "") + i(p, f);
    }, "");
  }, s = "", o = 0; o < this.length; o++) {
    var l = this[o];
    s += a(l, l.subject), this.length > 1 && o < this.length - 1 && (s += ", ");
  }
  return this.toStringCache = s, s;
}, LMe = {
  parse: _Me,
  toString: AMe
}, mie = function(e, r, n) {
  var i, a = Pt(e), s = mt(e), o = Pt(n), l, u, h = !1, f = !1, d = !1;
  switch (r.indexOf("!") >= 0 && (r = r.replace("!", ""), f = !0), r.indexOf("@") >= 0 && (r = r.replace("@", ""), h = !0), (a || o || h) && (l = !a && !s ? "" : "" + e, u = "" + n), h && (e = l = l.toLowerCase(), n = u = u.toLowerCase()), r) {
    case "*=":
      i = l.indexOf(u) >= 0;
      break;
    case "$=":
      i = l.indexOf(u, l.length - u.length) >= 0;
      break;
    case "^=":
      i = l.indexOf(u) === 0;
      break;
    case "=":
      i = e === n;
      break;
    case ">":
      d = !0, i = e > n;
      break;
    case ">=":
      d = !0, i = e >= n;
      break;
    case "<":
      d = !0, i = e < n;
      break;
    case "<=":
      d = !0, i = e <= n;
      break;
    default:
      i = !1;
      break;
  }
  return f && (e != null || !d) && (i = !i), i;
}, RMe = function(e, r) {
  switch (r) {
    case "?":
      return !!e;
    case "!":
      return !e;
    case "^":
      return e === void 0;
  }
}, IMe = function(e) {
  return e !== void 0;
}, _R = function(e, r) {
  return e.data(r);
}, MMe = function(e, r) {
  return e[r]();
}, pn = [], Xr = function(e, r) {
  return e.checks.every(function(n) {
    return pn[n.type](n, r);
  });
};
pn[At.GROUP] = function(t, e) {
  var r = t.value;
  return r === "*" || r === e.group();
};
pn[At.STATE] = function(t, e) {
  var r = t.value;
  return EMe(r, e);
};
pn[At.ID] = function(t, e) {
  var r = t.value;
  return e.id() === r;
};
pn[At.CLASS] = function(t, e) {
  var r = t.value;
  return e.hasClass(r);
};
pn[At.META_COMPARE] = function(t, e) {
  var r = t.field, n = t.operator, i = t.value;
  return mie(MMe(e, r), n, i);
};
pn[At.DATA_COMPARE] = function(t, e) {
  var r = t.field, n = t.operator, i = t.value;
  return mie(_R(e, r), n, i);
};
pn[At.DATA_BOOL] = function(t, e) {
  var r = t.field, n = t.operator;
  return RMe(_R(e, r), n);
};
pn[At.DATA_EXIST] = function(t, e) {
  var r = t.field;
  return t.operator, IMe(_R(e, r));
};
pn[At.UNDIRECTED_EDGE] = function(t, e) {
  var r = t.nodes[0], n = t.nodes[1], i = e.source(), a = e.target();
  return Xr(r, i) && Xr(n, a) || Xr(n, i) && Xr(r, a);
};
pn[At.NODE_NEIGHBOR] = function(t, e) {
  return Xr(t.node, e) && e.neighborhood().some(function(r) {
    return r.isNode() && Xr(t.neighbor, r);
  });
};
pn[At.DIRECTED_EDGE] = function(t, e) {
  return Xr(t.source, e.source()) && Xr(t.target, e.target());
};
pn[At.NODE_SOURCE] = function(t, e) {
  return Xr(t.source, e) && e.outgoers().some(function(r) {
    return r.isNode() && Xr(t.target, r);
  });
};
pn[At.NODE_TARGET] = function(t, e) {
  return Xr(t.target, e) && e.incomers().some(function(r) {
    return r.isNode() && Xr(t.source, r);
  });
};
pn[At.CHILD] = function(t, e) {
  return Xr(t.child, e) && Xr(t.parent, e.parent());
};
pn[At.PARENT] = function(t, e) {
  return Xr(t.parent, e) && e.children().some(function(r) {
    return Xr(t.child, r);
  });
};
pn[At.DESCENDANT] = function(t, e) {
  return Xr(t.descendant, e) && e.ancestors().some(function(r) {
    return Xr(t.ancestor, r);
  });
};
pn[At.ANCESTOR] = function(t, e) {
  return Xr(t.ancestor, e) && e.descendants().some(function(r) {
    return Xr(t.descendant, r);
  });
};
pn[At.COMPOUND_SPLIT] = function(t, e) {
  return Xr(t.subject, e) && Xr(t.left, e) && Xr(t.right, e);
};
pn[At.TRUE] = function() {
  return !0;
};
pn[At.COLLECTION] = function(t, e) {
  var r = t.value;
  return r.has(e);
};
pn[At.FILTER] = function(t, e) {
  var r = t.value;
  return r(e);
};
var NMe = function(e) {
  var r = this;
  if (r.length === 1 && r[0].checks.length === 1 && r[0].checks[0].type === At.ID)
    return e.getElementById(r[0].checks[0].value).collection();
  var n = function(a) {
    for (var s = 0; s < r.length; s++) {
      var o = r[s];
      if (Xr(o, a))
        return !0;
    }
    return !1;
  };
  return r.text() == null && (n = function() {
    return !0;
  }), e.filter(n);
}, DMe = function(e) {
  for (var r = this, n = 0; n < r.length; n++) {
    var i = r[n];
    if (Xr(i, e))
      return !0;
  }
  return !1;
}, OMe = {
  matches: DMe,
  filter: NMe
}, wc = function(e) {
  this.inputText = e, this.currentSubject = null, this.compoundCount = 0, this.edgeCount = 0, this.length = 0, e == null || Pt(e) && e.match(/^\s*$/) || (La(e) ? this.addQuery({
    checks: [{
      type: At.COLLECTION,
      value: e.collection()
    }]
  }) : ln(e) ? this.addQuery({
    checks: [{
      type: At.FILTER,
      value: e
    }]
  }) : Pt(e) ? this.parse(e) || (this.invalid = !0) : Jr("A selector must be created from a string; found "));
}, Tc = wc.prototype;
[LMe, OMe].forEach(function(t) {
  return Ut(Tc, t);
});
Tc.text = function() {
  return this.inputText;
};
Tc.size = function() {
  return this.length;
};
Tc.eq = function(t) {
  return this[t];
};
Tc.sameText = function(t) {
  return !this.invalid && !t.invalid && this.text() === t.text();
};
Tc.addQuery = function(t) {
  this[this.length++] = t;
};
Tc.selector = Tc.toString;
var oc = {
  allAre: function(e) {
    var r = new wc(e);
    return this.every(function(n) {
      return r.matches(n);
    });
  },
  is: function(e) {
    var r = new wc(e);
    return this.some(function(n) {
      return r.matches(n);
    });
  },
  some: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var i = r ? e.apply(r, [this[n], n, this]) : e(this[n], n, this);
      if (i)
        return !0;
    }
    return !1;
  },
  every: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var i = r ? e.apply(r, [this[n], n, this]) : e(this[n], n, this);
      if (!i)
        return !1;
    }
    return !0;
  },
  same: function(e) {
    if (this === e)
      return !0;
    e = this.cy().collection(e);
    var r = this.length, n = e.length;
    return r !== n ? !1 : r === 1 ? this[0] === e[0] : this.every(function(i) {
      return e.hasElementWithId(i.id());
    });
  },
  anySame: function(e) {
    return e = this.cy().collection(e), this.some(function(r) {
      return e.hasElementWithId(r.id());
    });
  },
  allAreNeighbors: function(e) {
    e = this.cy().collection(e);
    var r = this.neighborhood();
    return e.every(function(n) {
      return r.hasElementWithId(n.id());
    });
  },
  contains: function(e) {
    e = this.cy().collection(e);
    var r = this;
    return e.every(function(n) {
      return r.hasElementWithId(n.id());
    });
  }
};
oc.allAreNeighbours = oc.allAreNeighbors;
oc.has = oc.contains;
oc.equal = oc.equals = oc.same;
var Qa = function(e, r) {
  return function(i, a, s, o) {
    var l = i, u = this, h;
    if (l == null ? h = "" : La(l) && l.length === 1 && (h = l.id()), u.length === 1 && h) {
      var f = u[0]._private, d = f.traversalCache = f.traversalCache || {}, p = d[r] = d[r] || [], g = th(h), m = p[g];
      return m || (p[g] = e.call(u, i, a, s, o));
    } else
      return e.call(u, i, a, s, o);
  };
}, f0 = {
  parent: function(e) {
    var r = [];
    if (this.length === 1) {
      var n = this[0]._private.parent;
      if (n)
        return n;
    }
    for (var i = 0; i < this.length; i++) {
      var a = this[i], s = a._private.parent;
      s && r.push(s);
    }
    return this.spawn(r, !0).filter(e);
  },
  parents: function(e) {
    for (var r = [], n = this.parent(); n.nonempty(); ) {
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        r.push(a);
      }
      n = n.parent();
    }
    return this.spawn(r, !0).filter(e);
  },
  commonAncestors: function(e) {
    for (var r, n = 0; n < this.length; n++) {
      var i = this[n], a = i.parents();
      r = r || a, r = r.intersect(a);
    }
    return r.filter(e);
  },
  orphans: function(e) {
    return this.stdFilter(function(r) {
      return r.isOrphan();
    }).filter(e);
  },
  nonorphans: function(e) {
    return this.stdFilter(function(r) {
      return r.isChild();
    }).filter(e);
  },
  children: Qa(function(t) {
    for (var e = [], r = 0; r < this.length; r++)
      for (var n = this[r], i = n._private.children, a = 0; a < i.length; a++)
        e.push(i[a]);
    return this.spawn(e, !0).filter(t);
  }, "children"),
  siblings: function(e) {
    return this.parent().children().not(this).filter(e);
  },
  isParent: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.children.length !== 0;
  },
  isChildless: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.children.length === 0;
  },
  isChild: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.parent != null;
  },
  isOrphan: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.parent == null;
  },
  descendants: function(e) {
    var r = [];
    function n(i) {
      for (var a = 0; a < i.length; a++) {
        var s = i[a];
        r.push(s), s.children().nonempty() && n(s.children());
      }
    }
    return n(this.children()), this.spawn(r, !0).filter(e);
  }
};
function AR(t, e, r, n) {
  for (var i = [], a = new q0(), s = t.cy(), o = s.hasCompoundNodes(), l = 0; l < t.length; l++) {
    var u = t[l];
    r ? i.push(u) : o && n(i, a, u);
  }
  for (; i.length > 0; ) {
    var h = i.shift();
    e(h), a.add(h.id()), o && n(i, a, h);
  }
  return t;
}
function vie(t, e, r) {
  if (r.isParent())
    for (var n = r._private.children, i = 0; i < n.length; i++) {
      var a = n[i];
      e.has(a.id()) || t.push(a);
    }
}
f0.forEachDown = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return AR(this, t, e, vie);
};
function yie(t, e, r) {
  if (r.isChild()) {
    var n = r._private.parent;
    e.has(n.id()) || t.push(n);
  }
}
f0.forEachUp = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return AR(this, t, e, yie);
};
function PMe(t, e, r) {
  yie(t, e, r), vie(t, e, r);
}
f0.forEachUpAndDown = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return AR(this, t, e, PMe);
};
f0.ancestors = f0.parents;
var _1, bie;
_1 = bie = {
  data: Ar.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "data",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    immutableKeys: {
      id: !0,
      source: !0,
      target: !0,
      parent: !0
    },
    updateStyle: !0
  }),
  removeData: Ar.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: !0,
    immutableKeys: {
      id: !0,
      source: !0,
      target: !0,
      parent: !0
    },
    updateStyle: !0
  }),
  scratch: Ar.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "scratch",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeScratch: Ar.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  }),
  rscratch: Ar.data({
    field: "rscratch",
    allowBinding: !1,
    allowSetting: !0,
    settingTriggersEvent: !1,
    allowGetting: !0
  }),
  removeRscratch: Ar.removeData({
    field: "rscratch",
    triggerEvent: !1
  }),
  id: function() {
    var e = this[0];
    if (e)
      return e._private.data.id;
  }
};
_1.attr = _1.data;
_1.removeAttr = _1.removeData;
var $Me = bie, r3 = {};
function YC(t) {
  return function(e) {
    var r = this;
    if (e === void 0 && (e = !0), r.length !== 0)
      if (r.isNode() && !r.removed()) {
        for (var n = 0, i = r[0], a = i._private.edges, s = 0; s < a.length; s++) {
          var o = a[s];
          !e && o.isLoop() || (n += t(i, o));
        }
        return n;
      } else
        return;
  };
}
Ut(r3, {
  degree: YC(function(t, e) {
    return e.source().same(e.target()) ? 2 : 1;
  }),
  indegree: YC(function(t, e) {
    return e.target().same(t) ? 1 : 0;
  }),
  outdegree: YC(function(t, e) {
    return e.source().same(t) ? 1 : 0;
  })
});
function tf(t, e) {
  return function(r) {
    for (var n, i = this.nodes(), a = 0; a < i.length; a++) {
      var s = i[a], o = s[t](r);
      o !== void 0 && (n === void 0 || e(o, n)) && (n = o);
    }
    return n;
  };
}
Ut(r3, {
  minDegree: tf("degree", function(t, e) {
    return t < e;
  }),
  maxDegree: tf("degree", function(t, e) {
    return t > e;
  }),
  minIndegree: tf("indegree", function(t, e) {
    return t < e;
  }),
  maxIndegree: tf("indegree", function(t, e) {
    return t > e;
  }),
  minOutdegree: tf("outdegree", function(t, e) {
    return t < e;
  }),
  maxOutdegree: tf("outdegree", function(t, e) {
    return t > e;
  })
});
Ut(r3, {
  totalDegree: function(e) {
    for (var r = 0, n = this.nodes(), i = 0; i < n.length; i++)
      r += n[i].degree(e);
    return r;
  }
});
var _s, xie, wie = function(e, r, n) {
  for (var i = 0; i < e.length; i++) {
    var a = e[i];
    if (!a.locked()) {
      var s = a._private.position, o = {
        x: r.x != null ? r.x - s.x : 0,
        y: r.y != null ? r.y - s.y : 0
      };
      a.isParent() && !(o.x === 0 && o.y === 0) && a.children().shift(o, n), a.dirtyBoundingBoxCache();
    }
  }
}, $G = {
  field: "position",
  bindingEvent: "position",
  allowBinding: !0,
  allowSetting: !0,
  settingEvent: "position",
  settingTriggersEvent: !0,
  triggerFnName: "emitAndNotify",
  allowGetting: !0,
  validKeys: ["x", "y"],
  beforeGet: function(e) {
    e.updateCompoundBounds();
  },
  beforeSet: function(e, r) {
    wie(e, r, !1);
  },
  onSet: function(e) {
    e.dirtyCompoundBoundsCache();
  },
  canSet: function(e) {
    return !e.locked();
  }
};
_s = xie = {
  position: Ar.data($G),
  // position but no notification to renderer
  silentPosition: Ar.data(Ut({}, $G, {
    allowBinding: !1,
    allowSetting: !0,
    settingTriggersEvent: !1,
    allowGetting: !1,
    beforeSet: function(e, r) {
      wie(e, r, !0);
    },
    onSet: function(e) {
      e.dirtyCompoundBoundsCache();
    }
  })),
  positions: function(e, r) {
    if (yr(e))
      r ? this.silentPosition(e) : this.position(e);
    else if (ln(e)) {
      var n = e, i = this.cy();
      i.startBatch();
      for (var a = 0; a < this.length; a++) {
        var s = this[a], o = void 0;
        (o = n(s, a)) && (r ? s.silentPosition(o) : s.position(o));
      }
      i.endBatch();
    }
    return this;
  },
  silentPositions: function(e) {
    return this.positions(e, !0);
  },
  shift: function(e, r, n) {
    var i;
    if (yr(e) ? (i = {
      x: mt(e.x) ? e.x : 0,
      y: mt(e.y) ? e.y : 0
    }, n = r) : Pt(e) && mt(r) && (i = {
      x: 0,
      y: 0
    }, i[e] = r), i != null) {
      var a = this.cy();
      a.startBatch();
      for (var s = 0; s < this.length; s++) {
        var o = this[s];
        if (!(a.hasCompoundNodes() && o.isChild() && o.ancestors().anySame(this))) {
          var l = o.position(), u = {
            x: l.x + i.x,
            y: l.y + i.y
          };
          n ? o.silentPosition(u) : o.position(u);
        }
      }
      a.endBatch();
    }
    return this;
  },
  silentShift: function(e, r) {
    return yr(e) ? this.shift(e, !0) : Pt(e) && mt(r) && this.shift(e, r, !0), this;
  },
  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function(e, r) {
    var n = this[0], i = this.cy(), a = i.zoom(), s = i.pan(), o = yr(e) ? e : void 0, l = o !== void 0 || r !== void 0 && Pt(e);
    if (n && n.isNode())
      if (l)
        for (var u = 0; u < this.length; u++) {
          var h = this[u];
          r !== void 0 ? h.position(e, (r - s[e]) / a) : o !== void 0 && h.position(jne(o, a, s));
        }
      else {
        var f = n.position();
        return o = K4(f, a, s), e === void 0 ? o : o[e];
      }
    else if (!l)
      return;
    return this;
  },
  // get/set the position relative to the parent
  relativePosition: function(e, r) {
    var n = this[0], i = this.cy(), a = yr(e) ? e : void 0, s = a !== void 0 || r !== void 0 && Pt(e), o = i.hasCompoundNodes();
    if (n && n.isNode())
      if (s)
        for (var l = 0; l < this.length; l++) {
          var u = this[l], h = o ? u.parent() : null, f = h && h.length > 0, d = f;
          f && (h = h[0]);
          var p = d ? h.position() : {
            x: 0,
            y: 0
          };
          r !== void 0 ? u.position(e, r + p[e]) : a !== void 0 && u.position({
            x: a.x + p.x,
            y: a.y + p.y
          });
        }
      else {
        var g = n.position(), m = o ? n.parent() : null, v = m && m.length > 0, y = v;
        v && (m = m[0]);
        var b = y ? m.position() : {
          x: 0,
          y: 0
        };
        return a = {
          x: g.x - b.x,
          y: g.y - b.y
        }, e === void 0 ? a : a[e];
      }
    else if (!s)
      return;
    return this;
  }
};
_s.modelPosition = _s.point = _s.position;
_s.modelPositions = _s.points = _s.positions;
_s.renderedPoint = _s.renderedPosition;
_s.relativePoint = _s.relativePosition;
var BMe = xie, qf, Vc;
qf = Vc = {};
Vc.renderedBoundingBox = function(t) {
  var e = this.boundingBox(t), r = this.cy(), n = r.zoom(), i = r.pan(), a = e.x1 * n + i.x, s = e.x2 * n + i.x, o = e.y1 * n + i.y, l = e.y2 * n + i.y;
  return {
    x1: a,
    x2: s,
    y1: o,
    y2: l,
    w: s - a,
    h: l - o
  };
};
Vc.dirtyCompoundBoundsCache = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = this.cy();
  return !e.styleEnabled() || !e.hasCompoundNodes() ? this : (this.forEachUp(function(r) {
    if (r.isParent()) {
      var n = r._private;
      n.compoundBoundsClean = !1, n.bbCache = null, t || r.emitAndNotify("bounds");
    }
  }), this);
};
Vc.updateCompoundBounds = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = this.cy();
  if (!e.styleEnabled() || !e.hasCompoundNodes())
    return this;
  if (!t && e.batching())
    return this;
  function r(s) {
    if (!s.isParent())
      return;
    var o = s._private, l = s.children(), u = s.pstyle("compound-sizing-wrt-labels").value === "include", h = {
      width: {
        val: s.pstyle("min-width").pfValue,
        left: s.pstyle("min-width-bias-left"),
        right: s.pstyle("min-width-bias-right")
      },
      height: {
        val: s.pstyle("min-height").pfValue,
        top: s.pstyle("min-height-bias-top"),
        bottom: s.pstyle("min-height-bias-bottom")
      }
    }, f = l.boundingBox({
      includeLabels: u,
      includeOverlays: !1,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: !1
    }), d = o.position;
    (f.w === 0 || f.h === 0) && (f = {
      w: s.pstyle("width").pfValue,
      h: s.pstyle("height").pfValue
    }, f.x1 = d.x - f.w / 2, f.x2 = d.x + f.w / 2, f.y1 = d.y - f.h / 2, f.y2 = d.y + f.h / 2);
    function p(_, R, L) {
      var M = 0, P = 0, C = R + L;
      return _ > 0 && C > 0 && (M = R / C * _, P = L / C * _), {
        biasDiff: M,
        biasComplementDiff: P
      };
    }
    function g(_, R, L, M) {
      if (L.units === "%")
        switch (M) {
          case "width":
            return _ > 0 ? L.pfValue * _ : 0;
          case "height":
            return R > 0 ? L.pfValue * R : 0;
          case "average":
            return _ > 0 && R > 0 ? L.pfValue * (_ + R) / 2 : 0;
          case "min":
            return _ > 0 && R > 0 ? _ > R ? L.pfValue * R : L.pfValue * _ : 0;
          case "max":
            return _ > 0 && R > 0 ? _ > R ? L.pfValue * _ : L.pfValue * R : 0;
          default:
            return 0;
        }
      else return L.units === "px" ? L.pfValue : 0;
    }
    var m = h.width.left.value;
    h.width.left.units === "px" && h.width.val > 0 && (m = m * 100 / h.width.val);
    var v = h.width.right.value;
    h.width.right.units === "px" && h.width.val > 0 && (v = v * 100 / h.width.val);
    var y = h.height.top.value;
    h.height.top.units === "px" && h.height.val > 0 && (y = y * 100 / h.height.val);
    var b = h.height.bottom.value;
    h.height.bottom.units === "px" && h.height.val > 0 && (b = b * 100 / h.height.val);
    var x = p(h.width.val - f.w, m, v), T = x.biasDiff, E = x.biasComplementDiff, A = p(h.height.val - f.h, y, b), S = A.biasDiff, k = A.biasComplementDiff;
    o.autoPadding = g(f.w, f.h, s.pstyle("padding"), s.pstyle("padding-relative-to").value), o.autoWidth = Math.max(f.w, h.width.val), d.x = (-T + f.x1 + f.x2 + E) / 2, o.autoHeight = Math.max(f.h, h.height.val), d.y = (-S + f.y1 + f.y2 + k) / 2;
  }
  for (var n = 0; n < this.length; n++) {
    var i = this[n], a = i._private;
    (!a.compoundBoundsClean || t) && (r(i), e.batching() || (a.compoundBoundsClean = !0));
  }
  return this;
};
var Wa = function(e) {
  return e === 1 / 0 || e === -1 / 0 ? 0 : e;
}, ys = function(e, r, n, i, a) {
  i - r === 0 || a - n === 0 || r == null || n == null || i == null || a == null || (e.x1 = r < e.x1 ? r : e.x1, e.x2 = i > e.x2 ? i : e.x2, e.y1 = n < e.y1 ? n : e.y1, e.y2 = a > e.y2 ? a : e.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1);
}, Wl = function(e, r) {
  return r == null ? e : ys(e, r.x1, r.y1, r.x2, r.y2);
}, gp = function(e, r, n) {
  return aa(e, r, n);
}, Mv = function(e, r, n) {
  if (!r.cy().headless()) {
    var i = r._private, a = i.rstyle, s = a.arrowWidth / 2, o = r.pstyle(n + "-arrow-shape").value, l, u;
    if (o !== "none") {
      n === "source" ? (l = a.srcX, u = a.srcY) : n === "target" ? (l = a.tgtX, u = a.tgtY) : (l = a.midX, u = a.midY);
      var h = i.arrowBounds = i.arrowBounds || {}, f = h[n] = h[n] || {};
      f.x1 = l - s, f.y1 = u - s, f.x2 = l + s, f.y2 = u + s, f.w = f.x2 - f.x1, f.h = f.y2 - f.y1, Py(f, 1), ys(e, f.x1, f.y1, f.x2, f.y2);
    }
  }
}, XC = function(e, r, n) {
  if (!r.cy().headless()) {
    var i;
    n ? i = n + "-" : i = "";
    var a = r._private, s = a.rstyle, o = r.pstyle(i + "label").strValue;
    if (o) {
      var l = r.pstyle("text-halign"), u = r.pstyle("text-valign"), h = gp(s, "labelWidth", n), f = gp(s, "labelHeight", n), d = gp(s, "labelX", n), p = gp(s, "labelY", n), g = r.pstyle(i + "text-margin-x").pfValue, m = r.pstyle(i + "text-margin-y").pfValue, v = r.isEdge(), y = r.pstyle(i + "text-rotation"), b = r.pstyle("text-outline-width").pfValue, x = r.pstyle("text-border-width").pfValue, T = x / 2, E = r.pstyle("text-background-padding").pfValue, A = 2, S = f, k = h, _ = k / 2, R = S / 2, L, M, P, C;
      if (v)
        L = d - _, M = d + _, P = p - R, C = p + R;
      else {
        switch (l.value) {
          case "left":
            L = d - k, M = d;
            break;
          case "center":
            L = d - _, M = d + _;
            break;
          case "right":
            L = d, M = d + k;
            break;
        }
        switch (u.value) {
          case "top":
            P = p - S, C = p;
            break;
          case "center":
            P = p - R, C = p + R;
            break;
          case "bottom":
            P = p, C = p + S;
            break;
        }
      }
      var I = g - Math.max(b, T) - E - A, N = g + Math.max(b, T) + E + A, O = m - Math.max(b, T) - E - A, D = m + Math.max(b, T) + E + A;
      L += I, M += N, P += O, C += D;
      var $ = n || "main", z = a.labelBounds, B = z[$] = z[$] || {};
      B.x1 = L, B.y1 = P, B.x2 = M, B.y2 = C, B.w = M - L, B.h = C - P, B.leftPad = I, B.rightPad = N, B.topPad = O, B.botPad = D;
      var G = v && y.strValue === "autorotate", W = y.pfValue != null && y.pfValue !== 0;
      if (G || W) {
        var V = G ? gp(a.rstyle, "labelAngle", n) : y.pfValue, U = Math.cos(V), Z = Math.sin(V), K = (L + M) / 2, ce = (P + C) / 2;
        if (!v) {
          switch (l.value) {
            case "left":
              K = M;
              break;
            case "right":
              K = L;
              break;
          }
          switch (u.value) {
            case "top":
              ce = C;
              break;
            case "bottom":
              ce = P;
              break;
          }
        }
        var J = function(xe, Y) {
          return xe = xe - K, Y = Y - ce, {
            x: xe * U - Y * Z + K,
            y: xe * Z + Y * U + ce
          };
        }, ee = J(L, P), j = J(L, C), X = J(M, P), re = J(M, C);
        L = Math.min(ee.x, j.x, X.x, re.x), M = Math.max(ee.x, j.x, X.x, re.x), P = Math.min(ee.y, j.y, X.y, re.y), C = Math.max(ee.y, j.y, X.y, re.y);
      }
      var Q = $ + "Rot", ue = z[Q] = z[Q] || {};
      ue.x1 = L, ue.y1 = P, ue.x2 = M, ue.y2 = C, ue.w = M - L, ue.h = C - P, ys(e, L, P, M, C), ys(a.labelBounds.all, L, P, M, C);
    }
    return e;
  }
}, BG = function(e, r) {
  if (!r.cy().headless()) {
    var n = r.pstyle("outline-opacity").value, i = r.pstyle("outline-width").value, a = r.pstyle("outline-offset").value, s = i + a;
    Tie(e, r, n, s, "outside", s / 2);
  }
}, Tie = function(e, r, n, i, a, s) {
  if (!(n === 0 || i <= 0 || a === "inside")) {
    var o = r.cy(), l = r.pstyle("shape").value, u = o.renderer().nodeShapes[l], h = r.position(), f = h.x, d = h.y, p = r.width(), g = r.height();
    if (u.hasMiterBounds) {
      a === "center" && (i /= 2);
      var m = u.miterBounds(f, d, p, g, i);
      Wl(e, m);
    } else s != null && s > 0 && $y(e, [s, s, s, s]);
  }
}, FMe = function(e, r) {
  if (!r.cy().headless()) {
    var n = r.pstyle("border-opacity").value, i = r.pstyle("border-width").pfValue, a = r.pstyle("border-position").value;
    Tie(e, r, n, i, a);
  }
}, zMe = function(e, r) {
  var n = e._private.cy, i = n.styleEnabled(), a = n.headless(), s = ji(), o = e._private, l = e.isNode(), u = e.isEdge(), h, f, d, p, g, m, v = o.rstyle, y = l && i ? e.pstyle("bounds-expansion").pfValue : [0], b = function(ne) {
    return ne.pstyle("display").value !== "none";
  }, x = !i || b(e) && (!u || b(e.source()) && b(e.target()));
  if (x) {
    var T = 0, E = 0;
    i && r.includeOverlays && (T = e.pstyle("overlay-opacity").value, T !== 0 && (E = e.pstyle("overlay-padding").value));
    var A = 0, S = 0;
    i && r.includeUnderlays && (A = e.pstyle("underlay-opacity").value, A !== 0 && (S = e.pstyle("underlay-padding").value));
    var k = Math.max(E, S), _ = 0, R = 0;
    if (i && (_ = e.pstyle("width").pfValue, R = _ / 2), l && r.includeNodes) {
      var L = e.position();
      g = L.x, m = L.y;
      var M = e.outerWidth(), P = M / 2, C = e.outerHeight(), I = C / 2;
      h = g - P, f = g + P, d = m - I, p = m + I, ys(s, h, d, f, p), i && BG(s, e), i && r.includeOutlines && !a && BG(s, e), i && FMe(s, e);
    } else if (u && r.includeEdges)
      if (i && !a) {
        var N = e.pstyle("curve-style").strValue;
        if (h = Math.min(v.srcX, v.midX, v.tgtX), f = Math.max(v.srcX, v.midX, v.tgtX), d = Math.min(v.srcY, v.midY, v.tgtY), p = Math.max(v.srcY, v.midY, v.tgtY), h -= R, f += R, d -= R, p += R, ys(s, h, d, f, p), N === "haystack") {
          var O = v.haystackPts;
          if (O && O.length === 2) {
            if (h = O[0].x, d = O[0].y, f = O[1].x, p = O[1].y, h > f) {
              var D = h;
              h = f, f = D;
            }
            if (d > p) {
              var $ = d;
              d = p, p = $;
            }
            ys(s, h - R, d - R, f + R, p + R);
          }
        } else if (N === "bezier" || N === "unbundled-bezier" || ec(N, "segments") || ec(N, "taxi")) {
          var z;
          switch (N) {
            case "bezier":
            case "unbundled-bezier":
              z = v.bezierPts;
              break;
            case "segments":
            case "taxi":
            case "round-segments":
            case "round-taxi":
              z = v.linePts;
              break;
          }
          if (z != null)
            for (var B = 0; B < z.length; B++) {
              var G = z[B];
              h = G.x - R, f = G.x + R, d = G.y - R, p = G.y + R, ys(s, h, d, f, p);
            }
        }
      } else {
        var W = e.source(), V = W.position(), U = e.target(), Z = U.position();
        if (h = V.x, f = Z.x, d = V.y, p = Z.y, h > f) {
          var K = h;
          h = f, f = K;
        }
        if (d > p) {
          var ce = d;
          d = p, p = ce;
        }
        h -= R, f += R, d -= R, p += R, ys(s, h, d, f, p);
      }
    if (i && r.includeEdges && u && (Mv(s, e, "mid-source"), Mv(s, e, "mid-target"), Mv(s, e, "source"), Mv(s, e, "target")), i) {
      var J = e.pstyle("ghost").value === "yes";
      if (J) {
        var ee = e.pstyle("ghost-offset-x").pfValue, j = e.pstyle("ghost-offset-y").pfValue;
        ys(s, s.x1 + ee, s.y1 + j, s.x2 + ee, s.y2 + j);
      }
    }
    var X = o.bodyBounds = o.bodyBounds || {};
    Eq(X, s), $y(X, y), Py(X, 1), i && (h = s.x1, f = s.x2, d = s.y1, p = s.y2, ys(s, h - k, d - k, f + k, p + k));
    var re = o.overlayBounds = o.overlayBounds || {};
    Eq(re, s), $y(re, y), Py(re, 1);
    var Q = o.labelBounds = o.labelBounds || {};
    Q.all != null ? wRe(Q.all) : Q.all = ji(), i && r.includeLabels && (r.includeMainLabels && XC(s, e, null), u && (r.includeSourceLabels && XC(s, e, "source"), r.includeTargetLabels && XC(s, e, "target")));
  }
  return s.x1 = Wa(s.x1), s.y1 = Wa(s.y1), s.x2 = Wa(s.x2), s.y2 = Wa(s.y2), s.w = Wa(s.x2 - s.x1), s.h = Wa(s.y2 - s.y1), s.w > 0 && s.h > 0 && x && ($y(s, y), Py(s, 1)), s;
}, Eie = function(e) {
  var r = 0, n = function(s) {
    return (s ? 1 : 0) << r++;
  }, i = 0;
  return i += n(e.incudeNodes), i += n(e.includeEdges), i += n(e.includeLabels), i += n(e.includeMainLabels), i += n(e.includeSourceLabels), i += n(e.includeTargetLabels), i += n(e.includeOverlays), i += n(e.includeOutlines), i;
}, Sie = function(e) {
  var r = function(o) {
    return Math.round(o);
  };
  if (e.isEdge()) {
    var n = e.source().position(), i = e.target().position();
    return vq([r(n.x), r(n.y), r(i.x), r(i.y)]);
  } else {
    var a = e.position();
    return vq([r(a.x), r(a.y)]);
  }
}, FG = function(e, r) {
  var n = e._private, i, a = e.isEdge(), s = r == null ? zG : Eie(r), o = s === zG;
  if (n.bbCache == null ? (i = zMe(e, A1), n.bbCache = i, n.bbCachePosKey = Sie(e)) : i = n.bbCache, !o) {
    var l = e.isNode();
    i = ji(), (r.includeNodes && l || r.includeEdges && !l) && (r.includeOverlays ? Wl(i, n.overlayBounds) : Wl(i, n.bodyBounds)), r.includeLabels && (r.includeMainLabels && (!a || r.includeSourceLabels && r.includeTargetLabels) ? Wl(i, n.labelBounds.all) : (r.includeMainLabels && Wl(i, n.labelBounds.mainRot), r.includeSourceLabels && Wl(i, n.labelBounds.sourceRot), r.includeTargetLabels && Wl(i, n.labelBounds.targetRot))), i.w = i.x2 - i.x1, i.h = i.y2 - i.y1;
  }
  return i;
}, A1 = {
  includeNodes: !0,
  includeEdges: !0,
  includeLabels: !0,
  includeMainLabels: !0,
  includeSourceLabels: !0,
  includeTargetLabels: !0,
  includeOverlays: !0,
  includeUnderlays: !0,
  includeOutlines: !0,
  useCache: !0
}, zG = Eie(A1), qG = vi(A1);
Vc.boundingBox = function(t) {
  var e, r = t === void 0 || t.useCache === void 0 || t.useCache === !0, n = u0(function(h) {
    var f = h._private;
    return f.bbCache == null || f.styleDirty || f.bbCachePosKey !== Sie(h);
  }, function(h) {
    return h.id();
  });
  if (r && this.length === 1 && !n(this[0]))
    t === void 0 ? t = A1 : t = qG(t), e = FG(this[0], t);
  else {
    e = ji(), t = t || A1;
    var i = qG(t), a = this, s = a.cy(), o = s.styleEnabled();
    this.edges().forEach(n), this.nodes().forEach(n), o && this.recalculateRenderedStyle(r), this.updateCompoundBounds(!r);
    for (var l = 0; l < a.length; l++) {
      var u = a[l];
      n(u) && u.dirtyBoundingBoxCache(), Wl(e, FG(u, i));
    }
  }
  return e.x1 = Wa(e.x1), e.y1 = Wa(e.y1), e.x2 = Wa(e.x2), e.y2 = Wa(e.y2), e.w = Wa(e.x2 - e.x1), e.h = Wa(e.y2 - e.y1), e;
};
Vc.dirtyBoundingBoxCache = function() {
  for (var t = 0; t < this.length; t++) {
    var e = this[t]._private;
    e.bbCache = null, e.bbCachePosKey = null, e.bodyBounds = null, e.overlayBounds = null, e.labelBounds.all = null, e.labelBounds.source = null, e.labelBounds.target = null, e.labelBounds.main = null, e.labelBounds.sourceRot = null, e.labelBounds.targetRot = null, e.labelBounds.mainRot = null, e.arrowBounds.source = null, e.arrowBounds.target = null, e.arrowBounds["mid-source"] = null, e.arrowBounds["mid-target"] = null;
  }
  return this.emitAndNotify("bounds"), this;
};
Vc.boundingBoxAt = function(t) {
  var e = this.nodes(), r = this.cy(), n = r.hasCompoundNodes(), i = r.collection();
  if (n && (i = e.filter(function(u) {
    return u.isParent();
  }), e = e.not(i)), yr(t)) {
    var a = t;
    t = function() {
      return a;
    };
  }
  var s = function(h, f) {
    return h._private.bbAtOldPos = t(h, f);
  }, o = function(h) {
    return h._private.bbAtOldPos;
  };
  r.startBatch(), e.forEach(s).silentPositions(t), n && (i.dirtyCompoundBoundsCache(), i.dirtyBoundingBoxCache(), i.updateCompoundBounds(!0));
  var l = xRe(this.boundingBox({
    useCache: !1
  }));
  return e.silentPositions(o), n && (i.dirtyCompoundBoundsCache(), i.dirtyBoundingBoxCache(), i.updateCompoundBounds(!0)), r.endBatch(), l;
};
qf.boundingbox = qf.bb = qf.boundingBox;
qf.renderedBoundingbox = qf.renderedBoundingBox;
var qMe = Vc, Up, km;
Up = km = {};
var kie = function(e) {
  e.uppercaseName = rq(e.name), e.autoName = "auto" + e.uppercaseName, e.labelName = "label" + e.uppercaseName, e.outerName = "outer" + e.uppercaseName, e.uppercaseOuterName = rq(e.outerName), Up[e.name] = function() {
    var n = this[0], i = n._private, a = i.cy, s = a._private.styleEnabled;
    if (n)
      if (s) {
        if (n.isParent())
          return n.updateCompoundBounds(), i[e.autoName] || 0;
        var o = n.pstyle(e.name);
        switch (o.strValue) {
          case "label":
            return n.recalculateRenderedStyle(), i.rstyle[e.labelName] || 0;
          default:
            return o.pfValue;
        }
      } else
        return 1;
  }, Up["outer" + e.uppercaseName] = function() {
    var n = this[0], i = n._private, a = i.cy, s = a._private.styleEnabled;
    if (n)
      if (s) {
        var o = n[e.name](), l = n.pstyle("border-position").value, u;
        l === "center" ? u = n.pstyle("border-width").pfValue : l === "outside" ? u = 2 * n.pstyle("border-width").pfValue : u = 0;
        var h = 2 * n.padding();
        return o + u + h;
      } else
        return 1;
  }, Up["rendered" + e.uppercaseName] = function() {
    var n = this[0];
    if (n) {
      var i = n[e.name]();
      return i * this.cy().zoom();
    }
  }, Up["rendered" + e.uppercaseOuterName] = function() {
    var n = this[0];
    if (n) {
      var i = n[e.outerName]();
      return i * this.cy().zoom();
    }
  };
};
kie({
  name: "width"
});
kie({
  name: "height"
});
km.padding = function() {
  var t = this[0], e = t._private;
  return t.isParent() ? (t.updateCompoundBounds(), e.autoPadding !== void 0 ? e.autoPadding : t.pstyle("padding").pfValue) : t.pstyle("padding").pfValue;
};
km.paddedHeight = function() {
  var t = this[0];
  return t.height() + 2 * t.padding();
};
km.paddedWidth = function() {
  var t = this[0];
  return t.width() + 2 * t.padding();
};
var GMe = km, UMe = function(e, r) {
  if (e.isEdge() && e.takesUpSpace())
    return r(e);
}, VMe = function(e, r) {
  if (e.isEdge() && e.takesUpSpace()) {
    var n = e.cy();
    return K4(r(e), n.zoom(), n.pan());
  }
}, HMe = function(e, r) {
  if (e.isEdge() && e.takesUpSpace()) {
    var n = e.cy(), i = n.pan(), a = n.zoom();
    return r(e).map(function(s) {
      return K4(s, a, i);
    });
  }
}, WMe = function(e) {
  return e.renderer().getControlPoints(e);
}, YMe = function(e) {
  return e.renderer().getSegmentPoints(e);
}, XMe = function(e) {
  return e.renderer().getSourceEndpoint(e);
}, jMe = function(e) {
  return e.renderer().getTargetEndpoint(e);
}, KMe = function(e) {
  return e.renderer().getEdgeMidpoint(e);
}, GG = {
  controlPoints: {
    get: WMe,
    mult: !0
  },
  segmentPoints: {
    get: YMe,
    mult: !0
  },
  sourceEndpoint: {
    get: XMe
  },
  targetEndpoint: {
    get: jMe
  },
  midpoint: {
    get: KMe
  }
}, ZMe = function(e) {
  return "rendered" + e[0].toUpperCase() + e.substr(1);
}, QMe = Object.keys(GG).reduce(function(t, e) {
  var r = GG[e], n = ZMe(e);
  return t[e] = function() {
    return UMe(this, r.get);
  }, r.mult ? t[n] = function() {
    return HMe(this, r.get);
  } : t[n] = function() {
    return VMe(this, r.get);
  }, t;
}, {}), JMe = Ut({}, BMe, qMe, GMe, QMe);
/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/
var Cie = function(e, r) {
  this.recycle(e, r);
};
function mp() {
  return !1;
}
function Nv() {
  return !0;
}
Cie.prototype = {
  instanceString: function() {
    return "event";
  },
  recycle: function(e, r) {
    if (this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = mp, e != null && e.preventDefault ? (this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? Nv : mp) : e != null && e.type ? r = e : this.type = e, r != null && (this.originalEvent = r.originalEvent, this.type = r.type != null ? r.type : this.type, this.cy = r.cy, this.target = r.target, this.position = r.position, this.renderedPosition = r.renderedPosition, this.namespace = r.namespace, this.layout = r.layout), this.cy != null && this.position != null && this.renderedPosition == null) {
      var n = this.position, i = this.cy.zoom(), a = this.cy.pan();
      this.renderedPosition = {
        x: n.x * i + a.x,
        y: n.y * i + a.y
      };
    }
    this.timeStamp = e && e.timeStamp || Date.now();
  },
  preventDefault: function() {
    this.isDefaultPrevented = Nv;
    var e = this.originalEvent;
    e && e.preventDefault && e.preventDefault();
  },
  stopPropagation: function() {
    this.isPropagationStopped = Nv;
    var e = this.originalEvent;
    e && e.stopPropagation && e.stopPropagation();
  },
  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = Nv, this.stopPropagation();
  },
  isDefaultPrevented: mp,
  isPropagationStopped: mp,
  isImmediatePropagationStopped: mp
};
var _ie = /^([^.]+)(\.(?:[^.]+))?$/, eNe = ".*", Aie = {
  qualifierCompare: function(e, r) {
    return e === r;
  },
  eventMatches: function() {
    return !0;
  },
  addEventFields: function() {
  },
  callbackContext: function(e) {
    return e;
  },
  beforeEmit: function() {
  },
  afterEmit: function() {
  },
  bubble: function() {
    return !1;
  },
  parent: function() {
    return null;
  },
  context: null
}, UG = Object.keys(Aie), tNe = {};
function n3() {
  for (var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : tNe, e = arguments.length > 1 ? arguments[1] : void 0, r = 0; r < UG.length; r++) {
    var n = UG[r];
    this[n] = t[n] || Aie[n];
  }
  this.context = e || this.context, this.listeners = [], this.emitting = 0;
}
var Ec = n3.prototype, Lie = function(e, r, n, i, a, s, o) {
  ln(i) && (a = i, i = null), o && (s == null ? s = o : s = Ut({}, s, o));
  for (var l = Pr(n) ? n : n.split(/\s+/), u = 0; u < l.length; u++) {
    var h = l[u];
    if (!yc(h)) {
      var f = h.match(_ie);
      if (f) {
        var d = f[1], p = f[2] ? f[2] : null, g = r(e, h, d, p, i, a, s);
        if (g === !1)
          break;
      }
    }
  }
}, VG = function(e, r) {
  return e.addEventFields(e.context, r), new Cie(r.type, r);
}, rNe = function(e, r, n) {
  if (lLe(n)) {
    r(e, n);
    return;
  } else if (yr(n)) {
    r(e, VG(e, n));
    return;
  }
  for (var i = Pr(n) ? n : n.split(/\s+/), a = 0; a < i.length; a++) {
    var s = i[a];
    if (!yc(s)) {
      var o = s.match(_ie);
      if (o) {
        var l = o[1], u = o[2] ? o[2] : null, h = VG(e, {
          type: l,
          namespace: u,
          target: e.context
        });
        r(e, h);
      }
    }
  }
};
Ec.on = Ec.addListener = function(t, e, r, n, i) {
  return Lie(this, function(a, s, o, l, u, h, f) {
    ln(h) && a.listeners.push({
      event: s,
      // full event string
      callback: h,
      // callback to run
      type: o,
      // the event type (e.g. 'click')
      namespace: l,
      // the event namespace (e.g. ".foo")
      qualifier: u,
      // a restriction on whether to match this emitter
      conf: f
      // additional configuration
    });
  }, t, e, r, n, i), this;
};
Ec.one = function(t, e, r, n) {
  return this.on(t, e, r, n, {
    one: !0
  });
};
Ec.removeListener = Ec.off = function(t, e, r, n) {
  var i = this;
  this.emitting !== 0 && (this.listeners = VLe(this.listeners));
  for (var a = this.listeners, s = function(u) {
    var h = a[u];
    Lie(i, function(f, d, p, g, m, v) {
      if ((h.type === p || t === "*") && (!g && h.namespace !== ".*" || h.namespace === g) && (!m || f.qualifierCompare(h.qualifier, m)) && (!v || h.callback === v))
        return a.splice(u, 1), !1;
    }, t, e, r, n);
  }, o = a.length - 1; o >= 0; o--)
    s(o);
  return this;
};
Ec.removeAllListeners = function() {
  return this.removeListener("*");
};
Ec.emit = Ec.trigger = function(t, e, r) {
  var n = this.listeners, i = n.length;
  return this.emitting++, Pr(e) || (e = [e]), rNe(this, function(a, s) {
    r != null && (n = [{
      event: s.event,
      type: s.type,
      namespace: s.namespace,
      callback: r
    }], i = n.length);
    for (var o = function() {
      var h = n[l];
      if (h.type === s.type && (!h.namespace || h.namespace === s.namespace || h.namespace === eNe) && a.eventMatches(a.context, h, s)) {
        var f = [s];
        e != null && WLe(f, e), a.beforeEmit(a.context, h, s), h.conf && h.conf.one && (a.listeners = a.listeners.filter(function(g) {
          return g !== h;
        }));
        var d = a.callbackContext(a.context, h, s), p = h.callback.apply(d, f);
        a.afterEmit(a.context, h, s), p === !1 && (s.stopPropagation(), s.preventDefault());
      }
    }, l = 0; l < i; l++)
      o();
    a.bubble(a.context) && !s.isPropagationStopped() && a.parent(a.context).emit(s, e);
  }, t), this.emitting--, this;
};
var nNe = {
  qualifierCompare: function(e, r) {
    return e == null || r == null ? e == null && r == null : e.sameText(r);
  },
  eventMatches: function(e, r, n) {
    var i = r.qualifier;
    return i != null ? e !== n.target && bm(n.target) && i.matches(n.target) : !0;
  },
  addEventFields: function(e, r) {
    r.cy = e.cy(), r.target = e;
  },
  callbackContext: function(e, r, n) {
    return r.qualifier != null ? n.target : e;
  },
  beforeEmit: function(e, r) {
    r.conf && r.conf.once && r.conf.onceCollection.removeListener(r.event, r.qualifier, r.callback);
  },
  bubble: function() {
    return !0;
  },
  parent: function(e) {
    return e.isChild() ? e.parent() : e.cy();
  }
}, Dv = function(e) {
  return Pt(e) ? new wc(e) : e;
}, Rie = {
  createEmitter: function() {
    for (var e = 0; e < this.length; e++) {
      var r = this[e], n = r._private;
      n.emitter || (n.emitter = new n3(nNe, r));
    }
    return this;
  },
  emitter: function() {
    return this._private.emitter;
  },
  on: function(e, r, n) {
    for (var i = Dv(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().on(e, i, n);
    }
    return this;
  },
  removeListener: function(e, r, n) {
    for (var i = Dv(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().removeListener(e, i, n);
    }
    return this;
  },
  removeAllListeners: function() {
    for (var e = 0; e < this.length; e++) {
      var r = this[e];
      r.emitter().removeAllListeners();
    }
    return this;
  },
  one: function(e, r, n) {
    for (var i = Dv(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().one(e, i, n);
    }
    return this;
  },
  once: function(e, r, n) {
    for (var i = Dv(r), a = 0; a < this.length; a++) {
      var s = this[a];
      s.emitter().on(e, i, n, {
        once: !0,
        onceCollection: this
      });
    }
  },
  emit: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var i = this[n];
      i.emitter().emit(e, r);
    }
    return this;
  },
  emitAndNotify: function(e, r) {
    if (this.length !== 0)
      return this.cy().notify(e, this), this.emit(e, r), this;
  }
};
Ar.eventAliasesOn(Rie);
var Iie = {
  nodes: function(e) {
    return this.filter(function(r) {
      return r.isNode();
    }).filter(e);
  },
  edges: function(e) {
    return this.filter(function(r) {
      return r.isEdge();
    }).filter(e);
  },
  // internal helper to get nodes and edges as separate collections with single iteration over elements
  byGroup: function() {
    for (var e = this.spawn(), r = this.spawn(), n = 0; n < this.length; n++) {
      var i = this[n];
      i.isNode() ? e.push(i) : r.push(i);
    }
    return {
      nodes: e,
      edges: r
    };
  },
  filter: function(e, r) {
    if (e === void 0)
      return this;
    if (Pt(e) || La(e))
      return new wc(e).filter(this);
    if (ln(e)) {
      for (var n = this.spawn(), i = this, a = 0; a < i.length; a++) {
        var s = i[a], o = r ? e.apply(r, [s, a, i]) : e(s, a, i);
        o && n.push(s);
      }
      return n;
    }
    return this.spawn();
  },
  not: function(e) {
    if (e) {
      Pt(e) && (e = this.filter(e));
      for (var r = this.spawn(), n = 0; n < this.length; n++) {
        var i = this[n], a = e.has(i);
        a || r.push(i);
      }
      return r;
    } else
      return this;
  },
  absoluteComplement: function() {
    var e = this.cy();
    return e.mutableElements().not(this);
  },
  intersect: function(e) {
    if (Pt(e)) {
      var r = e;
      return this.filter(r);
    }
    for (var n = this.spawn(), i = this, a = e, s = this.length < e.length, o = s ? i : a, l = s ? a : i, u = 0; u < o.length; u++) {
      var h = o[u];
      l.has(h) && n.push(h);
    }
    return n;
  },
  xor: function(e) {
    var r = this._private.cy;
    Pt(e) && (e = r.$(e));
    var n = this.spawn(), i = this, a = e, s = function(l, u) {
      for (var h = 0; h < l.length; h++) {
        var f = l[h], d = f._private.data.id, p = u.hasElementWithId(d);
        p || n.push(f);
      }
    };
    return s(i, a), s(a, i), n;
  },
  diff: function(e) {
    var r = this._private.cy;
    Pt(e) && (e = r.$(e));
    var n = this.spawn(), i = this.spawn(), a = this.spawn(), s = this, o = e, l = function(h, f, d) {
      for (var p = 0; p < h.length; p++) {
        var g = h[p], m = g._private.data.id, v = f.hasElementWithId(m);
        v ? a.merge(g) : d.push(g);
      }
    };
    return l(s, o, n), l(o, s, i), {
      left: n,
      right: i,
      both: a
    };
  },
  add: function(e) {
    var r = this._private.cy;
    if (!e)
      return this;
    if (Pt(e)) {
      var n = e;
      e = r.mutableElements().filter(n);
    }
    for (var i = this.spawnSelf(), a = 0; a < e.length; a++) {
      var s = e[a], o = !this.has(s);
      o && i.push(s);
    }
    return i;
  },
  // in place merge on calling collection
  merge: function(e) {
    var r = this._private, n = r.cy;
    if (!e)
      return this;
    if (e && Pt(e)) {
      var i = e;
      e = n.mutableElements().filter(i);
    }
    for (var a = r.map, s = 0; s < e.length; s++) {
      var o = e[s], l = o._private.data.id, u = !a.has(l);
      if (u) {
        var h = this.length++;
        this[h] = o, a.set(l, {
          ele: o,
          index: h
        });
      }
    }
    return this;
  },
  unmergeAt: function(e) {
    var r = this[e], n = r.id(), i = this._private, a = i.map;
    this[e] = void 0, a.delete(n);
    var s = e === this.length - 1;
    if (this.length > 1 && !s) {
      var o = this.length - 1, l = this[o], u = l._private.data.id;
      this[o] = void 0, this[e] = l, a.set(u, {
        ele: l,
        index: e
      });
    }
    return this.length--, this;
  },
  // remove single ele in place in calling collection
  unmergeOne: function(e) {
    e = e[0];
    var r = this._private, n = e._private.data.id, i = r.map, a = i.get(n);
    if (!a)
      return this;
    var s = a.index;
    return this.unmergeAt(s), this;
  },
  // remove eles in place on calling collection
  unmerge: function(e) {
    var r = this._private.cy;
    if (!e)
      return this;
    if (e && Pt(e)) {
      var n = e;
      e = r.mutableElements().filter(n);
    }
    for (var i = 0; i < e.length; i++)
      this.unmergeOne(e[i]);
    return this;
  },
  unmergeBy: function(e) {
    for (var r = this.length - 1; r >= 0; r--) {
      var n = this[r];
      e(n) && this.unmergeAt(r);
    }
    return this;
  },
  map: function(e, r) {
    for (var n = [], i = this, a = 0; a < i.length; a++) {
      var s = i[a], o = r ? e.apply(r, [s, a, i]) : e(s, a, i);
      n.push(o);
    }
    return n;
  },
  reduce: function(e, r) {
    for (var n = r, i = this, a = 0; a < i.length; a++)
      n = e(n, i[a], a, i);
    return n;
  },
  max: function(e, r) {
    for (var n = -1 / 0, i, a = this, s = 0; s < a.length; s++) {
      var o = a[s], l = r ? e.apply(r, [o, s, a]) : e(o, s, a);
      l > n && (n = l, i = o);
    }
    return {
      value: n,
      ele: i
    };
  },
  min: function(e, r) {
    for (var n = 1 / 0, i, a = this, s = 0; s < a.length; s++) {
      var o = a[s], l = r ? e.apply(r, [o, s, a]) : e(o, s, a);
      l < n && (n = l, i = o);
    }
    return {
      value: n,
      ele: i
    };
  }
}, Er = Iie;
Er.u = Er["|"] = Er["+"] = Er.union = Er.or = Er.add;
Er["\\"] = Er["!"] = Er["-"] = Er.difference = Er.relativeComplement = Er.subtract = Er.not;
Er.n = Er["&"] = Er["."] = Er.and = Er.intersection = Er.intersect;
Er["^"] = Er["(+)"] = Er["(-)"] = Er.symmetricDifference = Er.symdiff = Er.xor;
Er.fnFilter = Er.filterFn = Er.stdFilter = Er.filter;
Er.complement = Er.abscomp = Er.absoluteComplement;
var iNe = {
  isNode: function() {
    return this.group() === "nodes";
  },
  isEdge: function() {
    return this.group() === "edges";
  },
  isLoop: function() {
    return this.isEdge() && this.source()[0] === this.target()[0];
  },
  isSimple: function() {
    return this.isEdge() && this.source()[0] !== this.target()[0];
  },
  group: function() {
    var e = this[0];
    if (e)
      return e._private.group;
  }
}, Mie = function(e, r) {
  var n = e.cy(), i = n.hasCompoundNodes();
  function a(h) {
    var f = h.pstyle("z-compound-depth");
    return f.value === "auto" ? i ? h.zDepth() : 0 : f.value === "bottom" ? -1 : f.value === "top" ? vR : 0;
  }
  var s = a(e) - a(r);
  if (s !== 0)
    return s;
  function o(h) {
    var f = h.pstyle("z-index-compare");
    return f.value === "auto" && h.isNode() ? 1 : 0;
  }
  var l = o(e) - o(r);
  if (l !== 0)
    return l;
  var u = e.pstyle("z-index").value - r.pstyle("z-index").value;
  return u !== 0 ? u : e.poolIndex() - r.poolIndex();
}, Nb = {
  forEach: function(e, r) {
    if (ln(e))
      for (var n = this.length, i = 0; i < n; i++) {
        var a = this[i], s = r ? e.apply(r, [a, i, this]) : e(a, i, this);
        if (s === !1)
          break;
      }
    return this;
  },
  toArray: function() {
    for (var e = [], r = 0; r < this.length; r++)
      e.push(this[r]);
    return e;
  },
  slice: function(e, r) {
    var n = [], i = this.length;
    r == null && (r = i), e == null && (e = 0), e < 0 && (e = i + e), r < 0 && (r = i + r);
    for (var a = e; a >= 0 && a < r && a < i; a++)
      n.push(this[a]);
    return this.spawn(n);
  },
  size: function() {
    return this.length;
  },
  eq: function(e) {
    return this[e] || this.spawn();
  },
  first: function() {
    return this[0] || this.spawn();
  },
  last: function() {
    return this[this.length - 1] || this.spawn();
  },
  empty: function() {
    return this.length === 0;
  },
  nonempty: function() {
    return !this.empty();
  },
  sort: function(e) {
    if (!ln(e))
      return this;
    var r = this.toArray().sort(e);
    return this.spawn(r);
  },
  sortByZIndex: function() {
    return this.sort(Mie);
  },
  zDepth: function() {
    var e = this[0];
    if (e) {
      var r = e._private, n = r.group;
      if (n === "nodes") {
        var i = r.data.parent ? e.parents().size() : 0;
        return e.isParent() ? i : vR - 1;
      } else {
        var a = r.source, s = r.target, o = a.zDepth(), l = s.zDepth();
        return Math.max(o, l, 0);
      }
    }
  }
};
Nb.each = Nb.forEach;
var aNe = function() {
  var e = "undefined", r = (typeof Symbol > "u" ? "undefined" : Vn(Symbol)) != e && Vn(Symbol.iterator) != e;
  r && (Nb[Symbol.iterator] = function() {
    var n = this, i = {
      value: void 0,
      done: !1
    }, a = 0, s = this.length;
    return Rne({
      next: function() {
        return a < s ? i.value = n[a++] : (i.value = void 0, i.done = !0), i;
      }
    }, Symbol.iterator, function() {
      return this;
    });
  });
};
aNe();
var sNe = vi({
  nodeDimensionsIncludeLabels: !1
}), Fy = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function(e) {
    e = sNe(e);
    var r;
    if (!this.takesUpSpace())
      r = {
        w: 0,
        h: 0
      };
    else if (e.nodeDimensionsIncludeLabels) {
      var n = this.boundingBox();
      r = {
        w: n.w,
        h: n.h
      };
    } else
      r = {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    return (r.w === 0 || r.h === 0) && (r.w = r.h = 1), r;
  },
  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function(e, r, n) {
    var i = this.nodes().filter(function(E) {
      return !E.isParent();
    }), a = this.cy(), s = r.eles, o = function(A) {
      return A.id();
    }, l = u0(n, o);
    e.emit({
      type: "layoutstart",
      layout: e
    }), e.animations = [];
    var u = function(A, S, k) {
      var _ = {
        x: S.x1 + S.w / 2,
        y: S.y1 + S.h / 2
      }, R = {
        // scale from center of bounding box (not necessarily 0,0)
        x: (k.x - _.x) * A,
        y: (k.y - _.y) * A
      };
      return {
        x: _.x + R.x,
        y: _.y + R.y
      };
    }, h = r.spacingFactor && r.spacingFactor !== 1, f = function() {
      if (!h)
        return null;
      for (var A = ji(), S = 0; S < i.length; S++) {
        var k = i[S], _ = l(k, S);
        Kne(A, _.x, _.y);
      }
      return A;
    }, d = f(), p = u0(function(E, A) {
      var S = l(E, A);
      if (h) {
        var k = Math.abs(r.spacingFactor);
        S = u(k, d, S);
      }
      return r.transform != null && (S = r.transform(E, S)), S;
    }, o);
    if (r.animate) {
      for (var g = 0; g < i.length; g++) {
        var m = i[g], v = p(m, g), y = r.animateFilter == null || r.animateFilter(m, g);
        if (y) {
          var b = m.animation({
            position: v,
            duration: r.animationDuration,
            easing: r.animationEasing
          });
          e.animations.push(b);
        } else
          m.position(v);
      }
      if (r.fit) {
        var x = a.animation({
          fit: {
            boundingBox: s.boundingBoxAt(p),
            padding: r.padding
          },
          duration: r.animationDuration,
          easing: r.animationEasing
        });
        e.animations.push(x);
      } else if (r.zoom !== void 0 && r.pan !== void 0) {
        var T = a.animation({
          zoom: r.zoom,
          pan: r.pan,
          duration: r.animationDuration,
          easing: r.animationEasing
        });
        e.animations.push(T);
      }
      e.animations.forEach(function(E) {
        return E.play();
      }), e.one("layoutready", r.ready), e.emit({
        type: "layoutready",
        layout: e
      }), G0.all(e.animations.map(function(E) {
        return E.promise();
      })).then(function() {
        e.one("layoutstop", r.stop), e.emit({
          type: "layoutstop",
          layout: e
        });
      });
    } else
      i.positions(p), r.fit && a.fit(r.eles, r.padding), r.zoom != null && a.zoom(r.zoom), r.pan && a.pan(r.pan), e.one("layoutready", r.ready), e.emit({
        type: "layoutready",
        layout: e
      }), e.one("layoutstop", r.stop), e.emit({
        type: "layoutstop",
        layout: e
      });
    return this;
  },
  layout: function(e) {
    var r = this.cy();
    return r.makeLayout(Ut({}, e, {
      eles: this
    }));
  }
};
Fy.createLayout = Fy.makeLayout = Fy.layout;
function Nie(t, e, r) {
  var n = r._private, i = n.styleCache = n.styleCache || [], a;
  return (a = i[t]) != null || (a = i[t] = e(r)), a;
}
function i3(t, e) {
  return t = th(t), function(n) {
    return Nie(t, e, n);
  };
}
function a3(t, e) {
  t = th(t);
  var r = function(i) {
    return e.call(i);
  };
  return function() {
    var i = this[0];
    if (i)
      return Nie(t, r, i);
  };
}
var di = {
  recalculateRenderedStyle: function(e) {
    var r = this.cy(), n = r.renderer(), i = r.styleEnabled();
    return n && i && n.recalculateRenderedStyle(this, e), this;
  },
  dirtyStyleCache: function() {
    var e = this.cy(), r = function(a) {
      return a._private.styleCache = null;
    };
    if (e.hasCompoundNodes()) {
      var n;
      n = this.spawnSelf().merge(this.descendants()).merge(this.parents()), n.merge(n.connectedEdges()), n.forEach(r);
    } else
      this.forEach(function(i) {
        r(i), i.connectedEdges().forEach(r);
      });
    return this;
  },
  // fully updates (recalculates) the style for the elements
  updateStyle: function(e) {
    var r = this._private.cy;
    if (!r.styleEnabled())
      return this;
    if (r.batching()) {
      var n = r._private.batchStyleEles;
      return n.merge(this), this;
    }
    var i = r.hasCompoundNodes(), a = this;
    e = !!(e || e === void 0), i && (a = this.spawnSelf().merge(this.descendants()).merge(this.parents()));
    var s = a;
    return e ? s.emitAndNotify("style") : s.emit("style"), a.forEach(function(o) {
      return o._private.styleDirty = !0;
    }), this;
  },
  // private: clears dirty flag and recalculates style
  cleanStyle: function() {
    var e = this.cy();
    if (e.styleEnabled())
      for (var r = 0; r < this.length; r++) {
        var n = this[r];
        n._private.styleDirty && (n._private.styleDirty = !1, e.style().apply(n));
      }
  },
  // get the internal parsed style object for the specified property
  parsedStyle: function(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = this[0], i = n.cy();
    if (i.styleEnabled() && n) {
      n._private.styleDirty && (n._private.styleDirty = !1, i.style().apply(n));
      var a = n._private.style[e];
      return a ?? (r ? i.style().getDefaultProperty(e) : null);
    }
  },
  numericStyle: function(e) {
    var r = this[0];
    if (r.cy().styleEnabled() && r) {
      var n = r.pstyle(e);
      return n.pfValue !== void 0 ? n.pfValue : n.value;
    }
  },
  numericStyleUnits: function(e) {
    var r = this[0];
    if (r.cy().styleEnabled() && r)
      return r.pstyle(e).units;
  },
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function(e) {
    var r = this.cy();
    if (!r.styleEnabled())
      return this;
    var n = this[0];
    if (n)
      return r.style().getRenderedStyle(n, e);
  },
  // read the calculated css style of the element or override the style (via a bypass)
  style: function(e, r) {
    var n = this.cy();
    if (!n.styleEnabled())
      return this;
    var i = !1, a = n.style();
    if (yr(e)) {
      var s = e;
      a.applyBypass(this, s, i), this.emitAndNotify("style");
    } else if (Pt(e))
      if (r === void 0) {
        var o = this[0];
        return o ? a.getStylePropertyValue(o, e) : void 0;
      } else
        a.applyBypass(this, e, r, i), this.emitAndNotify("style");
    else if (e === void 0) {
      var l = this[0];
      return l ? a.getRawStyle(l) : void 0;
    }
    return this;
  },
  removeStyle: function(e) {
    var r = this.cy();
    if (!r.styleEnabled())
      return this;
    var n = !1, i = r.style(), a = this;
    if (e === void 0)
      for (var s = 0; s < a.length; s++) {
        var o = a[s];
        i.removeAllBypasses(o, n);
      }
    else {
      e = e.split(/\s+/);
      for (var l = 0; l < a.length; l++) {
        var u = a[l];
        i.removeBypasses(u, e, n);
      }
    }
    return this.emitAndNotify("style"), this;
  },
  show: function() {
    return this.css("display", "element"), this;
  },
  hide: function() {
    return this.css("display", "none"), this;
  },
  effectiveOpacity: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return 1;
    var r = e.hasCompoundNodes(), n = this[0];
    if (n) {
      var i = n._private, a = n.pstyle("opacity").value;
      if (!r)
        return a;
      var s = i.data.parent ? n.parents() : null;
      if (s)
        for (var o = 0; o < s.length; o++) {
          var l = s[o], u = l.pstyle("opacity").value;
          a = u * a;
        }
      return a;
    }
  },
  transparent: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return !1;
    var r = this[0], n = r.cy().hasCompoundNodes();
    if (r)
      return n ? r.effectiveOpacity() === 0 : r.pstyle("opacity").value === 0;
  },
  backgrounding: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return !1;
    var r = this[0];
    return !!r._private.backgrounding;
  }
};
function jC(t, e) {
  var r = t._private, n = r.data.parent ? t.parents() : null;
  if (n)
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      if (!e(a))
        return !1;
    }
  return !0;
}
function LR(t) {
  var e = t.ok, r = t.edgeOkViaNode || t.ok, n = t.parentOk || t.ok;
  return function() {
    var i = this.cy();
    if (!i.styleEnabled())
      return !0;
    var a = this[0], s = i.hasCompoundNodes();
    if (a) {
      var o = a._private;
      if (!e(a))
        return !1;
      if (a.isNode())
        return !s || jC(a, n);
      var l = o.source, u = o.target;
      return r(l) && (!s || jC(l, r)) && (l === u || r(u) && (!s || jC(u, r)));
    }
  };
}
var U0 = i3("eleTakesUpSpace", function(t) {
  return t.pstyle("display").value === "element" && t.width() !== 0 && (t.isNode() ? t.height() !== 0 : !0);
});
di.takesUpSpace = a3("takesUpSpace", LR({
  ok: U0
}));
var oNe = i3("eleInteractive", function(t) {
  return t.pstyle("events").value === "yes" && t.pstyle("visibility").value === "visible" && U0(t);
}), lNe = i3("parentInteractive", function(t) {
  return t.pstyle("visibility").value === "visible" && U0(t);
});
di.interactive = a3("interactive", LR({
  ok: oNe,
  parentOk: lNe,
  edgeOkViaNode: U0
}));
di.noninteractive = function() {
  var t = this[0];
  if (t)
    return !t.interactive();
};
var cNe = i3("eleVisible", function(t) {
  return t.pstyle("visibility").value === "visible" && t.pstyle("opacity").pfValue !== 0 && U0(t);
}), uNe = U0;
di.visible = a3("visible", LR({
  ok: cNe,
  edgeOkViaNode: uNe
}));
di.hidden = function() {
  var t = this[0];
  if (t)
    return !t.visible();
};
di.isBundledBezier = a3("isBundledBezier", function() {
  return this.cy().styleEnabled() ? !this.removed() && this.pstyle("curve-style").value === "bezier" && this.takesUpSpace() : !1;
});
di.bypass = di.css = di.style;
di.renderedCss = di.renderedStyle;
di.removeBypass = di.removeCss = di.removeStyle;
di.pstyle = di.parsedStyle;
var lc = {};
function HG(t) {
  return function() {
    var e = arguments, r = [];
    if (e.length === 2) {
      var n = e[0], i = e[1];
      this.on(t.event, n, i);
    } else if (e.length === 1 && ln(e[0])) {
      var a = e[0];
      this.on(t.event, a);
    } else if (e.length === 0 || e.length === 1 && Pr(e[0])) {
      for (var s = e.length === 1 ? e[0] : null, o = 0; o < this.length; o++) {
        var l = this[o], u = !t.ableField || l._private[t.ableField], h = l._private[t.field] != t.value;
        if (t.overrideAble) {
          var f = t.overrideAble(l);
          if (f !== void 0 && (u = f, !f))
            return this;
        }
        u && (l._private[t.field] = t.value, h && r.push(l));
      }
      var d = this.spawn(r);
      d.updateStyle(), d.emit(t.event), s && d.emit(s);
    }
    return this;
  };
}
function V0(t) {
  lc[t.field] = function() {
    var e = this[0];
    if (e) {
      if (t.overrideField) {
        var r = t.overrideField(e);
        if (r !== void 0)
          return r;
      }
      return e._private[t.field];
    }
  }, lc[t.on] = HG({
    event: t.on,
    field: t.field,
    ableField: t.ableField,
    overrideAble: t.overrideAble,
    value: !0
  }), lc[t.off] = HG({
    event: t.off,
    field: t.field,
    ableField: t.ableField,
    overrideAble: t.overrideAble,
    value: !1
  });
}
V0({
  field: "locked",
  overrideField: function(e) {
    return e.cy().autolock() ? !0 : void 0;
  },
  on: "lock",
  off: "unlock"
});
V0({
  field: "grabbable",
  overrideField: function(e) {
    return e.cy().autoungrabify() || e.pannable() ? !1 : void 0;
  },
  on: "grabify",
  off: "ungrabify"
});
V0({
  field: "selected",
  ableField: "selectable",
  overrideAble: function(e) {
    return e.cy().autounselectify() ? !1 : void 0;
  },
  on: "select",
  off: "unselect"
});
V0({
  field: "selectable",
  overrideField: function(e) {
    return e.cy().autounselectify() ? !1 : void 0;
  },
  on: "selectify",
  off: "unselectify"
});
lc.deselect = lc.unselect;
lc.grabbed = function() {
  var t = this[0];
  if (t)
    return t._private.grabbed;
};
V0({
  field: "active",
  on: "activate",
  off: "unactivate"
});
V0({
  field: "pannable",
  on: "panify",
  off: "unpanify"
});
lc.inactive = function() {
  var t = this[0];
  if (t)
    return !t._private.active;
};
var Li = {}, WG = function(e) {
  return function(n) {
    for (var i = this, a = [], s = 0; s < i.length; s++) {
      var o = i[s];
      if (o.isNode()) {
        for (var l = !1, u = o.connectedEdges(), h = 0; h < u.length; h++) {
          var f = u[h], d = f.source(), p = f.target();
          if (e.noIncomingEdges && p === o && d !== o || e.noOutgoingEdges && d === o && p !== o) {
            l = !0;
            break;
          }
        }
        l || a.push(o);
      }
    }
    return this.spawn(a, !0).filter(n);
  };
}, YG = function(e) {
  return function(r) {
    for (var n = this, i = [], a = 0; a < n.length; a++) {
      var s = n[a];
      if (s.isNode())
        for (var o = s.connectedEdges(), l = 0; l < o.length; l++) {
          var u = o[l], h = u.source(), f = u.target();
          e.outgoing && h === s ? (i.push(u), i.push(f)) : e.incoming && f === s && (i.push(u), i.push(h));
        }
    }
    return this.spawn(i, !0).filter(r);
  };
}, XG = function(e) {
  return function(r) {
    for (var n = this, i = [], a = {}; ; ) {
      var s = e.outgoing ? n.outgoers() : n.incomers();
      if (s.length === 0)
        break;
      for (var o = !1, l = 0; l < s.length; l++) {
        var u = s[l], h = u.id();
        a[h] || (a[h] = !0, i.push(u), o = !0);
      }
      if (!o)
        break;
      n = s;
    }
    return this.spawn(i, !0).filter(r);
  };
};
Li.clearTraversalCache = function() {
  for (var t = 0; t < this.length; t++)
    this[t]._private.traversalCache = null;
};
Ut(Li, {
  // get the root nodes in the DAG
  roots: WG({
    noIncomingEdges: !0
  }),
  // get the leaf nodes in the DAG
  leaves: WG({
    noOutgoingEdges: !0
  }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: Qa(YG({
    outgoing: !0
  }), "outgoers"),
  // aka DAG descendants
  successors: XG({
    outgoing: !0
  }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: Qa(YG({
    incoming: !0
  }), "incomers"),
  // aka DAG ancestors
  predecessors: XG({})
});
Ut(Li, {
  neighborhood: Qa(function(t) {
    for (var e = [], r = this.nodes(), n = 0; n < r.length; n++)
      for (var i = r[n], a = i.connectedEdges(), s = 0; s < a.length; s++) {
        var o = a[s], l = o.source(), u = o.target(), h = i === l ? u : l;
        h.length > 0 && e.push(h[0]), e.push(o[0]);
      }
    return this.spawn(e, !0).filter(t);
  }, "neighborhood"),
  closedNeighborhood: function(e) {
    return this.neighborhood().add(this).filter(e);
  },
  openNeighborhood: function(e) {
    return this.neighborhood(e);
  }
});
Li.neighbourhood = Li.neighborhood;
Li.closedNeighbourhood = Li.closedNeighborhood;
Li.openNeighbourhood = Li.openNeighborhood;
Ut(Li, {
  source: Qa(function(e) {
    var r = this[0], n;
    return r && (n = r._private.source || r.cy().collection()), n && e ? n.filter(e) : n;
  }, "source"),
  target: Qa(function(e) {
    var r = this[0], n;
    return r && (n = r._private.target || r.cy().collection()), n && e ? n.filter(e) : n;
  }, "target"),
  sources: jG({
    attr: "source"
  }),
  targets: jG({
    attr: "target"
  })
});
function jG(t) {
  return function(r) {
    for (var n = [], i = 0; i < this.length; i++) {
      var a = this[i], s = a._private[t.attr];
      s && n.push(s);
    }
    return this.spawn(n, !0).filter(r);
  };
}
Ut(Li, {
  edgesWith: Qa(KG(), "edgesWith"),
  edgesTo: Qa(KG({
    thisIsSrc: !0
  }), "edgesTo")
});
function KG(t) {
  return function(r) {
    var n = [], i = this._private.cy, a = t || {};
    Pt(r) && (r = i.$(r));
    for (var s = 0; s < r.length; s++)
      for (var o = r[s]._private.edges, l = 0; l < o.length; l++) {
        var u = o[l], h = u._private.data, f = this.hasElementWithId(h.source) && r.hasElementWithId(h.target), d = r.hasElementWithId(h.source) && this.hasElementWithId(h.target), p = f || d;
        p && ((a.thisIsSrc || a.thisIsTgt) && (a.thisIsSrc && !f || a.thisIsTgt && !d) || n.push(u));
      }
    return this.spawn(n, !0);
  };
}
Ut(Li, {
  connectedEdges: Qa(function(t) {
    for (var e = [], r = this, n = 0; n < r.length; n++) {
      var i = r[n];
      if (i.isNode())
        for (var a = i._private.edges, s = 0; s < a.length; s++) {
          var o = a[s];
          e.push(o);
        }
    }
    return this.spawn(e, !0).filter(t);
  }, "connectedEdges"),
  connectedNodes: Qa(function(t) {
    for (var e = [], r = this, n = 0; n < r.length; n++) {
      var i = r[n];
      i.isEdge() && (e.push(i.source()[0]), e.push(i.target()[0]));
    }
    return this.spawn(e, !0).filter(t);
  }, "connectedNodes"),
  parallelEdges: Qa(ZG(), "parallelEdges"),
  codirectedEdges: Qa(ZG({
    codirected: !0
  }), "codirectedEdges")
});
function ZG(t) {
  var e = {
    codirected: !1
  };
  return t = Ut({}, e, t), function(n) {
    for (var i = [], a = this.edges(), s = t, o = 0; o < a.length; o++)
      for (var l = a[o], u = l._private, h = u.source, f = h._private.data.id, d = u.data.target, p = h._private.edges, g = 0; g < p.length; g++) {
        var m = p[g], v = m._private.data, y = v.target, b = v.source, x = y === d && b === f, T = f === y && d === b;
        (s.codirected && x || !s.codirected && (x || T)) && i.push(m);
      }
    return this.spawn(i, !0).filter(n);
  };
}
Ut(Li, {
  components: function(e) {
    var r = this, n = r.cy(), i = n.collection(), a = e == null ? r.nodes() : e.nodes(), s = [];
    e != null && a.empty() && (a = e.sources());
    var o = function(h, f) {
      i.merge(h), a.unmerge(h), f.merge(h);
    };
    if (a.empty())
      return r.spawn();
    var l = function() {
      var h = n.collection();
      s.push(h);
      var f = a[0];
      o(f, h), r.bfs({
        directed: !1,
        roots: f,
        visit: function(p) {
          return o(p, h);
        }
      }), h.forEach(function(d) {
        d.connectedEdges().forEach(function(p) {
          r.has(p) && h.has(p.source()) && h.has(p.target()) && h.merge(p);
        });
      });
    };
    do
      l();
    while (a.length > 0);
    return s;
  },
  component: function() {
    var e = this[0];
    return e.cy().mutableElements().components(e)[0];
  }
});
Li.componentsOf = Li.components;
var pi = function(e, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (e === void 0) {
    Jr("A collection must have a reference to the core");
    return;
  }
  var a = new el(), s = !1;
  if (!r)
    r = [];
  else if (r.length > 0 && yr(r[0]) && !bm(r[0])) {
    s = !0;
    for (var o = [], l = new q0(), u = 0, h = r.length; u < h; u++) {
      var f = r[u];
      f.data == null && (f.data = {});
      var d = f.data;
      if (d.id == null)
        d.id = Yne();
      else if (e.hasElementWithId(d.id) || l.has(d.id))
        continue;
      var p = new j4(e, f, !1);
      o.push(p), l.add(d.id);
    }
    r = o;
  }
  this.length = 0;
  for (var g = 0, m = r.length; g < m; g++) {
    var v = r[g][0];
    if (v != null) {
      var y = v._private.data.id;
      (!n || !a.has(y)) && (n && a.set(y, {
        index: this.length,
        ele: v
      }), this[this.length] = v, this.length++);
    }
  }
  this._private = {
    eles: this,
    cy: e,
    get map() {
      return this.lazyMap == null && this.rebuildMap(), this.lazyMap;
    },
    set map(b) {
      this.lazyMap = b;
    },
    rebuildMap: function() {
      for (var x = this.lazyMap = new el(), T = this.eles, E = 0; E < T.length; E++) {
        var A = T[E];
        x.set(A.id(), {
          index: E,
          ele: A
        });
      }
    }
  }, n && (this._private.map = a), s && !i && this.restore();
}, Ur = j4.prototype = pi.prototype = Object.create(Array.prototype);
Ur.instanceString = function() {
  return "collection";
};
Ur.spawn = function(t, e) {
  return new pi(this.cy(), t, e);
};
Ur.spawnSelf = function() {
  return this.spawn(this);
};
Ur.cy = function() {
  return this._private.cy;
};
Ur.renderer = function() {
  return this._private.cy.renderer();
};
Ur.element = function() {
  return this[0];
};
Ur.collection = function() {
  return Nne(this) ? this : new pi(this._private.cy, [this]);
};
Ur.unique = function() {
  return new pi(this._private.cy, this, !0);
};
Ur.hasElementWithId = function(t) {
  return t = "" + t, this._private.map.has(t);
};
Ur.getElementById = function(t) {
  t = "" + t;
  var e = this._private.cy, r = this._private.map.get(t);
  return r ? r.ele : new pi(e);
};
Ur.$id = Ur.getElementById;
Ur.poolIndex = function() {
  var t = this._private.cy, e = t._private.elements, r = this[0]._private.data.id;
  return e._private.map.get(r).index;
};
Ur.indexOf = function(t) {
  var e = t[0]._private.data.id;
  return this._private.map.get(e).index;
};
Ur.indexOfId = function(t) {
  return t = "" + t, this._private.map.get(t).index;
};
Ur.json = function(t) {
  var e = this.element(), r = this.cy();
  if (e == null && t)
    return this;
  if (e != null) {
    var n = e._private;
    if (yr(t)) {
      if (r.startBatch(), t.data) {
        e.data(t.data);
        var i = n.data;
        if (e.isEdge()) {
          var a = !1, s = {}, o = t.data.source, l = t.data.target;
          o != null && o != i.source && (s.source = "" + o, a = !0), l != null && l != i.target && (s.target = "" + l, a = !0), a && (e = e.move(s));
        } else {
          var u = "parent" in t.data, h = t.data.parent;
          u && (h != null || i.parent != null) && h != i.parent && (h === void 0 && (h = null), h != null && (h = "" + h), e = e.move({
            parent: h
          }));
        }
      }
      t.position && e.position(t.position);
      var f = function(m, v, y) {
        var b = t[m];
        b != null && b !== n[m] && (b ? e[v]() : e[y]());
      };
      return f("removed", "remove", "restore"), f("selected", "select", "unselect"), f("selectable", "selectify", "unselectify"), f("locked", "lock", "unlock"), f("grabbable", "grabify", "ungrabify"), f("pannable", "panify", "unpanify"), t.classes != null && e.classes(t.classes), r.endBatch(), this;
    } else if (t === void 0) {
      var d = {
        data: so(n.data),
        position: so(n.position),
        group: n.group,
        removed: n.removed,
        selected: n.selected,
        selectable: n.selectable,
        locked: n.locked,
        grabbable: n.grabbable,
        pannable: n.pannable,
        classes: null
      };
      d.classes = "";
      var p = 0;
      return n.classes.forEach(function(g) {
        return d.classes += p++ === 0 ? g : " " + g;
      }), d;
    }
  }
};
Ur.jsons = function() {
  for (var t = [], e = 0; e < this.length; e++) {
    var r = this[e], n = r.json();
    t.push(n);
  }
  return t;
};
Ur.clone = function() {
  for (var t = this.cy(), e = [], r = 0; r < this.length; r++) {
    var n = this[r], i = n.json(), a = new j4(t, i, !1);
    e.push(a);
  }
  return new pi(t, e);
};
Ur.copy = Ur.clone;
Ur.restore = function() {
  for (var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = this, n = r.cy(), i = n._private, a = [], s = [], o, l = 0, u = r.length; l < u; l++) {
    var h = r[l];
    e && !h.removed() || (h.isNode() ? a.push(h) : s.push(h));
  }
  o = a.concat(s);
  var f, d = function() {
    o.splice(f, 1), f--;
  };
  for (f = 0; f < o.length; f++) {
    var p = o[f], g = p._private, m = g.data;
    if (p.clearTraversalCache(), !(!e && !g.removed)) {
      if (m.id === void 0)
        m.id = Yne();
      else if (mt(m.id))
        m.id = "" + m.id;
      else if (yc(m.id) || !Pt(m.id)) {
        Jr("Can not create element with invalid string ID `" + m.id + "`"), d();
        continue;
      } else if (n.hasElementWithId(m.id)) {
        Jr("Can not create second element with ID `" + m.id + "`"), d();
        continue;
      }
    }
    var v = m.id;
    if (p.isNode()) {
      var y = g.position;
      y.x == null && (y.x = 0), y.y == null && (y.y = 0);
    }
    if (p.isEdge()) {
      for (var b = p, x = ["source", "target"], T = x.length, E = !1, A = 0; A < T; A++) {
        var S = x[A], k = m[S];
        mt(k) && (k = m[S] = "" + m[S]), k == null || k === "" ? (Jr("Can not create edge `" + v + "` with unspecified " + S), E = !0) : n.hasElementWithId(k) || (Jr("Can not create edge `" + v + "` with nonexistant " + S + " `" + k + "`"), E = !0);
      }
      if (E) {
        d();
        continue;
      }
      var _ = n.getElementById(m.source), R = n.getElementById(m.target);
      _.same(R) ? _._private.edges.push(b) : (_._private.edges.push(b), R._private.edges.push(b)), b._private.source = _, b._private.target = R;
    }
    g.map = new el(), g.map.set(v, {
      ele: p,
      index: 0
    }), g.removed = !1, e && n.addToPool(p);
  }
  for (var L = 0; L < a.length; L++) {
    var M = a[L], P = M._private.data;
    mt(P.parent) && (P.parent = "" + P.parent);
    var C = P.parent, I = C != null;
    if (I || M._private.parent) {
      var N = M._private.parent ? n.collection().merge(M._private.parent) : n.getElementById(C);
      if (N.empty())
        P.parent = void 0;
      else if (N[0].removed())
        Rr("Node added with missing parent, reference to parent removed"), P.parent = void 0, M._private.parent = null;
      else {
        for (var O = !1, D = N; !D.empty(); ) {
          if (M.same(D)) {
            O = !0, P.parent = void 0;
            break;
          }
          D = D.parent();
        }
        O || (N[0]._private.children.push(M), M._private.parent = N[0], i.hasCompoundNodes = !0);
      }
    }
  }
  if (o.length > 0) {
    for (var $ = o.length === r.length ? r : new pi(n, o), z = 0; z < $.length; z++) {
      var B = $[z];
      B.isNode() || (B.parallelEdges().clearTraversalCache(), B.source().clearTraversalCache(), B.target().clearTraversalCache());
    }
    var G;
    i.hasCompoundNodes ? G = n.collection().merge($).merge($.connectedNodes()).merge($.parent()) : G = $, G.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(t), t ? $.emitAndNotify("add") : e && $.emit("add");
  }
  return r;
};
Ur.removed = function() {
  var t = this[0];
  return t && t._private.removed;
};
Ur.inside = function() {
  var t = this[0];
  return t && !t._private.removed;
};
Ur.remove = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = this, n = [], i = {}, a = r._private.cy;
  function s(C) {
    for (var I = C._private.edges, N = 0; N < I.length; N++)
      l(I[N]);
  }
  function o(C) {
    for (var I = C._private.children, N = 0; N < I.length; N++)
      l(I[N]);
  }
  function l(C) {
    var I = i[C.id()];
    e && C.removed() || I || (i[C.id()] = !0, C.isNode() ? (n.push(C), s(C), o(C)) : n.unshift(C));
  }
  for (var u = 0, h = r.length; u < h; u++) {
    var f = r[u];
    l(f);
  }
  function d(C, I) {
    var N = C._private.edges;
    bc(N, I), C.clearTraversalCache();
  }
  function p(C) {
    C.clearTraversalCache();
  }
  var g = [];
  g.ids = {};
  function m(C, I) {
    I = I[0], C = C[0];
    var N = C._private.children, O = C.id();
    bc(N, I), I._private.parent = null, g.ids[O] || (g.ids[O] = !0, g.push(C));
  }
  r.dirtyCompoundBoundsCache(), e && a.removeFromPool(n);
  for (var v = 0; v < n.length; v++) {
    var y = n[v];
    if (y.isEdge()) {
      var b = y.source()[0], x = y.target()[0];
      d(b, y), d(x, y);
      for (var T = y.parallelEdges(), E = 0; E < T.length; E++) {
        var A = T[E];
        p(A), A.isBundledBezier() && A.dirtyBoundingBoxCache();
      }
    } else {
      var S = y.parent();
      S.length !== 0 && m(S, y);
    }
    e && (y._private.removed = !0);
  }
  var k = a._private.elements;
  a._private.hasCompoundNodes = !1;
  for (var _ = 0; _ < k.length; _++) {
    var R = k[_];
    if (R.isParent()) {
      a._private.hasCompoundNodes = !0;
      break;
    }
  }
  var L = new pi(this.cy(), n);
  L.size() > 0 && (t ? L.emitAndNotify("remove") : e && L.emit("remove"));
  for (var M = 0; M < g.length; M++) {
    var P = g[M];
    (!e || !P.removed()) && P.updateStyle();
  }
  return L;
};
Ur.move = function(t) {
  var e = this._private.cy, r = this, n = !1, i = !1, a = function(g) {
    return g == null ? g : "" + g;
  };
  if (t.source !== void 0 || t.target !== void 0) {
    var s = a(t.source), o = a(t.target), l = s != null && e.hasElementWithId(s), u = o != null && e.hasElementWithId(o);
    (l || u) && (e.batch(function() {
      r.remove(n, i), r.emitAndNotify("moveout");
      for (var p = 0; p < r.length; p++) {
        var g = r[p], m = g._private.data;
        g.isEdge() && (l && (m.source = s), u && (m.target = o));
      }
      r.restore(n, i);
    }), r.emitAndNotify("move"));
  } else if (t.parent !== void 0) {
    var h = a(t.parent), f = h === null || e.hasElementWithId(h);
    if (f) {
      var d = h === null ? void 0 : h;
      e.batch(function() {
        var p = r.remove(n, i);
        p.emitAndNotify("moveout");
        for (var g = 0; g < r.length; g++) {
          var m = r[g], v = m._private.data;
          m.isNode() && (v.parent = d);
        }
        p.restore(n, i);
      }), r.emitAndNotify("move");
    }
  }
  return this;
};
[aie, wMe, By, oc, f0, $Me, r3, JMe, Rie, Iie, iNe, Nb, Fy, di, lc, Li].forEach(function(t) {
  Ut(Ur, t);
});
var hNe = {
  add: function(e) {
    var r, n = this;
    if (La(e)) {
      var i = e;
      if (i._private.cy === n)
        r = i.restore();
      else {
        for (var a = [], s = 0; s < i.length; s++) {
          var o = i[s];
          a.push(o.json());
        }
        r = new pi(n, a);
      }
    } else if (Pr(e)) {
      var l = e;
      r = new pi(n, l);
    } else if (yr(e) && (Pr(e.nodes) || Pr(e.edges))) {
      for (var u = e, h = [], f = ["nodes", "edges"], d = 0, p = f.length; d < p; d++) {
        var g = f[d], m = u[g];
        if (Pr(m))
          for (var v = 0, y = m.length; v < y; v++) {
            var b = Ut({
              group: g
            }, m[v]);
            h.push(b);
          }
      }
      r = new pi(n, h);
    } else {
      var x = e;
      r = new j4(n, x).collection();
    }
    return r;
  },
  remove: function(e) {
    if (!La(e)) {
      if (Pt(e)) {
        var r = e;
        e = this.$(r);
      }
    }
    return e.remove();
  }
};
/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
function fNe(t, e, r, n) {
  var i = 4, a = 1e-3, s = 1e-7, o = 10, l = 11, u = 1 / (l - 1), h = typeof Float32Array < "u";
  if (arguments.length !== 4)
    return !1;
  for (var f = 0; f < 4; ++f)
    if (typeof arguments[f] != "number" || isNaN(arguments[f]) || !isFinite(arguments[f]))
      return !1;
  t = Math.min(t, 1), r = Math.min(r, 1), t = Math.max(t, 0), r = Math.max(r, 0);
  var d = h ? new Float32Array(l) : new Array(l);
  function p(R, L) {
    return 1 - 3 * L + 3 * R;
  }
  function g(R, L) {
    return 3 * L - 6 * R;
  }
  function m(R) {
    return 3 * R;
  }
  function v(R, L, M) {
    return ((p(L, M) * R + g(L, M)) * R + m(L)) * R;
  }
  function y(R, L, M) {
    return 3 * p(L, M) * R * R + 2 * g(L, M) * R + m(L);
  }
  function b(R, L) {
    for (var M = 0; M < i; ++M) {
      var P = y(L, t, r);
      if (P === 0)
        return L;
      var C = v(L, t, r) - R;
      L -= C / P;
    }
    return L;
  }
  function x() {
    for (var R = 0; R < l; ++R)
      d[R] = v(R * u, t, r);
  }
  function T(R, L, M) {
    var P, C, I = 0;
    do
      C = L + (M - L) / 2, P = v(C, t, r) - R, P > 0 ? M = C : L = C;
    while (Math.abs(P) > s && ++I < o);
    return C;
  }
  function E(R) {
    for (var L = 0, M = 1, P = l - 1; M !== P && d[M] <= R; ++M)
      L += u;
    --M;
    var C = (R - d[M]) / (d[M + 1] - d[M]), I = L + C * u, N = y(I, t, r);
    return N >= a ? b(R, I) : N === 0 ? I : T(R, L, L + u);
  }
  var A = !1;
  function S() {
    A = !0, (t !== e || r !== n) && x();
  }
  var k = function(L) {
    return A || S(), t === e && r === n ? L : L === 0 ? 0 : L === 1 ? 1 : v(E(L), e, n);
  };
  k.getControlPoints = function() {
    return [{
      x: t,
      y: e
    }, {
      x: r,
      y: n
    }];
  };
  var _ = "generateBezier(" + [t, e, r, n] + ")";
  return k.toString = function() {
    return _;
  }, k;
}
/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
var dNe = /* @__PURE__ */ (function() {
  function t(n) {
    return -n.tension * n.x - n.friction * n.v;
  }
  function e(n, i, a) {
    var s = {
      x: n.x + a.dx * i,
      v: n.v + a.dv * i,
      tension: n.tension,
      friction: n.friction
    };
    return {
      dx: s.v,
      dv: t(s)
    };
  }
  function r(n, i) {
    var a = {
      dx: n.v,
      dv: t(n)
    }, s = e(n, i * 0.5, a), o = e(n, i * 0.5, s), l = e(n, i, o), u = 1 / 6 * (a.dx + 2 * (s.dx + o.dx) + l.dx), h = 1 / 6 * (a.dv + 2 * (s.dv + o.dv) + l.dv);
    return n.x = n.x + u * i, n.v = n.v + h * i, n;
  }
  return function n(i, a, s) {
    var o = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    }, l = [0], u = 0, h = 1 / 1e4, f = 16 / 1e3, d, p, g;
    for (i = parseFloat(i) || 500, a = parseFloat(a) || 20, s = s || null, o.tension = i, o.friction = a, d = s !== null, d ? (u = n(i, a), p = u / s * f) : p = f; g = r(g || o, p), l.push(1 + g.x), u += 16, Math.abs(g.x) > h && Math.abs(g.v) > h; )
      ;
    return d ? function(m) {
      return l[m * (l.length - 1) | 0];
    } : u;
  };
})(), Br = function(e, r, n, i) {
  var a = fNe(e, r, n, i);
  return function(s, o, l) {
    return s + (o - s) * a(l);
  };
}, zy = {
  linear: function(e, r, n) {
    return e + (r - e) * n;
  },
  // default easings
  ease: Br(0.25, 0.1, 0.25, 1),
  "ease-in": Br(0.42, 0, 1, 1),
  "ease-out": Br(0, 0, 0.58, 1),
  "ease-in-out": Br(0.42, 0, 0.58, 1),
  // sine
  "ease-in-sine": Br(0.47, 0, 0.745, 0.715),
  "ease-out-sine": Br(0.39, 0.575, 0.565, 1),
  "ease-in-out-sine": Br(0.445, 0.05, 0.55, 0.95),
  // quad
  "ease-in-quad": Br(0.55, 0.085, 0.68, 0.53),
  "ease-out-quad": Br(0.25, 0.46, 0.45, 0.94),
  "ease-in-out-quad": Br(0.455, 0.03, 0.515, 0.955),
  // cubic
  "ease-in-cubic": Br(0.55, 0.055, 0.675, 0.19),
  "ease-out-cubic": Br(0.215, 0.61, 0.355, 1),
  "ease-in-out-cubic": Br(0.645, 0.045, 0.355, 1),
  // quart
  "ease-in-quart": Br(0.895, 0.03, 0.685, 0.22),
  "ease-out-quart": Br(0.165, 0.84, 0.44, 1),
  "ease-in-out-quart": Br(0.77, 0, 0.175, 1),
  // quint
  "ease-in-quint": Br(0.755, 0.05, 0.855, 0.06),
  "ease-out-quint": Br(0.23, 1, 0.32, 1),
  "ease-in-out-quint": Br(0.86, 0, 0.07, 1),
  // expo
  "ease-in-expo": Br(0.95, 0.05, 0.795, 0.035),
  "ease-out-expo": Br(0.19, 1, 0.22, 1),
  "ease-in-out-expo": Br(1, 0, 0, 1),
  // circ
  "ease-in-circ": Br(0.6, 0.04, 0.98, 0.335),
  "ease-out-circ": Br(0.075, 0.82, 0.165, 1),
  "ease-in-out-circ": Br(0.785, 0.135, 0.15, 0.86),
  // user param easings...
  spring: function(e, r, n) {
    if (n === 0)
      return zy.linear;
    var i = dNe(e, r, n);
    return function(a, s, o) {
      return a + (s - a) * i(o);
    };
  },
  "cubic-bezier": Br
};
function QG(t, e, r, n, i) {
  if (n === 1 || e === r)
    return r;
  var a = i(e, r, n);
  return t == null || ((t.roundValue || t.color) && (a = Math.round(a)), t.min !== void 0 && (a = Math.max(a, t.min)), t.max !== void 0 && (a = Math.min(a, t.max))), a;
}
function JG(t, e) {
  return t.pfValue != null || t.value != null ? t.pfValue != null && (e == null || e.type.units !== "%") ? t.pfValue : t.value : t;
}
function rf(t, e, r, n, i) {
  var a = i != null ? i.type : null;
  r < 0 ? r = 0 : r > 1 && (r = 1);
  var s = JG(t, i), o = JG(e, i);
  if (mt(s) && mt(o))
    return QG(a, s, o, r, n);
  if (Pr(s) && Pr(o)) {
    for (var l = [], u = 0; u < o.length; u++) {
      var h = s[u], f = o[u];
      if (h != null && f != null) {
        var d = QG(a, h, f, r, n);
        l.push(d);
      } else
        l.push(f);
    }
    return l;
  }
}
function pNe(t, e, r, n) {
  var i = !n, a = t._private, s = e._private, o = s.easing, l = s.startTime, u = n ? t : t.cy(), h = u.style();
  if (!s.easingImpl)
    if (o == null)
      s.easingImpl = zy.linear;
    else {
      var f;
      if (Pt(o)) {
        var d = h.parse("transition-timing-function", o);
        f = d.value;
      } else
        f = o;
      var p, g;
      Pt(f) ? (p = f, g = []) : (p = f[1], g = f.slice(2).map(function($) {
        return +$;
      })), g.length > 0 ? (p === "spring" && g.push(s.duration), s.easingImpl = zy[p].apply(null, g)) : s.easingImpl = zy[p];
    }
  var m = s.easingImpl, v;
  if (s.duration === 0 ? v = 1 : v = (r - l) / s.duration, s.applying && (v = s.progress), v < 0 ? v = 0 : v > 1 && (v = 1), s.delay == null) {
    var y = s.startPosition, b = s.position;
    if (b && i && !t.locked()) {
      var x = {};
      vp(y.x, b.x) && (x.x = rf(y.x, b.x, v, m)), vp(y.y, b.y) && (x.y = rf(y.y, b.y, v, m)), t.position(x);
    }
    var T = s.startPan, E = s.pan, A = a.pan, S = E != null && n;
    S && (vp(T.x, E.x) && (A.x = rf(T.x, E.x, v, m)), vp(T.y, E.y) && (A.y = rf(T.y, E.y, v, m)), t.emit("pan"));
    var k = s.startZoom, _ = s.zoom, R = _ != null && n;
    R && (vp(k, _) && (a.zoom = k1(a.minZoom, rf(k, _, v, m), a.maxZoom)), t.emit("zoom")), (S || R) && t.emit("viewport");
    var L = s.style;
    if (L && L.length > 0 && i) {
      for (var M = 0; M < L.length; M++) {
        var P = L[M], C = P.name, I = P, N = s.startStyle[C], O = h.properties[N.name], D = rf(N, I, v, m, O);
        h.overrideBypass(t, C, D);
      }
      t.emit("style");
    }
  }
  return s.progress = v, v;
}
function vp(t, e) {
  return t == null || e == null ? !1 : mt(t) && mt(e) ? !0 : !!(t && e);
}
function gNe(t, e, r, n) {
  var i = e._private;
  i.started = !0, i.startTime = r - i.progress * i.duration;
}
function eU(t, e) {
  var r = e._private.aniEles, n = [];
  function i(h, f) {
    var d = h._private, p = d.animation.current, g = d.animation.queue, m = !1;
    if (p.length === 0) {
      var v = g.shift();
      v && p.push(v);
    }
    for (var y = function(A) {
      for (var S = A.length - 1; S >= 0; S--) {
        var k = A[S];
        k();
      }
      A.splice(0, A.length);
    }, b = p.length - 1; b >= 0; b--) {
      var x = p[b], T = x._private;
      if (T.stopped) {
        p.splice(b, 1), T.hooked = !1, T.playing = !1, T.started = !1, y(T.frames);
        continue;
      }
      !T.playing && !T.applying || (T.playing && T.applying && (T.applying = !1), T.started || gNe(h, x, t), pNe(h, x, t, f), T.applying && (T.applying = !1), y(T.frames), T.step != null && T.step(t), x.completed() && (p.splice(b, 1), T.hooked = !1, T.playing = !1, T.started = !1, y(T.completes)), m = !0);
    }
    return !f && p.length === 0 && g.length === 0 && n.push(h), m;
  }
  for (var a = !1, s = 0; s < r.length; s++) {
    var o = r[s], l = i(o);
    a = a || l;
  }
  var u = i(e, !0);
  (a || u) && (r.length > 0 ? e.notify("draw", r) : e.notify("draw")), r.unmerge(n), e.emit("step");
}
var mNe = {
  // pull in animation functions
  animate: Ar.animate(),
  animation: Ar.animation(),
  animated: Ar.animated(),
  clearQueue: Ar.clearQueue(),
  delay: Ar.delay(),
  delayAnimation: Ar.delayAnimation(),
  stop: Ar.stop(),
  addToAnimationPool: function(e) {
    var r = this;
    r.styleEnabled() && r._private.aniEles.merge(e);
  },
  stopAnimationLoop: function() {
    this._private.animationsRunning = !1;
  },
  startAnimationLoop: function() {
    var e = this;
    if (e._private.animationsRunning = !0, !e.styleEnabled())
      return;
    function r() {
      e._private.animationsRunning && Ab(function(a) {
        eU(a, e), r();
      });
    }
    var n = e.renderer();
    n && n.beforeRender ? n.beforeRender(function(a, s) {
      eU(s, e);
    }, n.beforeRenderPriorities.animations) : r();
  }
}, vNe = {
  qualifierCompare: function(e, r) {
    return e == null || r == null ? e == null && r == null : e.sameText(r);
  },
  eventMatches: function(e, r, n) {
    var i = r.qualifier;
    return i != null ? e !== n.target && bm(n.target) && i.matches(n.target) : !0;
  },
  addEventFields: function(e, r) {
    r.cy = e, r.target = e;
  },
  callbackContext: function(e, r, n) {
    return r.qualifier != null ? n.target : e;
  }
}, Ov = function(e) {
  return Pt(e) ? new wc(e) : e;
}, Die = {
  createEmitter: function() {
    var e = this._private;
    return e.emitter || (e.emitter = new n3(vNe, this)), this;
  },
  emitter: function() {
    return this._private.emitter;
  },
  on: function(e, r, n) {
    return this.emitter().on(e, Ov(r), n), this;
  },
  removeListener: function(e, r, n) {
    return this.emitter().removeListener(e, Ov(r), n), this;
  },
  removeAllListeners: function() {
    return this.emitter().removeAllListeners(), this;
  },
  one: function(e, r, n) {
    return this.emitter().one(e, Ov(r), n), this;
  },
  once: function(e, r, n) {
    return this.emitter().one(e, Ov(r), n), this;
  },
  emit: function(e, r) {
    return this.emitter().emit(e, r), this;
  },
  emitAndNotify: function(e, r) {
    return this.emit(e), this.notify(e, r), this;
  }
};
Ar.eventAliasesOn(Die);
var xA = {
  png: function(e) {
    var r = this._private.renderer;
    return e = e || {}, r.png(e);
  },
  jpg: function(e) {
    var r = this._private.renderer;
    return e = e || {}, e.bg = e.bg || "#fff", r.jpg(e);
  }
};
xA.jpeg = xA.jpg;
var qy = {
  layout: function(e) {
    var r = this;
    if (e == null) {
      Jr("Layout options must be specified to make a layout");
      return;
    }
    if (e.name == null) {
      Jr("A `name` must be specified to make a layout");
      return;
    }
    var n = e.name, i = r.extension("layout", n);
    if (i == null) {
      Jr("No such layout `" + n + "` found.  Did you forget to import it and `cytoscape.use()` it?");
      return;
    }
    var a;
    Pt(e.eles) ? a = r.$(e.eles) : a = e.eles != null ? e.eles : r.$();
    var s = new i(Ut({}, e, {
      cy: r,
      eles: a
    }));
    return s;
  }
};
qy.createLayout = qy.makeLayout = qy.layout;
var yNe = {
  notify: function(e, r) {
    var n = this._private;
    if (this.batching()) {
      n.batchNotifications = n.batchNotifications || {};
      var i = n.batchNotifications[e] = n.batchNotifications[e] || this.collection();
      r != null && i.merge(r);
      return;
    }
    if (n.notificationsEnabled) {
      var a = this.renderer();
      this.destroyed() || !a || a.notify(e, r);
    }
  },
  notifications: function(e) {
    var r = this._private;
    return e === void 0 ? r.notificationsEnabled : (r.notificationsEnabled = !!e, this);
  },
  noNotifications: function(e) {
    this.notifications(!1), e(), this.notifications(!0);
  },
  batching: function() {
    return this._private.batchCount > 0;
  },
  startBatch: function() {
    var e = this._private;
    return e.batchCount == null && (e.batchCount = 0), e.batchCount === 0 && (e.batchStyleEles = this.collection(), e.batchNotifications = {}), e.batchCount++, this;
  },
  endBatch: function() {
    var e = this._private;
    if (e.batchCount === 0)
      return this;
    if (e.batchCount--, e.batchCount === 0) {
      e.batchStyleEles.updateStyle();
      var r = this.renderer();
      Object.keys(e.batchNotifications).forEach(function(n) {
        var i = e.batchNotifications[n];
        i.empty() ? r.notify(n) : r.notify(n, i);
      });
    }
    return this;
  },
  batch: function(e) {
    return this.startBatch(), e(), this.endBatch(), this;
  },
  // for backwards compatibility
  batchData: function(e) {
    var r = this;
    return this.batch(function() {
      for (var n = Object.keys(e), i = 0; i < n.length; i++) {
        var a = n[i], s = e[a], o = r.getElementById(a);
        o.data(s);
      }
    });
  }
}, bNe = vi({
  hideEdgesOnViewport: !1,
  textureOnViewport: !1,
  motionBlur: !1,
  motionBlurOpacity: 0.05,
  pixelRatio: void 0,
  desktopTapThreshold: 4,
  touchTapThreshold: 8,
  wheelSensitivity: 1,
  debug: !1,
  showFps: !1,
  // webgl options
  webgl: !1,
  webglDebug: !1,
  webglDebugShowAtlases: !1,
  // defaults good for mobile
  webglTexSize: 2048,
  webglTexRows: 36,
  webglTexRowsNodes: 18,
  webglBatchSize: 2048,
  webglTexPerBatch: 14,
  webglBgColor: [255, 255, 255]
}), wA = {
  renderTo: function(e, r, n, i) {
    var a = this._private.renderer;
    return a.renderTo(e, r, n, i), this;
  },
  renderer: function() {
    return this._private.renderer;
  },
  forceRender: function() {
    return this.notify("draw"), this;
  },
  resize: function() {
    return this.invalidateSize(), this.emitAndNotify("resize"), this;
  },
  initRenderer: function(e) {
    var r = this, n = r.extension("renderer", e.name);
    if (n == null) {
      Jr("Can not initialise: No such renderer `".concat(e.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
      return;
    }
    e.wheelSensitivity !== void 0 && Rr("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
    var i = bNe(e);
    i.cy = r, r._private.renderer = new n(i), this.notify("init");
  },
  destroyRenderer: function() {
    var e = this;
    e.notify("destroy");
    var r = e.container();
    if (r)
      for (r._cyreg = null; r.childNodes.length > 0; )
        r.removeChild(r.childNodes[0]);
    e._private.renderer = null, e.mutableElements().forEach(function(n) {
      var i = n._private;
      i.rscratch = {}, i.rstyle = {}, i.animation.current = [], i.animation.queue = [];
    });
  },
  onRender: function(e) {
    return this.on("render", e);
  },
  offRender: function(e) {
    return this.off("render", e);
  }
};
wA.invalidateDimensions = wA.resize;
var Gy = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function(e, r) {
    return Pt(e) ? this.$(e) : La(e) ? e.collection() : Pr(e) ? (r || (r = {}), new pi(this, e, r.unique, r.removed)) : new pi(this);
  },
  nodes: function(e) {
    var r = this.$(function(n) {
      return n.isNode();
    });
    return e ? r.filter(e) : r;
  },
  edges: function(e) {
    var r = this.$(function(n) {
      return n.isEdge();
    });
    return e ? r.filter(e) : r;
  },
  // search the graph like jQuery
  $: function(e) {
    var r = this._private.elements;
    return e ? r.filter(e) : r.spawnSelf();
  },
  mutableElements: function() {
    return this._private.elements;
  }
};
Gy.elements = Gy.filter = Gy.$;
var ni = {}, Gg = "t", xNe = "f";
ni.apply = function(t) {
  for (var e = this, r = e._private, n = r.cy, i = n.collection(), a = 0; a < t.length; a++) {
    var s = t[a], o = e.getContextMeta(s);
    if (!o.empty) {
      var l = e.getContextStyle(o), u = e.applyContextStyle(o, l, s);
      s._private.appliedInitStyle ? e.updateTransitions(s, u.diffProps) : s._private.appliedInitStyle = !0;
      var h = e.updateStyleHints(s);
      h && i.push(s);
    }
  }
  return i;
};
ni.getPropertiesDiff = function(t, e) {
  var r = this, n = r._private.propDiffs = r._private.propDiffs || {}, i = t + "-" + e, a = n[i];
  if (a)
    return a;
  for (var s = [], o = {}, l = 0; l < r.length; l++) {
    var u = r[l], h = t[l] === Gg, f = e[l] === Gg, d = h !== f, p = u.mappedProperties.length > 0;
    if (d || f && p) {
      var g = void 0;
      d && p || d ? g = u.properties : p && (g = u.mappedProperties);
      for (var m = 0; m < g.length; m++) {
        for (var v = g[m], y = v.name, b = !1, x = l + 1; x < r.length; x++) {
          var T = r[x], E = e[x] === Gg;
          if (E && (b = T.properties[v.name] != null, b))
            break;
        }
        !o[y] && !b && (o[y] = !0, s.push(y));
      }
    }
  }
  return n[i] = s, s;
};
ni.getContextMeta = function(t) {
  for (var e = this, r = "", n, i = t._private.styleCxtKey || "", a = 0; a < e.length; a++) {
    var s = e[a], o = s.selector && s.selector.matches(t);
    o ? r += Gg : r += xNe;
  }
  return n = e.getPropertiesDiff(i, r), t._private.styleCxtKey = r, {
    key: r,
    diffPropNames: n,
    empty: n.length === 0
  };
};
ni.getContextStyle = function(t) {
  var e = t.key, r = this, n = this._private.contextStyles = this._private.contextStyles || {};
  if (n[e])
    return n[e];
  for (var i = {
    _private: {
      key: e
    }
  }, a = 0; a < r.length; a++) {
    var s = r[a], o = e[a] === Gg;
    if (o)
      for (var l = 0; l < s.properties.length; l++) {
        var u = s.properties[l];
        i[u.name] = u;
      }
  }
  return n[e] = i, i;
};
ni.applyContextStyle = function(t, e, r) {
  for (var n = this, i = t.diffPropNames, a = {}, s = n.types, o = 0; o < i.length; o++) {
    var l = i[o], u = e[l], h = r.pstyle(l);
    if (!u)
      if (h)
        h.bypass ? u = {
          name: l,
          deleteBypassed: !0
        } : u = {
          name: l,
          delete: !0
        };
      else continue;
    if (h !== u) {
      if (u.mapped === s.fn && h != null && h.mapping != null && h.mapping.value === u.value) {
        var f = h.mapping, d = f.fnValue = u.value(r);
        if (d === f.prevFnValue)
          continue;
      }
      var p = a[l] = {
        prev: h
      };
      n.applyParsedProperty(r, u), p.next = r.pstyle(l), p.next && p.next.bypass && (p.next = p.next.bypassed);
    }
  }
  return {
    diffProps: a
  };
};
ni.updateStyleHints = function(t) {
  var e = t._private, r = this, n = r.propertyGroupNames, i = r.propertyGroupKeys, a = function(X, re, Q) {
    return r.getPropertiesHash(X, re, Q);
  }, s = e.styleKey;
  if (t.removed())
    return !1;
  var o = e.group === "nodes", l = t._private.style;
  n = Object.keys(l);
  for (var u = 0; u < i.length; u++) {
    var h = i[u];
    e.styleKeys[h] = [Eu, gf];
  }
  for (var f = function(X, re) {
    return e.styleKeys[re][0] = T1(X, e.styleKeys[re][0]);
  }, d = function(X, re) {
    return e.styleKeys[re][1] = E1(X, e.styleKeys[re][1]);
  }, p = function(X, re) {
    f(X, re), d(X, re);
  }, g = function(X, re) {
    for (var Q = 0; Q < X.length; Q++) {
      var ue = X.charCodeAt(Q);
      f(ue, re), d(ue, re);
    }
  }, m = 2e9, v = function(X) {
    return -128 < X && X < 128 && Math.floor(X) !== X ? m - (X * 1024 | 0) : X;
  }, y = 0; y < n.length; y++) {
    var b = n[y], x = l[b];
    if (x != null) {
      var T = this.properties[b], E = T.type, A = T.groupKey, S = void 0;
      T.hashOverride != null ? S = T.hashOverride(t, x) : x.pfValue != null && (S = x.pfValue);
      var k = T.enums == null ? x.value : null, _ = S != null, R = k != null, L = _ || R, M = x.units;
      if (E.number && L && !E.multiple) {
        var P = _ ? S : k;
        p(v(P), A), !_ && M != null && g(M, A);
      } else
        g(x.strValue, A);
    }
  }
  for (var C = [Eu, gf], I = 0; I < i.length; I++) {
    var N = i[I], O = e.styleKeys[N];
    C[0] = T1(O[0], C[0]), C[1] = E1(O[1], C[1]);
  }
  e.styleKey = PLe(C[0], C[1]);
  var D = e.styleKeys;
  e.labelDimsKey = Gl(D.labelDimensions);
  var $ = a(t, ["label"], D.labelDimensions);
  if (e.labelKey = Gl($), e.labelStyleKey = Gl(_v(D.commonLabel, $)), !o) {
    var z = a(t, ["source-label"], D.labelDimensions);
    e.sourceLabelKey = Gl(z), e.sourceLabelStyleKey = Gl(_v(D.commonLabel, z));
    var B = a(t, ["target-label"], D.labelDimensions);
    e.targetLabelKey = Gl(B), e.targetLabelStyleKey = Gl(_v(D.commonLabel, B));
  }
  if (o) {
    var G = e.styleKeys, W = G.nodeBody, V = G.nodeBorder, U = G.nodeOutline, Z = G.backgroundImage, K = G.compound, ce = G.pie, J = G.stripe, ee = [W, V, U, Z, K, ce, J].filter(function(j) {
      return j != null;
    }).reduce(_v, [Eu, gf]);
    e.nodeKey = Gl(ee), e.hasPie = ce != null && ce[0] !== Eu && ce[1] !== gf, e.hasStripe = J != null && J[0] !== Eu && J[1] !== gf;
  }
  return s !== e.styleKey;
};
ni.clearStyleHints = function(t) {
  var e = t._private;
  e.styleCxtKey = "", e.styleKeys = {}, e.styleKey = null, e.labelKey = null, e.labelStyleKey = null, e.sourceLabelKey = null, e.sourceLabelStyleKey = null, e.targetLabelKey = null, e.targetLabelStyleKey = null, e.nodeKey = null, e.hasPie = null, e.hasStripe = null;
};
ni.applyParsedProperty = function(t, e) {
  var r = this, n = e, i = t._private.style, a, s = r.types, o = r.properties[n.name].type, l = n.bypass, u = i[n.name], h = u && u.bypass, f = t._private, d = "mapping", p = function(W) {
    return W == null ? null : W.pfValue != null ? W.pfValue : W.value;
  }, g = function() {
    var W = p(u), V = p(n);
    r.checkTriggers(t, n.name, W, V);
  };
  if (e.name === "curve-style" && t.isEdge() && // loops must be bundled beziers
  (e.value !== "bezier" && t.isLoop() || // edges connected to compound nodes can not be haystacks
  e.value === "haystack" && (t.source().isParent() || t.target().isParent())) && (n = e = this.parse(e.name, "bezier", l)), n.delete)
    return i[n.name] = void 0, g(), !0;
  if (n.deleteBypassed)
    return u ? u.bypass ? (u.bypassed = void 0, g(), !0) : !1 : (g(), !0);
  if (n.deleteBypass)
    return u ? u.bypass ? (i[n.name] = u.bypassed, g(), !0) : !1 : (g(), !0);
  var m = function() {
    Rr("Do not assign mappings to elements without corresponding data (i.e. ele `" + t.id() + "` has no mapping for property `" + n.name + "` with data field `" + n.field + "`); try a `[" + n.field + "]` selector to limit scope to elements with `" + n.field + "` defined");
  };
  switch (n.mapped) {
    // flatten the property if mapped
    case s.mapData: {
      for (var v = n.field.split("."), y = f.data, b = 0; b < v.length && y; b++) {
        var x = v[b];
        y = y[x];
      }
      if (y == null)
        return m(), !1;
      var T;
      if (mt(y)) {
        var E = n.fieldMax - n.fieldMin;
        E === 0 ? T = 0 : T = (y - n.fieldMin) / E;
      } else
        return Rr("Do not use continuous mappers without specifying numeric data (i.e. `" + n.field + ": " + y + "` for `" + t.id() + "` is non-numeric)"), !1;
      if (T < 0 ? T = 0 : T > 1 && (T = 1), o.color) {
        var A = n.valueMin[0], S = n.valueMax[0], k = n.valueMin[1], _ = n.valueMax[1], R = n.valueMin[2], L = n.valueMax[2], M = n.valueMin[3] == null ? 1 : n.valueMin[3], P = n.valueMax[3] == null ? 1 : n.valueMax[3], C = [Math.round(A + (S - A) * T), Math.round(k + (_ - k) * T), Math.round(R + (L - R) * T), Math.round(M + (P - M) * T)];
        a = {
          // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: n.bypass,
          // we're a bypass if the mapping property is a bypass
          name: n.name,
          value: C,
          strValue: "rgb(" + C[0] + ", " + C[1] + ", " + C[2] + ")"
        };
      } else if (o.number) {
        var I = n.valueMin + (n.valueMax - n.valueMin) * T;
        a = this.parse(n.name, I, n.bypass, d);
      } else
        return !1;
      if (!a)
        return m(), !1;
      a.mapping = n, n = a;
      break;
    }
    // direct mapping
    case s.data: {
      for (var N = n.field.split("."), O = f.data, D = 0; D < N.length && O; D++) {
        var $ = N[D];
        O = O[$];
      }
      if (O != null && (a = this.parse(n.name, O, n.bypass, d)), !a)
        return m(), !1;
      a.mapping = n, n = a;
      break;
    }
    case s.fn: {
      var z = n.value, B = n.fnValue != null ? n.fnValue : z(t);
      if (n.prevFnValue = B, B == null)
        return Rr("Custom function mappers may not return null (i.e. `" + n.name + "` for ele `" + t.id() + "` is null)"), !1;
      if (a = this.parse(n.name, B, n.bypass, d), !a)
        return Rr("Custom function mappers may not return invalid values for the property type (i.e. `" + n.name + "` for ele `" + t.id() + "` is invalid)"), !1;
      a.mapping = so(n), n = a;
      break;
    }
    case void 0:
      break;
    // just set the property
    default:
      return !1;
  }
  return l ? (h ? n.bypassed = u.bypassed : n.bypassed = u, i[n.name] = n) : h ? u.bypassed = n : i[n.name] = n, g(), !0;
};
ni.cleanElements = function(t, e) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    if (this.clearStyleHints(n), n.dirtyCompoundBoundsCache(), n.dirtyBoundingBoxCache(), !e)
      n._private.style = {};
    else
      for (var i = n._private.style, a = Object.keys(i), s = 0; s < a.length; s++) {
        var o = a[s], l = i[o];
        l != null && (l.bypass ? l.bypassed = null : i[o] = null);
      }
  }
};
ni.update = function() {
  var t = this._private.cy, e = t.mutableElements();
  e.updateStyle();
};
ni.updateTransitions = function(t, e) {
  var r = this, n = t._private, i = t.pstyle("transition-property").value, a = t.pstyle("transition-duration").pfValue, s = t.pstyle("transition-delay").pfValue;
  if (i.length > 0 && a > 0) {
    for (var o = {}, l = !1, u = 0; u < i.length; u++) {
      var h = i[u], f = t.pstyle(h), d = e[h];
      if (d) {
        var p = d.prev, g = p, m = d.next != null ? d.next : f, v = !1, y = void 0, b = 1e-6;
        g && (mt(g.pfValue) && mt(m.pfValue) ? (v = m.pfValue - g.pfValue, y = g.pfValue + b * v) : mt(g.value) && mt(m.value) ? (v = m.value - g.value, y = g.value + b * v) : Pr(g.value) && Pr(m.value) && (v = g.value[0] !== m.value[0] || g.value[1] !== m.value[1] || g.value[2] !== m.value[2], y = g.strValue), v && (o[h] = m.strValue, this.applyBypass(t, h, y), l = !0));
      }
    }
    if (!l)
      return;
    n.transitioning = !0, new G0(function(x) {
      s > 0 ? t.delayAnimation(s).play().promise().then(x) : x();
    }).then(function() {
      return t.animation({
        style: o,
        duration: a,
        easing: t.pstyle("transition-timing-function").value,
        queue: !1
      }).play().promise();
    }).then(function() {
      r.removeBypasses(t, i), t.emitAndNotify("style"), n.transitioning = !1;
    });
  } else n.transitioning && (this.removeBypasses(t, i), t.emitAndNotify("style"), n.transitioning = !1);
};
ni.checkTrigger = function(t, e, r, n, i, a) {
  var s = this.properties[e], o = i(s);
  t.removed() || o != null && o(r, n, t) && a(s);
};
ni.checkZOrderTrigger = function(t, e, r, n) {
  var i = this;
  this.checkTrigger(t, e, r, n, function(a) {
    return a.triggersZOrder;
  }, function() {
    i._private.cy.notify("zorder", t);
  });
};
ni.checkBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(i) {
    return i.triggersBounds;
  }, function(i) {
    t.dirtyCompoundBoundsCache(), t.dirtyBoundingBoxCache();
  });
};
ni.checkConnectedEdgesBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(i) {
    return i.triggersBoundsOfConnectedEdges;
  }, function(i) {
    t.connectedEdges().forEach(function(a) {
      a.dirtyBoundingBoxCache();
    });
  });
};
ni.checkParallelEdgesBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(i) {
    return i.triggersBoundsOfParallelEdges;
  }, function(i) {
    t.parallelEdges().forEach(function(a) {
      a.dirtyBoundingBoxCache();
    });
  });
};
ni.checkTriggers = function(t, e, r, n) {
  t.dirtyStyleCache(), this.checkZOrderTrigger(t, e, r, n), this.checkBoundsTrigger(t, e, r, n), this.checkConnectedEdgesBoundsTrigger(t, e, r, n), this.checkParallelEdgesBoundsTrigger(t, e, r, n);
};
var Cm = {};
Cm.applyBypass = function(t, e, r, n) {
  var i = this, a = [], s = !0;
  if (e === "*" || e === "**") {
    if (r !== void 0)
      for (var o = 0; o < i.properties.length; o++) {
        var l = i.properties[o], u = l.name, h = this.parse(u, r, !0);
        h && a.push(h);
      }
  } else if (Pt(e)) {
    var f = this.parse(e, r, !0);
    f && a.push(f);
  } else if (yr(e)) {
    var d = e;
    n = r;
    for (var p = Object.keys(d), g = 0; g < p.length; g++) {
      var m = p[g], v = d[m];
      if (v === void 0 && (v = d[Y4(m)]), v !== void 0) {
        var y = this.parse(m, v, !0);
        y && a.push(y);
      }
    }
  } else
    return !1;
  if (a.length === 0)
    return !1;
  for (var b = !1, x = 0; x < t.length; x++) {
    for (var T = t[x], E = {}, A = void 0, S = 0; S < a.length; S++) {
      var k = a[S];
      if (n) {
        var _ = T.pstyle(k.name);
        A = E[k.name] = {
          prev: _
        };
      }
      b = this.applyParsedProperty(T, so(k)) || b, n && (A.next = T.pstyle(k.name));
    }
    b && this.updateStyleHints(T), n && this.updateTransitions(T, E, s);
  }
  return b;
};
Cm.overrideBypass = function(t, e, r) {
  e = gR(e);
  for (var n = 0; n < t.length; n++) {
    var i = t[n], a = i._private.style[e], s = this.properties[e].type, o = s.color, l = s.mutiple, u = a ? a.pfValue != null ? a.pfValue : a.value : null;
    !a || !a.bypass ? this.applyBypass(i, e, r) : (a.value = r, a.pfValue != null && (a.pfValue = r), o ? a.strValue = "rgb(" + r.join(",") + ")" : l ? a.strValue = r.join(" ") : a.strValue = "" + r, this.updateStyleHints(i)), this.checkTriggers(i, e, u, r);
  }
};
Cm.removeAllBypasses = function(t, e) {
  return this.removeBypasses(t, this.propertyNames, e);
};
Cm.removeBypasses = function(t, e, r) {
  for (var n = !0, i = 0; i < t.length; i++) {
    for (var a = t[i], s = {}, o = 0; o < e.length; o++) {
      var l = e[o], u = this.properties[l], h = a.pstyle(u.name);
      if (!(!h || !h.bypass)) {
        var f = "", d = this.parse(l, f, !0), p = s[u.name] = {
          prev: h
        };
        this.applyParsedProperty(a, d), p.next = a.pstyle(u.name);
      }
    }
    this.updateStyleHints(a), r && this.updateTransitions(a, s, n);
  }
};
var RR = {};
RR.getEmSizeInPixels = function() {
  var t = this.containerCss("font-size");
  return t != null ? parseFloat(t) : 1;
};
RR.containerCss = function(t) {
  var e = this._private.cy, r = e.container(), n = e.window();
  if (n && r && n.getComputedStyle)
    return n.getComputedStyle(r).getPropertyValue(t);
};
var vo = {};
vo.getRenderedStyle = function(t, e) {
  return e ? this.getStylePropertyValue(t, e, !0) : this.getRawStyle(t, !0);
};
vo.getRawStyle = function(t, e) {
  var r = this;
  if (t = t[0], t) {
    for (var n = {}, i = 0; i < r.properties.length; i++) {
      var a = r.properties[i], s = r.getStylePropertyValue(t, a.name, e);
      s != null && (n[a.name] = s, n[Y4(a.name)] = s);
    }
    return n;
  }
};
vo.getIndexedStyle = function(t, e, r, n) {
  var i = t.pstyle(e)[r][n];
  return i ?? t.cy().style().getDefaultProperty(e)[r][0];
};
vo.getStylePropertyValue = function(t, e, r) {
  var n = this;
  if (t = t[0], t) {
    var i = n.properties[e];
    i.alias && (i = i.pointsTo);
    var a = i.type, s = t.pstyle(i.name);
    if (s) {
      var o = s.value, l = s.units, u = s.strValue;
      if (r && a.number && o != null && mt(o)) {
        var h = t.cy().zoom(), f = function(v) {
          return v * h;
        }, d = function(v, y) {
          return f(v) + y;
        }, p = Pr(o), g = p ? l.every(function(m) {
          return m != null;
        }) : l != null;
        return g ? p ? o.map(function(m, v) {
          return d(m, l[v]);
        }).join(" ") : d(o, l) : p ? o.map(function(m) {
          return Pt(m) ? m : "" + f(m);
        }).join(" ") : "" + f(o);
      } else if (u != null)
        return u;
    }
    return null;
  }
};
vo.getAnimationStartStyle = function(t, e) {
  for (var r = {}, n = 0; n < e.length; n++) {
    var i = e[n], a = i.name, s = t.pstyle(a);
    s !== void 0 && (yr(s) ? s = this.parse(a, s.strValue) : s = this.parse(a, s)), s && (r[a] = s);
  }
  return r;
};
vo.getPropsList = function(t) {
  var e = this, r = [], n = t, i = e.properties;
  if (n)
    for (var a = Object.keys(n), s = 0; s < a.length; s++) {
      var o = a[s], l = n[o], u = i[o] || i[gR(o)], h = this.parse(u.name, l);
      h && r.push(h);
    }
  return r;
};
vo.getNonDefaultPropertiesHash = function(t, e, r) {
  var n = r.slice(), i, a, s, o, l, u;
  for (l = 0; l < e.length; l++)
    if (i = e[l], a = t.pstyle(i, !1), a != null)
      if (a.pfValue != null)
        n[0] = T1(o, n[0]), n[1] = E1(o, n[1]);
      else
        for (s = a.strValue, u = 0; u < s.length; u++)
          o = s.charCodeAt(u), n[0] = T1(o, n[0]), n[1] = E1(o, n[1]);
  return n;
};
vo.getPropertiesHash = vo.getNonDefaultPropertiesHash;
var s3 = {};
s3.appendFromJson = function(t) {
  for (var e = this, r = 0; r < t.length; r++) {
    var n = t[r], i = n.selector, a = n.style || n.css, s = Object.keys(a);
    e.selector(i);
    for (var o = 0; o < s.length; o++) {
      var l = s[o], u = a[l];
      e.css(l, u);
    }
  }
  return e;
};
s3.fromJson = function(t) {
  var e = this;
  return e.resetToDefault(), e.appendFromJson(t), e;
};
s3.json = function() {
  for (var t = [], e = this.defaultLength; e < this.length; e++) {
    for (var r = this[e], n = r.selector, i = r.properties, a = {}, s = 0; s < i.length; s++) {
      var o = i[s];
      a[o.name] = o.strValue;
    }
    t.push({
      selector: n ? n.toString() : "core",
      style: a
    });
  }
  return t;
};
var IR = {};
IR.appendFromString = function(t) {
  var e = this, r = this, n = "" + t, i, a, s;
  n = n.replace(/[/][*](\s|.)+?[*][/]/g, "");
  function o() {
    n.length > i.length ? n = n.substr(i.length) : n = "";
  }
  function l() {
    a.length > s.length ? a = a.substr(s.length) : a = "";
  }
  for (; ; ) {
    var u = n.match(/^\s*$/);
    if (u)
      break;
    var h = n.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
    if (!h) {
      Rr("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: " + n);
      break;
    }
    i = h[0];
    var f = h[1];
    if (f !== "core") {
      var d = new wc(f);
      if (d.invalid) {
        Rr("Skipping parsing of block: Invalid selector found in string stylesheet: " + f), o();
        continue;
      }
    }
    var p = h[2], g = !1;
    a = p;
    for (var m = []; ; ) {
      var v = a.match(/^\s*$/);
      if (v)
        break;
      var y = a.match(/^\s*(.+?)\s*:\s*(.+?)(?:\s*;|\s*$)/);
      if (!y) {
        Rr("Skipping parsing of block: Invalid formatting of style property and value definitions found in:" + p), g = !0;
        break;
      }
      s = y[0];
      var b = y[1], x = y[2], T = e.properties[b];
      if (!T) {
        Rr("Skipping property: Invalid property name in: " + s), l();
        continue;
      }
      var E = r.parse(b, x);
      if (!E) {
        Rr("Skipping property: Invalid property definition in: " + s), l();
        continue;
      }
      m.push({
        name: b,
        val: x
      }), l();
    }
    if (g) {
      o();
      break;
    }
    r.selector(f);
    for (var A = 0; A < m.length; A++) {
      var S = m[A];
      r.css(S.name, S.val);
    }
    o();
  }
  return r;
};
IR.fromString = function(t) {
  var e = this;
  return e.resetToDefault(), e.appendFromString(t), e;
};
var kn = {};
(function() {
  var t = Gn, e = pLe, r = mLe, n = vLe, i = yLe, a = function(j) {
    return "^" + j + "\\s*\\(\\s*([\\w\\.]+)\\s*\\)$";
  }, s = function(j) {
    var X = t + "|\\w+|" + e + "|" + r + "|" + n + "|" + i;
    return "^" + j + "\\s*\\(([\\w\\.]+)\\s*\\,\\s*(" + t + ")\\s*\\,\\s*(" + t + ")\\s*,\\s*(" + X + ")\\s*\\,\\s*(" + X + ")\\)$";
  }, o = [`^url\\s*\\(\\s*['"]?(.+?)['"]?\\s*\\)$`, "^(none)$", "^(.+)$"];
  kn.types = {
    time: {
      number: !0,
      min: 0,
      units: "s|ms",
      implicitUnits: "ms"
    },
    percent: {
      number: !0,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%"
    },
    percentages: {
      number: !0,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%",
      multiple: !0
    },
    zeroOneNumber: {
      number: !0,
      min: 0,
      max: 1,
      unitless: !0
    },
    zeroOneNumbers: {
      number: !0,
      min: 0,
      max: 1,
      unitless: !0,
      multiple: !0
    },
    nOneOneNumber: {
      number: !0,
      min: -1,
      max: 1,
      unitless: !0
    },
    nonNegativeInt: {
      number: !0,
      min: 0,
      integer: !0,
      unitless: !0
    },
    nonNegativeNumber: {
      number: !0,
      min: 0,
      unitless: !0
    },
    position: {
      enums: ["parent", "origin"]
    },
    nodeSize: {
      number: !0,
      min: 0,
      enums: ["label"]
    },
    number: {
      number: !0,
      unitless: !0
    },
    numbers: {
      number: !0,
      unitless: !0,
      multiple: !0
    },
    positiveNumber: {
      number: !0,
      unitless: !0,
      min: 0,
      strictMin: !0
    },
    size: {
      number: !0,
      min: 0
    },
    bidirectionalSize: {
      number: !0
    },
    // allows negative
    bidirectionalSizeMaybePercent: {
      number: !0,
      allowPercent: !0
    },
    // allows negative
    bidirectionalSizes: {
      number: !0,
      multiple: !0
    },
    // allows negative
    sizeMaybePercent: {
      number: !0,
      min: 0,
      allowPercent: !0
    },
    axisDirection: {
      enums: ["horizontal", "leftward", "rightward", "vertical", "upward", "downward", "auto"]
    },
    axisDirectionExplicit: {
      enums: ["leftward", "rightward", "upward", "downward"]
    },
    axisDirectionPrimary: {
      enums: ["horizontal", "vertical"]
    },
    paddingRelativeTo: {
      enums: ["width", "height", "average", "min", "max"]
    },
    bgWH: {
      number: !0,
      min: 0,
      allowPercent: !0,
      enums: ["auto"],
      multiple: !0
    },
    bgPos: {
      number: !0,
      allowPercent: !0,
      multiple: !0
    },
    bgRelativeTo: {
      enums: ["inner", "include-padding"],
      multiple: !0
    },
    bgRepeat: {
      enums: ["repeat", "repeat-x", "repeat-y", "no-repeat"],
      multiple: !0
    },
    bgFit: {
      enums: ["none", "contain", "cover"],
      multiple: !0
    },
    bgCrossOrigin: {
      enums: ["anonymous", "use-credentials", "null"],
      multiple: !0
    },
    bgClip: {
      enums: ["none", "node"],
      multiple: !0
    },
    bgContainment: {
      enums: ["inside", "over"],
      multiple: !0
    },
    boxSelection: {
      enums: ["contain", "overlap", "none"]
    },
    color: {
      color: !0
    },
    colors: {
      color: !0,
      multiple: !0
    },
    fill: {
      enums: ["solid", "linear-gradient", "radial-gradient"]
    },
    bool: {
      enums: ["yes", "no"]
    },
    bools: {
      enums: ["yes", "no"],
      multiple: !0
    },
    lineStyle: {
      enums: ["solid", "dotted", "dashed"]
    },
    lineCap: {
      enums: ["butt", "round", "square"]
    },
    linePosition: {
      enums: ["center", "inside", "outside"]
    },
    lineJoin: {
      enums: ["round", "bevel", "miter"]
    },
    borderStyle: {
      enums: ["solid", "dotted", "dashed", "double"]
    },
    curveStyle: {
      enums: ["bezier", "unbundled-bezier", "haystack", "segments", "straight", "straight-triangle", "taxi", "round-segments", "round-taxi"]
    },
    radiusType: {
      enums: ["arc-radius", "influence-radius"],
      multiple: !0
    },
    fontFamily: {
      regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
    },
    fontStyle: {
      enums: ["italic", "normal", "oblique"]
    },
    fontWeight: {
      enums: ["normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "800", "900", 100, 200, 300, 400, 500, 600, 700, 800, 900]
    },
    textDecoration: {
      enums: ["none", "underline", "overline", "line-through"]
    },
    textTransform: {
      enums: ["none", "uppercase", "lowercase"]
    },
    textWrap: {
      enums: ["none", "wrap", "ellipsis"]
    },
    textOverflowWrap: {
      enums: ["whitespace", "anywhere"]
    },
    textBackgroundShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "circle"]
    },
    nodeShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "cutrectangle", "cut-rectangle", "bottomroundrectangle", "bottom-round-rectangle", "barrel", "ellipse", "triangle", "round-triangle", "square", "pentagon", "round-pentagon", "hexagon", "round-hexagon", "concavehexagon", "concave-hexagon", "heptagon", "round-heptagon", "octagon", "round-octagon", "tag", "round-tag", "star", "diamond", "round-diamond", "vee", "rhomboid", "right-rhomboid", "polygon"]
    },
    overlayShape: {
      enums: ["roundrectangle", "round-rectangle", "ellipse"]
    },
    cornerRadius: {
      number: !0,
      min: 0,
      units: "px|em",
      implicitUnits: "px",
      enums: ["auto"]
    },
    compoundIncludeLabels: {
      enums: ["include", "exclude"]
    },
    arrowShape: {
      enums: ["tee", "triangle", "triangle-tee", "circle-triangle", "triangle-cross", "triangle-backcurve", "vee", "square", "circle", "diamond", "chevron", "none"]
    },
    arrowFill: {
      enums: ["filled", "hollow"]
    },
    arrowWidth: {
      number: !0,
      units: "%|px|em",
      implicitUnits: "px",
      enums: ["match-line"]
    },
    display: {
      enums: ["element", "none"]
    },
    visibility: {
      enums: ["hidden", "visible"]
    },
    zCompoundDepth: {
      enums: ["bottom", "orphan", "auto", "top"]
    },
    zIndexCompare: {
      enums: ["auto", "manual"]
    },
    valign: {
      enums: ["top", "center", "bottom"]
    },
    halign: {
      enums: ["left", "center", "right"]
    },
    justification: {
      enums: ["left", "center", "right", "auto"]
    },
    text: {
      string: !0
    },
    data: {
      mapping: !0,
      regex: a("data")
    },
    layoutData: {
      mapping: !0,
      regex: a("layoutData")
    },
    scratch: {
      mapping: !0,
      regex: a("scratch")
    },
    mapData: {
      mapping: !0,
      regex: s("mapData")
    },
    mapLayoutData: {
      mapping: !0,
      regex: s("mapLayoutData")
    },
    mapScratch: {
      mapping: !0,
      regex: s("mapScratch")
    },
    fn: {
      mapping: !0,
      fn: !0
    },
    url: {
      regexes: o,
      singleRegexMatchValue: !0
    },
    urls: {
      regexes: o,
      singleRegexMatchValue: !0,
      multiple: !0
    },
    propList: {
      propList: !0
    },
    angle: {
      number: !0,
      units: "deg|rad",
      implicitUnits: "rad"
    },
    textRotation: {
      number: !0,
      units: "deg|rad",
      implicitUnits: "rad",
      enums: ["none", "autorotate"]
    },
    polygonPointList: {
      number: !0,
      multiple: !0,
      evenMultiple: !0,
      min: -1,
      max: 1,
      unitless: !0
    },
    edgeDistances: {
      enums: ["intersection", "node-position", "endpoints"]
    },
    edgeEndpoint: {
      number: !0,
      multiple: !0,
      units: "%|px|em|deg|rad",
      implicitUnits: "px",
      enums: ["inside-to-node", "outside-to-node", "outside-to-node-or-label", "outside-to-line", "outside-to-line-or-label"],
      singleEnum: !0,
      validate: function(j, X) {
        switch (j.length) {
          case 2:
            return X[0] !== "deg" && X[0] !== "rad" && X[1] !== "deg" && X[1] !== "rad";
          case 1:
            return Pt(j[0]) || X[0] === "deg" || X[0] === "rad";
          default:
            return !1;
        }
      }
    },
    easing: {
      regexes: ["^(spring)\\s*\\(\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*\\)$", "^(cubic-bezier)\\s*\\(\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*\\)$"],
      enums: ["linear", "ease", "ease-in", "ease-out", "ease-in-out", "ease-in-sine", "ease-out-sine", "ease-in-out-sine", "ease-in-quad", "ease-out-quad", "ease-in-out-quad", "ease-in-cubic", "ease-out-cubic", "ease-in-out-cubic", "ease-in-quart", "ease-out-quart", "ease-in-out-quart", "ease-in-quint", "ease-out-quint", "ease-in-out-quint", "ease-in-expo", "ease-out-expo", "ease-in-out-expo", "ease-in-circ", "ease-out-circ", "ease-in-out-circ"]
    },
    gradientDirection: {
      enums: [
        "to-bottom",
        "to-top",
        "to-left",
        "to-right",
        "to-bottom-right",
        "to-bottom-left",
        "to-top-right",
        "to-top-left",
        "to-right-bottom",
        "to-left-bottom",
        "to-right-top",
        "to-left-top"
        // different order
      ]
    },
    boundsExpansion: {
      number: !0,
      multiple: !0,
      min: 0,
      validate: function(j) {
        var X = j.length;
        return X === 1 || X === 2 || X === 4;
      }
    }
  };
  var l = {
    zeroNonZero: function(j, X) {
      return (j == null || X == null) && j !== X || j == 0 && X != 0 ? !0 : j != 0 && X == 0;
    },
    any: function(j, X) {
      return j != X;
    },
    emptyNonEmpty: function(j, X) {
      var re = yc(j), Q = yc(X);
      return re && !Q || !re && Q;
    }
  }, u = kn.types, h = [{
    name: "label",
    type: u.text,
    triggersBounds: l.any,
    triggersZOrder: l.emptyNonEmpty
  }, {
    name: "text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }], f = [{
    name: "source-label",
    type: u.text,
    triggersBounds: l.any
  }, {
    name: "source-text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "source-text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "source-text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "source-text-offset",
    type: u.size,
    triggersBounds: l.any
  }], d = [{
    name: "target-label",
    type: u.text,
    triggersBounds: l.any
  }, {
    name: "target-text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "target-text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "target-text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "target-text-offset",
    type: u.size,
    triggersBounds: l.any
  }], p = [{
    name: "font-family",
    type: u.fontFamily,
    triggersBounds: l.any
  }, {
    name: "font-style",
    type: u.fontStyle,
    triggersBounds: l.any
  }, {
    name: "font-weight",
    type: u.fontWeight,
    triggersBounds: l.any
  }, {
    name: "font-size",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-transform",
    type: u.textTransform,
    triggersBounds: l.any
  }, {
    name: "text-wrap",
    type: u.textWrap,
    triggersBounds: l.any
  }, {
    name: "text-overflow-wrap",
    type: u.textOverflowWrap,
    triggersBounds: l.any
  }, {
    name: "text-max-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-outline-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "line-height",
    type: u.positiveNumber,
    triggersBounds: l.any
  }], g = [{
    name: "text-valign",
    type: u.valign,
    triggersBounds: l.any
  }, {
    name: "text-halign",
    type: u.halign,
    triggersBounds: l.any
  }, {
    name: "color",
    type: u.color
  }, {
    name: "text-outline-color",
    type: u.color
  }, {
    name: "text-outline-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-background-color",
    type: u.color
  }, {
    name: "text-background-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-background-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-border-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-border-color",
    type: u.color
  }, {
    name: "text-border-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-border-style",
    type: u.borderStyle,
    triggersBounds: l.any
  }, {
    name: "text-background-shape",
    type: u.textBackgroundShape,
    triggersBounds: l.any
  }, {
    name: "text-justification",
    type: u.justification
  }, {
    name: "box-select-labels",
    type: u.bool,
    triggersBounds: l.any
  }], m = [{
    name: "events",
    type: u.bool,
    triggersZOrder: l.any
  }, {
    name: "text-events",
    type: u.bool,
    triggersZOrder: l.any
  }, {
    name: "box-selection",
    type: u.boxSelection,
    triggersZOrder: l.any
  }], v = [{
    name: "display",
    type: u.display,
    triggersZOrder: l.any,
    triggersBounds: l.any,
    triggersBoundsOfConnectedEdges: l.any,
    triggersBoundsOfParallelEdges: function(j, X, re) {
      return j === X ? !1 : re.pstyle("curve-style").value === "bezier";
    }
  }, {
    name: "visibility",
    type: u.visibility,
    triggersZOrder: l.any
  }, {
    name: "opacity",
    type: u.zeroOneNumber,
    triggersZOrder: l.zeroNonZero
  }, {
    name: "text-opacity",
    type: u.zeroOneNumber
  }, {
    name: "min-zoomed-font-size",
    type: u.size
  }, {
    name: "z-compound-depth",
    type: u.zCompoundDepth,
    triggersZOrder: l.any
  }, {
    name: "z-index-compare",
    type: u.zIndexCompare,
    triggersZOrder: l.any
  }, {
    name: "z-index",
    type: u.number,
    triggersZOrder: l.any
  }], y = [{
    name: "overlay-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "overlay-color",
    type: u.color
  }, {
    name: "overlay-opacity",
    type: u.zeroOneNumber,
    triggersBounds: l.zeroNonZero
  }, {
    name: "overlay-shape",
    type: u.overlayShape,
    triggersBounds: l.any
  }, {
    name: "overlay-corner-radius",
    type: u.cornerRadius
  }], b = [{
    name: "underlay-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "underlay-color",
    type: u.color
  }, {
    name: "underlay-opacity",
    type: u.zeroOneNumber,
    triggersBounds: l.zeroNonZero
  }, {
    name: "underlay-shape",
    type: u.overlayShape,
    triggersBounds: l.any
  }, {
    name: "underlay-corner-radius",
    type: u.cornerRadius
  }], x = [{
    name: "transition-property",
    type: u.propList
  }, {
    name: "transition-duration",
    type: u.time
  }, {
    name: "transition-delay",
    type: u.time
  }, {
    name: "transition-timing-function",
    type: u.easing
  }], T = function(j, X) {
    return X.value === "label" ? -j.poolIndex() : X.pfValue;
  }, E = [{
    name: "height",
    type: u.nodeSize,
    triggersBounds: l.any,
    hashOverride: T
  }, {
    name: "width",
    type: u.nodeSize,
    triggersBounds: l.any,
    hashOverride: T
  }, {
    name: "shape",
    type: u.nodeShape,
    triggersBounds: l.any
  }, {
    name: "shape-polygon-points",
    type: u.polygonPointList,
    triggersBounds: l.any
  }, {
    name: "corner-radius",
    type: u.cornerRadius
  }, {
    name: "background-color",
    type: u.color
  }, {
    name: "background-fill",
    type: u.fill
  }, {
    name: "background-opacity",
    type: u.zeroOneNumber
  }, {
    name: "background-blacken",
    type: u.nOneOneNumber
  }, {
    name: "background-gradient-stop-colors",
    type: u.colors
  }, {
    name: "background-gradient-stop-positions",
    type: u.percentages
  }, {
    name: "background-gradient-direction",
    type: u.gradientDirection
  }, {
    name: "padding",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "padding-relative-to",
    type: u.paddingRelativeTo,
    triggersBounds: l.any
  }, {
    name: "bounds-expansion",
    type: u.boundsExpansion,
    triggersBounds: l.any
  }], A = [{
    name: "border-color",
    type: u.color
  }, {
    name: "border-opacity",
    type: u.zeroOneNumber
  }, {
    name: "border-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "border-style",
    type: u.borderStyle
  }, {
    name: "border-cap",
    type: u.lineCap
  }, {
    name: "border-join",
    type: u.lineJoin
  }, {
    name: "border-dash-pattern",
    type: u.numbers
  }, {
    name: "border-dash-offset",
    type: u.number
  }, {
    name: "border-position",
    type: u.linePosition
  }], S = [{
    name: "outline-color",
    type: u.color
  }, {
    name: "outline-opacity",
    type: u.zeroOneNumber
  }, {
    name: "outline-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "outline-style",
    type: u.borderStyle
  }, {
    name: "outline-offset",
    type: u.size,
    triggersBounds: l.any
  }], k = [{
    name: "background-image",
    type: u.urls
  }, {
    name: "background-image-crossorigin",
    type: u.bgCrossOrigin
  }, {
    name: "background-image-opacity",
    type: u.zeroOneNumbers
  }, {
    name: "background-image-containment",
    type: u.bgContainment
  }, {
    name: "background-image-smoothing",
    type: u.bools
  }, {
    name: "background-position-x",
    type: u.bgPos
  }, {
    name: "background-position-y",
    type: u.bgPos
  }, {
    name: "background-width-relative-to",
    type: u.bgRelativeTo
  }, {
    name: "background-height-relative-to",
    type: u.bgRelativeTo
  }, {
    name: "background-repeat",
    type: u.bgRepeat
  }, {
    name: "background-fit",
    type: u.bgFit
  }, {
    name: "background-clip",
    type: u.bgClip
  }, {
    name: "background-width",
    type: u.bgWH
  }, {
    name: "background-height",
    type: u.bgWH
  }, {
    name: "background-offset-x",
    type: u.bgPos
  }, {
    name: "background-offset-y",
    type: u.bgPos
  }], _ = [{
    name: "position",
    type: u.position,
    triggersBounds: l.any
  }, {
    name: "compound-sizing-wrt-labels",
    type: u.compoundIncludeLabels,
    triggersBounds: l.any
  }, {
    name: "min-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "min-width-bias-left",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-width-bias-right",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-height",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "min-height-bias-top",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-height-bias-bottom",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }], R = [{
    name: "line-style",
    type: u.lineStyle
  }, {
    name: "line-color",
    type: u.color
  }, {
    name: "line-fill",
    type: u.fill
  }, {
    name: "line-cap",
    type: u.lineCap
  }, {
    name: "line-opacity",
    type: u.zeroOneNumber
  }, {
    name: "line-dash-pattern",
    type: u.numbers
  }, {
    name: "line-dash-offset",
    type: u.number
  }, {
    name: "line-outline-width",
    type: u.size
  }, {
    name: "line-outline-color",
    type: u.color
  }, {
    name: "line-gradient-stop-colors",
    type: u.colors
  }, {
    name: "line-gradient-stop-positions",
    type: u.percentages
  }, {
    name: "curve-style",
    type: u.curveStyle,
    triggersBounds: l.any,
    triggersBoundsOfParallelEdges: function(j, X) {
      return j === X ? !1 : j === "bezier" || // remove from bundle
      X === "bezier";
    }
  }, {
    name: "haystack-radius",
    type: u.zeroOneNumber,
    triggersBounds: l.any
  }, {
    name: "source-endpoint",
    type: u.edgeEndpoint,
    triggersBounds: l.any
  }, {
    name: "target-endpoint",
    type: u.edgeEndpoint,
    triggersBounds: l.any
  }, {
    name: "control-point-step-size",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "control-point-distances",
    type: u.bidirectionalSizes,
    triggersBounds: l.any
  }, {
    name: "control-point-weights",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "segment-distances",
    type: u.bidirectionalSizes,
    triggersBounds: l.any
  }, {
    name: "segment-weights",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "segment-radii",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "radius-type",
    type: u.radiusType,
    triggersBounds: l.any
  }, {
    name: "taxi-turn",
    type: u.bidirectionalSizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "taxi-turn-min-distance",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "taxi-direction",
    type: u.axisDirection,
    triggersBounds: l.any
  }, {
    name: "taxi-radius",
    type: u.number,
    triggersBounds: l.any
  }, {
    name: "edge-distances",
    type: u.edgeDistances,
    triggersBounds: l.any
  }, {
    name: "arrow-scale",
    type: u.positiveNumber,
    triggersBounds: l.any
  }, {
    name: "loop-direction",
    type: u.angle,
    triggersBounds: l.any
  }, {
    name: "loop-sweep",
    type: u.angle,
    triggersBounds: l.any
  }, {
    name: "source-distance-from-node",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "target-distance-from-node",
    type: u.size,
    triggersBounds: l.any
  }], L = [{
    name: "ghost",
    type: u.bool,
    triggersBounds: l.any
  }, {
    name: "ghost-offset-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "ghost-offset-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "ghost-opacity",
    type: u.zeroOneNumber
  }], M = [{
    name: "selection-box-color",
    type: u.color
  }, {
    name: "selection-box-opacity",
    type: u.zeroOneNumber
  }, {
    name: "selection-box-border-color",
    type: u.color
  }, {
    name: "selection-box-border-width",
    type: u.size
  }, {
    name: "active-bg-color",
    type: u.color
  }, {
    name: "active-bg-opacity",
    type: u.zeroOneNumber
  }, {
    name: "active-bg-size",
    type: u.size
  }, {
    name: "outside-texture-bg-color",
    type: u.color
  }, {
    name: "outside-texture-bg-opacity",
    type: u.zeroOneNumber
  }], P = [];
  kn.pieBackgroundN = 16, P.push({
    name: "pie-size",
    type: u.sizeMaybePercent
  }), P.push({
    name: "pie-hole",
    type: u.sizeMaybePercent
  }), P.push({
    name: "pie-start-angle",
    type: u.angle
  });
  for (var C = 1; C <= kn.pieBackgroundN; C++)
    P.push({
      name: "pie-" + C + "-background-color",
      type: u.color
    }), P.push({
      name: "pie-" + C + "-background-size",
      type: u.percent
    }), P.push({
      name: "pie-" + C + "-background-opacity",
      type: u.zeroOneNumber
    });
  var I = [];
  kn.stripeBackgroundN = 16, I.push({
    name: "stripe-size",
    type: u.sizeMaybePercent
  }), I.push({
    name: "stripe-direction",
    type: u.axisDirectionPrimary
  });
  for (var N = 1; N <= kn.stripeBackgroundN; N++)
    I.push({
      name: "stripe-" + N + "-background-color",
      type: u.color
    }), I.push({
      name: "stripe-" + N + "-background-size",
      type: u.percent
    }), I.push({
      name: "stripe-" + N + "-background-opacity",
      type: u.zeroOneNumber
    });
  var O = [], D = kn.arrowPrefixes = ["source", "mid-source", "target", "mid-target"];
  [{
    name: "arrow-shape",
    type: u.arrowShape,
    triggersBounds: l.any
  }, {
    name: "arrow-color",
    type: u.color
  }, {
    name: "arrow-fill",
    type: u.arrowFill
  }, {
    name: "arrow-width",
    type: u.arrowWidth
  }].forEach(function(ee) {
    D.forEach(function(j) {
      var X = j + "-" + ee.name, re = ee.type, Q = ee.triggersBounds;
      O.push({
        name: X,
        type: re,
        triggersBounds: Q
      });
    });
  }, {});
  var $ = kn.properties = [].concat(m, x, v, y, b, L, g, p, h, f, d, E, A, S, k, P, I, _, R, O, M), z = kn.propertyGroups = {
    // common to all eles
    behavior: m,
    transition: x,
    visibility: v,
    overlay: y,
    underlay: b,
    ghost: L,
    // labels
    commonLabel: g,
    labelDimensions: p,
    mainLabel: h,
    sourceLabel: f,
    targetLabel: d,
    // node props
    nodeBody: E,
    nodeBorder: A,
    nodeOutline: S,
    backgroundImage: k,
    pie: P,
    stripe: I,
    compound: _,
    // edge props
    edgeLine: R,
    edgeArrow: O,
    core: M
  }, B = kn.propertyGroupNames = {}, G = kn.propertyGroupKeys = Object.keys(z);
  G.forEach(function(ee) {
    B[ee] = z[ee].map(function(j) {
      return j.name;
    }), z[ee].forEach(function(j) {
      return j.groupKey = ee;
    });
  });
  var W = kn.aliases = [{
    name: "content",
    pointsTo: "label"
  }, {
    name: "control-point-distance",
    pointsTo: "control-point-distances"
  }, {
    name: "control-point-weight",
    pointsTo: "control-point-weights"
  }, {
    name: "segment-distance",
    pointsTo: "segment-distances"
  }, {
    name: "segment-weight",
    pointsTo: "segment-weights"
  }, {
    name: "segment-radius",
    pointsTo: "segment-radii"
  }, {
    name: "edge-text-rotation",
    pointsTo: "text-rotation"
  }, {
    name: "padding-left",
    pointsTo: "padding"
  }, {
    name: "padding-right",
    pointsTo: "padding"
  }, {
    name: "padding-top",
    pointsTo: "padding"
  }, {
    name: "padding-bottom",
    pointsTo: "padding"
  }];
  kn.propertyNames = $.map(function(ee) {
    return ee.name;
  });
  for (var V = 0; V < $.length; V++) {
    var U = $[V];
    $[U.name] = U;
  }
  for (var Z = 0; Z < W.length; Z++) {
    var K = W[Z], ce = $[K.pointsTo], J = {
      name: K.name,
      alias: !0,
      pointsTo: ce
    };
    $.push(J), $[K.name] = J;
  }
})();
kn.getDefaultProperty = function(t) {
  return this.getDefaultProperties()[t];
};
kn.getDefaultProperties = function() {
  var t = this._private;
  if (t.defaultProperties != null)
    return t.defaultProperties;
  for (var e = Ut({
    // core props
    "selection-box-color": "#ddd",
    "selection-box-opacity": 0.65,
    "selection-box-border-color": "#aaa",
    "selection-box-border-width": 1,
    "active-bg-color": "black",
    "active-bg-opacity": 0.15,
    "active-bg-size": 30,
    "outside-texture-bg-color": "#000",
    "outside-texture-bg-opacity": 0.125,
    // common node/edge props
    events: "yes",
    "text-events": "no",
    "text-valign": "top",
    "text-halign": "center",
    "text-justification": "auto",
    "line-height": 1,
    color: "#000",
    "box-selection": "contain",
    "text-outline-color": "#000",
    "text-outline-width": 0,
    "text-outline-opacity": 1,
    "text-opacity": 1,
    "text-decoration": "none",
    "text-transform": "none",
    "text-wrap": "none",
    "text-overflow-wrap": "whitespace",
    "text-max-width": 9999,
    "text-background-color": "#000",
    "text-background-opacity": 0,
    "text-background-shape": "rectangle",
    "text-background-padding": 0,
    "text-border-opacity": 0,
    "text-border-width": 0,
    "text-border-style": "solid",
    "text-border-color": "#000",
    "font-family": "Helvetica Neue, Helvetica, sans-serif",
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": 16,
    "min-zoomed-font-size": 0,
    "text-rotation": "none",
    "source-text-rotation": "none",
    "target-text-rotation": "none",
    visibility: "visible",
    display: "element",
    opacity: 1,
    "z-compound-depth": "auto",
    "z-index-compare": "auto",
    "z-index": 0,
    label: "",
    "text-margin-x": 0,
    "text-margin-y": 0,
    "source-label": "",
    "source-text-offset": 0,
    "source-text-margin-x": 0,
    "source-text-margin-y": 0,
    "target-label": "",
    "target-text-offset": 0,
    "target-text-margin-x": 0,
    "target-text-margin-y": 0,
    "overlay-opacity": 0,
    "overlay-color": "#000",
    "overlay-padding": 10,
    "overlay-shape": "round-rectangle",
    "overlay-corner-radius": "auto",
    "underlay-opacity": 0,
    "underlay-color": "#000",
    "underlay-padding": 10,
    "underlay-shape": "round-rectangle",
    "underlay-corner-radius": "auto",
    "transition-property": "none",
    "transition-duration": 0,
    "transition-delay": 0,
    "transition-timing-function": "linear",
    "box-select-labels": "no",
    // node props
    "background-blacken": 0,
    "background-color": "#999",
    "background-fill": "solid",
    "background-opacity": 1,
    "background-image": "none",
    "background-image-crossorigin": "anonymous",
    "background-image-opacity": 1,
    "background-image-containment": "inside",
    "background-image-smoothing": "yes",
    "background-position-x": "50%",
    "background-position-y": "50%",
    "background-offset-x": 0,
    "background-offset-y": 0,
    "background-width-relative-to": "include-padding",
    "background-height-relative-to": "include-padding",
    "background-repeat": "no-repeat",
    "background-fit": "none",
    "background-clip": "node",
    "background-width": "auto",
    "background-height": "auto",
    "border-color": "#000",
    "border-opacity": 1,
    "border-width": 0,
    "border-style": "solid",
    "border-dash-pattern": [4, 2],
    "border-dash-offset": 0,
    "border-cap": "butt",
    "border-join": "miter",
    "border-position": "center",
    "outline-color": "#999",
    "outline-opacity": 1,
    "outline-width": 0,
    "outline-offset": 0,
    "outline-style": "solid",
    height: 30,
    width: 30,
    shape: "ellipse",
    "shape-polygon-points": "-1, -1,   1, -1,   1, 1,   -1, 1",
    "corner-radius": "auto",
    "bounds-expansion": 0,
    // node gradient
    "background-gradient-direction": "to-bottom",
    "background-gradient-stop-colors": "#999",
    "background-gradient-stop-positions": "0%",
    // ghost props
    ghost: "no",
    "ghost-offset-y": 0,
    "ghost-offset-x": 0,
    "ghost-opacity": 0,
    // compound props
    padding: 0,
    "padding-relative-to": "width",
    position: "origin",
    "compound-sizing-wrt-labels": "include",
    "min-width": 0,
    "min-width-bias-left": 0,
    "min-width-bias-right": 0,
    "min-height": 0,
    "min-height-bias-top": 0,
    "min-height-bias-bottom": 0
  }, {
    // node pie bg
    "pie-size": "100%",
    "pie-hole": 0,
    "pie-start-angle": "0deg"
  }, [{
    name: "pie-{{i}}-background-color",
    value: "black"
  }, {
    name: "pie-{{i}}-background-size",
    value: "0%"
  }, {
    name: "pie-{{i}}-background-opacity",
    value: 1
  }].reduce(function(l, u) {
    for (var h = 1; h <= kn.pieBackgroundN; h++) {
      var f = u.name.replace("{{i}}", h), d = u.value;
      l[f] = d;
    }
    return l;
  }, {}), {
    // node stripes bg
    "stripe-size": "100%",
    "stripe-direction": "horizontal"
  }, [{
    name: "stripe-{{i}}-background-color",
    value: "black"
  }, {
    name: "stripe-{{i}}-background-size",
    value: "0%"
  }, {
    name: "stripe-{{i}}-background-opacity",
    value: 1
  }].reduce(function(l, u) {
    for (var h = 1; h <= kn.stripeBackgroundN; h++) {
      var f = u.name.replace("{{i}}", h), d = u.value;
      l[f] = d;
    }
    return l;
  }, {}), {
    // edge props
    "line-style": "solid",
    "line-color": "#999",
    "line-fill": "solid",
    "line-cap": "butt",
    "line-opacity": 1,
    "line-outline-width": 0,
    "line-outline-color": "#000",
    "line-gradient-stop-colors": "#999",
    "line-gradient-stop-positions": "0%",
    "control-point-step-size": 40,
    "control-point-weights": 0.5,
    "segment-weights": 0.5,
    "segment-distances": 20,
    "segment-radii": 15,
    "radius-type": "arc-radius",
    "taxi-turn": "50%",
    "taxi-radius": 15,
    "taxi-turn-min-distance": 10,
    "taxi-direction": "auto",
    "edge-distances": "intersection",
    "curve-style": "haystack",
    "haystack-radius": 0,
    "arrow-scale": 1,
    "loop-direction": "-45deg",
    "loop-sweep": "-90deg",
    "source-distance-from-node": 0,
    "target-distance-from-node": 0,
    "source-endpoint": "outside-to-node",
    "target-endpoint": "outside-to-node",
    "line-dash-pattern": [6, 3],
    "line-dash-offset": 0
  }, [{
    name: "arrow-shape",
    value: "none"
  }, {
    name: "arrow-color",
    value: "#999"
  }, {
    name: "arrow-fill",
    value: "filled"
  }, {
    name: "arrow-width",
    value: 1
  }].reduce(function(l, u) {
    return kn.arrowPrefixes.forEach(function(h) {
      var f = h + "-" + u.name, d = u.value;
      l[f] = d;
    }), l;
  }, {})), r = {}, n = 0; n < this.properties.length; n++) {
    var i = this.properties[n];
    if (!i.pointsTo) {
      var a = i.name, s = e[a], o = this.parse(a, s);
      r[a] = o;
    }
  }
  return t.defaultProperties = r, t.defaultProperties;
};
kn.addDefaultStylesheet = function() {
  this.selector(":parent").css({
    shape: "rectangle",
    padding: 10,
    "background-color": "#eee",
    "border-color": "#ccc",
    "border-width": 1
  }).selector("edge").css({
    width: 3
  }).selector(":loop").css({
    "curve-style": "bezier"
  }).selector("edge:compound").css({
    "curve-style": "bezier",
    "source-endpoint": "outside-to-line",
    "target-endpoint": "outside-to-line"
  }).selector(":selected").css({
    "background-color": "#0169D9",
    "line-color": "#0169D9",
    "source-arrow-color": "#0169D9",
    "target-arrow-color": "#0169D9",
    "mid-source-arrow-color": "#0169D9",
    "mid-target-arrow-color": "#0169D9"
  }).selector(":parent:selected").css({
    "background-color": "#CCE1F9",
    "border-color": "#aec8e5"
  }).selector(":active").css({
    "overlay-color": "black",
    "overlay-padding": 10,
    "overlay-opacity": 0.25
  }), this.defaultLength = this.length;
};
var o3 = {};
o3.parse = function(t, e, r, n) {
  var i = this;
  if (ln(e))
    return i.parseImplWarn(t, e, r, n);
  var a = n === "mapping" || n === !0 || n === !1 || n == null ? "dontcare" : n, s = r ? "t" : "f", o = "" + e, l = Vne(t, o, s, a), u = i.propCache = i.propCache || [], h;
  return (h = u[l]) || (h = u[l] = i.parseImplWarn(t, e, r, n)), (r || n === "mapping") && (h = so(h), h && (h.value = so(h.value))), h;
};
o3.parseImplWarn = function(t, e, r, n) {
  var i = this.parseImpl(t, e, r, n);
  return !i && e != null && Rr("The style property `".concat(t, ": ").concat(e, "` is invalid")), i && (i.name === "width" || i.name === "height") && e === "label" && Rr("The style value of `label` is deprecated for `" + i.name + "`"), i;
};
o3.parseImpl = function(t, e, r, n) {
  var i = this;
  t = gR(t);
  var a = i.properties[t], s = e, o = i.types;
  if (!a || e === void 0)
    return null;
  a.alias && (a = a.pointsTo, t = a.name);
  var l = Pt(e);
  l && (e = e.trim());
  var u = a.type;
  if (!u)
    return null;
  if (r && (e === "" || e === null))
    return {
      name: t,
      value: e,
      bypass: !0,
      deleteBypass: !0
    };
  if (ln(e))
    return {
      name: t,
      value: e,
      strValue: "fn",
      mapped: o.fn,
      bypass: r
    };
  var h, f;
  if (!(!l || n || e.length < 7 || e[1] !== "a")) {
    if (e.length >= 7 && e[0] === "d" && (h = new RegExp(o.data.regex).exec(e))) {
      if (r)
        return !1;
      var d = o.data;
      return {
        name: t,
        value: h,
        strValue: "" + e,
        mapped: d,
        field: h[1],
        bypass: r
      };
    } else if (e.length >= 10 && e[0] === "m" && (f = new RegExp(o.mapData.regex).exec(e))) {
      if (r || u.multiple)
        return !1;
      var p = o.mapData;
      if (!(u.color || u.number))
        return !1;
      var g = this.parse(t, f[4]);
      if (!g || g.mapped)
        return !1;
      var m = this.parse(t, f[5]);
      if (!m || m.mapped)
        return !1;
      if (g.pfValue === m.pfValue || g.strValue === m.strValue)
        return Rr("`" + t + ": " + e + "` is not a valid mapper because the output range is zero; converting to `" + t + ": " + g.strValue + "`"), this.parse(t, g.strValue);
      if (u.color) {
        var v = g.value, y = m.value, b = v[0] === y[0] && v[1] === y[1] && v[2] === y[2] && // optional alpha
        (v[3] === y[3] || (v[3] == null || v[3] === 1) && (y[3] == null || y[3] === 1));
        if (b)
          return !1;
      }
      return {
        name: t,
        value: f,
        strValue: "" + e,
        mapped: p,
        field: f[1],
        fieldMin: parseFloat(f[2]),
        // min & max are numeric
        fieldMax: parseFloat(f[3]),
        valueMin: g.value,
        valueMax: m.value,
        bypass: r
      };
    }
  }
  if (u.multiple && n !== "multiple") {
    var x;
    if (l ? x = e.split(/\s+/) : Pr(e) ? x = e : x = [e], u.evenMultiple && x.length % 2 !== 0)
      return null;
    for (var T = [], E = [], A = [], S = "", k = !1, _ = 0; _ < x.length; _++) {
      var R = i.parse(t, x[_], r, "multiple");
      k = k || Pt(R.value), T.push(R.value), A.push(R.pfValue != null ? R.pfValue : R.value), E.push(R.units), S += (_ > 0 ? " " : "") + R.strValue;
    }
    return u.validate && !u.validate(T, E) ? null : u.singleEnum && k ? T.length === 1 && Pt(T[0]) ? {
      name: t,
      value: T[0],
      strValue: T[0],
      bypass: r
    } : null : {
      name: t,
      value: T,
      pfValue: A,
      strValue: S,
      bypass: r,
      units: E
    };
  }
  var L = function() {
    for (var J = 0; J < u.enums.length; J++) {
      var ee = u.enums[J];
      if (ee === e)
        return {
          name: t,
          value: e,
          strValue: "" + e,
          bypass: r
        };
    }
    return null;
  };
  if (u.number) {
    var M, P = "px";
    if (u.units && (M = u.units), u.implicitUnits && (P = u.implicitUnits), !u.unitless)
      if (l) {
        var C = "px|em" + (u.allowPercent ? "|\\%" : "");
        M && (C = M);
        var I = e.match("^(" + Gn + ")(" + C + ")?$");
        I && (e = I[1], M = I[2] || P);
      } else (!M || u.implicitUnits) && (M = P);
    if (e = parseFloat(e), isNaN(e) && u.enums === void 0)
      return null;
    if (isNaN(e) && u.enums !== void 0)
      return e = s, L();
    if (u.integer && !oLe(e) || u.min !== void 0 && (e < u.min || u.strictMin && e === u.min) || u.max !== void 0 && (e > u.max || u.strictMax && e === u.max))
      return null;
    var N = {
      name: t,
      value: e,
      strValue: "" + e + (M || ""),
      units: M,
      bypass: r
    };
    return u.unitless || M !== "px" && M !== "em" ? N.pfValue = e : N.pfValue = M === "px" || !M ? e : this.getEmSizeInPixels() * e, (M === "ms" || M === "s") && (N.pfValue = M === "ms" ? e : 1e3 * e), (M === "deg" || M === "rad") && (N.pfValue = M === "rad" ? e : vRe(e)), M === "%" && (N.pfValue = e / 100), N;
  } else if (u.propList) {
    var O = [], D = "" + e;
    if (D !== "none") {
      for (var $ = D.split(/\s*,\s*|\s+/), z = 0; z < $.length; z++) {
        var B = $[z].trim();
        i.properties[B] ? O.push(B) : Rr("`" + B + "` is not a valid property name");
      }
      if (O.length === 0)
        return null;
    }
    return {
      name: t,
      value: O,
      strValue: O.length === 0 ? "none" : O.join(" "),
      bypass: r
    };
  } else if (u.color) {
    var G = $ne(e);
    return G ? {
      name: t,
      value: G,
      pfValue: G,
      strValue: "rgb(" + G[0] + "," + G[1] + "," + G[2] + ")",
      // n.b. no spaces b/c of multiple support
      bypass: r
    } : null;
  } else if (u.regex || u.regexes) {
    if (u.enums) {
      var W = L();
      if (W)
        return W;
    }
    for (var V = u.regexes ? u.regexes : [u.regex], U = 0; U < V.length; U++) {
      var Z = new RegExp(V[U]), K = Z.exec(e);
      if (K)
        return {
          name: t,
          value: u.singleRegexMatchValue ? K[1] : K,
          strValue: "" + e,
          bypass: r
        };
    }
    return null;
  } else return u.string ? {
    name: t,
    value: "" + e,
    strValue: "" + e,
    bypass: r
  } : u.enums ? L() : null;
};
var Jn = function(e) {
  if (!(this instanceof Jn))
    return new Jn(e);
  if (!pR(e)) {
    Jr("A style must have a core reference");
    return;
  }
  this._private = {
    cy: e,
    coreStyle: {}
  }, this.length = 0, this.resetToDefault();
}, Ri = Jn.prototype;
Ri.instanceString = function() {
  return "style";
};
Ri.clear = function() {
  for (var t = this._private, e = t.cy, r = e.elements(), n = 0; n < this.length; n++)
    this[n] = void 0;
  return this.length = 0, t.contextStyles = {}, t.propDiffs = {}, this.cleanElements(r, !0), r.forEach(function(i) {
    var a = i[0]._private;
    a.styleDirty = !0, a.appliedInitStyle = !1;
  }), this;
};
Ri.resetToDefault = function() {
  return this.clear(), this.addDefaultStylesheet(), this;
};
Ri.core = function(t) {
  return this._private.coreStyle[t] || this.getDefaultProperty(t);
};
Ri.selector = function(t) {
  var e = t === "core" ? null : new wc(t), r = this.length++;
  return this[r] = {
    selector: e,
    properties: [],
    mappedProperties: [],
    index: r
  }, this;
};
Ri.css = function() {
  var t = this, e = arguments;
  if (e.length === 1)
    for (var r = e[0], n = 0; n < t.properties.length; n++) {
      var i = t.properties[n], a = r[i.name];
      a === void 0 && (a = r[Y4(i.name)]), a !== void 0 && this.cssRule(i.name, a);
    }
  else e.length === 2 && this.cssRule(e[0], e[1]);
  return this;
};
Ri.style = Ri.css;
Ri.cssRule = function(t, e) {
  var r = this.parse(t, e);
  if (r) {
    var n = this.length - 1;
    this[n].properties.push(r), this[n].properties[r.name] = r, r.name.match(/pie-(\d+)-background-size/) && r.value && (this._private.hasPie = !0), r.name.match(/stripe-(\d+)-background-size/) && r.value && (this._private.hasStripe = !0), r.mapped && this[n].mappedProperties.push(r);
    var i = !this[n].selector;
    i && (this._private.coreStyle[r.name] = r);
  }
  return this;
};
Ri.append = function(t) {
  return Dne(t) ? t.appendToStyle(this) : Pr(t) ? this.appendFromJson(t) : Pt(t) && this.appendFromString(t), this;
};
Jn.fromJson = function(t, e) {
  var r = new Jn(t);
  return r.fromJson(e), r;
};
Jn.fromString = function(t, e) {
  return new Jn(t).fromString(e);
};
[ni, Cm, RR, vo, s3, IR, kn, o3].forEach(function(t) {
  Ut(Ri, t);
});
Jn.types = Ri.types;
Jn.properties = Ri.properties;
Jn.propertyGroups = Ri.propertyGroups;
Jn.propertyGroupNames = Ri.propertyGroupNames;
Jn.propertyGroupKeys = Ri.propertyGroupKeys;
var wNe = {
  style: function(e) {
    if (e) {
      var r = this.setStyle(e);
      r.update();
    }
    return this._private.style;
  },
  setStyle: function(e) {
    var r = this._private;
    return Dne(e) ? r.style = e.generateStyle(this) : Pr(e) ? r.style = Jn.fromJson(this, e) : Pt(e) ? r.style = Jn.fromString(this, e) : r.style = Jn(this), r.style;
  },
  // e.g. cy.data() changed => recalc ele mappers
  updateStyle: function() {
    this.mutableElements().updateStyle();
  }
}, TNe = "single", ih = {
  autolock: function(e) {
    if (e !== void 0)
      this._private.autolock = !!e;
    else
      return this._private.autolock;
    return this;
  },
  autoungrabify: function(e) {
    if (e !== void 0)
      this._private.autoungrabify = !!e;
    else
      return this._private.autoungrabify;
    return this;
  },
  autounselectify: function(e) {
    if (e !== void 0)
      this._private.autounselectify = !!e;
    else
      return this._private.autounselectify;
    return this;
  },
  selectionType: function(e) {
    var r = this._private;
    if (r.selectionType == null && (r.selectionType = TNe), e !== void 0)
      (e === "additive" || e === "single") && (r.selectionType = e);
    else
      return r.selectionType;
    return this;
  },
  panningEnabled: function(e) {
    if (e !== void 0)
      this._private.panningEnabled = !!e;
    else
      return this._private.panningEnabled;
    return this;
  },
  userPanningEnabled: function(e) {
    if (e !== void 0)
      this._private.userPanningEnabled = !!e;
    else
      return this._private.userPanningEnabled;
    return this;
  },
  zoomingEnabled: function(e) {
    if (e !== void 0)
      this._private.zoomingEnabled = !!e;
    else
      return this._private.zoomingEnabled;
    return this;
  },
  userZoomingEnabled: function(e) {
    if (e !== void 0)
      this._private.userZoomingEnabled = !!e;
    else
      return this._private.userZoomingEnabled;
    return this;
  },
  boxSelectionEnabled: function(e) {
    if (e !== void 0)
      this._private.boxSelectionEnabled = !!e;
    else
      return this._private.boxSelectionEnabled;
    return this;
  },
  pan: function() {
    var e = arguments, r = this._private.pan, n, i, a, s, o;
    switch (e.length) {
      case 0:
        return r;
      case 1:
        if (Pt(e[0]))
          return n = e[0], r[n];
        if (yr(e[0])) {
          if (!this._private.panningEnabled)
            return this;
          a = e[0], s = a.x, o = a.y, mt(s) && (r.x = s), mt(o) && (r.y = o), this.emit("pan viewport");
        }
        break;
      case 2:
        if (!this._private.panningEnabled)
          return this;
        n = e[0], i = e[1], (n === "x" || n === "y") && mt(i) && (r[n] = i), this.emit("pan viewport");
        break;
    }
    return this.notify("viewport"), this;
  },
  panBy: function(e, r) {
    var n = arguments, i = this._private.pan, a, s, o, l, u;
    if (!this._private.panningEnabled)
      return this;
    switch (n.length) {
      case 1:
        yr(e) && (o = n[0], l = o.x, u = o.y, mt(l) && (i.x += l), mt(u) && (i.y += u), this.emit("pan viewport"));
        break;
      case 2:
        a = e, s = r, (a === "x" || a === "y") && mt(s) && (i[a] += s), this.emit("pan viewport");
        break;
    }
    return this.notify("viewport"), this;
  },
  gc: function() {
    this.notify("gc");
  },
  fit: function(e, r) {
    var n = this.getFitViewport(e, r);
    if (n) {
      var i = this._private;
      i.zoom = n.zoom, i.pan = n.pan, this.emit("pan zoom viewport"), this.notify("viewport");
    }
    return this;
  },
  getFitViewport: function(e, r) {
    if (mt(e) && r === void 0 && (r = e, e = void 0), !(!this._private.panningEnabled || !this._private.zoomingEnabled)) {
      var n;
      if (Pt(e)) {
        var i = e;
        e = this.$(i);
      } else if (uLe(e)) {
        var a = e;
        n = {
          x1: a.x1,
          y1: a.y1,
          x2: a.x2,
          y2: a.y2
        }, n.w = n.x2 - n.x1, n.h = n.y2 - n.y1;
      } else La(e) || (e = this.mutableElements());
      if (!(La(e) && e.empty())) {
        n = n || e.boundingBox();
        var s = this.width(), o = this.height(), l;
        if (r = mt(r) ? r : 0, !isNaN(s) && !isNaN(o) && s > 0 && o > 0 && !isNaN(n.w) && !isNaN(n.h) && n.w > 0 && n.h > 0) {
          l = Math.min((s - 2 * r) / n.w, (o - 2 * r) / n.h), l = l > this._private.maxZoom ? this._private.maxZoom : l, l = l < this._private.minZoom ? this._private.minZoom : l;
          var u = {
            // now pan to middle
            x: (s - l * (n.x1 + n.x2)) / 2,
            y: (o - l * (n.y1 + n.y2)) / 2
          };
          return {
            zoom: l,
            pan: u
          };
        }
      }
    }
  },
  zoomRange: function(e, r) {
    var n = this._private;
    if (r == null) {
      var i = e;
      e = i.min, r = i.max;
    }
    return mt(e) && mt(r) && e <= r ? (n.minZoom = e, n.maxZoom = r) : mt(e) && r === void 0 && e <= n.maxZoom ? n.minZoom = e : mt(r) && e === void 0 && r >= n.minZoom && (n.maxZoom = r), this;
  },
  minZoom: function(e) {
    return e === void 0 ? this._private.minZoom : this.zoomRange({
      min: e
    });
  },
  maxZoom: function(e) {
    return e === void 0 ? this._private.maxZoom : this.zoomRange({
      max: e
    });
  },
  getZoomedViewport: function(e) {
    var r = this._private, n = r.pan, i = r.zoom, a, s, o = !1;
    if (r.zoomingEnabled || (o = !0), mt(e) ? s = e : yr(e) && (s = e.level, e.position != null ? a = K4(e.position, i, n) : e.renderedPosition != null && (a = e.renderedPosition), a != null && !r.panningEnabled && (o = !0)), s = s > r.maxZoom ? r.maxZoom : s, s = s < r.minZoom ? r.minZoom : s, o || !mt(s) || s === i || a != null && (!mt(a.x) || !mt(a.y)))
      return null;
    if (a != null) {
      var l = n, u = i, h = s, f = {
        x: -h / u * (a.x - l.x) + a.x,
        y: -h / u * (a.y - l.y) + a.y
      };
      return {
        zoomed: !0,
        panned: !0,
        zoom: h,
        pan: f
      };
    } else
      return {
        zoomed: !0,
        panned: !1,
        zoom: s,
        pan: n
      };
  },
  zoom: function(e) {
    if (e === void 0)
      return this._private.zoom;
    var r = this.getZoomedViewport(e), n = this._private;
    return r == null || !r.zoomed ? this : (n.zoom = r.zoom, r.panned && (n.pan.x = r.pan.x, n.pan.y = r.pan.y), this.emit("zoom" + (r.panned ? " pan" : "") + " viewport"), this.notify("viewport"), this);
  },
  viewport: function(e) {
    var r = this._private, n = !0, i = !0, a = [], s = !1, o = !1;
    if (!e)
      return this;
    if (mt(e.zoom) || (n = !1), yr(e.pan) || (i = !1), !n && !i)
      return this;
    if (n) {
      var l = e.zoom;
      l < r.minZoom || l > r.maxZoom || !r.zoomingEnabled ? s = !0 : (r.zoom = l, a.push("zoom"));
    }
    if (i && (!s || !e.cancelOnFailedZoom) && r.panningEnabled) {
      var u = e.pan;
      mt(u.x) && (r.pan.x = u.x, o = !1), mt(u.y) && (r.pan.y = u.y, o = !1), o || a.push("pan");
    }
    return a.length > 0 && (a.push("viewport"), this.emit(a.join(" ")), this.notify("viewport")), this;
  },
  center: function(e) {
    var r = this.getCenterPan(e);
    return r && (this._private.pan = r, this.emit("pan viewport"), this.notify("viewport")), this;
  },
  getCenterPan: function(e, r) {
    if (this._private.panningEnabled) {
      if (Pt(e)) {
        var n = e;
        e = this.mutableElements().filter(n);
      } else La(e) || (e = this.mutableElements());
      if (e.length !== 0) {
        var i = e.boundingBox(), a = this.width(), s = this.height();
        r = r === void 0 ? this._private.zoom : r;
        var o = {
          // middle
          x: (a - r * (i.x1 + i.x2)) / 2,
          y: (s - r * (i.y1 + i.y2)) / 2
        };
        return o;
      }
    }
  },
  reset: function() {
    return !this._private.panningEnabled || !this._private.zoomingEnabled ? this : (this.viewport({
      pan: {
        x: 0,
        y: 0
      },
      zoom: 1
    }), this);
  },
  invalidateSize: function() {
    this._private.sizeCache = null;
  },
  size: function() {
    var e = this._private, r = e.container, n = this;
    return e.sizeCache = e.sizeCache || (r ? (function() {
      var i = n.window().getComputedStyle(r), a = function(o) {
        return parseFloat(i.getPropertyValue(o));
      };
      return {
        width: r.clientWidth - a("padding-left") - a("padding-right"),
        height: r.clientHeight - a("padding-top") - a("padding-bottom")
      };
    })() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },
  width: function() {
    return this.size().width;
  },
  height: function() {
    return this.size().height;
  },
  extent: function() {
    var e = this._private.pan, r = this._private.zoom, n = this.renderedExtent(), i = {
      x1: (n.x1 - e.x) / r,
      x2: (n.x2 - e.x) / r,
      y1: (n.y1 - e.y) / r,
      y2: (n.y2 - e.y) / r
    };
    return i.w = i.x2 - i.x1, i.h = i.y2 - i.y1, i;
  },
  renderedExtent: function() {
    var e = this.width(), r = this.height();
    return {
      x1: 0,
      y1: 0,
      x2: e,
      y2: r,
      w: e,
      h: r
    };
  },
  multiClickDebounceTime: function(e) {
    if (e) this._private.multiClickDebounceTime = e;
    else return this._private.multiClickDebounceTime;
    return this;
  }
};
ih.centre = ih.center;
ih.autolockNodes = ih.autolock;
ih.autoungrabifyNodes = ih.autoungrabify;
var L1 = {
  data: Ar.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "data",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeData: Ar.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  }),
  scratch: Ar.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "scratch",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeScratch: Ar.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  })
};
L1.attr = L1.data;
L1.removeAttr = L1.removeData;
var R1 = function(e) {
  var r = this;
  e = Ut({}, e);
  var n = e.container;
  n && !_b(n) && _b(n[0]) && (n = n[0]);
  var i = n ? n._cyreg : null;
  i = i || {}, i && i.cy && (i.cy.destroy(), i = {});
  var a = i.readies = i.readies || [];
  n && (n._cyreg = i), i.cy = r;
  var s = Bn !== void 0 && n !== void 0 && !e.headless, o = e;
  o.layout = Ut({
    name: s ? "grid" : "null"
  }, o.layout), o.renderer = Ut({
    name: s ? "canvas" : "null"
  }, o.renderer);
  var l = function(g, m, v) {
    return m !== void 0 ? m : v !== void 0 ? v : g;
  }, u = this._private = {
    container: n,
    // html dom ele container
    ready: !1,
    // whether ready has been triggered
    options: o,
    // cached options
    elements: new pi(this),
    // elements in the graph
    listeners: [],
    // list of listeners
    aniEles: new pi(this),
    // elements being animated
    data: o.data || {},
    // data for the core
    scratch: {},
    // scratch object for core
    layout: null,
    renderer: null,
    destroyed: !1,
    // whether destroy was called
    notificationsEnabled: !0,
    // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: l(!0, o.zoomingEnabled),
    userZoomingEnabled: l(!0, o.userZoomingEnabled),
    panningEnabled: l(!0, o.panningEnabled),
    userPanningEnabled: l(!0, o.userPanningEnabled),
    boxSelectionEnabled: l(!0, o.boxSelectionEnabled),
    autolock: l(!1, o.autolock, o.autolockNodes),
    autoungrabify: l(!1, o.autoungrabify, o.autoungrabifyNodes),
    autounselectify: l(!1, o.autounselectify),
    styleEnabled: o.styleEnabled === void 0 ? s : o.styleEnabled,
    zoom: mt(o.zoom) ? o.zoom : 1,
    pan: {
      x: yr(o.pan) && mt(o.pan.x) ? o.pan.x : 0,
      y: yr(o.pan) && mt(o.pan.y) ? o.pan.y : 0
    },
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: !1,
    multiClickDebounceTime: l(250, o.multiClickDebounceTime)
  };
  this.createEmitter(), this.selectionType(o.selectionType), this.zoomRange({
    min: o.minZoom,
    max: o.maxZoom
  });
  var h = function(g, m) {
    var v = g.some(hLe);
    if (v)
      return G0.all(g).then(m);
    m(g);
  };
  u.styleEnabled && r.setStyle([]);
  var f = Ut({}, o, o.renderer);
  r.initRenderer(f);
  var d = function(g, m, v) {
    r.notifications(!1);
    var y = r.mutableElements();
    y.length > 0 && y.remove(), g != null && (yr(g) || Pr(g)) && r.add(g), r.one("layoutready", function(x) {
      r.notifications(!0), r.emit(x), r.one("load", m), r.emitAndNotify("load");
    }).one("layoutstop", function() {
      r.one("done", v), r.emit("done");
    });
    var b = Ut({}, r._private.options.layout);
    b.eles = r.elements(), r.layout(b).run();
  };
  h([o.style, o.elements], function(p) {
    var g = p[0], m = p[1];
    u.styleEnabled && r.style().append(g), d(m, function() {
      r.startAnimationLoop(), u.ready = !0, ln(o.ready) && r.on("ready", o.ready);
      for (var v = 0; v < a.length; v++) {
        var y = a[v];
        r.on("ready", y);
      }
      i && (i.readies = []), r.emit("ready");
    }, o.done);
  });
}, Db = R1.prototype;
Ut(Db, {
  instanceString: function() {
    return "core";
  },
  isReady: function() {
    return this._private.ready;
  },
  destroyed: function() {
    return this._private.destroyed;
  },
  ready: function(e) {
    return this.isReady() ? this.emitter().emit("ready", [], e) : this.on("ready", e), this;
  },
  destroy: function() {
    var e = this;
    if (!e.destroyed())
      return e.stopAnimationLoop(), e.destroyRenderer(), this.emit("destroy"), e._private.destroyed = !0, e;
  },
  hasElementWithId: function(e) {
    return this._private.elements.hasElementWithId(e);
  },
  getElementById: function(e) {
    return this._private.elements.getElementById(e);
  },
  hasCompoundNodes: function() {
    return this._private.hasCompoundNodes;
  },
  headless: function() {
    return this._private.renderer.isHeadless();
  },
  styleEnabled: function() {
    return this._private.styleEnabled;
  },
  addToPool: function(e) {
    return this._private.elements.merge(e), this;
  },
  removeFromPool: function(e) {
    return this._private.elements.unmerge(e), this;
  },
  container: function() {
    return this._private.container || null;
  },
  window: function() {
    var e = this._private.container;
    if (e == null) return Bn;
    var r = this._private.container.ownerDocument;
    return r === void 0 || r == null ? Bn : r.defaultView || Bn;
  },
  mount: function(e) {
    if (e != null) {
      var r = this, n = r._private, i = n.options;
      return !_b(e) && _b(e[0]) && (e = e[0]), r.stopAnimationLoop(), r.destroyRenderer(), n.container = e, n.styleEnabled = !0, r.invalidateSize(), r.initRenderer(Ut({}, i, i.renderer, {
        // allow custom renderer name to be re-used, otherwise use canvas
        name: i.renderer.name === "null" ? "canvas" : i.renderer.name
      })), r.startAnimationLoop(), r.style(i.style), r.emit("mount"), r;
    }
  },
  unmount: function() {
    var e = this;
    return e.stopAnimationLoop(), e.destroyRenderer(), e.initRenderer({
      name: "null"
    }), e.emit("unmount"), e;
  },
  options: function() {
    return so(this._private.options);
  },
  json: function(e) {
    var r = this, n = r._private, i = r.mutableElements(), a = function(T) {
      return r.getElementById(T.id());
    };
    if (yr(e)) {
      if (r.startBatch(), e.elements) {
        var s = {}, o = function(T, E) {
          for (var A = [], S = [], k = 0; k < T.length; k++) {
            var _ = T[k];
            if (!_.data.id) {
              Rr("cy.json() cannot handle elements without an ID attribute");
              continue;
            }
            var R = "" + _.data.id, L = r.getElementById(R);
            s[R] = !0, L.length !== 0 ? S.push({
              ele: L,
              json: _
            }) : (E && (_.group = E), A.push(_));
          }
          r.add(A);
          for (var M = 0; M < S.length; M++) {
            var P = S[M], C = P.ele, I = P.json;
            C.json(I);
          }
        };
        if (Pr(e.elements))
          o(e.elements);
        else
          for (var l = ["nodes", "edges"], u = 0; u < l.length; u++) {
            var h = l[u], f = e.elements[h];
            Pr(f) && o(f, h);
          }
        var d = r.collection();
        i.filter(function(x) {
          return !s[x.id()];
        }).forEach(function(x) {
          x.isParent() ? d.merge(x) : x.remove();
        }), d.forEach(function(x) {
          return x.children().move({
            parent: null
          });
        }), d.forEach(function(x) {
          return a(x).remove();
        });
      }
      e.style && r.style(e.style), e.zoom != null && e.zoom !== n.zoom && r.zoom(e.zoom), e.pan && (e.pan.x !== n.pan.x || e.pan.y !== n.pan.y) && r.pan(e.pan), e.data && r.data(e.data);
      for (var p = ["minZoom", "maxZoom", "zoomingEnabled", "userZoomingEnabled", "panningEnabled", "userPanningEnabled", "boxSelectionEnabled", "autolock", "autoungrabify", "autounselectify", "multiClickDebounceTime"], g = 0; g < p.length; g++) {
        var m = p[g];
        e[m] != null && r[m](e[m]);
      }
      return r.endBatch(), this;
    } else {
      var v = !!e, y = {};
      v ? y.elements = this.elements().map(function(x) {
        return x.json();
      }) : (y.elements = {}, i.forEach(function(x) {
        var T = x.group();
        y.elements[T] || (y.elements[T] = []), y.elements[T].push(x.json());
      })), this._private.styleEnabled && (y.style = r.style().json()), y.data = so(r.data());
      var b = n.options;
      return y.zoomingEnabled = n.zoomingEnabled, y.userZoomingEnabled = n.userZoomingEnabled, y.zoom = n.zoom, y.minZoom = n.minZoom, y.maxZoom = n.maxZoom, y.panningEnabled = n.panningEnabled, y.userPanningEnabled = n.userPanningEnabled, y.pan = so(n.pan), y.boxSelectionEnabled = n.boxSelectionEnabled, y.renderer = so(b.renderer), y.hideEdgesOnViewport = b.hideEdgesOnViewport, y.textureOnViewport = b.textureOnViewport, y.wheelSensitivity = b.wheelSensitivity, y.motionBlur = b.motionBlur, y.multiClickDebounceTime = b.multiClickDebounceTime, y;
    }
  }
});
Db.$id = Db.getElementById;
[hNe, mNe, Die, xA, qy, yNe, wA, Gy, wNe, ih, L1].forEach(function(t) {
  Ut(Db, t);
});
var ENe = {
  fit: !0,
  // whether to fit the viewport to the graph
  directed: !1,
  // whether the tree is directed downwards (or edges can point in any direction if false)
  direction: "downward",
  // determines the direction in which the tree structure is drawn.  The possible values are 'downward', 'upward', 'rightward', or 'leftward'.
  padding: 30,
  // padding on fit
  circle: !1,
  // put depths in concentric circles if true, put depths top down if false
  grid: !1,
  // whether to create an even grid into which the DAG is placed (circle:false only)
  spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: void 0,
  // the roots of the trees
  depthSort: void 0,
  // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled,
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
}, SNe = {
  maximal: !1,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also
  acyclic: !1
  // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops
}, nf = function(e) {
  return e.scratch("breadthfirst");
}, tU = function(e, r) {
  return e.scratch("breadthfirst", r);
};
function Oie(t) {
  this.options = Ut({}, ENe, SNe, t);
}
Oie.prototype.run = function() {
  var t = this.options, e = t.cy, r = t.eles, n = r.nodes().filter(function(Ne) {
    return Ne.isChildless();
  }), i = r, a = t.directed, s = t.acyclic || t.maximal || t.maximalAdjustments > 0, o = !!t.boundingBox, l = ji(o ? t.boundingBox : structuredClone(e.extent())), u;
  if (La(t.roots))
    u = t.roots;
  else if (Pr(t.roots)) {
    for (var h = [], f = 0; f < t.roots.length; f++) {
      var d = t.roots[f], p = e.getElementById(d);
      h.push(p);
    }
    u = e.collection(h);
  } else if (Pt(t.roots))
    u = e.$(t.roots);
  else if (a)
    u = n.roots();
  else {
    var g = r.components();
    u = e.collection();
    for (var m = function() {
      var fe = g[v], qe = fe.maxDegree(!1), ze = fe.filter(function(Ge) {
        return Ge.degree(!1) === qe;
      });
      u = u.add(ze);
    }, v = 0; v < g.length; v++)
      m();
  }
  var y = [], b = {}, x = function(fe, qe) {
    y[qe] == null && (y[qe] = []);
    var ze = y[qe].length;
    y[qe].push(fe), tU(fe, {
      index: ze,
      depth: qe
    });
  }, T = function(fe, qe) {
    var ze = nf(fe), Ge = ze.depth, Ee = ze.index;
    y[Ge][Ee] = null, fe.isChildless() && x(fe, qe);
  };
  i.bfs({
    roots: u,
    directed: t.directed,
    visit: function(fe, qe, ze, Ge, Ee) {
      var Oe = fe[0], Ce = Oe.id();
      Oe.isChildless() && x(Oe, Ee), b[Ce] = !0;
    }
  });
  for (var E = [], A = 0; A < n.length; A++) {
    var S = n[A];
    b[S.id()] || E.push(S);
  }
  var k = function(fe) {
    for (var qe = y[fe], ze = 0; ze < qe.length; ze++) {
      var Ge = qe[ze];
      if (Ge == null) {
        qe.splice(ze, 1), ze--;
        continue;
      }
      tU(Ge, {
        depth: fe,
        index: ze
      });
    }
  }, _ = function(fe, qe) {
    for (var ze = nf(fe), Ge = fe.incomers().filter(function(Ie) {
      return Ie.isNode() && r.has(Ie);
    }), Ee = -1, Oe = fe.id(), Ce = 0; Ce < Ge.length; Ce++) {
      var Ae = Ge[Ce], $e = nf(Ae);
      Ee = Math.max(Ee, $e.depth);
    }
    if (ze.depth <= Ee) {
      if (!t.acyclic && qe[Oe])
        return null;
      var me = Ee + 1;
      return T(fe, me), qe[Oe] = me, !0;
    }
    return !1;
  };
  if (a && s) {
    var R = [], L = {}, M = function(fe) {
      return R.push(fe);
    }, P = function() {
      return R.shift();
    };
    for (n.forEach(function(Ne) {
      return R.push(Ne);
    }); R.length > 0; ) {
      var C = P(), I = _(C, L);
      if (I)
        C.outgoers().filter(function(Ne) {
          return Ne.isNode() && r.has(Ne);
        }).forEach(M);
      else if (I === null) {
        Rr("Detected double maximal shift for node `" + C.id() + "`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.");
        break;
      }
    }
  }
  var N = 0;
  if (t.avoidOverlap)
    for (var O = 0; O < n.length; O++) {
      var D = n[O], $ = D.layoutDimensions(t), z = $.w, B = $.h;
      N = Math.max(N, z, B);
    }
  var G = {}, W = function(fe) {
    if (G[fe.id()])
      return G[fe.id()];
    for (var qe = nf(fe).depth, ze = fe.neighborhood(), Ge = 0, Ee = 0, Oe = 0; Oe < ze.length; Oe++) {
      var Ce = ze[Oe];
      if (!(Ce.isEdge() || Ce.isParent() || !n.has(Ce))) {
        var Ae = nf(Ce);
        if (Ae != null) {
          var $e = Ae.index, me = Ae.depth;
          if (!($e == null || me == null)) {
            var Ie = y[me].length;
            me < qe && (Ge += $e / Ie, Ee++);
          }
        }
      }
    }
    return Ee = Math.max(1, Ee), Ge = Ge / Ee, Ee === 0 && (Ge = 0), G[fe.id()] = Ge, Ge;
  }, V = function(fe, qe) {
    var ze = W(fe), Ge = W(qe), Ee = ze - Ge;
    return Ee === 0 ? Pne(fe.id(), qe.id()) : Ee;
  };
  t.depthSort !== void 0 && (V = t.depthSort);
  for (var U = y.length, Z = 0; Z < U; Z++)
    y[Z].sort(V), k(Z);
  for (var K = [], ce = 0; ce < E.length; ce++)
    K.push(E[ce]);
  var J = function() {
    for (var fe = 0; fe < U; fe++)
      k(fe);
  };
  K.length && (y.unshift(K), U = y.length, J());
  for (var ee = 0, j = 0; j < U; j++)
    ee = Math.max(y[j].length, ee);
  var X = {
    x: l.x1 + l.w / 2,
    y: l.y1 + l.h / 2
  }, re = n.reduce(function(Ne, fe) {
    return (function(qe) {
      return {
        w: Ne.w === -1 ? qe.w : (Ne.w + qe.w) / 2,
        h: Ne.h === -1 ? qe.h : (Ne.h + qe.h) / 2
      };
    })(fe.boundingBox({
      includeLabels: t.nodeDimensionsIncludeLabels
    }));
  }, {
    w: -1,
    h: -1
  }), Q = Math.max(
    // only one depth
    U === 1 ? 0 : (
      // inside a bounding box, no need for top & bottom padding
      o ? (l.h - t.padding * 2 - re.h) / (U - 1) : (l.h - t.padding * 2 - re.h) / (U + 1)
    ),
    N
  ), ue = y.reduce(function(Ne, fe) {
    return Math.max(Ne, fe.length);
  }, 0), ne = function(fe) {
    var qe = nf(fe), ze = qe.depth, Ge = qe.index;
    if (t.circle) {
      var Ee = Math.min(l.w / 2 / U, l.h / 2 / U);
      Ee = Math.max(Ee, N);
      var Oe = Ee * ze + Ee - (U > 0 && y[0].length <= 3 ? Ee / 2 : 0), Ce = 2 * Math.PI / y[ze].length * Ge;
      return ze === 0 && y[0].length === 1 && (Oe = 1), {
        x: X.x + Oe * Math.cos(Ce),
        y: X.y + Oe * Math.sin(Ce)
      };
    } else {
      var Ae = y[ze].length, $e = Math.max(
        // only one depth
        Ae === 1 ? 0 : (
          // inside a bounding box, no need for left & right padding
          o ? (l.w - t.padding * 2 - re.w) / ((t.grid ? ue : Ae) - 1) : (l.w - t.padding * 2 - re.w) / ((t.grid ? ue : Ae) + 1)
        ),
        N
      ), me = {
        x: X.x + (Ge + 1 - (Ae + 1) / 2) * $e,
        y: X.y + (ze + 1 - (U + 1) / 2) * Q
      };
      return me;
    }
  }, xe = {
    downward: 0,
    leftward: 90,
    upward: 180,
    rightward: -90
  };
  Object.keys(xe).indexOf(t.direction) === -1 && Jr("Invalid direction '".concat(t.direction, "' specified for breadthfirst layout. Valid values are: ").concat(Object.keys(xe).join(", ")));
  var Y = function(fe) {
    return zLe(ne(fe), l, xe[t.direction]);
  };
  return r.nodes().layoutPositions(this, t, Y), this;
};
var kNe = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: void 0,
  // the radius of the circle
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: !0,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function Pie(t) {
  this.options = Ut({}, kNe, t);
}
Pie.prototype.run = function() {
  var t = this.options, e = t, r = t.cy, n = e.eles, i = e.counterclockwise !== void 0 ? !e.counterclockwise : e.clockwise, a = n.nodes().not(":parent");
  e.sort && (a = a.sort(e.sort));
  for (var s = ji(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: r.width(),
    h: r.height()
  }), o = {
    x: s.x1 + s.w / 2,
    y: s.y1 + s.h / 2
  }, l = e.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / a.length : e.sweep, u = l / Math.max(1, a.length - 1), h, f = 0, d = 0; d < a.length; d++) {
    var p = a[d], g = p.layoutDimensions(e), m = g.w, v = g.h;
    f = Math.max(f, m, v);
  }
  if (mt(e.radius) ? h = e.radius : a.length <= 1 ? h = 0 : h = Math.min(s.h, s.w) / 2 - f, a.length > 1 && e.avoidOverlap) {
    f *= 1.75;
    var y = Math.cos(u) - Math.cos(0), b = Math.sin(u) - Math.sin(0), x = Math.sqrt(f * f / (y * y + b * b));
    h = Math.max(x, h);
  }
  var T = function(A, S) {
    var k = e.startAngle + S * u * (i ? 1 : -1), _ = h * Math.cos(k), R = h * Math.sin(k), L = {
      x: o.x + _,
      y: o.y + R
    };
    return L;
  };
  return n.nodes().layoutPositions(this, e, T), this;
};
var CNe = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: !0,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: !1,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: void 0,
  // height of layout area (overrides container height)
  width: void 0,
  // width of layout area (overrides container width)
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function(e) {
    return e.degree();
  },
  levelWidth: function(e) {
    return e.maxDegree() / 4;
  },
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function $ie(t) {
  this.options = Ut({}, CNe, t);
}
$ie.prototype.run = function() {
  for (var t = this.options, e = t, r = e.counterclockwise !== void 0 ? !e.counterclockwise : e.clockwise, n = t.cy, i = e.eles, a = i.nodes().not(":parent"), s = ji(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: n.width(),
    h: n.height()
  }), o = {
    x: s.x1 + s.w / 2,
    y: s.y1 + s.h / 2
  }, l = [], u = 0, h = 0; h < a.length; h++) {
    var f = a[h], d = void 0;
    d = e.concentric(f), l.push({
      value: d,
      node: f
    }), f._private.scratch.concentric = d;
  }
  a.updateStyle();
  for (var p = 0; p < a.length; p++) {
    var g = a[p], m = g.layoutDimensions(e);
    u = Math.max(u, m.w, m.h);
  }
  l.sort(function(Q, ue) {
    return ue.value - Q.value;
  });
  for (var v = e.levelWidth(a), y = [[]], b = y[0], x = 0; x < l.length; x++) {
    var T = l[x];
    if (b.length > 0) {
      var E = Math.abs(b[0].value - T.value);
      E >= v && (b = [], y.push(b));
    }
    b.push(T);
  }
  var A = u + e.minNodeSpacing;
  if (!e.avoidOverlap) {
    var S = y.length > 0 && y[0].length > 1, k = Math.min(s.w, s.h) / 2 - A, _ = k / (y.length + S ? 1 : 0);
    A = Math.min(A, _);
  }
  for (var R = 0, L = 0; L < y.length; L++) {
    var M = y[L], P = e.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / M.length : e.sweep, C = M.dTheta = P / Math.max(1, M.length - 1);
    if (M.length > 1 && e.avoidOverlap) {
      var I = Math.cos(C) - Math.cos(0), N = Math.sin(C) - Math.sin(0), O = Math.sqrt(A * A / (I * I + N * N));
      R = Math.max(O, R);
    }
    M.r = R, R += A;
  }
  if (e.equidistant) {
    for (var D = 0, $ = 0, z = 0; z < y.length; z++) {
      var B = y[z], G = B.r - $;
      D = Math.max(D, G);
    }
    $ = 0;
    for (var W = 0; W < y.length; W++) {
      var V = y[W];
      W === 0 && ($ = V.r), V.r = $, $ += D;
    }
  }
  for (var U = {}, Z = 0; Z < y.length; Z++)
    for (var K = y[Z], ce = K.dTheta, J = K.r, ee = 0; ee < K.length; ee++) {
      var j = K[ee], X = e.startAngle + (r ? 1 : -1) * ce * ee, re = {
        x: o.x + J * Math.cos(X),
        y: o.y + J * Math.sin(X)
      };
      U[j.node.id()] = re;
    }
  return i.nodes().layoutPositions(this, e, function(Q) {
    var ue = Q.id();
    return U[ue];
  }), this;
};
var KC, _Ne = {
  // Called on `layoutready`
  ready: function() {
  },
  // Called on `layoutstop`
  stop: function() {
  },
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: !0,
  // Easing of the animation for animate:'end'
  animationEasing: void 0,
  // The duration of the animation for animate:'end'
  animationDuration: void 0,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function(e, r) {
    return !0;
  },
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
  refresh: 20,
  // Whether to fit the network view after when done
  fit: !0,
  // Padding on fit
  padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: void 0,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: !1,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: !1,
  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function(e) {
    return 2048;
  },
  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,
  // Ideal edge (non nested) length
  idealEdgeLength: function(e) {
    return 32;
  },
  // Divisor to compute edge forces
  edgeElasticity: function(e) {
    return 32;
  },
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,
  // Gravity force (constant)
  gravity: 1,
  // Maximum number of iterations to perform
  numIter: 1e3,
  // Initial temperature (maximum node displacement)
  initialTemp: 1e3,
  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1
};
function l3(t) {
  this.options = Ut({}, _Ne, t), this.options.layout = this;
  var e = this.options.eles.nodes(), r = this.options.eles.edges(), n = r.filter(function(i) {
    var a = i.source().data("id"), s = i.target().data("id"), o = e.some(function(u) {
      return u.data("id") === a;
    }), l = e.some(function(u) {
      return u.data("id") === s;
    });
    return !o || !l;
  });
  this.options.eles = this.options.eles.not(n);
}
l3.prototype.run = function() {
  var t = this.options, e = t.cy, r = this;
  r.stopped = !1, (t.animate === !0 || t.animate === !1) && r.emit({
    type: "layoutstart",
    layout: r
  }), t.debug === !0 ? KC = !0 : KC = !1;
  var n = ANe(e, r, t);
  KC && RNe(n), t.randomize && INe(n);
  var i = yl(), a = function() {
    MNe(n, e, t), t.fit === !0 && e.fit(t.padding);
  }, s = function(d) {
    return !(r.stopped || d >= t.numIter || (NNe(n, t), n.temperature = n.temperature * t.coolingFactor, n.temperature < t.minTemp));
  }, o = function() {
    if (t.animate === !0 || t.animate === !1)
      a(), r.one("layoutstop", t.stop), r.emit({
        type: "layoutstop",
        layout: r
      });
    else {
      var d = t.eles.nodes(), p = Fie(n, t, d);
      d.layoutPositions(r, t, p);
    }
  }, l = 0, u = !0;
  if (t.animate === !0) {
    var h = function() {
      for (var d = 0; u && d < t.refresh; )
        u = s(l), l++, d++;
      if (!u)
        nU(n, t), o();
      else {
        var p = yl();
        p - i >= t.animationThreshold && a(), Ab(h);
      }
    };
    h();
  } else {
    for (; u; )
      u = s(l), l++;
    nU(n, t), o();
  }
  return this;
};
l3.prototype.stop = function() {
  return this.stopped = !0, this.thread && this.thread.stop(), this.emit("layoutstop"), this;
};
l3.prototype.destroy = function() {
  return this.thread && this.thread.stop(), this;
};
var ANe = function(e, r, n) {
  for (var i = n.eles.edges(), a = n.eles.nodes(), s = ji(n.boundingBox ? n.boundingBox : {
    x1: 0,
    y1: 0,
    w: e.width(),
    h: e.height()
  }), o = {
    isCompound: e.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: a.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: i.size(),
    temperature: n.initialTemp,
    clientWidth: s.w,
    clientHeight: s.h,
    boundingBox: s
  }, l = n.eles.components(), u = {}, h = 0; h < l.length; h++)
    for (var f = l[h], d = 0; d < f.length; d++) {
      var p = f[d];
      u[p.id()] = h;
    }
  for (var h = 0; h < o.nodeSize; h++) {
    var g = a[h], m = g.layoutDimensions(n), v = {};
    v.isLocked = g.locked(), v.id = g.data("id"), v.parentId = g.data("parent"), v.cmptId = u[g.id()], v.children = [], v.positionX = g.position("x"), v.positionY = g.position("y"), v.offsetX = 0, v.offsetY = 0, v.height = m.w, v.width = m.h, v.maxX = v.positionX + v.width / 2, v.minX = v.positionX - v.width / 2, v.maxY = v.positionY + v.height / 2, v.minY = v.positionY - v.height / 2, v.padLeft = parseFloat(g.style("padding")), v.padRight = parseFloat(g.style("padding")), v.padTop = parseFloat(g.style("padding")), v.padBottom = parseFloat(g.style("padding")), v.nodeRepulsion = ln(n.nodeRepulsion) ? n.nodeRepulsion(g) : n.nodeRepulsion, o.layoutNodes.push(v), o.idToIndex[v.id] = h;
  }
  for (var y = [], b = 0, x = -1, T = [], h = 0; h < o.nodeSize; h++) {
    var g = o.layoutNodes[h], E = g.parentId;
    E != null ? o.layoutNodes[o.idToIndex[E]].children.push(g.id) : (y[++x] = g.id, T.push(g.id));
  }
  for (o.graphSet.push(T); b <= x; ) {
    var A = y[b++], S = o.idToIndex[A], p = o.layoutNodes[S], k = p.children;
    if (k.length > 0) {
      o.graphSet.push(k);
      for (var h = 0; h < k.length; h++)
        y[++x] = k[h];
    }
  }
  for (var h = 0; h < o.graphSet.length; h++)
    for (var _ = o.graphSet[h], d = 0; d < _.length; d++) {
      var R = o.idToIndex[_[d]];
      o.indexToGraph[R] = h;
    }
  for (var h = 0; h < o.edgeSize; h++) {
    var L = i[h], M = {};
    M.id = L.data("id"), M.sourceId = L.data("source"), M.targetId = L.data("target");
    var P = ln(n.idealEdgeLength) ? n.idealEdgeLength(L) : n.idealEdgeLength, C = ln(n.edgeElasticity) ? n.edgeElasticity(L) : n.edgeElasticity, I = o.idToIndex[M.sourceId], N = o.idToIndex[M.targetId], O = o.indexToGraph[I], D = o.indexToGraph[N];
    if (O != D) {
      for (var $ = LNe(M.sourceId, M.targetId, o), z = o.graphSet[$], B = 0, v = o.layoutNodes[I]; z.indexOf(v.id) === -1; )
        v = o.layoutNodes[o.idToIndex[v.parentId]], B++;
      for (v = o.layoutNodes[N]; z.indexOf(v.id) === -1; )
        v = o.layoutNodes[o.idToIndex[v.parentId]], B++;
      P *= B * n.nestingFactor;
    }
    M.idealLength = P, M.elasticity = C, o.layoutEdges.push(M);
  }
  return o;
}, LNe = function(e, r, n) {
  var i = Bie(e, r, 0, n);
  return 2 > i.count ? 0 : i.graph;
}, Bie = function(e, r, n, i) {
  var a = i.graphSet[n];
  if (-1 < a.indexOf(e) && -1 < a.indexOf(r))
    return {
      count: 2,
      graph: n
    };
  for (var s = 0, o = 0; o < a.length; o++) {
    var l = a[o], u = i.idToIndex[l], h = i.layoutNodes[u].children;
    if (h.length !== 0) {
      var f = i.indexToGraph[i.idToIndex[h[0]]], d = Bie(e, r, f, i);
      if (d.count !== 0)
        if (d.count === 1) {
          if (s++, s === 2)
            break;
        } else
          return d;
    }
  }
  return {
    count: s,
    graph: n
  };
}, RNe, INe = function(e, r) {
  for (var n = e.clientWidth, i = e.clientHeight, a = 0; a < e.nodeSize; a++) {
    var s = e.layoutNodes[a];
    s.children.length === 0 && !s.isLocked && (s.positionX = Math.random() * n, s.positionY = Math.random() * i);
  }
}, Fie = function(e, r, n) {
  var i = e.boundingBox, a = {
    x1: 1 / 0,
    x2: -1 / 0,
    y1: 1 / 0,
    y2: -1 / 0
  };
  return r.boundingBox && (n.forEach(function(s) {
    var o = e.layoutNodes[e.idToIndex[s.data("id")]];
    a.x1 = Math.min(a.x1, o.positionX), a.x2 = Math.max(a.x2, o.positionX), a.y1 = Math.min(a.y1, o.positionY), a.y2 = Math.max(a.y2, o.positionY);
  }), a.w = a.x2 - a.x1, a.h = a.y2 - a.y1), function(s, o) {
    var l = e.layoutNodes[e.idToIndex[s.data("id")]];
    if (r.boundingBox) {
      var u = a.w === 0 ? 0.5 : (l.positionX - a.x1) / a.w, h = a.h === 0 ? 0.5 : (l.positionY - a.y1) / a.h;
      return {
        x: i.x1 + u * i.w,
        y: i.y1 + h * i.h
      };
    } else
      return {
        x: l.positionX,
        y: l.positionY
      };
  };
}, MNe = function(e, r, n) {
  var i = n.layout, a = n.eles.nodes(), s = Fie(e, n, a);
  a.positions(s), e.ready !== !0 && (e.ready = !0, i.one("layoutready", n.ready), i.emit({
    type: "layoutready",
    layout: this
  }));
}, NNe = function(e, r, n) {
  DNe(e, r), $Ne(e), BNe(e, r), FNe(e), zNe(e);
}, DNe = function(e, r) {
  for (var n = 0; n < e.graphSet.length; n++)
    for (var i = e.graphSet[n], a = i.length, s = 0; s < a; s++)
      for (var o = e.layoutNodes[e.idToIndex[i[s]]], l = s + 1; l < a; l++) {
        var u = e.layoutNodes[e.idToIndex[i[l]]];
        ONe(o, u, e, r);
      }
}, rU = function(e) {
  return -1 + 2 * e * Math.random();
}, ONe = function(e, r, n, i) {
  var a = e.cmptId, s = r.cmptId;
  if (!(a !== s && !n.isCompound)) {
    var o = r.positionX - e.positionX, l = r.positionY - e.positionY, u = 1;
    o === 0 && l === 0 && (o = rU(u), l = rU(u));
    var h = PNe(e, r, o, l);
    if (h > 0)
      var f = i.nodeOverlap * h, d = Math.sqrt(o * o + l * l), p = f * o / d, g = f * l / d;
    else
      var m = Ob(e, o, l), v = Ob(r, -1 * o, -1 * l), y = v.x - m.x, b = v.y - m.y, x = y * y + b * b, d = Math.sqrt(x), f = (e.nodeRepulsion + r.nodeRepulsion) / x, p = f * y / d, g = f * b / d;
    e.isLocked || (e.offsetX -= p, e.offsetY -= g), r.isLocked || (r.offsetX += p, r.offsetY += g);
  }
}, PNe = function(e, r, n, i) {
  if (n > 0)
    var a = e.maxX - r.minX;
  else
    var a = r.maxX - e.minX;
  if (i > 0)
    var s = e.maxY - r.minY;
  else
    var s = r.maxY - e.minY;
  return a >= 0 && s >= 0 ? Math.sqrt(a * a + s * s) : 0;
}, Ob = function(e, r, n) {
  var i = e.positionX, a = e.positionY, s = e.height || 1, o = e.width || 1, l = n / r, u = s / o, h = {};
  return r === 0 && 0 < n || r === 0 && 0 > n ? (h.x = i, h.y = a + s / 2, h) : 0 < r && -1 * u <= l && l <= u ? (h.x = i + o / 2, h.y = a + o * n / 2 / r, h) : 0 > r && -1 * u <= l && l <= u ? (h.x = i - o / 2, h.y = a - o * n / 2 / r, h) : 0 < n && (l <= -1 * u || l >= u) ? (h.x = i + s * r / 2 / n, h.y = a + s / 2, h) : (0 > n && (l <= -1 * u || l >= u) && (h.x = i - s * r / 2 / n, h.y = a - s / 2), h);
}, $Ne = function(e, r) {
  for (var n = 0; n < e.edgeSize; n++) {
    var i = e.layoutEdges[n], a = e.idToIndex[i.sourceId], s = e.layoutNodes[a], o = e.idToIndex[i.targetId], l = e.layoutNodes[o], u = l.positionX - s.positionX, h = l.positionY - s.positionY;
    if (!(u === 0 && h === 0)) {
      var f = Ob(s, u, h), d = Ob(l, -1 * u, -1 * h), p = d.x - f.x, g = d.y - f.y, m = Math.sqrt(p * p + g * g), v = Math.pow(i.idealLength - m, 2) / i.elasticity;
      if (m !== 0)
        var y = v * p / m, b = v * g / m;
      else
        var y = 0, b = 0;
      s.isLocked || (s.offsetX += y, s.offsetY += b), l.isLocked || (l.offsetX -= y, l.offsetY -= b);
    }
  }
}, BNe = function(e, r) {
  if (r.gravity !== 0)
    for (var n = 1, i = 0; i < e.graphSet.length; i++) {
      var a = e.graphSet[i], s = a.length;
      if (i === 0)
        var o = e.clientHeight / 2, l = e.clientWidth / 2;
      else
        var u = e.layoutNodes[e.idToIndex[a[0]]], h = e.layoutNodes[e.idToIndex[u.parentId]], o = h.positionX, l = h.positionY;
      for (var f = 0; f < s; f++) {
        var d = e.layoutNodes[e.idToIndex[a[f]]];
        if (!d.isLocked) {
          var p = o - d.positionX, g = l - d.positionY, m = Math.sqrt(p * p + g * g);
          if (m > n) {
            var v = r.gravity * p / m, y = r.gravity * g / m;
            d.offsetX += v, d.offsetY += y;
          }
        }
      }
    }
}, FNe = function(e, r) {
  var n = [], i = 0, a = -1;
  for (n.push.apply(n, e.graphSet[0]), a += e.graphSet[0].length; i <= a; ) {
    var s = n[i++], o = e.idToIndex[s], l = e.layoutNodes[o], u = l.children;
    if (0 < u.length && !l.isLocked) {
      for (var h = l.offsetX, f = l.offsetY, d = 0; d < u.length; d++) {
        var p = e.layoutNodes[e.idToIndex[u[d]]];
        p.offsetX += h, p.offsetY += f, n[++a] = u[d];
      }
      l.offsetX = 0, l.offsetY = 0;
    }
  }
}, zNe = function(e, r) {
  for (var n = 0; n < e.nodeSize; n++) {
    var i = e.layoutNodes[n];
    0 < i.children.length && (i.maxX = void 0, i.minX = void 0, i.maxY = void 0, i.minY = void 0);
  }
  for (var n = 0; n < e.nodeSize; n++) {
    var i = e.layoutNodes[n];
    if (!(0 < i.children.length || i.isLocked)) {
      var a = qNe(i.offsetX, i.offsetY, e.temperature);
      i.positionX += a.x, i.positionY += a.y, i.offsetX = 0, i.offsetY = 0, i.minX = i.positionX - i.width, i.maxX = i.positionX + i.width, i.minY = i.positionY - i.height, i.maxY = i.positionY + i.height, zie(i, e);
    }
  }
  for (var n = 0; n < e.nodeSize; n++) {
    var i = e.layoutNodes[n];
    0 < i.children.length && !i.isLocked && (i.positionX = (i.maxX + i.minX) / 2, i.positionY = (i.maxY + i.minY) / 2, i.width = i.maxX - i.minX, i.height = i.maxY - i.minY);
  }
}, qNe = function(e, r, n) {
  var i = Math.sqrt(e * e + r * r);
  if (i > n)
    var a = {
      x: n * e / i,
      y: n * r / i
    };
  else
    var a = {
      x: e,
      y: r
    };
  return a;
}, zie = function(e, r) {
  var n = e.parentId;
  if (n != null) {
    var i = r.layoutNodes[r.idToIndex[n]], a = !1;
    if ((i.maxX == null || e.maxX + i.padRight > i.maxX) && (i.maxX = e.maxX + i.padRight, a = !0), (i.minX == null || e.minX - i.padLeft < i.minX) && (i.minX = e.minX - i.padLeft, a = !0), (i.maxY == null || e.maxY + i.padBottom > i.maxY) && (i.maxY = e.maxY + i.padBottom, a = !0), (i.minY == null || e.minY - i.padTop < i.minY) && (i.minY = e.minY - i.padTop, a = !0), a)
      return zie(i, r);
  }
}, nU = function(e, r) {
  for (var n = e.layoutNodes, i = [], a = 0; a < n.length; a++) {
    var s = n[a], o = s.cmptId, l = i[o] = i[o] || [];
    l.push(s);
  }
  for (var u = 0, a = 0; a < i.length; a++) {
    var h = i[a];
    if (h) {
      h.x1 = 1 / 0, h.x2 = -1 / 0, h.y1 = 1 / 0, h.y2 = -1 / 0;
      for (var f = 0; f < h.length; f++) {
        var d = h[f];
        h.x1 = Math.min(h.x1, d.positionX - d.width / 2), h.x2 = Math.max(h.x2, d.positionX + d.width / 2), h.y1 = Math.min(h.y1, d.positionY - d.height / 2), h.y2 = Math.max(h.y2, d.positionY + d.height / 2);
      }
      h.w = h.x2 - h.x1, h.h = h.y2 - h.y1, u += h.w * h.h;
    }
  }
  i.sort(function(b, x) {
    return x.w * x.h - b.w * b.h;
  });
  for (var p = 0, g = 0, m = 0, v = 0, y = Math.sqrt(u) * e.clientWidth / e.clientHeight, a = 0; a < i.length; a++) {
    var h = i[a];
    if (h) {
      for (var f = 0; f < h.length; f++) {
        var d = h[f];
        d.isLocked || (d.positionX += p - h.x1, d.positionY += g - h.y1);
      }
      p += h.w + r.componentSpacing, m += h.w + r.componentSpacing, v = Math.max(v, h.h), m > y && (g += v + r.componentSpacing, p = 0, m = 0, v = 0);
    }
  }
}, GNe = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // padding used on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: !1,
  // uses all available space on false, uses minimal space on true
  rows: void 0,
  // force num of rows in the grid
  cols: void 0,
  // force num of columns in the grid
  position: function(e) {
  },
  // returns { row, col } for element
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function qie(t) {
  this.options = Ut({}, GNe, t);
}
qie.prototype.run = function() {
  var t = this.options, e = t, r = t.cy, n = e.eles, i = n.nodes().not(":parent");
  e.sort && (i = i.sort(e.sort));
  var a = ji(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: r.width(),
    h: r.height()
  });
  if (a.h === 0 || a.w === 0)
    n.nodes().layoutPositions(this, e, function(W) {
      return {
        x: a.x1,
        y: a.y1
      };
    });
  else {
    var s = i.size(), o = Math.sqrt(s * a.h / a.w), l = Math.round(o), u = Math.round(a.w / a.h * o), h = function(V) {
      if (V == null)
        return Math.min(l, u);
      var U = Math.min(l, u);
      U == l ? l = V : u = V;
    }, f = function(V) {
      if (V == null)
        return Math.max(l, u);
      var U = Math.max(l, u);
      U == l ? l = V : u = V;
    }, d = e.rows, p = e.cols != null ? e.cols : e.columns;
    if (d != null && p != null)
      l = d, u = p;
    else if (d != null && p == null)
      l = d, u = Math.ceil(s / l);
    else if (d == null && p != null)
      u = p, l = Math.ceil(s / u);
    else if (u * l > s) {
      var g = h(), m = f();
      (g - 1) * m >= s ? h(g - 1) : (m - 1) * g >= s && f(m - 1);
    } else
      for (; u * l < s; ) {
        var v = h(), y = f();
        (y + 1) * v >= s ? f(y + 1) : h(v + 1);
      }
    var b = a.w / u, x = a.h / l;
    if (e.condense && (b = 0, x = 0), e.avoidOverlap)
      for (var T = 0; T < i.length; T++) {
        var E = i[T], A = E._private.position;
        (A.x == null || A.y == null) && (A.x = 0, A.y = 0);
        var S = E.layoutDimensions(e), k = e.avoidOverlapPadding, _ = S.w + k, R = S.h + k;
        b = Math.max(b, _), x = Math.max(x, R);
      }
    for (var L = {}, M = function(V, U) {
      return !!L["c-" + V + "-" + U];
    }, P = function(V, U) {
      L["c-" + V + "-" + U] = !0;
    }, C = 0, I = 0, N = function() {
      I++, I >= u && (I = 0, C++);
    }, O = {}, D = 0; D < i.length; D++) {
      var $ = i[D], z = e.position($);
      if (z && (z.row !== void 0 || z.col !== void 0)) {
        var B = {
          row: z.row,
          col: z.col
        };
        if (B.col === void 0)
          for (B.col = 0; M(B.row, B.col); )
            B.col++;
        else if (B.row === void 0)
          for (B.row = 0; M(B.row, B.col); )
            B.row++;
        O[$.id()] = B, P(B.row, B.col);
      }
    }
    var G = function(V, U) {
      var Z, K;
      if (V.locked() || V.isParent())
        return !1;
      var ce = O[V.id()];
      if (ce)
        Z = ce.col * b + b / 2 + a.x1, K = ce.row * x + x / 2 + a.y1;
      else {
        for (; M(C, I); )
          N();
        Z = I * b + b / 2 + a.x1, K = C * x + x / 2 + a.y1, P(C, I), N();
      }
      return {
        x: Z,
        y: K
      };
    };
    i.layoutPositions(this, e, G);
  }
  return this;
};
var UNe = {
  ready: function() {
  },
  // on layoutready
  stop: function() {
  }
  // on layoutstop
};
function MR(t) {
  this.options = Ut({}, UNe, t);
}
MR.prototype.run = function() {
  var t = this.options, e = t.eles, r = this;
  return t.cy, r.emit("layoutstart"), e.nodes().positions(function() {
    return {
      x: 0,
      y: 0
    };
  }), r.one("layoutready", t.ready), r.emit("layoutready"), r.one("layoutstop", t.stop), r.emit("layoutstop"), this;
};
MR.prototype.stop = function() {
  return this;
};
var VNe = {
  positions: void 0,
  // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: void 0,
  // the zoom level to set (prob want fit = false if set)
  pan: void 0,
  // the pan level to set (prob want fit = false if set)
  fit: !0,
  // whether to fit to viewport
  padding: 30,
  // padding on fit
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function Gie(t) {
  this.options = Ut({}, VNe, t);
}
Gie.prototype.run = function() {
  var t = this.options, e = t.eles, r = e.nodes(), n = ln(t.positions);
  function i(a) {
    if (t.positions == null)
      return fRe(a.position());
    if (n)
      return t.positions(a);
    var s = t.positions[a._private.data.id];
    return s ?? null;
  }
  return r.layoutPositions(this, t, function(a, s) {
    var o = i(a);
    return a.locked() || o == null ? !1 : o;
  }), this;
};
var HNe = {
  fit: !0,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function Uie(t) {
  this.options = Ut({}, HNe, t);
}
Uie.prototype.run = function() {
  var t = this.options, e = t.cy, r = t.eles, n = ji(t.boundingBox ? t.boundingBox : {
    x1: 0,
    y1: 0,
    w: e.width(),
    h: e.height()
  }), i = function(s, o) {
    return {
      x: n.x1 + Math.round(Math.random() * n.w),
      y: n.y1 + Math.round(Math.random() * n.h)
    };
  };
  return r.nodes().layoutPositions(this, t, i), this;
};
var WNe = [{
  name: "breadthfirst",
  impl: Oie
}, {
  name: "circle",
  impl: Pie
}, {
  name: "concentric",
  impl: $ie
}, {
  name: "cose",
  impl: l3
}, {
  name: "grid",
  impl: qie
}, {
  name: "null",
  impl: MR
}, {
  name: "preset",
  impl: Gie
}, {
  name: "random",
  impl: Uie
}];
function Vie(t) {
  this.options = t, this.notifications = 0;
}
var iU = function() {
}, aU = function() {
  throw new Error("A headless instance can not render images");
};
Vie.prototype = {
  recalculateRenderedStyle: iU,
  notify: function() {
    this.notifications++;
  },
  init: iU,
  isHeadless: function() {
    return !0;
  },
  png: aU,
  jpg: aU
};
var NR = {};
NR.arrowShapeWidth = 0.3;
NR.registerArrowShapes = function() {
  var t = this.arrowShapes = {}, e = this, r = function(u, h, f, d, p, g, m) {
    var v = p.x - f / 2 - m, y = p.x + f / 2 + m, b = p.y - f / 2 - m, x = p.y + f / 2 + m, T = v <= u && u <= y && b <= h && h <= x;
    return T;
  }, n = function(u, h, f, d, p) {
    var g = u * Math.cos(d) - h * Math.sin(d), m = u * Math.sin(d) + h * Math.cos(d), v = g * f, y = m * f, b = v + p.x, x = y + p.y;
    return {
      x: b,
      y: x
    };
  }, i = function(u, h, f, d) {
    for (var p = [], g = 0; g < u.length; g += 2) {
      var m = u[g], v = u[g + 1];
      p.push(n(m, v, h, f, d));
    }
    return p;
  }, a = function(u) {
    for (var h = [], f = 0; f < u.length; f++) {
      var d = u[f];
      h.push(d.x, d.y);
    }
    return h;
  }, s = function(u) {
    return u.pstyle("width").pfValue * u.pstyle("arrow-scale").pfValue * 2;
  }, o = function(u, h) {
    Pt(h) && (h = t[h]), t[u] = Ut({
      name: u,
      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
      collide: function(d, p, g, m, v, y) {
        var b = a(i(this.points, g + 2 * y, m, v)), x = sa(d, p, b);
        return x;
      },
      roughCollide: r,
      draw: function(d, p, g, m) {
        var v = i(this.points, p, g, m);
        e.arrowShapeImpl("polygon")(d, v);
      },
      spacing: function(d) {
        return 0;
      },
      gap: s
    }, h);
  };
  o("none", {
    collide: Lb,
    roughCollide: Lb,
    draw: yR,
    spacing: bq,
    gap: bq
  }), o("triangle", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  }), o("arrow", "triangle"), o("triangle-backcurve", {
    points: t.triangle.points,
    controlPoint: [0, -0.15],
    roughCollide: r,
    draw: function(u, h, f, d, p) {
      var g = i(this.points, h, f, d), m = this.controlPoint, v = n(m[0], m[1], h, f, d);
      e.arrowShapeImpl(this.name)(u, g, v);
    },
    gap: function(u) {
      return s(u) * 0.8;
    }
  }), o("triangle-tee", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
    collide: function(u, h, f, d, p, g, m) {
      var v = a(i(this.points, f + 2 * m, d, p)), y = a(i(this.pointsTee, f + 2 * m, d, p)), b = sa(u, h, v) || sa(u, h, y);
      return b;
    },
    draw: function(u, h, f, d, p) {
      var g = i(this.points, h, f, d), m = i(this.pointsTee, h, f, d);
      e.arrowShapeImpl(this.name)(u, g, m);
    }
  }), o("circle-triangle", {
    radius: 0.15,
    pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],
    collide: function(u, h, f, d, p, g, m) {
      var v = p, y = Math.pow(v.x - u, 2) + Math.pow(v.y - h, 2) <= Math.pow((f + 2 * m) * this.radius, 2), b = a(i(this.points, f + 2 * m, d, p));
      return sa(u, h, b) || y;
    },
    draw: function(u, h, f, d, p) {
      var g = i(this.pointsTr, h, f, d);
      e.arrowShapeImpl(this.name)(u, g, d.x, d.y, this.radius * h);
    },
    spacing: function(u) {
      return e.getArrowWidth(u.pstyle("width").pfValue, u.pstyle("arrow-scale").value) * this.radius;
    }
  }), o("triangle-cross", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    baseCrossLinePts: [
      -0.15,
      -0.4,
      // first half of the rectangle
      -0.15,
      -0.4,
      0.15,
      -0.4,
      // second half of the rectangle
      0.15,
      -0.4
    ],
    crossLinePts: function(u, h) {
      var f = this.baseCrossLinePts.slice(), d = h / u, p = 3, g = 5;
      return f[p] = f[p] - d, f[g] = f[g] - d, f;
    },
    collide: function(u, h, f, d, p, g, m) {
      var v = a(i(this.points, f + 2 * m, d, p)), y = a(i(this.crossLinePts(f, g), f + 2 * m, d, p)), b = sa(u, h, v) || sa(u, h, y);
      return b;
    },
    draw: function(u, h, f, d, p) {
      var g = i(this.points, h, f, d), m = i(this.crossLinePts(h, p), h, f, d);
      e.arrowShapeImpl(this.name)(u, g, m);
    }
  }), o("vee", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
    gap: function(u) {
      return s(u) * 0.525;
    }
  }), o("circle", {
    radius: 0.15,
    collide: function(u, h, f, d, p, g, m) {
      var v = p, y = Math.pow(v.x - u, 2) + Math.pow(v.y - h, 2) <= Math.pow((f + 2 * m) * this.radius, 2);
      return y;
    },
    draw: function(u, h, f, d, p) {
      e.arrowShapeImpl(this.name)(u, d.x, d.y, this.radius * h);
    },
    spacing: function(u) {
      return e.getArrowWidth(u.pstyle("width").pfValue, u.pstyle("arrow-scale").value) * this.radius;
    }
  }), o("tee", {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
    spacing: function(u) {
      return 1;
    },
    gap: function(u) {
      return 1;
    }
  }), o("square", {
    points: [-0.15, 0, 0.15, 0, 0.15, -0.3, -0.15, -0.3]
  }), o("diamond", {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
    gap: function(u) {
      return u.pstyle("width").pfValue * u.pstyle("arrow-scale").value;
    }
  }), o("chevron", {
    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
    gap: function(u) {
      return 0.95 * u.pstyle("width").pfValue * u.pstyle("arrow-scale").value;
    }
  });
};
var Nh = {};
Nh.projectIntoViewport = function(t, e) {
  var r = this.cy, n = this.findContainerClientCoords(), i = n[0], a = n[1], s = n[4], o = r.pan(), l = r.zoom(), u = ((t - i) / s - o.x) / l, h = ((e - a) / s - o.y) / l;
  return [u, h];
};
Nh.findContainerClientCoords = function() {
  if (this.containerBB)
    return this.containerBB;
  var t = this.container, e = t.getBoundingClientRect(), r = this.cy.window().getComputedStyle(t), n = function(y) {
    return parseFloat(r.getPropertyValue(y));
  }, i = {
    left: n("padding-left"),
    right: n("padding-right"),
    top: n("padding-top"),
    bottom: n("padding-bottom")
  }, a = {
    left: n("border-left-width"),
    right: n("border-right-width"),
    top: n("border-top-width"),
    bottom: n("border-bottom-width")
  }, s = t.clientWidth, o = t.clientHeight, l = i.left + i.right, u = i.top + i.bottom, h = a.left + a.right, f = e.width / (s + h), d = s - l, p = o - u, g = e.left + i.left + a.left, m = e.top + i.top + a.top;
  return this.containerBB = [g, m, d, p, f];
};
Nh.invalidateContainerClientCoordsCache = function() {
  this.containerBB = null;
};
Nh.findNearestElement = function(t, e, r, n) {
  return this.findNearestElements(t, e, r, n)[0];
};
Nh.findNearestElements = function(t, e, r, n) {
  var i = this, a = this, s = a.getCachedZSortedEles(), o = [], l = a.cy.zoom(), u = a.cy.hasCompoundNodes(), h = (n ? 24 : 8) / l, f = (n ? 8 : 2) / l, d = (n ? 8 : 2) / l, p = 1 / 0, g, m;
  r && (s = s.interactive);
  function v(S, k) {
    if (S.isNode()) {
      if (m)
        return;
      m = S, o.push(S);
    }
    if (S.isEdge() && (k == null || k < p))
      if (g) {
        if (g.pstyle("z-compound-depth").value === S.pstyle("z-compound-depth").value && g.pstyle("z-compound-depth").value === S.pstyle("z-compound-depth").value) {
          for (var _ = 0; _ < o.length; _++)
            if (o[_].isEdge()) {
              o[_] = S, g = S, p = k ?? p;
              break;
            }
        }
      } else
        o.push(S), g = S, p = k ?? p;
  }
  function y(S) {
    var k = S.outerWidth() + 2 * f, _ = S.outerHeight() + 2 * f, R = k / 2, L = _ / 2, M = S.position(), P = S.pstyle("corner-radius").value === "auto" ? "auto" : S.pstyle("corner-radius").pfValue, C = S._private.rscratch;
    if (M.x - R <= t && t <= M.x + R && M.y - L <= e && e <= M.y + L) {
      var I = a.nodeShapes[i.getNodeShape(S)];
      if (I.checkPoint(t, e, 0, k, _, M.x, M.y, P, C))
        return v(S, 0), !0;
    }
  }
  function b(S) {
    var k = S._private, _ = k.rscratch, R = S.pstyle("width").pfValue, L = S.pstyle("arrow-scale").value, M = R / 2 + h, P = M * M, C = M * 2, D = k.source, $ = k.target, I;
    if (_.edgeType === "segments" || _.edgeType === "straight" || _.edgeType === "haystack") {
      for (var N = _.allpts, O = 0; O + 3 < N.length; O += 2)
        if (CRe(t, e, N[O], N[O + 1], N[O + 2], N[O + 3], C) && P > (I = IRe(t, e, N[O], N[O + 1], N[O + 2], N[O + 3])))
          return v(S, I), !0;
    } else if (_.edgeType === "bezier" || _.edgeType === "multibezier" || _.edgeType === "self" || _.edgeType === "compound") {
      for (var N = _.allpts, O = 0; O + 5 < _.allpts.length; O += 4)
        if (_Re(t, e, N[O], N[O + 1], N[O + 2], N[O + 3], N[O + 4], N[O + 5], C) && P > (I = RRe(t, e, N[O], N[O + 1], N[O + 2], N[O + 3], N[O + 4], N[O + 5])))
          return v(S, I), !0;
    }
    for (var D = D || k.source, $ = $ || k.target, z = i.getArrowWidth(R, L), B = [{
      name: "source",
      x: _.arrowStartX,
      y: _.arrowStartY,
      angle: _.srcArrowAngle
    }, {
      name: "target",
      x: _.arrowEndX,
      y: _.arrowEndY,
      angle: _.tgtArrowAngle
    }, {
      name: "mid-source",
      x: _.midX,
      y: _.midY,
      angle: _.midsrcArrowAngle
    }, {
      name: "mid-target",
      x: _.midX,
      y: _.midY,
      angle: _.midtgtArrowAngle
    }], O = 0; O < B.length; O++) {
      var G = B[O], W = a.arrowShapes[S.pstyle(G.name + "-arrow-shape").value], V = S.pstyle("width").pfValue;
      if (W.roughCollide(t, e, z, G.angle, {
        x: G.x,
        y: G.y
      }, V, h) && W.collide(t, e, z, G.angle, {
        x: G.x,
        y: G.y
      }, V, h))
        return v(S), !0;
    }
    u && o.length > 0 && (y(D), y($));
  }
  function x(S, k, _) {
    return aa(S, k, _);
  }
  function T(S, k) {
    var _ = S._private, R = d, L;
    k ? L = k + "-" : L = "", S.boundingBox();
    var M = _.labelBounds[k || "main"], P = S.pstyle(L + "label").value, C = S.pstyle("text-events").strValue === "yes";
    if (!(!C || !P)) {
      var I = x(_.rscratch, "labelX", k), N = x(_.rscratch, "labelY", k), O = x(_.rscratch, "labelAngle", k), D = S.pstyle(L + "text-margin-x").pfValue, $ = S.pstyle(L + "text-margin-y").pfValue, z = M.x1 - R - D, B = M.x2 + R - D, G = M.y1 - R - $, W = M.y2 + R - $;
      if (O) {
        var V = Math.cos(O), U = Math.sin(O), Z = function(re, Q) {
          return re = re - I, Q = Q - N, {
            x: re * V - Q * U + I,
            y: re * U + Q * V + N
          };
        }, K = Z(z, G), ce = Z(z, W), J = Z(B, G), ee = Z(B, W), j = [
          // with the margin added after the rotation is applied
          K.x + D,
          K.y + $,
          J.x + D,
          J.y + $,
          ee.x + D,
          ee.y + $,
          ce.x + D,
          ce.y + $
        ];
        if (sa(t, e, j))
          return v(S), !0;
      } else if (tc(M, t, e))
        return v(S), !0;
    }
  }
  for (var E = s.length - 1; E >= 0; E--) {
    var A = s[E];
    A.isNode() ? y(A) || T(A) : b(A) || T(A) || T(A, "source") || T(A, "target");
  }
  return o;
};
Nh.getAllInBox = function(t, e, r, n) {
  var i = this.getCachedZSortedEles().interactive, a = this.cy.zoom(), s = 2 / a, o = [], l = Math.min(t, r), u = Math.max(t, r), h = Math.min(e, n), f = Math.max(e, n);
  t = l, r = u, e = h, n = f;
  var d = ji({
    x1: t,
    y1: e,
    x2: r,
    y2: n
  }), p = [{
    x: d.x1,
    y: d.y1
  }, {
    x: d.x2,
    y: d.y1
  }, {
    x: d.x2,
    y: d.y2
  }, {
    x: d.x1,
    y: d.y2
  }], g = [[p[0], p[1]], [p[1], p[2]], [p[2], p[3]], [p[3], p[0]]];
  function m(re, Q, ue) {
    return aa(re, Q, ue);
  }
  function v(re, Q) {
    var ue = re._private, ne = s, xe = "";
    re.boundingBox();
    var Y = ue.labelBounds.main;
    if (!Y)
      return null;
    var Ne = m(ue.rscratch, "labelX", Q), fe = m(ue.rscratch, "labelY", Q), qe = m(ue.rscratch, "labelAngle", Q), ze = re.pstyle(xe + "text-margin-x").pfValue, Ge = re.pstyle(xe + "text-margin-y").pfValue, Ee = Y.x1 - ne - ze, Oe = Y.x2 + ne - ze, Ce = Y.y1 - ne - Ge, Ae = Y.y2 + ne - Ge;
    if (qe) {
      var $e = Math.cos(qe), me = Math.sin(qe), Ie = function(he, F) {
        return he = he - Ne, F = F - fe, {
          x: he * $e - F * me + Ne,
          y: he * me + F * $e + fe
        };
      };
      return [Ie(Ee, Ce), Ie(Oe, Ce), Ie(Oe, Ae), Ie(Ee, Ae)];
    } else
      return [{
        x: Ee,
        y: Ce
      }, {
        x: Oe,
        y: Ce
      }, {
        x: Oe,
        y: Ae
      }, {
        x: Ee,
        y: Ae
      }];
  }
  function y(re, Q, ue, ne) {
    function xe(Y, Ne, fe) {
      return (fe.y - Y.y) * (Ne.x - Y.x) > (Ne.y - Y.y) * (fe.x - Y.x);
    }
    return xe(re, ue, ne) !== xe(Q, ue, ne) && xe(re, Q, ue) !== xe(re, Q, ne);
  }
  for (var b = 0; b < i.length; b++) {
    var x = i[b];
    if (x.isNode()) {
      var T = x, E = T.pstyle("text-events").strValue === "yes", A = T.pstyle("box-selection").strValue, S = T.pstyle("box-select-labels").strValue === "yes";
      if (A === "none")
        continue;
      var k = (A === "overlap" || S) && E, _ = T.boundingBox({
        includeNodes: !0,
        includeEdges: !1,
        includeLabels: k
      });
      if (A === "contain") {
        var R = !1;
        if (S && E) {
          var L = v(T);
          L && Xk(L, p) && (o.push(T), R = !0);
        }
        !R && Zne(d, _) && o.push(T);
      } else if (A === "overlap" && TR(d, _)) {
        var M = T.boundingBox({
          includeNodes: !0,
          includeEdges: !0,
          includeLabels: !1,
          includeMainLabels: !1,
          includeSourceLabels: !1,
          includeTargetLabels: !1
        }), P = [{
          x: M.x1,
          y: M.y1
        }, {
          x: M.x2,
          y: M.y1
        }, {
          x: M.x2,
          y: M.y2
        }, {
          x: M.x1,
          y: M.y2
        }];
        if (Xk(P, p))
          o.push(T);
        else {
          var C = v(T);
          C && Xk(C, p) && o.push(T);
        }
      }
    } else {
      var I = x, N = I._private, O = N.rscratch, D = I.pstyle("box-selection").strValue;
      if (D === "none")
        continue;
      if (D === "contain") {
        if (O.startX != null && O.startY != null && !tc(d, O.startX, O.startY) || O.endX != null && O.endY != null && !tc(d, O.endX, O.endY))
          continue;
        if (O.edgeType === "bezier" || O.edgeType === "multibezier" || O.edgeType === "self" || O.edgeType === "compound" || O.edgeType === "segments" || O.edgeType === "haystack") {
          for (var $ = N.rstyle.bezierPts || N.rstyle.linePts || N.rstyle.haystackPts, z = !0, B = 0; B < $.length; B++)
            if (!Sq(d, $[B])) {
              z = !1;
              break;
            }
          z && o.push(I);
        } else O.edgeType === "straight" && o.push(I);
      } else if (D === "overlap") {
        var G = !1;
        if (O.startX != null && O.startY != null && O.endX != null && O.endY != null && (tc(d, O.startX, O.startY) || tc(d, O.endX, O.endY)))
          o.push(I), G = !0;
        else if (!G && O.edgeType === "haystack") {
          for (var W = N.rstyle.haystackPts, V = 0; V < W.length; V++)
            if (Sq(d, W[V])) {
              o.push(I), G = !0;
              break;
            }
        }
        if (!G) {
          var U = N.rstyle.bezierPts || N.rstyle.linePts || N.rstyle.haystackPts;
          if ((!U || U.length < 2) && O.edgeType === "straight" && O.startX != null && O.startY != null && O.endX != null && O.endY != null && (U = [{
            x: O.startX,
            y: O.startY
          }, {
            x: O.endX,
            y: O.endY
          }]), !U || U.length < 2) continue;
          for (var Z = 0; Z < U.length - 1; Z++) {
            for (var K = U[Z], ce = U[Z + 1], J = 0; J < g.length; J++) {
              var ee = Cn(g[J], 2), j = ee[0], X = ee[1];
              if (y(K, ce, j, X)) {
                o.push(I), G = !0;
                break;
              }
            }
            if (G) break;
          }
        }
      }
    }
  }
  return o;
};
var Pb = {};
Pb.calculateArrowAngles = function(t) {
  var e = t._private.rscratch, r = e.edgeType === "haystack", n = e.edgeType === "bezier", i = e.edgeType === "multibezier", a = e.edgeType === "segments", s = e.edgeType === "compound", o = e.edgeType === "self", l, u, h, f, d, p, y, b;
  if (r ? (h = e.haystackPts[0], f = e.haystackPts[1], d = e.haystackPts[2], p = e.haystackPts[3]) : (h = e.arrowStartX, f = e.arrowStartY, d = e.arrowEndX, p = e.arrowEndY), y = e.midX, b = e.midY, a)
    l = h - e.segpts[0], u = f - e.segpts[1];
  else if (i || s || o || n) {
    var g = e.allpts, m = Zn(g[0], g[2], g[4], 0.1), v = Zn(g[1], g[3], g[5], 0.1);
    l = h - m, u = f - v;
  } else
    l = h - y, u = f - b;
  e.srcArrowAngle = Av(l, u);
  var y = e.midX, b = e.midY;
  if (r && (y = (h + d) / 2, b = (f + p) / 2), l = d - h, u = p - f, a) {
    var g = e.allpts;
    if (g.length / 2 % 2 === 0) {
      var x = g.length / 2, T = x - 2;
      l = g[x] - g[T], u = g[x + 1] - g[T + 1];
    } else if (e.isRound)
      l = e.midVector[1], u = -e.midVector[0];
    else {
      var x = g.length / 2 - 1, T = x - 2;
      l = g[x] - g[T], u = g[x + 1] - g[T + 1];
    }
  } else if (i || s || o) {
    var g = e.allpts, E = e.ctrlpts, A, S, k, _;
    if (E.length / 2 % 2 === 0) {
      var R = g.length / 2 - 1, L = R + 2, M = L + 2;
      A = Zn(g[R], g[L], g[M], 0), S = Zn(g[R + 1], g[L + 1], g[M + 1], 0), k = Zn(g[R], g[L], g[M], 1e-4), _ = Zn(g[R + 1], g[L + 1], g[M + 1], 1e-4);
    } else {
      var L = g.length / 2 - 1, R = L - 2, M = L + 2;
      A = Zn(g[R], g[L], g[M], 0.4999), S = Zn(g[R + 1], g[L + 1], g[M + 1], 0.4999), k = Zn(g[R], g[L], g[M], 0.5), _ = Zn(g[R + 1], g[L + 1], g[M + 1], 0.5);
    }
    l = k - A, u = _ - S;
  }
  if (e.midtgtArrowAngle = Av(l, u), e.midDispX = l, e.midDispY = u, l *= -1, u *= -1, a) {
    var g = e.allpts;
    if (g.length / 2 % 2 !== 0) {
      if (!e.isRound) {
        var x = g.length / 2 - 1, P = x + 2;
        l = -(g[P] - g[x]), u = -(g[P + 1] - g[x + 1]);
      }
    }
  }
  if (e.midsrcArrowAngle = Av(l, u), a)
    l = d - e.segpts[e.segpts.length - 2], u = p - e.segpts[e.segpts.length - 1];
  else if (i || s || o || n) {
    var g = e.allpts, C = g.length, m = Zn(g[C - 6], g[C - 4], g[C - 2], 0.9), v = Zn(g[C - 5], g[C - 3], g[C - 1], 0.9);
    l = d - m, u = p - v;
  } else
    l = d - y, u = p - b;
  e.tgtArrowAngle = Av(l, u);
};
Pb.getArrowWidth = Pb.getArrowHeight = function(t, e) {
  var r = this.arrowWidthCache = this.arrowWidthCache || {}, n = r[t + ", " + e];
  return n || (n = Math.max(Math.pow(t * 13.37, 0.9), 29) * e, r[t + ", " + e] = n, n);
};
var TA, EA, js = {}, Ga = {}, sU, oU, Su, Uy, Fo, fu, xu, Vs, af, Pv, Hie, Wie, SA, kA, lU, cU = function(e, r, n) {
  n.x = r.x - e.x, n.y = r.y - e.y, n.len = Math.sqrt(n.x * n.x + n.y * n.y), n.nx = n.x / n.len, n.ny = n.y / n.len, n.ang = Math.atan2(n.ny, n.nx);
}, YNe = function(e, r) {
  r.x = e.x * -1, r.y = e.y * -1, r.nx = e.nx * -1, r.ny = e.ny * -1, r.ang = e.ang > 0 ? -(Math.PI - e.ang) : Math.PI + e.ang;
}, XNe = function(e, r, n, i, a) {
  if (e !== lU ? cU(r, e, js) : YNe(Ga, js), cU(r, n, Ga), sU = js.nx * Ga.ny - js.ny * Ga.nx, oU = js.nx * Ga.nx - js.ny * -Ga.ny, Fo = Math.asin(Math.max(-1, Math.min(1, sU))), Math.abs(Fo) < 1e-6) {
    TA = r.x, EA = r.y, xu = af = 0;
    return;
  }
  Su = 1, Uy = !1, oU < 0 ? Fo < 0 ? Fo = Math.PI + Fo : (Fo = Math.PI - Fo, Su = -1, Uy = !0) : Fo > 0 && (Su = -1, Uy = !0), r.radius !== void 0 ? af = r.radius : af = i, fu = Fo / 2, Pv = Math.min(js.len / 2, Ga.len / 2), a ? (Vs = Math.abs(Math.cos(fu) * af / Math.sin(fu)), Vs > Pv ? (Vs = Pv, xu = Math.abs(Vs * Math.sin(fu) / Math.cos(fu))) : xu = af) : (Vs = Math.min(Pv, af), xu = Math.abs(Vs * Math.sin(fu) / Math.cos(fu))), SA = r.x + Ga.nx * Vs, kA = r.y + Ga.ny * Vs, TA = SA - Ga.ny * xu * Su, EA = kA + Ga.nx * xu * Su, Hie = r.x + js.nx * Vs, Wie = r.y + js.ny * Vs, lU = r;
};
function Yie(t, e) {
  e.radius === 0 ? t.lineTo(e.cx, e.cy) : t.arc(e.cx, e.cy, e.radius, e.startAngle, e.endAngle, e.counterClockwise);
}
function DR(t, e, r, n) {
  var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
  return n === 0 || e.radius === 0 ? {
    cx: e.x,
    cy: e.y,
    radius: 0,
    startX: e.x,
    startY: e.y,
    stopX: e.x,
    stopY: e.y,
    startAngle: void 0,
    endAngle: void 0,
    counterClockwise: void 0
  } : (XNe(t, e, r, n, i), {
    cx: TA,
    cy: EA,
    radius: xu,
    startX: Hie,
    startY: Wie,
    stopX: SA,
    stopY: kA,
    startAngle: js.ang + Math.PI / 2 * Su,
    endAngle: Ga.ang - Math.PI / 2 * Su,
    counterClockwise: Uy
  });
}
var I1 = 0.01, jNe = Math.sqrt(2 * I1), Ni = {};
Ni.findMidptPtsEtc = function(t, e) {
  var r = e.posPts, n = e.intersectionPts, i = e.vectorNormInverse, a, s = t.pstyle("source-endpoint"), o = t.pstyle("target-endpoint"), l = s.units != null && o.units != null, u = function(E, A, S, k) {
    var _ = k - A, R = S - E, L = Math.sqrt(R * R + _ * _);
    return {
      x: -_ / L,
      y: R / L
    };
  }, h = t.pstyle("edge-distances").value;
  switch (h) {
    case "node-position":
      a = r;
      break;
    case "intersection":
      a = n;
      break;
    case "endpoints": {
      if (l) {
        var f = this.manualEndptToPx(t.source()[0], s), d = Cn(f, 2), p = d[0], g = d[1], m = this.manualEndptToPx(t.target()[0], o), v = Cn(m, 2), y = v[0], b = v[1], x = {
          x1: p,
          y1: g,
          x2: y,
          y2: b
        };
        i = u(p, g, y, b), a = x;
      } else
        Rr("Edge ".concat(t.id(), " has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).")), a = n;
      break;
    }
  }
  return {
    midptPts: a,
    vectorNormInverse: i
  };
};
Ni.findHaystackPoints = function(t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e], n = r._private, i = n.rscratch;
    if (!i.haystack) {
      var a = Math.random() * 2 * Math.PI;
      i.source = {
        x: Math.cos(a),
        y: Math.sin(a)
      }, a = Math.random() * 2 * Math.PI, i.target = {
        x: Math.cos(a),
        y: Math.sin(a)
      };
    }
    var s = n.source, o = n.target, l = s.position(), u = o.position(), h = s.width(), f = o.width(), d = s.height(), p = o.height(), g = r.pstyle("haystack-radius").value, m = g / 2;
    i.haystackPts = i.allpts = [i.source.x * h * m + l.x, i.source.y * d * m + l.y, i.target.x * f * m + u.x, i.target.y * p * m + u.y], i.midX = (i.allpts[0] + i.allpts[2]) / 2, i.midY = (i.allpts[1] + i.allpts[3]) / 2, i.edgeType = "haystack", i.haystack = !0, this.storeEdgeProjections(r), this.calculateArrowAngles(r), this.recalculateEdgeLabelProjections(r), this.calculateLabelAngles(r);
  }
};
Ni.findSegmentsPoints = function(t, e) {
  var r = t._private.rscratch, n = t.pstyle("segment-weights"), i = t.pstyle("segment-distances"), a = t.pstyle("segment-radii"), s = t.pstyle("radius-type"), o = Math.min(n.pfValue.length, i.pfValue.length), l = a.pfValue[a.pfValue.length - 1], u = s.pfValue[s.pfValue.length - 1];
  r.edgeType = "segments", r.segpts = [], r.radii = [], r.isArcRadius = [];
  for (var h = 0; h < o; h++) {
    var f = n.pfValue[h], d = i.pfValue[h], p = 1 - f, g = f, m = this.findMidptPtsEtc(t, e), v = m.midptPts, y = m.vectorNormInverse, b = {
      x: v.x1 * p + v.x2 * g,
      y: v.y1 * p + v.y2 * g
    };
    r.segpts.push(b.x + y.x * d, b.y + y.y * d), r.radii.push(a.pfValue[h] !== void 0 ? a.pfValue[h] : l), r.isArcRadius.push((s.pfValue[h] !== void 0 ? s.pfValue[h] : u) === "arc-radius");
  }
};
Ni.findLoopPoints = function(t, e, r, n) {
  var i = t._private.rscratch, a = e.dirCounts, s = e.srcPos, o = t.pstyle("control-point-distances"), l = o ? o.pfValue[0] : void 0, u = t.pstyle("loop-direction").pfValue, h = t.pstyle("loop-sweep").pfValue, f = t.pstyle("control-point-step-size").pfValue;
  i.edgeType = "self";
  var d = r, p = f;
  n && (d = 0, p = l);
  var g = u - Math.PI / 2, m = g - h / 2, v = g + h / 2, y = u + "_" + h;
  d = a[y] === void 0 ? a[y] = 0 : ++a[y], i.ctrlpts = [s.x + Math.cos(m) * 1.4 * p * (d / 3 + 1), s.y + Math.sin(m) * 1.4 * p * (d / 3 + 1), s.x + Math.cos(v) * 1.4 * p * (d / 3 + 1), s.y + Math.sin(v) * 1.4 * p * (d / 3 + 1)];
};
Ni.findCompoundLoopPoints = function(t, e, r, n) {
  var i = t._private.rscratch;
  i.edgeType = "compound";
  var a = e.srcPos, s = e.tgtPos, o = e.srcW, l = e.srcH, u = e.tgtW, h = e.tgtH, f = t.pstyle("control-point-step-size").pfValue, d = t.pstyle("control-point-distances"), p = d ? d.pfValue[0] : void 0, g = r, m = f;
  n && (g = 0, m = p);
  var v = 50, y = {
    x: a.x - o / 2,
    y: a.y - l / 2
  }, b = {
    x: s.x - u / 2,
    y: s.y - h / 2
  }, x = {
    x: Math.min(y.x, b.x),
    y: Math.min(y.y, b.y)
  }, T = 0.5, E = Math.max(T, Math.log(o * I1)), A = Math.max(T, Math.log(u * I1));
  i.ctrlpts = [x.x, x.y - (1 + Math.pow(v, 1.12) / 100) * m * (g / 3 + 1) * E, x.x - (1 + Math.pow(v, 1.12) / 100) * m * (g / 3 + 1) * A, x.y];
};
Ni.findStraightEdgePoints = function(t) {
  t._private.rscratch.edgeType = "straight";
};
Ni.findBezierPoints = function(t, e, r, n, i) {
  var a = t._private.rscratch, s = t.pstyle("control-point-step-size").pfValue, o = t.pstyle("control-point-distances"), l = t.pstyle("control-point-weights"), u = o && l ? Math.min(o.value.length, l.value.length) : 1, h = o ? o.pfValue[0] : void 0, f = l.value[0], d = n;
  a.edgeType = d ? "multibezier" : "bezier", a.ctrlpts = [];
  for (var p = 0; p < u; p++) {
    var g = (0.5 - e.eles.length / 2 + r) * s * (i ? -1 : 1), m = void 0, v = wR(g);
    d && (h = o ? o.pfValue[p] : s, f = l.value[p]), n ? m = h : m = h !== void 0 ? v * h : void 0;
    var y = m !== void 0 ? m : g, b = 1 - f, x = f, T = this.findMidptPtsEtc(t, e), E = T.midptPts, A = T.vectorNormInverse, S = {
      x: E.x1 * b + E.x2 * x,
      y: E.y1 * b + E.y2 * x
    };
    a.ctrlpts.push(S.x + A.x * y, S.y + A.y * y);
  }
};
Ni.findTaxiPoints = function(t, e) {
  var r = t._private.rscratch;
  r.edgeType = "segments";
  var n = "vertical", i = "horizontal", a = "leftward", s = "rightward", o = "downward", l = "upward", u = "auto", h = e.posPts, f = e.srcW, d = e.srcH, p = e.tgtW, g = e.tgtH, m = t.pstyle("edge-distances").value, v = m !== "node-position", y = t.pstyle("taxi-direction").value, b = y, x = t.pstyle("taxi-turn"), T = x.units === "%", E = x.pfValue, A = E < 0, S = t.pstyle("taxi-turn-min-distance").pfValue, k = v ? (f + p) / 2 : 0, _ = v ? (d + g) / 2 : 0, R = h.x2 - h.x1, L = h.y2 - h.y1, M = function(F, oe) {
    return F > 0 ? Math.max(F - oe, 0) : Math.min(F + oe, 0);
  }, P = M(R, k), C = M(L, _), I = !1;
  b === u ? y = Math.abs(P) > Math.abs(C) ? i : n : b === l || b === o ? (y = n, I = !0) : (b === a || b === s) && (y = i, I = !0);
  var N = y === n, O = N ? C : P, D = N ? L : R, $ = wR(D), z = !1;
  !(I && (T || A)) && (b === o && D < 0 || b === l && D > 0 || b === a && D > 0 || b === s && D < 0) && ($ *= -1, O = $ * Math.abs(O), z = !0);
  var B;
  if (T) {
    var G = E < 0 ? 1 + E : E;
    B = G * O;
  } else {
    var W = E < 0 ? O : 0;
    B = W + E * $;
  }
  var V = function(F) {
    return Math.abs(F) < S || Math.abs(F) >= Math.abs(O);
  }, U = V(B), Z = V(Math.abs(O) - Math.abs(B)), K = U || Z;
  if (K && !z)
    if (N) {
      var ce = Math.abs(D) <= d / 2, J = Math.abs(R) <= p / 2;
      if (ce) {
        var ee = (h.x1 + h.x2) / 2, j = h.y1, X = h.y2;
        r.segpts = [ee, j, ee, X];
      } else if (J) {
        var re = (h.y1 + h.y2) / 2, Q = h.x1, ue = h.x2;
        r.segpts = [Q, re, ue, re];
      } else
        r.segpts = [h.x1, h.y2];
    } else {
      var ne = Math.abs(D) <= f / 2, xe = Math.abs(L) <= g / 2;
      if (ne) {
        var Y = (h.y1 + h.y2) / 2, Ne = h.x1, fe = h.x2;
        r.segpts = [Ne, Y, fe, Y];
      } else if (xe) {
        var qe = (h.x1 + h.x2) / 2, ze = h.y1, Ge = h.y2;
        r.segpts = [qe, ze, qe, Ge];
      } else
        r.segpts = [h.x2, h.y1];
    }
  else if (N) {
    var Ee = h.y1 + B + (v ? d / 2 * $ : 0), Oe = h.x1, Ce = h.x2;
    r.segpts = [Oe, Ee, Ce, Ee];
  } else {
    var Ae = h.x1 + B + (v ? f / 2 * $ : 0), $e = h.y1, me = h.y2;
    r.segpts = [Ae, $e, Ae, me];
  }
  if (r.isRound) {
    var Ie = t.pstyle("taxi-radius").value, te = t.pstyle("radius-type").value[0] === "arc-radius";
    r.radii = new Array(r.segpts.length / 2).fill(Ie), r.isArcRadius = new Array(r.segpts.length / 2).fill(te);
  }
};
Ni.tryToCorrectInvalidPoints = function(t, e) {
  var r = t._private.rscratch;
  if (r.edgeType === "bezier") {
    var n = e.srcPos, i = e.tgtPos, a = e.srcW, s = e.srcH, o = e.tgtW, l = e.tgtH, u = e.srcShape, h = e.tgtShape, f = e.srcCornerRadius, d = e.tgtCornerRadius, p = e.srcRs, g = e.tgtRs, m = !mt(r.startX) || !mt(r.startY), v = !mt(r.arrowStartX) || !mt(r.arrowStartY), y = !mt(r.endX) || !mt(r.endY), b = !mt(r.arrowEndX) || !mt(r.arrowEndY), x = 3, T = this.getArrowWidth(t.pstyle("width").pfValue, t.pstyle("arrow-scale").value) * this.arrowShapeWidth, E = x * T, A = rh({
      x: r.ctrlpts[0],
      y: r.ctrlpts[1]
    }, {
      x: r.startX,
      y: r.startY
    }), S = A < E, k = rh({
      x: r.ctrlpts[0],
      y: r.ctrlpts[1]
    }, {
      x: r.endX,
      y: r.endY
    }), _ = k < E, R = !1;
    if (m || v || S) {
      R = !0;
      var L = {
        // delta
        x: r.ctrlpts[0] - n.x,
        y: r.ctrlpts[1] - n.y
      }, M = Math.sqrt(L.x * L.x + L.y * L.y), P = {
        // normalised delta
        x: L.x / M,
        y: L.y / M
      }, C = Math.max(a, s), I = {
        // *2 radius guarantees outside shape
        x: r.ctrlpts[0] + P.x * 2 * C,
        y: r.ctrlpts[1] + P.y * 2 * C
      }, N = u.intersectLine(n.x, n.y, a, s, I.x, I.y, 0, f, p);
      S ? (r.ctrlpts[0] = r.ctrlpts[0] + P.x * (E - A), r.ctrlpts[1] = r.ctrlpts[1] + P.y * (E - A)) : (r.ctrlpts[0] = N[0] + P.x * E, r.ctrlpts[1] = N[1] + P.y * E);
    }
    if (y || b || _) {
      R = !0;
      var O = {
        // delta
        x: r.ctrlpts[0] - i.x,
        y: r.ctrlpts[1] - i.y
      }, D = Math.sqrt(O.x * O.x + O.y * O.y), $ = {
        // normalised delta
        x: O.x / D,
        y: O.y / D
      }, z = Math.max(a, s), B = {
        // *2 radius guarantees outside shape
        x: r.ctrlpts[0] + $.x * 2 * z,
        y: r.ctrlpts[1] + $.y * 2 * z
      }, G = h.intersectLine(i.x, i.y, o, l, B.x, B.y, 0, d, g);
      _ ? (r.ctrlpts[0] = r.ctrlpts[0] + $.x * (E - k), r.ctrlpts[1] = r.ctrlpts[1] + $.y * (E - k)) : (r.ctrlpts[0] = G[0] + $.x * E, r.ctrlpts[1] = G[1] + $.y * E);
    }
    R && this.findEndpoints(t);
  }
};
Ni.storeAllpts = function(t) {
  var e = t._private.rscratch;
  if (e.edgeType === "multibezier" || e.edgeType === "bezier" || e.edgeType === "self" || e.edgeType === "compound") {
    e.allpts = [], e.allpts.push(e.startX, e.startY);
    for (var r = 0; r + 1 < e.ctrlpts.length; r += 2)
      e.allpts.push(e.ctrlpts[r], e.ctrlpts[r + 1]), r + 3 < e.ctrlpts.length && e.allpts.push((e.ctrlpts[r] + e.ctrlpts[r + 2]) / 2, (e.ctrlpts[r + 1] + e.ctrlpts[r + 3]) / 2);
    e.allpts.push(e.endX, e.endY);
    var n, i;
    e.ctrlpts.length / 2 % 2 === 0 ? (n = e.allpts.length / 2 - 1, e.midX = e.allpts[n], e.midY = e.allpts[n + 1]) : (n = e.allpts.length / 2 - 3, i = 0.5, e.midX = Zn(e.allpts[n], e.allpts[n + 2], e.allpts[n + 4], i), e.midY = Zn(e.allpts[n + 1], e.allpts[n + 3], e.allpts[n + 5], i));
  } else if (e.edgeType === "straight")
    e.allpts = [e.startX, e.startY, e.endX, e.endY], e.midX = (e.startX + e.endX + e.arrowStartX + e.arrowEndX) / 4, e.midY = (e.startY + e.endY + e.arrowStartY + e.arrowEndY) / 4;
  else if (e.edgeType === "segments") {
    if (e.allpts = [], e.allpts.push(e.startX, e.startY), e.allpts.push.apply(e.allpts, e.segpts), e.allpts.push(e.endX, e.endY), e.isRound) {
      e.roundCorners = [];
      for (var a = 2; a + 3 < e.allpts.length; a += 2) {
        var s = e.radii[a / 2 - 1], o = e.isArcRadius[a / 2 - 1];
        e.roundCorners.push(DR({
          x: e.allpts[a - 2],
          y: e.allpts[a - 1]
        }, {
          x: e.allpts[a],
          y: e.allpts[a + 1],
          radius: s
        }, {
          x: e.allpts[a + 2],
          y: e.allpts[a + 3]
        }, s, o));
      }
    }
    if (e.segpts.length % 4 === 0) {
      var l = e.segpts.length / 2, u = l - 2;
      e.midX = (e.segpts[u] + e.segpts[l]) / 2, e.midY = (e.segpts[u + 1] + e.segpts[l + 1]) / 2;
    } else {
      var h = e.segpts.length / 2 - 1;
      if (!e.isRound)
        e.midX = e.segpts[h], e.midY = e.segpts[h + 1];
      else {
        var f = {
          x: e.segpts[h],
          y: e.segpts[h + 1]
        }, d = e.roundCorners[h / 2];
        if (d.radius === 0) {
          var p = {
            x: e.segpts[h + 2],
            y: e.segpts[h + 3]
          };
          e.midX = f.x, e.midY = f.y, e.midVector = [f.y - p.y, p.x - f.x];
        } else {
          var g = [f.x - d.cx, f.y - d.cy], m = d.radius / Math.sqrt(Math.pow(g[0], 2) + Math.pow(g[1], 2));
          g = g.map(function(v) {
            return v * m;
          }), e.midX = d.cx + g[0], e.midY = d.cy + g[1], e.midVector = g;
        }
      }
    }
  }
};
Ni.checkForInvalidEdgeWarning = function(t) {
  var e = t[0]._private.rscratch;
  e.nodesOverlap || mt(e.startX) && mt(e.startY) && mt(e.endX) && mt(e.endY) ? e.loggedErr = !1 : e.loggedErr || (e.loggedErr = !0, Rr("Edge `" + t.id() + "` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap."));
};
Ni.findEdgeControlPoints = function(t) {
  var e = this;
  if (!(!t || t.length === 0)) {
    for (var r = this, n = r.cy, i = n.hasCompoundNodes(), a = new el(), s = function(_, R) {
      return [].concat(Cb(_), [R ? 1 : 0]).join("-");
    }, o = [], l = [], u = 0; u < t.length; u++) {
      var h = t[u], f = h._private, d = h.pstyle("curve-style").value;
      if (!(h.removed() || !h.takesUpSpace())) {
        if (d === "haystack") {
          l.push(h);
          continue;
        }
        var p = d === "unbundled-bezier" || ec(d, "segments") || d === "straight" || d === "straight-triangle" || ec(d, "taxi"), g = d === "unbundled-bezier" || d === "bezier", m = f.source, v = f.target, y = m.poolIndex(), b = v.poolIndex(), x = [y, b].sort(), T = s(x, p), E = a.get(T);
        E == null && (E = {
          eles: []
        }, o.push({
          pairId: x,
          edgeIsUnbundled: p
        }), a.set(T, E)), E.eles.push(h), p && (E.hasUnbundled = !0), g && (E.hasBezier = !0);
      }
    }
    for (var A = function() {
      var _ = o[S], R = _.pairId, L = _.edgeIsUnbundled, M = s(R, L), P = a.get(M), C;
      if (!P.hasUnbundled) {
        var I = P.eles[0].parallelEdges().filter(function(te) {
          return te.isBundledBezier();
        });
        bR(P.eles), I.forEach(function(te) {
          return P.eles.push(te);
        }), P.eles.sort(function(te, he) {
          return te.poolIndex() - he.poolIndex();
        });
      }
      var N = P.eles[0], O = N.source(), D = N.target();
      if (O.poolIndex() > D.poolIndex()) {
        var $ = O;
        O = D, D = $;
      }
      var z = P.srcPos = O.position(), B = P.tgtPos = D.position(), G = P.srcW = O.outerWidth(), W = P.srcH = O.outerHeight(), V = P.tgtW = D.outerWidth(), U = P.tgtH = D.outerHeight(), Z = P.srcShape = r.nodeShapes[e.getNodeShape(O)], K = P.tgtShape = r.nodeShapes[e.getNodeShape(D)], ce = P.srcCornerRadius = O.pstyle("corner-radius").value === "auto" ? "auto" : O.pstyle("corner-radius").pfValue, J = P.tgtCornerRadius = D.pstyle("corner-radius").value === "auto" ? "auto" : D.pstyle("corner-radius").pfValue, ee = P.tgtRs = D._private.rscratch, j = P.srcRs = O._private.rscratch;
      P.dirCounts = {
        north: 0,
        west: 0,
        south: 0,
        east: 0,
        northwest: 0,
        southwest: 0,
        northeast: 0,
        southeast: 0
      };
      for (var X = 0; X < P.eles.length; X++) {
        var re = P.eles[X], Q = re[0]._private.rscratch, ue = re.pstyle("curve-style").value, ne = ue === "unbundled-bezier" || ec(ue, "segments") || ec(ue, "taxi"), xe = !O.same(re.source());
        if (!P.calculatedIntersection && O !== D && (P.hasBezier || P.hasUnbundled)) {
          P.calculatedIntersection = !0;
          var Y = Z.intersectLine(z.x, z.y, G, W, B.x, B.y, 0, ce, j), Ne = P.srcIntn = Y, fe = K.intersectLine(B.x, B.y, V, U, z.x, z.y, 0, J, ee), qe = P.tgtIntn = fe, ze = P.intersectionPts = {
            x1: Y[0],
            x2: fe[0],
            y1: Y[1],
            y2: fe[1]
          }, Ge = P.posPts = {
            x1: z.x,
            x2: B.x,
            y1: z.y,
            y2: B.y
          }, Ee = fe[1] - Y[1], Oe = fe[0] - Y[0], Ce = Math.sqrt(Oe * Oe + Ee * Ee);
          mt(Ce) && Ce >= jNe || (Ce = Math.sqrt(Math.max(Oe * Oe, I1) + Math.max(Ee * Ee, I1)));
          var Ae = P.vector = {
            x: Oe,
            y: Ee
          }, $e = P.vectorNorm = {
            x: Ae.x / Ce,
            y: Ae.y / Ce
          }, me = {
            x: -$e.y,
            y: $e.x
          };
          P.nodesOverlap = !mt(Ce) || K.checkPoint(Y[0], Y[1], 0, V, U, B.x, B.y, J, ee) || Z.checkPoint(fe[0], fe[1], 0, G, W, z.x, z.y, ce, j), P.vectorNormInverse = me, C = {
            nodesOverlap: P.nodesOverlap,
            dirCounts: P.dirCounts,
            calculatedIntersection: !0,
            hasBezier: P.hasBezier,
            hasUnbundled: P.hasUnbundled,
            eles: P.eles,
            srcPos: B,
            srcRs: ee,
            tgtPos: z,
            tgtRs: j,
            srcW: V,
            srcH: U,
            tgtW: G,
            tgtH: W,
            srcIntn: qe,
            tgtIntn: Ne,
            srcShape: K,
            tgtShape: Z,
            posPts: {
              x1: Ge.x2,
              y1: Ge.y2,
              x2: Ge.x1,
              y2: Ge.y1
            },
            intersectionPts: {
              x1: ze.x2,
              y1: ze.y2,
              x2: ze.x1,
              y2: ze.y1
            },
            vector: {
              x: -Ae.x,
              y: -Ae.y
            },
            vectorNorm: {
              x: -$e.x,
              y: -$e.y
            },
            vectorNormInverse: {
              x: -me.x,
              y: -me.y
            }
          };
        }
        var Ie = xe ? C : P;
        Q.nodesOverlap = Ie.nodesOverlap, Q.srcIntn = Ie.srcIntn, Q.tgtIntn = Ie.tgtIntn, Q.isRound = ue.startsWith("round"), i && (O.isParent() || O.isChild() || D.isParent() || D.isChild()) && (O.parents().anySame(D) || D.parents().anySame(O) || O.same(D) && O.isParent()) ? e.findCompoundLoopPoints(re, Ie, X, ne) : O === D ? e.findLoopPoints(re, Ie, X, ne) : ue.endsWith("segments") ? e.findSegmentsPoints(re, Ie) : ue.endsWith("taxi") ? e.findTaxiPoints(re, Ie) : ue === "straight" || !ne && P.eles.length % 2 === 1 && X === Math.floor(P.eles.length / 2) ? e.findStraightEdgePoints(re) : e.findBezierPoints(re, Ie, X, ne, xe), e.findEndpoints(re), e.tryToCorrectInvalidPoints(re, Ie), e.checkForInvalidEdgeWarning(re), e.storeAllpts(re), e.storeEdgeProjections(re), e.calculateArrowAngles(re), e.recalculateEdgeLabelProjections(re), e.calculateLabelAngles(re);
      }
    }, S = 0; S < o.length; S++)
      A();
    this.findHaystackPoints(l);
  }
};
function Xie(t) {
  var e = [];
  if (t != null) {
    for (var r = 0; r < t.length; r += 2) {
      var n = t[r], i = t[r + 1];
      e.push({
        x: n,
        y: i
      });
    }
    return e;
  }
}
Ni.getSegmentPoints = function(t) {
  var e = t[0]._private.rscratch;
  this.recalculateRenderedStyle(t);
  var r = e.edgeType;
  if (r === "segments")
    return Xie(e.segpts);
};
Ni.getControlPoints = function(t) {
  var e = t[0]._private.rscratch;
  this.recalculateRenderedStyle(t);
  var r = e.edgeType;
  if (r === "bezier" || r === "multibezier" || r === "self" || r === "compound")
    return Xie(e.ctrlpts);
};
Ni.getEdgeMidpoint = function(t) {
  var e = t[0]._private.rscratch;
  return this.recalculateRenderedStyle(t), {
    x: e.midX,
    y: e.midY
  };
};
var _m = {};
_m.manualEndptToPx = function(t, e) {
  var r = this, n = t.position(), i = t.outerWidth(), a = t.outerHeight(), s = t._private.rscratch;
  if (e.value.length === 2) {
    var o = [e.pfValue[0], e.pfValue[1]];
    return e.units[0] === "%" && (o[0] = o[0] * i), e.units[1] === "%" && (o[1] = o[1] * a), o[0] += n.x, o[1] += n.y, o;
  } else {
    var l = e.pfValue[0];
    l = -Math.PI / 2 + l;
    var u = 2 * Math.max(i, a), h = [n.x + Math.cos(l) * u, n.y + Math.sin(l) * u];
    return r.nodeShapes[this.getNodeShape(t)].intersectLine(n.x, n.y, i, a, h[0], h[1], 0, t.pstyle("corner-radius").value === "auto" ? "auto" : t.pstyle("corner-radius").pfValue, s);
  }
};
_m.findEndpoints = function(t) {
  var e, r, n, i, a = this, s, o = t.source()[0], l = t.target()[0], u = o.position(), h = l.position(), f = t.pstyle("target-arrow-shape").value, d = t.pstyle("source-arrow-shape").value, p = t.pstyle("target-distance-from-node").pfValue, g = t.pstyle("source-distance-from-node").pfValue, m = o._private.rscratch, v = l._private.rscratch, y = t.pstyle("curve-style").value, b = t._private.rscratch, x = b.edgeType, T = ec(y, "taxi"), E = x === "self" || x === "compound", A = x === "bezier" || x === "multibezier" || E, S = x !== "bezier", k = x === "straight" || x === "segments", _ = x === "segments", R = A || S || k, L = E || T, M = t.pstyle("source-endpoint"), P = L ? "outside-to-node" : M.value, C = o.pstyle("corner-radius").value === "auto" ? "auto" : o.pstyle("corner-radius").pfValue, I = t.pstyle("target-endpoint"), N = L ? "outside-to-node" : I.value, O = l.pstyle("corner-radius").value === "auto" ? "auto" : l.pstyle("corner-radius").pfValue;
  b.srcManEndpt = M, b.tgtManEndpt = I;
  var D, $, z, B, G = (e = (I == null || (r = I.pfValue) === null || r === void 0 ? void 0 : r.length) === 2 ? I.pfValue : null) !== null && e !== void 0 ? e : [0, 0], W = (n = (M == null || (i = M.pfValue) === null || i === void 0 ? void 0 : i.length) === 2 ? M.pfValue : null) !== null && n !== void 0 ? n : [0, 0];
  if (A) {
    var V = [b.ctrlpts[0], b.ctrlpts[1]], U = S ? [b.ctrlpts[b.ctrlpts.length - 2], b.ctrlpts[b.ctrlpts.length - 1]] : V;
    D = U, $ = V;
  } else if (k) {
    var Z = _ ? b.segpts.slice(0, 2) : [h.x + G[0], h.y + G[1]], K = _ ? b.segpts.slice(b.segpts.length - 2) : [u.x + W[0], u.y + W[1]];
    D = K, $ = Z;
  }
  if (N === "inside-to-node")
    s = [h.x, h.y];
  else if (I.units)
    s = this.manualEndptToPx(l, I);
  else if (N === "outside-to-line")
    s = b.tgtIntn;
  else if (N === "outside-to-node" || N === "outside-to-node-or-label" ? z = D : (N === "outside-to-line" || N === "outside-to-line-or-label") && (z = [u.x, u.y]), s = a.nodeShapes[this.getNodeShape(l)].intersectLine(h.x, h.y, l.outerWidth(), l.outerHeight(), z[0], z[1], 0, O, v), N === "outside-to-node-or-label" || N === "outside-to-line-or-label") {
    var ce = l._private.rscratch, J = ce.labelWidth, ee = ce.labelHeight, j = ce.labelX, X = ce.labelY, re = J / 2, Q = ee / 2, ue = l.pstyle("text-valign").value;
    ue === "top" ? X -= Q : ue === "bottom" && (X += Q);
    var ne = l.pstyle("text-halign").value;
    ne === "left" ? j -= re : ne === "right" && (j += re);
    var xe = C1(z[0], z[1], [j - re, X - Q, j + re, X - Q, j + re, X + Q, j - re, X + Q], h.x, h.y);
    if (xe.length > 0) {
      var Y = u, Ne = bu(Y, Sf(s)), fe = bu(Y, Sf(xe)), qe = Ne;
      if (fe < Ne && (s = xe, qe = fe), xe.length > 2) {
        var ze = bu(Y, {
          x: xe[2],
          y: xe[3]
        });
        ze < qe && (s = [xe[2], xe[3]]);
      }
    }
  }
  var Ge = Lv(s, D, a.arrowShapes[f].spacing(t) + p), Ee = Lv(s, D, a.arrowShapes[f].gap(t) + p);
  if (b.endX = Ee[0], b.endY = Ee[1], b.arrowEndX = Ge[0], b.arrowEndY = Ge[1], P === "inside-to-node")
    s = [u.x, u.y];
  else if (M.units)
    s = this.manualEndptToPx(o, M);
  else if (P === "outside-to-line")
    s = b.srcIntn;
  else if (P === "outside-to-node" || P === "outside-to-node-or-label" ? B = $ : (P === "outside-to-line" || P === "outside-to-line-or-label") && (B = [h.x, h.y]), s = a.nodeShapes[this.getNodeShape(o)].intersectLine(u.x, u.y, o.outerWidth(), o.outerHeight(), B[0], B[1], 0, C, m), P === "outside-to-node-or-label" || P === "outside-to-line-or-label") {
    var Oe = o._private.rscratch, Ce = Oe.labelWidth, Ae = Oe.labelHeight, $e = Oe.labelX, me = Oe.labelY, Ie = Ce / 2, te = Ae / 2, he = o.pstyle("text-valign").value;
    he === "top" ? me -= te : he === "bottom" && (me += te);
    var F = o.pstyle("text-halign").value;
    F === "left" ? $e -= Ie : F === "right" && ($e += Ie);
    var oe = C1(B[0], B[1], [$e - Ie, me - te, $e + Ie, me - te, $e + Ie, me + te, $e - Ie, me + te], u.x, u.y);
    if (oe.length > 0) {
      var se = h, ge = bu(se, Sf(s)), de = bu(se, Sf(oe)), we = ge;
      if (de < ge && (s = [oe[0], oe[1]], we = de), oe.length > 2) {
        var _e = bu(se, {
          x: oe[2],
          y: oe[3]
        });
        _e < we && (s = [oe[2], oe[3]]);
      }
    }
  }
  var Se = Lv(s, $, a.arrowShapes[d].spacing(t) + g), Me = Lv(s, $, a.arrowShapes[d].gap(t) + g);
  b.startX = Me[0], b.startY = Me[1], b.arrowStartX = Se[0], b.arrowStartY = Se[1], R && (!mt(b.startX) || !mt(b.startY) || !mt(b.endX) || !mt(b.endY) ? b.badLine = !0 : b.badLine = !1);
};
_m.getSourceEndpoint = function(t) {
  var e = t[0]._private.rscratch;
  switch (this.recalculateRenderedStyle(t), e.edgeType) {
    case "haystack":
      return {
        x: e.haystackPts[0],
        y: e.haystackPts[1]
      };
    default:
      return {
        x: e.arrowStartX,
        y: e.arrowStartY
      };
  }
};
_m.getTargetEndpoint = function(t) {
  var e = t[0]._private.rscratch;
  switch (this.recalculateRenderedStyle(t), e.edgeType) {
    case "haystack":
      return {
        x: e.haystackPts[2],
        y: e.haystackPts[3]
      };
    default:
      return {
        x: e.arrowEndX,
        y: e.arrowEndY
      };
  }
};
var OR = {};
function KNe(t, e, r) {
  for (var n = function(u, h, f, d) {
    return Zn(u, h, f, d);
  }, i = e._private, a = i.rstyle.bezierPts, s = 0; s < t.bezierProjPcts.length; s++) {
    var o = t.bezierProjPcts[s];
    a.push({
      x: n(r[0], r[2], r[4], o),
      y: n(r[1], r[3], r[5], o)
    });
  }
}
OR.storeEdgeProjections = function(t) {
  var e = t._private, r = e.rscratch, n = r.edgeType;
  if (e.rstyle.bezierPts = null, e.rstyle.linePts = null, e.rstyle.haystackPts = null, n === "multibezier" || n === "bezier" || n === "self" || n === "compound") {
    e.rstyle.bezierPts = [];
    for (var i = 0; i + 5 < r.allpts.length; i += 4)
      KNe(this, t, r.allpts.slice(i, i + 6));
  } else if (n === "segments")
    for (var a = e.rstyle.linePts = [], i = 0; i + 1 < r.allpts.length; i += 2)
      a.push({
        x: r.allpts[i],
        y: r.allpts[i + 1]
      });
  else if (n === "haystack") {
    var s = r.haystackPts;
    e.rstyle.haystackPts = [{
      x: s[0],
      y: s[1]
    }, {
      x: s[2],
      y: s[3]
    }];
  }
  e.rstyle.arrowWidth = this.getArrowWidth(t.pstyle("width").pfValue, t.pstyle("arrow-scale").value) * this.arrowShapeWidth;
};
OR.recalculateEdgeProjections = function(t) {
  this.findEdgeControlPoints(t);
};
var Co = {};
Co.recalculateNodeLabelProjection = function(t) {
  var e = t.pstyle("label").strValue;
  if (!yc(e)) {
    var r, n, i = t._private, a = t.width(), s = t.height(), o = t.padding(), l = t.position(), u = t.pstyle("text-halign").strValue, h = t.pstyle("text-valign").strValue, f = i.rscratch, d = i.rstyle;
    switch (u) {
      case "left":
        r = l.x - a / 2 - o;
        break;
      case "right":
        r = l.x + a / 2 + o;
        break;
      default:
        r = l.x;
    }
    switch (h) {
      case "top":
        n = l.y - s / 2 - o;
        break;
      case "bottom":
        n = l.y + s / 2 + o;
        break;
      default:
        n = l.y;
    }
    f.labelX = r, f.labelY = n, d.labelX = r, d.labelY = n, this.calculateLabelAngles(t), this.applyLabelDimensions(t);
  }
};
var jie = function(e, r) {
  var n = Math.atan(r / e);
  return e === 0 && n < 0 && (n = n * -1), n;
}, Kie = function(e, r) {
  var n = r.x - e.x, i = r.y - e.y;
  return jie(n, i);
}, ZNe = function(e, r, n, i) {
  var a = k1(0, i - 1e-3, 1), s = k1(0, i + 1e-3, 1), o = Bf(e, r, n, a), l = Bf(e, r, n, s);
  return Kie(o, l);
};
Co.recalculateEdgeLabelProjections = function(t) {
  var e, r = t._private, n = r.rscratch, i = this, a = {
    mid: t.pstyle("label").strValue,
    source: t.pstyle("source-label").strValue,
    target: t.pstyle("target-label").strValue
  };
  if (a.mid || a.source || a.target) {
    e = {
      x: n.midX,
      y: n.midY
    };
    var s = function(f, d, p) {
      Yo(r.rscratch, f, d, p), Yo(r.rstyle, f, d, p);
    };
    s("labelX", null, e.x), s("labelY", null, e.y);
    var o = jie(n.midDispX, n.midDispY);
    s("labelAutoAngle", null, o);
    var l = function() {
      if (l.cache)
        return l.cache;
      for (var f = [], d = 0; d + 5 < n.allpts.length; d += 4) {
        var p = {
          x: n.allpts[d],
          y: n.allpts[d + 1]
        }, g = {
          x: n.allpts[d + 2],
          y: n.allpts[d + 3]
        }, m = {
          x: n.allpts[d + 4],
          y: n.allpts[d + 5]
        };
        f.push({
          p0: p,
          p1: g,
          p2: m,
          startDist: 0,
          length: 0,
          segments: []
        });
      }
      var v = r.rstyle.bezierPts, y = i.bezierProjPcts.length;
      function b(S, k, _, R, L) {
        var M = rh(k, _), P = S.segments[S.segments.length - 1], C = {
          p0: k,
          p1: _,
          t0: R,
          t1: L,
          startDist: P ? P.startDist + P.length : 0,
          length: M
        };
        S.segments.push(C), S.length += M;
      }
      for (var x = 0; x < f.length; x++) {
        var T = f[x], E = f[x - 1];
        E && (T.startDist = E.startDist + E.length), b(T, T.p0, v[x * y], 0, i.bezierProjPcts[0]);
        for (var A = 0; A < y - 1; A++)
          b(T, v[x * y + A], v[x * y + A + 1], i.bezierProjPcts[A], i.bezierProjPcts[A + 1]);
        b(T, v[x * y + y - 1], T.p2, i.bezierProjPcts[y - 1], 1);
      }
      return l.cache = f;
    }, u = function(f) {
      var d, p = f === "source";
      if (a[f]) {
        var g = t.pstyle(f + "-text-offset").pfValue;
        switch (n.edgeType) {
          case "self":
          case "compound":
          case "bezier":
          case "multibezier": {
            for (var m = l(), v, y = 0, b = 0, x = 0; x < m.length; x++) {
              for (var T = m[p ? x : m.length - 1 - x], E = 0; E < T.segments.length; E++) {
                var A = T.segments[p ? E : T.segments.length - 1 - E], S = x === m.length - 1 && E === T.segments.length - 1;
                if (y = b, b += A.length, b >= g || S) {
                  v = {
                    cp: T,
                    segment: A
                  };
                  break;
                }
              }
              if (v)
                break;
            }
            var k = v.cp, _ = v.segment, R = (g - y) / _.length, L = _.t1 - _.t0, M = p ? _.t0 + L * R : _.t1 - L * R;
            M = k1(0, M, 1), e = Bf(k.p0, k.p1, k.p2, M), d = ZNe(k.p0, k.p1, k.p2, M);
            break;
          }
          case "straight":
          case "segments":
          case "haystack": {
            for (var P = 0, C, I, N, O, D = n.allpts.length, $ = 0; $ + 3 < D && (p ? (N = {
              x: n.allpts[$],
              y: n.allpts[$ + 1]
            }, O = {
              x: n.allpts[$ + 2],
              y: n.allpts[$ + 3]
            }) : (N = {
              x: n.allpts[D - 2 - $],
              y: n.allpts[D - 1 - $]
            }, O = {
              x: n.allpts[D - 4 - $],
              y: n.allpts[D - 3 - $]
            }), C = rh(N, O), I = P, P += C, !(P >= g)); $ += 2)
              ;
            var z = g - I, B = z / C;
            B = k1(0, B, 1), e = bRe(N, O, B), d = Kie(N, O);
            break;
          }
        }
        s("labelX", f, e.x), s("labelY", f, e.y), s("labelAutoAngle", f, d);
      }
    };
    u("source"), u("target"), this.applyLabelDimensions(t);
  }
};
Co.applyLabelDimensions = function(t) {
  this.applyPrefixedLabelDimensions(t), t.isEdge() && (this.applyPrefixedLabelDimensions(t, "source"), this.applyPrefixedLabelDimensions(t, "target"));
};
Co.applyPrefixedLabelDimensions = function(t, e) {
  var r = t._private, n = this.getLabelText(t, e), i = th(n, t._private.labelDimsKey);
  if (aa(r.rscratch, "prefixedLabelDimsKey", e) !== i) {
    Yo(r.rscratch, "prefixedLabelDimsKey", e, i);
    var a = this.calculateLabelDimensions(t, n), s = t.pstyle("line-height").pfValue, o = t.pstyle("text-wrap").strValue, l = aa(r.rscratch, "labelWrapCachedLines", e) || [], u = o !== "wrap" ? 1 : Math.max(l.length, 1), h = a.height / u, f = h * s, d = a.width, p = a.height + (u - 1) * (s - 1) * h;
    Yo(r.rstyle, "labelWidth", e, d), Yo(r.rscratch, "labelWidth", e, d), Yo(r.rstyle, "labelHeight", e, p), Yo(r.rscratch, "labelHeight", e, p), Yo(r.rscratch, "labelLineHeight", e, f);
  }
};
Co.getLabelText = function(t, e) {
  var r = t._private, n = e ? e + "-" : "", i = t.pstyle(n + "label").strValue, a = t.pstyle("text-transform").value, s = function(W, V) {
    return V ? (Yo(r.rscratch, W, e, V), V) : aa(r.rscratch, W, e);
  };
  if (!i)
    return "";
  a == "none" || (a == "uppercase" ? i = i.toUpperCase() : a == "lowercase" && (i = i.toLowerCase()));
  var o = t.pstyle("text-wrap").value;
  if (o === "wrap") {
    var l = s("labelKey");
    if (l != null && s("labelWrapKey") === l)
      return s("labelWrapCachedText");
    for (var u = "\u200B", h = i.split(`
`), f = t.pstyle("text-max-width").pfValue, d = t.pstyle("text-overflow-wrap").value, p = d === "anywhere", g = [], m = /[\s\u200b]+|$/g, v = 0; v < h.length; v++) {
      var y = h[v], b = this.calculateLabelDimensions(t, y), x = b.width;
      if (p) {
        var T = y.split("").join(u);
        y = T;
      }
      if (x > f) {
        var E = y.matchAll(m), A = "", S = 0, k = ca(E), _;
        try {
          for (k.s(); !(_ = k.n()).done; ) {
            var R = _.value, L = R[0], M = y.substring(S, R.index);
            S = R.index + L.length;
            var P = A.length === 0 ? M : A + M + L, C = this.calculateLabelDimensions(t, P), I = C.width;
            I <= f ? A += M + L : (A && g.push(A), A = M + L);
          }
        } catch (G) {
          k.e(G);
        } finally {
          k.f();
        }
        A.match(/^[\s\u200b]+$/) || g.push(A);
      } else
        g.push(y);
    }
    s("labelWrapCachedLines", g), i = s("labelWrapCachedText", g.join(`
`)), s("labelWrapKey", l);
  } else if (o === "ellipsis") {
    var N = t.pstyle("text-max-width").pfValue, O = "", D = "\u2026", $ = !1;
    if (this.calculateLabelDimensions(t, i).width < N)
      return i;
    for (var z = 0; z < i.length; z++) {
      var B = this.calculateLabelDimensions(t, O + i[z] + D).width;
      if (B > N)
        break;
      O += i[z], z === i.length - 1 && ($ = !0);
    }
    return $ || (O += D), O;
  }
  return i;
};
Co.getLabelJustification = function(t) {
  var e = t.pstyle("text-justification").strValue, r = t.pstyle("text-halign").strValue;
  if (e === "auto")
    if (t.isNode())
      switch (r) {
        case "left":
          return "right";
        case "right":
          return "left";
        default:
          return "center";
      }
    else
      return "center";
  else
    return e;
};
Co.calculateLabelDimensions = function(t, e) {
  var r = this, n = r.cy.window(), i = n.document, a = 0, s = t.pstyle("font-style").strValue, o = t.pstyle("font-size").pfValue, l = t.pstyle("font-family").strValue, u = t.pstyle("font-weight").strValue, h = this.labelCalcCanvas, f = this.labelCalcCanvasContext;
  if (!h) {
    h = this.labelCalcCanvas = i.createElement("canvas"), f = this.labelCalcCanvasContext = h.getContext("2d");
    var d = h.style;
    d.position = "absolute", d.left = "-9999px", d.top = "-9999px", d.zIndex = "-1", d.visibility = "hidden", d.pointerEvents = "none";
  }
  f.font = "".concat(s, " ").concat(u, " ").concat(o, "px ").concat(l);
  for (var p = 0, g = 0, m = e.split(`
`), v = 0; v < m.length; v++) {
    var y = m[v], b = f.measureText(y), x = Math.ceil(b.width), T = o;
    p = Math.max(x, p), g += T;
  }
  return p += a, g += a, {
    width: p,
    height: g
  };
};
Co.calculateLabelAngle = function(t, e) {
  var r = t._private, n = r.rscratch, i = t.isEdge(), a = e ? e + "-" : "", s = t.pstyle(a + "text-rotation"), o = s.strValue;
  return o === "none" ? 0 : i && o === "autorotate" ? n.labelAutoAngle : o === "autorotate" ? 0 : s.pfValue;
};
Co.calculateLabelAngles = function(t) {
  var e = this, r = t.isEdge(), n = t._private, i = n.rscratch;
  i.labelAngle = e.calculateLabelAngle(t), r && (i.sourceLabelAngle = e.calculateLabelAngle(t, "source"), i.targetLabelAngle = e.calculateLabelAngle(t, "target"));
};
var Zie = {}, uU = 28, hU = !1;
Zie.getNodeShape = function(t) {
  var e = this, r = t.pstyle("shape").value;
  if (r === "cutrectangle" && (t.width() < uU || t.height() < uU))
    return hU || (Rr("The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead"), hU = !0), "rectangle";
  if (t.isParent())
    return r === "rectangle" || r === "roundrectangle" || r === "round-rectangle" || r === "cutrectangle" || r === "cut-rectangle" || r === "barrel" ? r : "rectangle";
  if (r === "polygon") {
    var n = t.pstyle("shape-polygon-points").value;
    return e.nodeShapes.makePolygon(n).name;
  }
  return r;
};
var c3 = {};
c3.registerCalculationListeners = function() {
  var t = this.cy, e = t.collection(), r = this, n = function(s) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    if (e.merge(s), o)
      for (var l = 0; l < s.length; l++) {
        var u = s[l], h = u._private, f = h.rstyle;
        f.clean = !1, f.cleanConnected = !1;
      }
  };
  r.binder(t).on("bounds.* dirty.*", function(s) {
    var o = s.target;
    n(o);
  }).on("style.* background.*", function(s) {
    var o = s.target;
    n(o, !1);
  });
  var i = function(s) {
    if (s) {
      var o = r.onUpdateEleCalcsFns;
      e.cleanStyle();
      for (var l = 0; l < e.length; l++) {
        var u = e[l], h = u._private.rstyle;
        u.isNode() && !h.cleanConnected && (n(u.connectedEdges()), h.cleanConnected = !0);
      }
      if (o)
        for (var f = 0; f < o.length; f++) {
          var d = o[f];
          d(s, e);
        }
      r.recalculateRenderedStyle(e), e = t.collection();
    }
  };
  r.flushRenderedStyleQueue = function() {
    i(!0);
  }, r.beforeRender(i, r.beforeRenderPriorities.eleCalcs);
};
c3.onUpdateEleCalcs = function(t) {
  var e = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
  e.push(t);
};
c3.recalculateRenderedStyle = function(t, e) {
  var r = function(T) {
    return T._private.rstyle.cleanConnected;
  };
  if (t.length !== 0) {
    var n = [], i = [];
    if (!this.destroyed) {
      e === void 0 && (e = !0);
      for (var a = 0; a < t.length; a++) {
        var s = t[a], o = s._private, l = o.rstyle;
        s.isEdge() && (!r(s.source()) || !r(s.target())) && (l.clean = !1), s.isEdge() && s.isBundledBezier() && s.parallelEdges().some(function(x) {
          return !x._private.rstyle.clean && x.isBundledBezier();
        }) && (l.clean = !1), !(e && l.clean || s.removed()) && s.pstyle("display").value !== "none" && (o.group === "nodes" ? i.push(s) : n.push(s), l.clean = !0);
      }
      for (var u = 0; u < i.length; u++) {
        var h = i[u], f = h._private, d = f.rstyle, p = h.position();
        this.recalculateNodeLabelProjection(h), d.nodeX = p.x, d.nodeY = p.y, d.nodeW = h.pstyle("width").pfValue, d.nodeH = h.pstyle("height").pfValue;
      }
      this.recalculateEdgeProjections(n);
      for (var g = 0; g < n.length; g++) {
        var m = n[g], v = m._private, y = v.rstyle, b = v.rscratch;
        y.srcX = b.arrowStartX, y.srcY = b.arrowStartY, y.tgtX = b.arrowEndX, y.tgtY = b.arrowEndY, y.midX = b.midX, y.midY = b.midY, y.labelAngle = b.labelAngle, y.sourceLabelAngle = b.sourceLabelAngle, y.targetLabelAngle = b.targetLabelAngle;
      }
    }
  }
};
var u3 = {};
u3.updateCachedGrabbedEles = function() {
  var t = this.cachedZSortedEles;
  if (t) {
    t.drag = [], t.nondrag = [];
    for (var e = [], r = 0; r < t.length; r++) {
      var n = t[r], i = n._private.rscratch;
      n.grabbed() && !n.isParent() ? e.push(n) : i.inDragLayer ? t.drag.push(n) : t.nondrag.push(n);
    }
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      t.drag.push(n);
    }
  }
};
u3.invalidateCachedZSortedEles = function() {
  this.cachedZSortedEles = null;
};
u3.getCachedZSortedEles = function(t) {
  if (t || !this.cachedZSortedEles) {
    var e = this.cy.mutableElements().toArray();
    e.sort(Mie), e.interactive = e.filter(function(r) {
      return r.interactive();
    }), this.cachedZSortedEles = e, this.updateCachedGrabbedEles();
  } else
    e = this.cachedZSortedEles;
  return e;
};
var Qie = {};
[Nh, Pb, Ni, _m, OR, Co, Zie, c3, u3].forEach(function(t) {
  Ut(Qie, t);
});
var Jie = {};
Jie.getCachedImage = function(t, e, r) {
  var n = this, i = n.imageCache = n.imageCache || {}, a = i[t];
  if (a)
    return a.image.complete || a.image.addEventListener("load", r), a.image;
  a = i[t] = i[t] || {};
  var s = a.image = new Image();
  s.addEventListener("load", r), s.addEventListener("error", function() {
    s.error = !0;
  });
  var o = "data:", l = t.substring(0, o.length).toLowerCase() === o;
  return l || (e = e === "null" ? null : e, s.crossOrigin = e), s.src = t, s;
};
var H0 = {};
H0.registerBinding = function(t, e, r, n) {
  var i = Array.prototype.slice.apply(arguments, [1]);
  if (Array.isArray(t)) {
    for (var a = [], s = 0; s < t.length; s++) {
      var o = t[s];
      if (o !== void 0) {
        var l = this.binder(o);
        a.push(l.on.apply(l, i));
      }
    }
    return a;
  }
  var l = this.binder(t);
  return l.on.apply(l, i);
};
H0.binder = function(t) {
  var e = this, r = e.cy.window(), n = t === r || t === r.document || t === r.document.body || cLe(t);
  if (e.supportsPassiveEvents == null) {
    var i = !1;
    try {
      var a = Object.defineProperty({}, "passive", {
        get: function() {
          return i = !0, !0;
        }
      });
      r.addEventListener("test", null, a);
    } catch {
    }
    e.supportsPassiveEvents = i;
  }
  var s = function(l, u, h) {
    var f = Array.prototype.slice.call(arguments);
    return n && e.supportsPassiveEvents && (f[2] = {
      capture: h ?? !1,
      passive: !1,
      once: !1
    }), e.bindings.push({
      target: t,
      args: f
    }), (t.addEventListener || t.on).apply(t, f), this;
  };
  return {
    on: s,
    addEventListener: s,
    addListener: s,
    bind: s
  };
};
H0.nodeIsDraggable = function(t) {
  return t && t.isNode() && !t.locked() && t.grabbable();
};
H0.nodeIsGrabbable = function(t) {
  return this.nodeIsDraggable(t) && t.interactive();
};
H0.load = function() {
  var t = this, e = t.cy.window(), r = function(F) {
    return F.selected();
  }, n = function(F) {
    var oe = F.getRootNode();
    if (oe && oe.nodeType === 11 && oe.host !== void 0)
      return oe;
  }, i = function(F, oe, se, ge) {
    F == null && (F = t.cy);
    for (var de = 0; de < oe.length; de++) {
      var we = oe[de];
      F.emit({
        originalEvent: se,
        type: we,
        position: ge
      });
    }
  }, a = function(F) {
    return F.shiftKey || F.metaKey || F.ctrlKey;
  }, s = function(F, oe) {
    var se = !0;
    if (t.cy.hasCompoundNodes() && F && F.pannable())
      for (var ge = 0; oe && ge < oe.length; ge++) {
        var F = oe[ge];
        if (F.isNode() && F.isParent() && !F.pannable()) {
          se = !1;
          break;
        }
      }
    else
      se = !0;
    return se;
  }, o = function(F) {
    F[0]._private.grabbed = !0;
  }, l = function(F) {
    F[0]._private.grabbed = !1;
  }, u = function(F) {
    F[0]._private.rscratch.inDragLayer = !0;
  }, h = function(F) {
    F[0]._private.rscratch.inDragLayer = !1;
  }, f = function(F) {
    F[0]._private.rscratch.isGrabTarget = !0;
  }, d = function(F) {
    F[0]._private.rscratch.isGrabTarget = !1;
  }, p = function(F, oe) {
    var se = oe.addToList, ge = se.has(F);
    !ge && F.grabbable() && !F.locked() && (se.merge(F), o(F));
  }, g = function(F, oe) {
    if (F.cy().hasCompoundNodes() && !(oe.inDragLayer == null && oe.addToList == null)) {
      var se = F.descendants();
      oe.inDragLayer && (se.forEach(u), se.connectedEdges().forEach(u)), oe.addToList && p(se, oe);
    }
  }, m = function(F, oe) {
    oe = oe || {};
    var se = F.cy().hasCompoundNodes();
    oe.inDragLayer && (F.forEach(u), F.neighborhood().stdFilter(function(ge) {
      return !se || ge.isEdge();
    }).forEach(u)), oe.addToList && F.forEach(function(ge) {
      p(ge, oe);
    }), g(F, oe), b(F, {
      inDragLayer: oe.inDragLayer
    }), t.updateCachedGrabbedEles();
  }, v = m, y = function(F) {
    F && (t.getCachedZSortedEles().forEach(function(oe) {
      l(oe), h(oe), d(oe);
    }), t.updateCachedGrabbedEles());
  }, b = function(F, oe) {
    if (!(oe.inDragLayer == null && oe.addToList == null) && F.cy().hasCompoundNodes()) {
      var se = F.ancestors().orphans();
      if (!se.same(F)) {
        var ge = se.descendants().spawnSelf().merge(se).unmerge(F).unmerge(F.descendants()), de = ge.connectedEdges();
        oe.inDragLayer && (de.forEach(u), ge.forEach(u)), oe.addToList && ge.forEach(function(we) {
          p(we, oe);
        });
      }
    }
  }, x = function() {
    document.activeElement != null && document.activeElement.blur != null && document.activeElement.blur();
  }, T = typeof MutationObserver < "u", E = typeof ResizeObserver < "u";
  T ? (t.removeObserver = new MutationObserver(function(he) {
    for (var F = 0; F < he.length; F++) {
      var oe = he[F], se = oe.removedNodes;
      if (se)
        for (var ge = 0; ge < se.length; ge++) {
          var de = se[ge];
          if (de === t.container) {
            t.destroy();
            break;
          }
        }
    }
  }), t.container.parentNode && t.removeObserver.observe(t.container.parentNode, {
    childList: !0
  })) : t.registerBinding(t.container, "DOMNodeRemoved", function(he) {
    t.destroy();
  });
  var A = Em(function() {
    t.cy.resize();
  }, 100);
  T && (t.styleObserver = new MutationObserver(A), t.styleObserver.observe(t.container, {
    attributes: !0
  })), t.registerBinding(e, "resize", A), E && (t.resizeObserver = new ResizeObserver(A), t.resizeObserver.observe(t.container));
  var S = function(F, oe) {
    for (; F != null; )
      oe(F), F = F.parentNode;
  }, k = function() {
    t.invalidateContainerClientCoordsCache();
  };
  S(t.container, function(he) {
    t.registerBinding(he, "transitionend", k), t.registerBinding(he, "animationend", k), t.registerBinding(he, "scroll", k);
  }), t.registerBinding(t.container, "contextmenu", function(he) {
    he.preventDefault();
  });
  var _ = function() {
    return t.selection[4] !== 0;
  }, R = function(F) {
    for (var oe = t.findContainerClientCoords(), se = oe[0], ge = oe[1], de = oe[2], we = oe[3], _e = F.touches ? F.touches : [F], Se = !1, Me = 0; Me < _e.length; Me++) {
      var Xe = _e[Me];
      if (se <= Xe.clientX && Xe.clientX <= se + de && ge <= Xe.clientY && Xe.clientY <= ge + we) {
        Se = !0;
        break;
      }
    }
    if (!Se)
      return !1;
    for (var We = t.container, Ke = F.target, Ze = Ke.parentNode, Pe = !1; Ze; ) {
      if (Ze === We) {
        Pe = !0;
        break;
      }
      Ze = Ze.parentNode;
    }
    return !!Pe;
  };
  t.registerBinding(t.container, "mousedown", function(F) {
    if (R(F) && !(t.hoverData.which === 1 && F.which !== 1)) {
      F.preventDefault(), x(), t.hoverData.capture = !0, t.hoverData.which = F.which;
      var oe = t.cy, se = [F.clientX, F.clientY], ge = t.projectIntoViewport(se[0], se[1]), de = t.selection, we = t.findNearestElements(ge[0], ge[1], !0, !1), _e = we[0], Se = t.dragData.possibleDragElements;
      t.hoverData.mdownPos = ge, t.hoverData.mdownGPos = se;
      var Me = function(Ve) {
        return {
          originalEvent: F,
          type: Ve,
          position: {
            x: ge[0],
            y: ge[1]
          }
        };
      }, Xe = function() {
        t.hoverData.tapholdCancelled = !1, clearTimeout(t.hoverData.tapholdTimeout), t.hoverData.tapholdTimeout = setTimeout(function() {
          if (!t.hoverData.tapholdCancelled) {
            var Ve = t.hoverData.down;
            Ve ? Ve.emit(Me("taphold")) : oe.emit(Me("taphold"));
          }
        }, t.tapholdDuration);
      };
      if (F.which == 3) {
        t.hoverData.cxtStarted = !0;
        var We = {
          originalEvent: F,
          type: "cxttapstart",
          position: {
            x: ge[0],
            y: ge[1]
          }
        };
        _e ? (_e.activate(), _e.emit(We), t.hoverData.down = _e) : oe.emit(We), t.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime(), t.hoverData.cxtDragged = !1;
      } else if (F.which == 1) {
        _e && _e.activate();
        {
          if (_e != null && t.nodeIsGrabbable(_e)) {
            var Ke = function(Ve) {
              Ve.emit(Me("grab"));
            };
            if (f(_e), !_e.selected())
              Se = t.dragData.possibleDragElements = oe.collection(), v(_e, {
                addToList: Se
              }), _e.emit(Me("grabon")).emit(Me("grab"));
            else {
              Se = t.dragData.possibleDragElements = oe.collection();
              var Ze = oe.$(function(Pe) {
                return Pe.isNode() && Pe.selected() && t.nodeIsGrabbable(Pe);
              });
              m(Ze, {
                addToList: Se
              }), _e.emit(Me("grabon")), Ze.forEach(Ke);
            }
            t.redrawHint("eles", !0), t.redrawHint("drag", !0);
          }
          t.hoverData.down = _e, t.hoverData.downs = we, t.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime();
        }
        i(_e, ["mousedown", "tapstart", "vmousedown"], F, {
          x: ge[0],
          y: ge[1]
        }), _e == null ? (de[4] = 1, t.data.bgActivePosistion = {
          x: ge[0],
          y: ge[1]
        }, t.redrawHint("select", !0), t.redraw()) : _e.pannable() && (de[4] = 1), Xe();
      }
      de[0] = de[2] = ge[0], de[1] = de[3] = ge[1];
    }
  }, !1);
  var L = n(t.container);
  t.registerBinding([e, L], "mousemove", function(F) {
    var oe = t.hoverData.capture;
    if (!(!oe && !R(F))) {
      var se = !1, ge = t.cy, de = ge.zoom(), we = [F.clientX, F.clientY], _e = t.projectIntoViewport(we[0], we[1]), Se = t.hoverData.mdownPos, Me = t.hoverData.mdownGPos, Xe = t.selection, We = null;
      !t.hoverData.draggingEles && !t.hoverData.dragging && !t.hoverData.selecting && (We = t.findNearestElement(_e[0], _e[1], !0, !1));
      var Ke = t.hoverData.last, Ze = t.hoverData.down, Pe = [_e[0] - Xe[2], _e[1] - Xe[3]], Ve = t.dragData.possibleDragElements, ht;
      if (Me) {
        var st = we[0] - Me[0], Ue = st * st, Et = we[1] - Me[1], He = Et * Et, rt = Ue + He;
        t.hoverData.isOverThresholdDrag = ht = rt >= t.desktopTapThreshold2;
      }
      var ct = a(F);
      ht && (t.hoverData.tapholdCancelled = !0);
      var ut = function() {
        var ft = t.hoverData.dragDelta = t.hoverData.dragDelta || [];
        ft.length === 0 ? (ft.push(Pe[0]), ft.push(Pe[1])) : (ft[0] += Pe[0], ft[1] += Pe[1]);
      };
      se = !0, i(We, ["mousemove", "vmousemove", "tapdrag"], F, {
        x: _e[0],
        y: _e[1]
      });
      var nt = function(ft) {
        return {
          originalEvent: F,
          type: ft,
          position: {
            x: _e[0],
            y: _e[1]
          }
        };
      }, bt = function() {
        t.data.bgActivePosistion = void 0, t.hoverData.selecting || ge.emit(nt("boxstart")), Xe[4] = 1, t.hoverData.selecting = !0, t.redrawHint("select", !0), t.redraw();
      };
      if (t.hoverData.which === 3) {
        if (ht) {
          var er = nt("cxtdrag");
          Ze ? Ze.emit(er) : ge.emit(er), t.hoverData.cxtDragged = !0, (!t.hoverData.cxtOver || We !== t.hoverData.cxtOver) && (t.hoverData.cxtOver && t.hoverData.cxtOver.emit(nt("cxtdragout")), t.hoverData.cxtOver = We, We && We.emit(nt("cxtdragover")));
        }
      } else if (t.hoverData.dragging) {
        if (se = !0, ge.panningEnabled() && ge.userPanningEnabled()) {
          var Dt;
          if (t.hoverData.justStartedPan) {
            var ir = t.hoverData.mdownPos;
            Dt = {
              x: (_e[0] - ir[0]) * de,
              y: (_e[1] - ir[1]) * de
            }, t.hoverData.justStartedPan = !1;
          } else
            Dt = {
              x: Pe[0] * de,
              y: Pe[1] * de
            };
          ge.panBy(Dt), ge.emit(nt("dragpan")), t.hoverData.dragged = !0;
        }
        _e = t.projectIntoViewport(F.clientX, F.clientY);
      } else if (Xe[4] == 1 && (Ze == null || Ze.pannable())) {
        if (ht) {
          if (!t.hoverData.dragging && ge.boxSelectionEnabled() && (ct || !ge.panningEnabled() || !ge.userPanningEnabled()))
            bt();
          else if (!t.hoverData.selecting && ge.panningEnabled() && ge.userPanningEnabled()) {
            var wr = s(Ze, t.hoverData.downs);
            wr && (t.hoverData.dragging = !0, t.hoverData.justStartedPan = !0, Xe[4] = 0, t.data.bgActivePosistion = Sf(Se), t.redrawHint("select", !0), t.redraw());
          }
          Ze && Ze.pannable() && Ze.active() && Ze.unactivate();
        }
      } else {
        if (Ze && Ze.pannable() && Ze.active() && Ze.unactivate(), (!Ze || !Ze.grabbed()) && We != Ke && (Ke && i(Ke, ["mouseout", "tapdragout"], F, {
          x: _e[0],
          y: _e[1]
        }), We && i(We, ["mouseover", "tapdragover"], F, {
          x: _e[0],
          y: _e[1]
        }), t.hoverData.last = We), Ze)
          if (ht) {
            if (ge.boxSelectionEnabled() && ct)
              Ze && Ze.grabbed() && (y(Ve), Ze.emit(nt("freeon")), Ve.emit(nt("free")), t.dragData.didDrag && (Ze.emit(nt("dragfreeon")), Ve.emit(nt("dragfree")))), bt();
            else if (Ze && Ze.grabbed() && t.nodeIsDraggable(Ze)) {
              var ar = !t.dragData.didDrag;
              ar && t.redrawHint("eles", !0), t.dragData.didDrag = !0, t.hoverData.draggingEles || m(Ve, {
                inDragLayer: !0
              });
              var Wt = {
                x: 0,
                y: 0
              };
              if (mt(Pe[0]) && mt(Pe[1]) && (Wt.x += Pe[0], Wt.y += Pe[1], ar)) {
                var ur = t.hoverData.dragDelta;
                ur && mt(ur[0]) && mt(ur[1]) && (Wt.x += ur[0], Wt.y += ur[1]);
              }
              t.hoverData.draggingEles = !0, Ve.silentShift(Wt).emit(nt("position")).emit(nt("drag")), t.redrawHint("drag", !0), t.redraw();
            }
          } else
            ut();
        se = !0;
      }
      if (Xe[2] = _e[0], Xe[3] = _e[1], se)
        return F.stopPropagation && F.stopPropagation(), F.preventDefault && F.preventDefault(), !1;
    }
  }, !1);
  var M, P, C;
  t.registerBinding(e, "mouseup", function(F) {
    if (!(t.hoverData.which === 1 && F.which !== 1 && t.hoverData.capture)) {
      var oe = t.hoverData.capture;
      if (oe) {
        t.hoverData.capture = !1;
        var se = t.cy, ge = t.projectIntoViewport(F.clientX, F.clientY), de = t.selection, we = t.findNearestElement(ge[0], ge[1], !0, !1), _e = t.dragData.possibleDragElements, Se = t.hoverData.down, Me = a(F);
        t.data.bgActivePosistion && (t.redrawHint("select", !0), t.redraw()), t.hoverData.tapholdCancelled = !0, t.data.bgActivePosistion = void 0, Se && Se.unactivate();
        var Xe = function(st) {
          return {
            originalEvent: F,
            type: st,
            position: {
              x: ge[0],
              y: ge[1]
            }
          };
        };
        if (t.hoverData.which === 3) {
          var We = Xe("cxttapend");
          if (Se ? Se.emit(We) : se.emit(We), !t.hoverData.cxtDragged) {
            var Ke = Xe("cxttap");
            Se ? Se.emit(Ke) : se.emit(Ke);
          }
          t.hoverData.cxtDragged = !1, t.hoverData.which = null;
        } else if (t.hoverData.which === 1) {
          if (i(we, ["mouseup", "tapend", "vmouseup"], F, {
            x: ge[0],
            y: ge[1]
          }), !t.dragData.didDrag && // didn't move a node around
          !t.hoverData.dragged && // didn't pan
          !t.hoverData.selecting && // not box selection
          !t.hoverData.isOverThresholdDrag && (i(Se, ["click", "tap", "vclick"], F, {
            x: ge[0],
            y: ge[1]
          }), P = !1, F.timeStamp - C <= se.multiClickDebounceTime() ? (M && clearTimeout(M), P = !0, C = null, i(Se, ["dblclick", "dbltap", "vdblclick"], F, {
            x: ge[0],
            y: ge[1]
          })) : (M = setTimeout(function() {
            P || i(Se, ["oneclick", "onetap", "voneclick"], F, {
              x: ge[0],
              y: ge[1]
            });
          }, se.multiClickDebounceTime()), C = F.timeStamp)), Se == null && !t.dragData.didDrag && !t.hoverData.selecting && !t.hoverData.dragged && !a(F) && (se.$(r).unselect(["tapunselect"]), _e.length > 0 && t.redrawHint("eles", !0), t.dragData.possibleDragElements = _e = se.collection()), we == Se && !t.dragData.didDrag && !t.hoverData.selecting && we != null && we._private.selectable && (t.hoverData.dragging || (se.selectionType() === "additive" || Me ? we.selected() ? we.unselect(["tapunselect"]) : we.select(["tapselect"]) : Me || (se.$(r).unmerge(we).unselect(["tapunselect"]), we.select(["tapselect"]))), t.redrawHint("eles", !0)), t.hoverData.selecting) {
            var Ze = se.collection(t.getAllInBox(de[0], de[1], de[2], de[3]));
            t.redrawHint("select", !0), Ze.length > 0 && t.redrawHint("eles", !0), se.emit(Xe("boxend"));
            var Pe = function(st) {
              return st.selectable() && !st.selected();
            };
            se.selectionType() === "additive" || Me || se.$(r).unmerge(Ze).unselect(), Ze.emit(Xe("box")).stdFilter(Pe).select().emit(Xe("boxselect")), t.redraw();
          }
          if (t.hoverData.dragging && (t.hoverData.dragging = !1, t.redrawHint("select", !0), t.redrawHint("eles", !0), t.redraw()), !de[4]) {
            t.redrawHint("drag", !0), t.redrawHint("eles", !0);
            var Ve = Se && Se.grabbed();
            y(_e), Ve && (Se.emit(Xe("freeon")), _e.emit(Xe("free")), t.dragData.didDrag && (Se.emit(Xe("dragfreeon")), _e.emit(Xe("dragfree"))));
          }
        }
        de[4] = 0, t.hoverData.down = null, t.hoverData.cxtStarted = !1, t.hoverData.draggingEles = !1, t.hoverData.selecting = !1, t.hoverData.isOverThresholdDrag = !1, t.dragData.didDrag = !1, t.hoverData.dragged = !1, t.hoverData.dragDelta = [], t.hoverData.mdownPos = null, t.hoverData.mdownGPos = null, t.hoverData.which = null;
      }
    }
  }, !1);
  var I = [], N = 4, O, D = 1e5, $ = function(F, oe) {
    for (var se = 0; se < F.length; se++)
      if (F[se] % oe !== 0)
        return !1;
    return !0;
  }, z = function(F) {
    for (var oe = Math.abs(F[0]), se = 1; se < F.length; se++)
      if (Math.abs(F[se]) !== oe)
        return !1;
    return !0;
  }, B = function(F) {
    var oe = !1, se = F.deltaY;
    if (se == null && (F.wheelDeltaY != null ? se = F.wheelDeltaY / 4 : F.wheelDelta != null && (se = F.wheelDelta / 4)), se !== 0) {
      if (O == null)
        if (I.length >= N) {
          var ge = I;
          if (O = $(ge, 5), !O) {
            var de = Math.abs(ge[0]);
            O = z(ge) && de > 5;
          }
          if (O)
            for (var we = 0; we < ge.length; we++)
              D = Math.min(Math.abs(ge[we]), D);
        } else
          I.push(se), oe = !0;
      else O && (D = Math.min(Math.abs(se), D));
      if (!t.scrollingPage) {
        var _e = t.cy, Se = _e.zoom(), Me = _e.pan(), Xe = t.projectIntoViewport(F.clientX, F.clientY), We = [Xe[0] * Se + Me.x, Xe[1] * Se + Me.y];
        if (t.hoverData.draggingEles || t.hoverData.dragging || t.hoverData.cxtStarted || _()) {
          F.preventDefault();
          return;
        }
        if (_e.panningEnabled() && _e.userPanningEnabled() && _e.zoomingEnabled() && _e.userZoomingEnabled()) {
          F.preventDefault(), t.data.wheelZooming = !0, clearTimeout(t.data.wheelTimeout), t.data.wheelTimeout = setTimeout(function() {
            t.data.wheelZooming = !1, t.redrawHint("eles", !0), t.redraw();
          }, 150);
          var Ke;
          oe && Math.abs(se) > 5 && (se = wR(se) * 5), Ke = se / -250, O && (Ke /= D, Ke *= 3), Ke = Ke * t.wheelSensitivity;
          var Ze = F.deltaMode === 1;
          Ze && (Ke *= 33);
          var Pe = _e.zoom() * Math.pow(10, Ke);
          F.type === "gesturechange" && (Pe = t.gestureStartZoom * F.scale), _e.zoom({
            level: Pe,
            renderedPosition: {
              x: We[0],
              y: We[1]
            }
          }), _e.emit({
            type: F.type === "gesturechange" ? "pinchzoom" : "scrollzoom",
            originalEvent: F,
            position: {
              x: Xe[0],
              y: Xe[1]
            }
          });
        }
      }
    }
  };
  t.registerBinding(t.container, "wheel", B, !0), t.registerBinding(e, "scroll", function(F) {
    t.scrollingPage = !0, clearTimeout(t.scrollingPageTimeout), t.scrollingPageTimeout = setTimeout(function() {
      t.scrollingPage = !1;
    }, 250);
  }, !0), t.registerBinding(t.container, "gesturestart", function(F) {
    t.gestureStartZoom = t.cy.zoom(), t.hasTouchStarted || F.preventDefault();
  }, !0), t.registerBinding(t.container, "gesturechange", function(he) {
    t.hasTouchStarted || B(he);
  }, !0), t.registerBinding(t.container, "mouseout", function(F) {
    var oe = t.projectIntoViewport(F.clientX, F.clientY);
    t.cy.emit({
      originalEvent: F,
      type: "mouseout",
      position: {
        x: oe[0],
        y: oe[1]
      }
    });
  }, !1), t.registerBinding(t.container, "mouseover", function(F) {
    var oe = t.projectIntoViewport(F.clientX, F.clientY);
    t.cy.emit({
      originalEvent: F,
      type: "mouseover",
      position: {
        x: oe[0],
        y: oe[1]
      }
    });
  }, !1);
  var G, W, V, U, Z, K, ce, J, ee, j, X, re, Q, ue = function(F, oe, se, ge) {
    return Math.sqrt((se - F) * (se - F) + (ge - oe) * (ge - oe));
  }, ne = function(F, oe, se, ge) {
    return (se - F) * (se - F) + (ge - oe) * (ge - oe);
  }, xe;
  t.registerBinding(t.container, "touchstart", xe = function(F) {
    if (t.hasTouchStarted = !0, !!R(F)) {
      x(), t.touchData.capture = !0, t.data.bgActivePosistion = void 0;
      var oe = t.cy, se = t.touchData.now, ge = t.touchData.earlier;
      if (F.touches[0]) {
        var de = t.projectIntoViewport(F.touches[0].clientX, F.touches[0].clientY);
        se[0] = de[0], se[1] = de[1];
      }
      if (F.touches[1]) {
        var de = t.projectIntoViewport(F.touches[1].clientX, F.touches[1].clientY);
        se[2] = de[0], se[3] = de[1];
      }
      if (F.touches[2]) {
        var de = t.projectIntoViewport(F.touches[2].clientX, F.touches[2].clientY);
        se[4] = de[0], se[5] = de[1];
      }
      var we = function(ct) {
        return {
          originalEvent: F,
          type: ct,
          position: {
            x: se[0],
            y: se[1]
          }
        };
      };
      if (F.touches[1]) {
        t.touchData.singleTouchMoved = !0, y(t.dragData.touchDragEles);
        var _e = t.findContainerClientCoords();
        ee = _e[0], j = _e[1], X = _e[2], re = _e[3], G = F.touches[0].clientX - ee, W = F.touches[0].clientY - j, V = F.touches[1].clientX - ee, U = F.touches[1].clientY - j, Q = 0 <= G && G <= X && 0 <= V && V <= X && 0 <= W && W <= re && 0 <= U && U <= re;
        var Se = oe.pan(), Me = oe.zoom();
        Z = ue(G, W, V, U), K = ne(G, W, V, U), ce = [(G + V) / 2, (W + U) / 2], J = [(ce[0] - Se.x) / Me, (ce[1] - Se.y) / Me];
        var Xe = 200, We = Xe * Xe;
        if (K < We && !F.touches[2]) {
          var Ke = t.findNearestElement(se[0], se[1], !0, !0), Ze = t.findNearestElement(se[2], se[3], !0, !0);
          Ke && Ke.isNode() ? (Ke.activate().emit(we("cxttapstart")), t.touchData.start = Ke) : Ze && Ze.isNode() ? (Ze.activate().emit(we("cxttapstart")), t.touchData.start = Ze) : oe.emit(we("cxttapstart")), t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxt = !0, t.touchData.cxtDragged = !1, t.data.bgActivePosistion = void 0, t.redraw();
          return;
        }
      }
      if (F.touches[2])
        oe.boxSelectionEnabled() && F.preventDefault();
      else if (!F.touches[1]) {
        if (F.touches[0]) {
          var Pe = t.findNearestElements(se[0], se[1], !0, !0), Ve = Pe[0];
          if (Ve != null && (Ve.activate(), t.touchData.start = Ve, t.touchData.starts = Pe, t.nodeIsGrabbable(Ve))) {
            var ht = t.dragData.touchDragEles = oe.collection(), st = null;
            t.redrawHint("eles", !0), t.redrawHint("drag", !0), Ve.selected() ? (st = oe.$(function(rt) {
              return rt.selected() && t.nodeIsGrabbable(rt);
            }), m(st, {
              addToList: ht
            })) : v(Ve, {
              addToList: ht
            }), f(Ve), Ve.emit(we("grabon")), st ? st.forEach(function(rt) {
              rt.emit(we("grab"));
            }) : Ve.emit(we("grab"));
          }
          i(Ve, ["touchstart", "tapstart", "vmousedown"], F, {
            x: se[0],
            y: se[1]
          }), Ve == null && (t.data.bgActivePosistion = {
            x: de[0],
            y: de[1]
          }, t.redrawHint("select", !0), t.redraw()), t.touchData.singleTouchMoved = !1, t.touchData.singleTouchStartTime = +/* @__PURE__ */ new Date(), clearTimeout(t.touchData.tapholdTimeout), t.touchData.tapholdTimeout = setTimeout(function() {
            t.touchData.singleTouchMoved === !1 && !t.pinching && !t.touchData.selecting && i(t.touchData.start, ["taphold"], F, {
              x: se[0],
              y: se[1]
            });
          }, t.tapholdDuration);
        }
      }
      if (F.touches.length >= 1) {
        for (var Ue = t.touchData.startPosition = [null, null, null, null, null, null], Et = 0; Et < se.length; Et++)
          Ue[Et] = ge[Et] = se[Et];
        var He = F.touches[0];
        t.touchData.startGPosition = [He.clientX, He.clientY];
      }
    }
  }, !1);
  var Y;
  t.registerBinding(e, "touchmove", Y = function(F) {
    var oe = t.touchData.capture;
    if (!(!oe && !R(F))) {
      var se = t.selection, ge = t.cy, de = t.touchData.now, we = t.touchData.earlier, _e = ge.zoom();
      if (F.touches[0]) {
        var Se = t.projectIntoViewport(F.touches[0].clientX, F.touches[0].clientY);
        de[0] = Se[0], de[1] = Se[1];
      }
      if (F.touches[1]) {
        var Se = t.projectIntoViewport(F.touches[1].clientX, F.touches[1].clientY);
        de[2] = Se[0], de[3] = Se[1];
      }
      if (F.touches[2]) {
        var Se = t.projectIntoViewport(F.touches[2].clientX, F.touches[2].clientY);
        de[4] = Se[0], de[5] = Se[1];
      }
      var Me = function(Km) {
        return {
          originalEvent: F,
          type: Km,
          position: {
            x: de[0],
            y: de[1]
          }
        };
      }, Xe = t.touchData.startGPosition, We;
      if (oe && F.touches[0] && Xe) {
        for (var Ke = [], Ze = 0; Ze < de.length; Ze++)
          Ke[Ze] = de[Ze] - we[Ze];
        var Pe = F.touches[0].clientX - Xe[0], Ve = Pe * Pe, ht = F.touches[0].clientY - Xe[1], st = ht * ht, Ue = Ve + st;
        We = Ue >= t.touchTapThreshold2;
      }
      if (oe && t.touchData.cxt) {
        F.preventDefault();
        var Et = F.touches[0].clientX - ee, He = F.touches[0].clientY - j, rt = F.touches[1].clientX - ee, ct = F.touches[1].clientY - j, ut = ne(Et, He, rt, ct), nt = ut / K, bt = 150, er = bt * bt, Dt = 1.5, ir = Dt * Dt;
        if (nt >= ir || ut >= er) {
          t.touchData.cxt = !1, t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
          var wr = Me("cxttapend");
          t.touchData.start ? (t.touchData.start.unactivate().emit(wr), t.touchData.start = null) : ge.emit(wr);
        }
      }
      if (oe && t.touchData.cxt) {
        var wr = Me("cxtdrag");
        t.data.bgActivePosistion = void 0, t.redrawHint("select", !0), t.touchData.start ? t.touchData.start.emit(wr) : ge.emit(wr), t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxtDragged = !0;
        var ar = t.findNearestElement(de[0], de[1], !0, !0);
        (!t.touchData.cxtOver || ar !== t.touchData.cxtOver) && (t.touchData.cxtOver && t.touchData.cxtOver.emit(Me("cxtdragout")), t.touchData.cxtOver = ar, ar && ar.emit(Me("cxtdragover")));
      } else if (oe && F.touches[2] && ge.boxSelectionEnabled())
        F.preventDefault(), t.data.bgActivePosistion = void 0, this.lastThreeTouch = +/* @__PURE__ */ new Date(), t.touchData.selecting || ge.emit(Me("boxstart")), t.touchData.selecting = !0, t.touchData.didSelect = !0, se[4] = 1, !se || se.length === 0 || se[0] === void 0 ? (se[0] = (de[0] + de[2] + de[4]) / 3, se[1] = (de[1] + de[3] + de[5]) / 3, se[2] = (de[0] + de[2] + de[4]) / 3 + 1, se[3] = (de[1] + de[3] + de[5]) / 3 + 1) : (se[2] = (de[0] + de[2] + de[4]) / 3, se[3] = (de[1] + de[3] + de[5]) / 3), t.redrawHint("select", !0), t.redraw();
      else if (oe && F.touches[1] && !t.touchData.didSelect && ge.zoomingEnabled() && ge.panningEnabled() && ge.userZoomingEnabled() && ge.userPanningEnabled()) {
        F.preventDefault(), t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
        var Wt = t.dragData.touchDragEles;
        if (Wt) {
          t.redrawHint("drag", !0);
          for (var ur = 0; ur < Wt.length; ur++) {
            var cn = Wt[ur]._private;
            cn.grabbed = !1, cn.rscratch.inDragLayer = !1;
          }
        }
        var ft = t.touchData.start, Et = F.touches[0].clientX - ee, He = F.touches[0].clientY - j, rt = F.touches[1].clientX - ee, ct = F.touches[1].clientY - j, ke = ue(Et, He, rt, ct), Je = ke / Z;
        if (Q) {
          var xt = Et - G, lr = He - W, Vr = rt - V, hr = ct - U, Kr = (xt + Vr) / 2, bi = (lr + hr) / 2, En = ge.zoom(), Sn = En * Je, dt = ge.pan(), wt = J[0] * En + dt.x, lt = J[1] * En + dt.y, je = {
            x: -Sn / En * (wt - dt.x - Kr) + wt,
            y: -Sn / En * (lt - dt.y - bi) + lt
          };
          if (ft && ft.active()) {
            var Wt = t.dragData.touchDragEles;
            y(Wt), t.redrawHint("drag", !0), t.redrawHint("eles", !0), ft.unactivate().emit(Me("freeon")), Wt.emit(Me("free")), t.dragData.didDrag && (ft.emit(Me("dragfreeon")), Wt.emit(Me("dragfree")));
          }
          ge.viewport({
            zoom: Sn,
            pan: je,
            cancelOnFailedZoom: !0
          }), ge.emit(Me("pinchzoom")), Z = ke, G = Et, W = He, V = rt, U = ct, t.pinching = !0;
        }
        if (F.touches[0]) {
          var Se = t.projectIntoViewport(F.touches[0].clientX, F.touches[0].clientY);
          de[0] = Se[0], de[1] = Se[1];
        }
        if (F.touches[1]) {
          var Se = t.projectIntoViewport(F.touches[1].clientX, F.touches[1].clientY);
          de[2] = Se[0], de[3] = Se[1];
        }
        if (F.touches[2]) {
          var Se = t.projectIntoViewport(F.touches[2].clientX, F.touches[2].clientY);
          de[4] = Se[0], de[5] = Se[1];
        }
      } else if (F.touches[0] && !t.touchData.didSelect) {
        var Qt = t.touchData.start, pe = t.touchData.last, ar;
        if (!t.hoverData.draggingEles && !t.swipePanning && (ar = t.findNearestElement(de[0], de[1], !0, !0)), oe && Qt != null && F.preventDefault(), oe && Qt != null && t.nodeIsDraggable(Qt))
          if (We) {
            var Wt = t.dragData.touchDragEles, Fl = !t.dragData.didDrag;
            Fl && m(Wt, {
              inDragLayer: !0
            }), t.dragData.didDrag = !0;
            var ve = {
              x: 0,
              y: 0
            };
            if (mt(Ke[0]) && mt(Ke[1]) && (ve.x += Ke[0], ve.y += Ke[1], Fl)) {
              t.redrawHint("eles", !0);
              var Tr = t.touchData.dragDelta;
              Tr && mt(Tr[0]) && mt(Tr[1]) && (ve.x += Tr[0], ve.y += Tr[1]);
            }
            t.hoverData.draggingEles = !0, Wt.silentShift(ve).emit(Me("position")).emit(Me("drag")), t.redrawHint("drag", !0), t.touchData.startPosition[0] == we[0] && t.touchData.startPosition[1] == we[1] && t.redrawHint("eles", !0), t.redraw();
          } else {
            var Tr = t.touchData.dragDelta = t.touchData.dragDelta || [];
            Tr.length === 0 ? (Tr.push(Ke[0]), Tr.push(Ke[1])) : (Tr[0] += Ke[0], Tr[1] += Ke[1]);
          }
        if (i(Qt || ar, ["touchmove", "tapdrag", "vmousemove"], F, {
          x: de[0],
          y: de[1]
        }), (!Qt || !Qt.grabbed()) && ar != pe && (pe && pe.emit(Me("tapdragout")), ar && ar.emit(Me("tapdragover"))), t.touchData.last = ar, oe)
          for (var ur = 0; ur < de.length; ur++)
            de[ur] && t.touchData.startPosition[ur] && We && (t.touchData.singleTouchMoved = !0);
        if (oe && (Qt == null || Qt.pannable()) && ge.panningEnabled() && ge.userPanningEnabled()) {
          var jm = s(Qt, t.touchData.starts);
          jm && (F.preventDefault(), t.data.bgActivePosistion || (t.data.bgActivePosistion = Sf(t.touchData.startPosition)), t.swipePanning ? (ge.panBy({
            x: Ke[0] * _e,
            y: Ke[1] * _e
          }), ge.emit(Me("dragpan"))) : We && (t.swipePanning = !0, ge.panBy({
            x: Pe * _e,
            y: ht * _e
          }), ge.emit(Me("dragpan")), Qt && (Qt.unactivate(), t.redrawHint("select", !0), t.touchData.start = null)));
          var Se = t.projectIntoViewport(F.touches[0].clientX, F.touches[0].clientY);
          de[0] = Se[0], de[1] = Se[1];
        }
      }
      for (var Ze = 0; Ze < de.length; Ze++)
        we[Ze] = de[Ze];
      oe && F.touches.length > 0 && !t.hoverData.draggingEles && !t.swipePanning && t.data.bgActivePosistion != null && (t.data.bgActivePosistion = void 0, t.redrawHint("select", !0), t.redraw());
    }
  }, !1);
  var Ne;
  t.registerBinding(e, "touchcancel", Ne = function(F) {
    var oe = t.touchData.start;
    t.touchData.capture = !1, oe && oe.unactivate();
  });
  var fe, qe, ze, Ge;
  if (t.registerBinding(e, "touchend", fe = function(F) {
    var oe = t.touchData.start, se = t.touchData.capture;
    if (se)
      F.touches.length === 0 && (t.touchData.capture = !1), F.preventDefault();
    else
      return;
    var ge = t.selection;
    t.swipePanning = !1, t.hoverData.draggingEles = !1;
    var de = t.cy, we = de.zoom(), _e = t.touchData.now, Se = t.touchData.earlier;
    if (F.touches[0]) {
      var Me = t.projectIntoViewport(F.touches[0].clientX, F.touches[0].clientY);
      _e[0] = Me[0], _e[1] = Me[1];
    }
    if (F.touches[1]) {
      var Me = t.projectIntoViewport(F.touches[1].clientX, F.touches[1].clientY);
      _e[2] = Me[0], _e[3] = Me[1];
    }
    if (F.touches[2]) {
      var Me = t.projectIntoViewport(F.touches[2].clientX, F.touches[2].clientY);
      _e[4] = Me[0], _e[5] = Me[1];
    }
    var Xe = function(er) {
      return {
        originalEvent: F,
        type: er,
        position: {
          x: _e[0],
          y: _e[1]
        }
      };
    };
    oe && oe.unactivate();
    var We;
    if (t.touchData.cxt) {
      if (We = Xe("cxttapend"), oe ? oe.emit(We) : de.emit(We), !t.touchData.cxtDragged) {
        var Ke = Xe("cxttap");
        oe ? oe.emit(Ke) : de.emit(Ke);
      }
      t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxt = !1, t.touchData.start = null, t.redraw();
      return;
    }
    if (!F.touches[2] && de.boxSelectionEnabled() && t.touchData.selecting) {
      t.touchData.selecting = !1;
      var Ze = de.collection(t.getAllInBox(ge[0], ge[1], ge[2], ge[3]));
      ge[0] = void 0, ge[1] = void 0, ge[2] = void 0, ge[3] = void 0, ge[4] = 0, t.redrawHint("select", !0), de.emit(Xe("boxend"));
      var Pe = function(er) {
        return er.selectable() && !er.selected();
      };
      Ze.emit(Xe("box")).stdFilter(Pe).select().emit(Xe("boxselect")), Ze.nonempty() && t.redrawHint("eles", !0), t.redraw();
    }
    if (oe?.unactivate(), F.touches[2])
      t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
    else if (!F.touches[1]) {
      if (!F.touches[0]) {
        if (!F.touches[0]) {
          t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
          var Ve = t.dragData.touchDragEles;
          if (oe != null) {
            var ht = oe._private.grabbed;
            y(Ve), t.redrawHint("drag", !0), t.redrawHint("eles", !0), ht && (oe.emit(Xe("freeon")), Ve.emit(Xe("free")), t.dragData.didDrag && (oe.emit(Xe("dragfreeon")), Ve.emit(Xe("dragfree")))), i(oe, ["touchend", "tapend", "vmouseup", "tapdragout"], F, {
              x: _e[0],
              y: _e[1]
            }), oe.unactivate(), t.touchData.start = null;
          } else {
            var st = t.findNearestElement(_e[0], _e[1], !0, !0);
            i(st, ["touchend", "tapend", "vmouseup", "tapdragout"], F, {
              x: _e[0],
              y: _e[1]
            });
          }
          var Ue = t.touchData.startPosition[0] - _e[0], Et = Ue * Ue, He = t.touchData.startPosition[1] - _e[1], rt = He * He, ct = Et + rt, ut = ct * we * we;
          t.touchData.singleTouchMoved || (oe || de.$(":selected").unselect(["tapunselect"]), i(oe, ["tap", "vclick"], F, {
            x: _e[0],
            y: _e[1]
          }), qe = !1, F.timeStamp - Ge <= de.multiClickDebounceTime() ? (ze && clearTimeout(ze), qe = !0, Ge = null, i(oe, ["dbltap", "vdblclick"], F, {
            x: _e[0],
            y: _e[1]
          })) : (ze = setTimeout(function() {
            qe || i(oe, ["onetap", "voneclick"], F, {
              x: _e[0],
              y: _e[1]
            });
          }, de.multiClickDebounceTime()), Ge = F.timeStamp)), oe != null && !t.dragData.didDrag && oe._private.selectable && ut < t.touchTapThreshold2 && !t.pinching && (de.selectionType() === "single" ? (de.$(r).unmerge(oe).unselect(["tapunselect"]), oe.select(["tapselect"])) : oe.selected() ? oe.unselect(["tapunselect"]) : oe.select(["tapselect"]), t.redrawHint("eles", !0)), t.touchData.singleTouchMoved = !0;
        }
      }
    }
    for (var nt = 0; nt < _e.length; nt++)
      Se[nt] = _e[nt];
    t.dragData.didDrag = !1, F.touches.length === 0 && (t.touchData.dragDelta = [], t.touchData.startPosition = [null, null, null, null, null, null], t.touchData.startGPosition = null, t.touchData.didSelect = !1), F.touches.length < 2 && (F.touches.length === 1 && (t.touchData.startGPosition = [F.touches[0].clientX, F.touches[0].clientY]), t.pinching = !1, t.redrawHint("eles", !0), t.redraw());
  }, !1), typeof TouchEvent > "u") {
    var Ee = [], Oe = function(F) {
      return {
        clientX: F.clientX,
        clientY: F.clientY,
        force: 1,
        identifier: F.pointerId,
        pageX: F.pageX,
        pageY: F.pageY,
        radiusX: F.width / 2,
        radiusY: F.height / 2,
        screenX: F.screenX,
        screenY: F.screenY,
        target: F.target
      };
    }, Ce = function(F) {
      return {
        event: F,
        touch: Oe(F)
      };
    }, Ae = function(F) {
      Ee.push(Ce(F));
    }, $e = function(F) {
      for (var oe = 0; oe < Ee.length; oe++) {
        var se = Ee[oe];
        if (se.event.pointerId === F.pointerId) {
          Ee.splice(oe, 1);
          return;
        }
      }
    }, me = function(F) {
      var oe = Ee.filter(function(se) {
        return se.event.pointerId === F.pointerId;
      })[0];
      oe.event = F, oe.touch = Oe(F);
    }, Ie = function(F) {
      F.touches = Ee.map(function(oe) {
        return oe.touch;
      });
    }, te = function(F) {
      return F.pointerType === "mouse" || F.pointerType === 4;
    };
    t.registerBinding(t.container, "pointerdown", function(he) {
      te(he) || (he.preventDefault(), Ae(he), Ie(he), xe(he));
    }), t.registerBinding(t.container, "pointerup", function(he) {
      te(he) || ($e(he), Ie(he), fe(he));
    }), t.registerBinding(t.container, "pointercancel", function(he) {
      te(he) || ($e(he), Ie(he), Ne(he));
    }), t.registerBinding(t.container, "pointermove", function(he) {
      te(he) || (he.preventDefault(), me(he), Ie(he), Y(he));
    });
  }
};
var Rl = {};
Rl.generatePolygon = function(t, e) {
  return this.nodeShapes[t] = {
    renderer: this,
    name: t,
    points: e,
    draw: function(n, i, a, s, o, l) {
      this.renderer.nodeShapeImpl("polygon", n, i, a, s, o, this.points);
    },
    intersectLine: function(n, i, a, s, o, l, u, h) {
      return C1(o, l, this.points, n, i, a / 2, s / 2, u);
    },
    checkPoint: function(n, i, a, s, o, l, u, h) {
      return bl(n, i, this.points, l, u, s, o, [0, -1], a);
    },
    hasMiterBounds: t !== "rectangle",
    miterBounds: function(n, i, a, s, o, l) {
      return kRe(this.points, n, i, a, s, o);
    }
  };
};
Rl.generateEllipse = function() {
  return this.nodeShapes.ellipse = {
    renderer: this,
    name: "ellipse",
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      return NRe(a, s, e, r, n / 2 + o, i / 2 + o);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      return Du(e, r, i, a, s, o, n);
    }
  };
};
Rl.generateRoundPolygon = function(t, e) {
  return this.nodeShapes[t] = {
    renderer: this,
    name: t,
    points: e,
    getOrCreateCorners: function(n, i, a, s, o, l, u) {
      if (l[u] !== void 0 && l[u + "-cx"] === n && l[u + "-cy"] === i)
        return l[u];
      l[u] = new Array(e.length / 2), l[u + "-cx"] = n, l[u + "-cy"] = i;
      var h = a / 2, f = s / 2;
      o = o === "auto" ? eie(a, s) : o;
      for (var d = new Array(e.length / 2), p = 0; p < e.length / 2; p++)
        d[p] = {
          x: n + h * e[p * 2],
          y: i + f * e[p * 2 + 1]
        };
      var g, m, v, y, b = d.length;
      for (m = d[b - 1], g = 0; g < b; g++)
        v = d[g % b], y = d[(g + 1) % b], l[u][g] = DR(m, v, y, o), m = v, v = y;
      return l[u];
    },
    draw: function(n, i, a, s, o, l, u) {
      this.renderer.nodeShapeImpl("round-polygon", n, i, a, s, o, this.points, this.getOrCreateCorners(i, a, s, o, l, u, "drawCorners"));
    },
    intersectLine: function(n, i, a, s, o, l, u, h, f) {
      return ORe(o, l, this.points, n, i, a, s, u, this.getOrCreateCorners(n, i, a, s, h, f, "corners"));
    },
    checkPoint: function(n, i, a, s, o, l, u, h, f) {
      return MRe(n, i, this.points, l, u, s, o, this.getOrCreateCorners(l, u, s, o, h, f, "corners"));
    }
  };
};
Rl.generateRoundRectangle = function() {
  return this.nodeShapes["round-rectangle"] = this.nodeShapes.roundrectangle = {
    renderer: this,
    name: "round-rectangle",
    points: Bi(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a, this.points, s);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      return Qne(a, s, e, r, n, i, o, l);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      var u = i / 2, h = a / 2;
      l = l === "auto" ? xc(i, a) : l, l = Math.min(u, h, l);
      var f = l * 2;
      return !!(bl(e, r, this.points, s, o, i, a - f, [0, -1], n) || bl(e, r, this.points, s, o, i - f, a, [0, -1], n) || Du(e, r, f, f, s - u + l, o - h + l, n) || Du(e, r, f, f, s + u - l, o - h + l, n) || Du(e, r, f, f, s + u - l, o + h - l, n) || Du(e, r, f, f, s - u + l, o + h - l, n));
    }
  };
};
Rl.generateCutRectangle = function() {
  return this.nodeShapes["cut-rectangle"] = this.nodeShapes.cutrectangle = {
    renderer: this,
    name: "cut-rectangle",
    cornerLength: ER(),
    points: Bi(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a, null, s);
    },
    generateCutTrianglePts: function(e, r, n, i, a) {
      var s = a === "auto" ? this.cornerLength : a, o = r / 2, l = e / 2, u = n - l, h = n + l, f = i - o, d = i + o;
      return {
        topLeft: [u, f + s, u + s, f, u + s, f + s],
        topRight: [h - s, f, h, f + s, h - s, f + s],
        bottomRight: [h, d - s, h - s, d, h - s, d - s],
        bottomLeft: [u + s, d, u, d - s, u + s, d - s]
      };
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      var u = this.generateCutTrianglePts(n + 2 * o, i + 2 * o, e, r, l), h = [].concat.apply([], [u.topLeft.splice(0, 4), u.topRight.splice(0, 4), u.bottomRight.splice(0, 4), u.bottomLeft.splice(0, 4)]);
      return C1(a, s, h, e, r);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      var u = l === "auto" ? this.cornerLength : l;
      if (bl(e, r, this.points, s, o, i, a - 2 * u, [0, -1], n) || bl(e, r, this.points, s, o, i - 2 * u, a, [0, -1], n))
        return !0;
      var h = this.generateCutTrianglePts(i, a, s, o);
      return sa(e, r, h.topLeft) || sa(e, r, h.topRight) || sa(e, r, h.bottomRight) || sa(e, r, h.bottomLeft);
    }
  };
};
Rl.generateBarrel = function() {
  return this.nodeShapes.barrel = {
    renderer: this,
    name: "barrel",
    points: Bi(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      var u = 0.15, h = 0.5, f = 0.85, d = this.generateBarrelBezierPts(n + 2 * o, i + 2 * o, e, r), p = function(v) {
        var y = Bf({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, u), b = Bf({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, h), x = Bf({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, f);
        return [v[0], v[1], y.x, y.y, b.x, b.y, x.x, x.y, v[4], v[5]];
      }, g = [].concat(p(d.topLeft), p(d.topRight), p(d.bottomRight), p(d.bottomLeft));
      return C1(a, s, g, e, r);
    },
    generateBarrelBezierPts: function(e, r, n, i) {
      var a = r / 2, s = e / 2, o = n - s, l = n + s, u = i - a, h = i + a, f = dA(e, r), d = f.heightOffset, p = f.widthOffset, g = f.ctrlPtOffsetPct * e, m = {
        topLeft: [o, u + d, o + g, u, o + p, u],
        topRight: [l - p, u, l - g, u, l, u + d],
        bottomRight: [l, h - d, l - g, h, l - p, h],
        bottomLeft: [o + p, h, o + g, h, o, h - d]
      };
      return m.topLeft.isTop = !0, m.topRight.isTop = !0, m.bottomLeft.isBottom = !0, m.bottomRight.isBottom = !0, m;
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      var u = dA(i, a), h = u.heightOffset, f = u.widthOffset;
      if (bl(e, r, this.points, s, o, i, a - 2 * h, [0, -1], n) || bl(e, r, this.points, s, o, i - 2 * f, a, [0, -1], n))
        return !0;
      for (var d = this.generateBarrelBezierPts(i, a, s, o), p = function(k, _, R) {
        var L = R[4], M = R[2], P = R[0], C = R[5], I = R[1], N = Math.min(L, P), O = Math.max(L, P), D = Math.min(C, I), $ = Math.max(C, I);
        if (N <= k && k <= O && D <= _ && _ <= $) {
          var z = PRe(L, M, P), B = ARe(z[0], z[1], z[2], k), G = B.filter(function(W) {
            return 0 <= W && W <= 1;
          });
          if (G.length > 0)
            return G[0];
        }
        return null;
      }, g = Object.keys(d), m = 0; m < g.length; m++) {
        var v = g[m], y = d[v], b = p(e, r, y);
        if (b != null) {
          var x = y[5], T = y[3], E = y[1], A = Zn(x, T, E, b);
          if (y.isTop && A <= r || y.isBottom && r <= A)
            return !0;
        }
      }
      return !1;
    }
  };
};
Rl.generateBottomRoundrectangle = function() {
  return this.nodeShapes["bottom-round-rectangle"] = this.nodeShapes.bottomroundrectangle = {
    renderer: this,
    name: "bottom-round-rectangle",
    points: Bi(4, 0),
    draw: function(e, r, n, i, a, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, i, a, this.points, s);
    },
    intersectLine: function(e, r, n, i, a, s, o, l) {
      var u = e - (n / 2 + o), h = r - (i / 2 + o), f = h, d = e + (n / 2 + o), p = rc(a, s, e, r, u, h, d, f, !1);
      return p.length > 0 ? p : Qne(a, s, e, r, n, i, o, l);
    },
    checkPoint: function(e, r, n, i, a, s, o, l) {
      l = l === "auto" ? xc(i, a) : l;
      var u = 2 * l;
      if (bl(e, r, this.points, s, o, i, a - u, [0, -1], n) || bl(e, r, this.points, s, o, i - u, a, [0, -1], n))
        return !0;
      var h = i / 2 + 2 * n, f = a / 2 + 2 * n, d = [s - h, o - f, s - h, o, s + h, o, s + h, o - f];
      return !!(sa(e, r, d) || Du(e, r, u, u, s + i / 2 - l, o + a / 2 - l, n) || Du(e, r, u, u, s - i / 2 + l, o + a / 2 - l, n));
    }
  };
};
Rl.registerNodeShapes = function() {
  var t = this.nodeShapes = {}, e = this;
  this.generateEllipse(), this.generatePolygon("triangle", Bi(3, 0)), this.generateRoundPolygon("round-triangle", Bi(3, 0)), this.generatePolygon("rectangle", Bi(4, 0)), t.square = t.rectangle, this.generateRoundRectangle(), this.generateCutRectangle(), this.generateBarrel(), this.generateBottomRoundrectangle();
  {
    var r = [0, 1, 1, 0, 0, -1, -1, 0];
    this.generatePolygon("diamond", r), this.generateRoundPolygon("round-diamond", r);
  }
  this.generatePolygon("pentagon", Bi(5, 0)), this.generateRoundPolygon("round-pentagon", Bi(5, 0)), this.generatePolygon("hexagon", Bi(6, 0)), this.generateRoundPolygon("round-hexagon", Bi(6, 0)), this.generatePolygon("heptagon", Bi(7, 0)), this.generateRoundPolygon("round-heptagon", Bi(7, 0)), this.generatePolygon("octagon", Bi(8, 0)), this.generateRoundPolygon("round-octagon", Bi(8, 0));
  var n = new Array(20);
  {
    var i = fA(5, 0), a = fA(5, Math.PI / 5), s = 0.5 * (3 - Math.sqrt(5));
    s *= 1.57;
    for (var o = 0; o < a.length / 2; o++)
      a[o * 2] *= s, a[o * 2 + 1] *= s;
    for (var o = 0; o < 20 / 4; o++)
      n[o * 4] = i[o * 2], n[o * 4 + 1] = i[o * 2 + 1], n[o * 4 + 2] = a[o * 2], n[o * 4 + 3] = a[o * 2 + 1];
  }
  n = Jne(n), this.generatePolygon("star", n), this.generatePolygon("vee", [-1, -1, 0, -0.333, 1, -1, 0, 1]), this.generatePolygon("rhomboid", [-1, -1, 0.333, -1, 1, 1, -0.333, 1]), this.generatePolygon("right-rhomboid", [-0.333, -1, 1, -1, 0.333, 1, -1, 1]), this.nodeShapes.concavehexagon = this.generatePolygon("concave-hexagon", [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
  {
    var l = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
    this.generatePolygon("tag", l), this.generateRoundPolygon("round-tag", l);
  }
  t.makePolygon = function(u) {
    var h = u.join("$"), f = "polygon-" + h, d;
    return (d = this[f]) ? d : e.generatePolygon(f, u);
  };
};
var Am = {};
Am.timeToRender = function() {
  return this.redrawTotalTime / this.redrawCount;
};
Am.redraw = function(t) {
  t = t || Xne();
  var e = this;
  e.averageRedrawTime === void 0 && (e.averageRedrawTime = 0), e.lastRedrawTime === void 0 && (e.lastRedrawTime = 0), e.lastDrawTime === void 0 && (e.lastDrawTime = 0), e.requestedFrame = !0, e.renderOptions = t;
};
Am.beforeRender = function(t, e) {
  if (!this.destroyed) {
    e == null && Jr("Priority is not optional for beforeRender");
    var r = this.beforeRenderCallbacks;
    r.push({
      fn: t,
      priority: e
    }), r.sort(function(n, i) {
      return i.priority - n.priority;
    });
  }
};
var fU = function(e, r, n) {
  for (var i = e.beforeRenderCallbacks, a = 0; a < i.length; a++)
    i[a].fn(r, n);
};
Am.startRenderLoop = function() {
  var t = this, e = t.cy;
  if (!t.renderLoopStarted) {
    t.renderLoopStarted = !0;
    var r = function(i) {
      if (!t.destroyed) {
        if (!e.batching()) if (t.requestedFrame && !t.skipFrame) {
          fU(t, !0, i);
          var a = yl();
          t.render(t.renderOptions);
          var s = t.lastDrawTime = yl();
          t.averageRedrawTime === void 0 && (t.averageRedrawTime = s - a), t.redrawCount === void 0 && (t.redrawCount = 0), t.redrawCount++, t.redrawTotalTime === void 0 && (t.redrawTotalTime = 0);
          var o = s - a;
          t.redrawTotalTime += o, t.lastRedrawTime = o, t.averageRedrawTime = t.averageRedrawTime / 2 + o / 2, t.requestedFrame = !1;
        } else
          fU(t, !1, i);
        t.skipFrame = !1, Ab(r);
      }
    };
    Ab(r);
  }
};
var QNe = function(e) {
  this.init(e);
}, eae = QNe, W0 = eae.prototype;
W0.clientFunctions = ["redrawHint", "render", "renderTo", "matchCanvasSize", "nodeShapeImpl", "arrowShapeImpl"];
W0.init = function(t) {
  var e = this;
  e.options = t, e.cy = t.cy;
  var r = e.container = t.cy.container(), n = e.cy.window();
  if (n) {
    var i = n.document, a = i.head, s = "__________cytoscape_stylesheet", o = "__________cytoscape_container", l = i.getElementById(s) != null;
    if (r.className.indexOf(o) < 0 && (r.className = (r.className || "") + " " + o), !l) {
      var u = i.createElement("style");
      u.id = s, u.textContent = "." + o + " { position: relative; }", a.insertBefore(u, a.children[0]);
    }
    var h = n.getComputedStyle(r), f = h.getPropertyValue("position");
    f === "static" && Rr("A Cytoscape container has style position:static and so can not use UI extensions properly");
  }
  e.selection = [void 0, void 0, void 0, void 0, 0], e.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95], e.hoverData = {
    down: null,
    last: null,
    downTime: null,
    triggerMode: null,
    dragging: !1,
    initialPan: [null, null],
    capture: !1
  }, e.dragData = {
    possibleDragElements: []
  }, e.touchData = {
    start: null,
    capture: !1,
    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: !0,
    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  }, e.redraws = 0, e.showFps = t.showFps, e.debug = t.debug, e.webgl = t.webgl, e.hideEdgesOnViewport = t.hideEdgesOnViewport, e.textureOnViewport = t.textureOnViewport, e.wheelSensitivity = t.wheelSensitivity, e.motionBlurEnabled = t.motionBlur, e.forcedPixelRatio = mt(t.pixelRatio) ? t.pixelRatio : null, e.motionBlur = t.motionBlur, e.motionBlurOpacity = t.motionBlurOpacity, e.motionBlurTransparency = 1 - e.motionBlurOpacity, e.motionBlurPxRatio = 1, e.mbPxRBlurry = 1, e.minMbLowQualFrames = 4, e.fullQualityMb = !1, e.clearedForMotionBlur = [], e.desktopTapThreshold = t.desktopTapThreshold, e.desktopTapThreshold2 = t.desktopTapThreshold * t.desktopTapThreshold, e.touchTapThreshold = t.touchTapThreshold, e.touchTapThreshold2 = t.touchTapThreshold * t.touchTapThreshold, e.tapholdDuration = 500, e.bindings = [], e.beforeRenderCallbacks = [], e.beforeRenderPriorities = {
    // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 150,
    lyrTxrSkip: 100
  }, e.registerNodeShapes(), e.registerArrowShapes(), e.registerCalculationListeners();
};
W0.notify = function(t, e) {
  var r = this, n = r.cy;
  if (!this.destroyed) {
    if (t === "init") {
      r.load();
      return;
    }
    if (t === "destroy") {
      r.destroy();
      return;
    }
    (t === "add" || t === "remove" || t === "move" && n.hasCompoundNodes() || t === "load" || t === "zorder" || t === "mount") && r.invalidateCachedZSortedEles(), t === "viewport" && r.redrawHint("select", !0), t === "gc" && r.redrawHint("gc", !0), (t === "load" || t === "resize" || t === "mount") && (r.invalidateContainerClientCoordsCache(), r.matchCanvasSize(r.container)), r.redrawHint("eles", !0), r.redrawHint("drag", !0), this.startRenderLoop(), this.redraw();
  }
};
W0.destroy = function() {
  var t = this;
  t.destroyed = !0, t.cy.stopAnimationLoop();
  for (var e = 0; e < t.bindings.length; e++) {
    var r = t.bindings[e], n = r, i = n.target;
    (i.off || i.removeEventListener).apply(i, n.args);
  }
  if (t.bindings = [], t.beforeRenderCallbacks = [], t.onUpdateEleCalcsFns = [], t.removeObserver && t.removeObserver.disconnect(), t.styleObserver && t.styleObserver.disconnect(), t.resizeObserver && t.resizeObserver.disconnect(), t.labelCalcDiv)
    try {
      document.body.removeChild(t.labelCalcDiv);
    } catch {
    }
};
W0.isHeadless = function() {
  return !1;
};
[NR, Qie, Jie, H0, Rl, Am].forEach(function(t) {
  Ut(W0, t);
});
var ZC = 1e3 / 60, tae = {
  setupDequeueing: function(e) {
    return function() {
      var n = this, i = this.renderer;
      if (!n.dequeueingSetup) {
        n.dequeueingSetup = !0;
        var a = Em(function() {
          i.redrawHint("eles", !0), i.redrawHint("drag", !0), i.redraw();
        }, e.deqRedrawThreshold), s = function(u, h) {
          var f = yl(), d = i.averageRedrawTime, p = i.lastRedrawTime, g = [], m = i.cy.extent(), v = i.getPixelRatio();
          for (u || i.flushRenderedStyleQueue(); ; ) {
            var y = yl(), b = y - f, x = y - h;
            if (p < ZC) {
              var T = ZC - (u ? d : 0);
              if (x >= e.deqFastCost * T)
                break;
            } else if (u) {
              if (b >= e.deqCost * p || b >= e.deqAvgCost * d)
                break;
            } else if (x >= e.deqNoDrawCost * ZC)
              break;
            var E = e.deq(n, v, m);
            if (E.length > 0)
              for (var A = 0; A < E.length; A++)
                g.push(E[A]);
            else
              break;
          }
          g.length > 0 && (e.onDeqd(n, g), !u && e.shouldRedraw(n, g, v, m) && a());
        }, o = e.priority || yR;
        i.beforeRender(s, o(n));
      }
    };
  }
}, JNe = /* @__PURE__ */ (function() {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Lb;
    Gc(this, t), this.idsByKey = new el(), this.keyForId = new el(), this.cachesByLvl = new el(), this.lvls = [], this.getKey = e, this.doesEleInvalidateKey = r;
  }
  return Uc(t, [{
    key: "getIdsFor",
    value: function(r) {
      r == null && Jr("Can not get id list for null key");
      var n = this.idsByKey, i = this.idsByKey.get(r);
      return i || (i = new q0(), n.set(r, i)), i;
    }
  }, {
    key: "addIdForKey",
    value: function(r, n) {
      r != null && this.getIdsFor(r).add(n);
    }
  }, {
    key: "deleteIdForKey",
    value: function(r, n) {
      r != null && this.getIdsFor(r).delete(n);
    }
  }, {
    key: "getNumberOfIdsForKey",
    value: function(r) {
      return r == null ? 0 : this.getIdsFor(r).size;
    }
  }, {
    key: "updateKeyMappingFor",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n), a = this.getKey(r);
      this.deleteIdForKey(i, n), this.addIdForKey(a, n), this.keyForId.set(n, a);
    }
  }, {
    key: "deleteKeyMappingFor",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n);
      this.deleteIdForKey(i, n), this.keyForId.delete(n);
    }
  }, {
    key: "keyHasChangedFor",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n), a = this.getKey(r);
      return i !== a;
    }
  }, {
    key: "isInvalid",
    value: function(r) {
      return this.keyHasChangedFor(r) || this.doesEleInvalidateKey(r);
    }
  }, {
    key: "getCachesAt",
    value: function(r) {
      var n = this.cachesByLvl, i = this.lvls, a = n.get(r);
      return a || (a = new el(), n.set(r, a), i.push(r)), a;
    }
  }, {
    key: "getCache",
    value: function(r, n) {
      return this.getCachesAt(n).get(r);
    }
  }, {
    key: "get",
    value: function(r, n) {
      var i = this.getKey(r), a = this.getCache(i, n);
      return a != null && this.updateKeyMappingFor(r), a;
    }
  }, {
    key: "getForCachedKey",
    value: function(r, n) {
      var i = this.keyForId.get(r.id()), a = this.getCache(i, n);
      return a;
    }
  }, {
    key: "hasCache",
    value: function(r, n) {
      return this.getCachesAt(n).has(r);
    }
  }, {
    key: "has",
    value: function(r, n) {
      var i = this.getKey(r);
      return this.hasCache(i, n);
    }
  }, {
    key: "setCache",
    value: function(r, n, i) {
      i.key = r, this.getCachesAt(n).set(r, i);
    }
  }, {
    key: "set",
    value: function(r, n, i) {
      var a = this.getKey(r);
      this.setCache(a, n, i), this.updateKeyMappingFor(r);
    }
  }, {
    key: "deleteCache",
    value: function(r, n) {
      this.getCachesAt(n).delete(r);
    }
  }, {
    key: "delete",
    value: function(r, n) {
      var i = this.getKey(r);
      this.deleteCache(i, n);
    }
  }, {
    key: "invalidateKey",
    value: function(r) {
      var n = this;
      this.lvls.forEach(function(i) {
        return n.deleteCache(r, i);
      });
    }
    // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)
  }, {
    key: "invalidate",
    value: function(r) {
      var n = r.id(), i = this.keyForId.get(n);
      this.deleteKeyMappingFor(r);
      var a = this.doesEleInvalidateKey(r);
      return a && this.invalidateKey(i), a || this.getNumberOfIdsForKey(i) === 0;
    }
  }]);
})(), dU = 25, $v = 50, Vy = -4, CA = 3, rae = 7.99, eDe = 8, tDe = 1024, rDe = 1024, nDe = 1024, iDe = 0.2, aDe = 0.8, sDe = 10, oDe = 0.15, lDe = 0.1, cDe = 0.9, uDe = 0.9, hDe = 100, fDe = 1, Cf = {
  dequeue: "dequeue",
  downscale: "downscale",
  highQuality: "highQuality"
}, dDe = vi({
  getKey: null,
  doesEleInvalidateKey: Lb,
  drawElement: null,
  getBoundingBox: null,
  getRotationPoint: null,
  getRotationOffset: null,
  isVisible: Hne,
  allowEdgeTxrCaching: !0,
  allowParentTxrCaching: !0
}), Vp = function(e, r) {
  var n = this;
  n.renderer = e, n.onDequeues = [];
  var i = dDe(r);
  Ut(n, i), n.lookup = new JNe(i.getKey, i.doesEleInvalidateKey), n.setupDequeueing();
}, jn = Vp.prototype;
jn.reasons = Cf;
jn.getTextureQueue = function(t) {
  var e = this;
  return e.eleImgCaches = e.eleImgCaches || {}, e.eleImgCaches[t] = e.eleImgCaches[t] || [];
};
jn.getRetiredTextureQueue = function(t) {
  var e = this, r = e.eleImgCaches.retired = e.eleImgCaches.retired || {}, n = r[t] = r[t] || [];
  return n;
};
jn.getElementQueue = function() {
  var t = this, e = t.eleCacheQueue = t.eleCacheQueue || new Sm(function(r, n) {
    return n.reqs - r.reqs;
  });
  return e;
};
jn.getElementKeyToQueue = function() {
  var t = this, e = t.eleKeyToCacheQueue = t.eleKeyToCacheQueue || {};
  return e;
};
jn.getElement = function(t, e, r, n, i) {
  var a = this, s = this.renderer, o = s.cy.zoom(), l = this.lookup;
  if (!e || e.w === 0 || e.h === 0 || isNaN(e.w) || isNaN(e.h) || !t.visible() || t.removed() || !a.allowEdgeTxrCaching && t.isEdge() || !a.allowParentTxrCaching && t.isParent())
    return null;
  if (n == null && (n = Math.ceil(xR(o * r))), n < Vy)
    n = Vy;
  else if (o >= rae || n > CA)
    return null;
  var u = Math.pow(2, n), h = e.h * u, f = e.w * u, d = s.eleTextBiggerThanMin(t, u);
  if (!this.isVisible(t, d))
    return null;
  var p = l.get(t, n);
  if (p && p.invalidated && (p.invalidated = !1, p.texture.invalidatedWidth -= p.width), p)
    return p;
  var g;
  if (h <= dU ? g = dU : h <= $v ? g = $v : g = Math.ceil(h / $v) * $v, h > nDe || f > rDe)
    return null;
  var m = a.getTextureQueue(g), v = m[m.length - 2], y = function() {
    return a.recycleTexture(g, f) || a.addTexture(g, f);
  };
  v || (v = m[m.length - 1]), v || (v = y()), v.width - v.usedWidth < f && (v = y());
  for (var b = function(N) {
    return N && N.scaledLabelShown === d;
  }, x = i && i === Cf.dequeue, T = i && i === Cf.highQuality, E = i && i === Cf.downscale, A, S = n + 1; S <= CA; S++) {
    var k = l.get(t, S);
    if (k) {
      A = k;
      break;
    }
  }
  var _ = A && A.level === n + 1 ? A : null, R = function() {
    v.context.drawImage(_.texture.canvas, _.x, 0, _.width, _.height, v.usedWidth, 0, f, h);
  };
  if (v.context.setTransform(1, 0, 0, 1, 0, 0), v.context.clearRect(v.usedWidth, 0, f, g), b(_))
    R();
  else if (b(A))
    if (T) {
      for (var L = A.level; L > n; L--)
        _ = a.getElement(t, e, r, L, Cf.downscale);
      R();
    } else
      return a.queueElement(t, A.level - 1), A;
  else {
    var M;
    if (!x && !T && !E)
      for (var P = n - 1; P >= Vy; P--) {
        var C = l.get(t, P);
        if (C) {
          M = C;
          break;
        }
      }
    if (b(M))
      return a.queueElement(t, n), M;
    v.context.translate(v.usedWidth, 0), v.context.scale(u, u), this.drawElement(v.context, t, e, d, !1), v.context.scale(1 / u, 1 / u), v.context.translate(-v.usedWidth, 0);
  }
  return p = {
    x: v.usedWidth,
    texture: v,
    level: n,
    scale: u,
    width: f,
    height: h,
    scaledLabelShown: d
  }, v.usedWidth += Math.ceil(f + eDe), v.eleCaches.push(p), l.set(t, n, p), a.checkTextureFullness(v), p;
};
jn.invalidateElements = function(t) {
  for (var e = 0; e < t.length; e++)
    this.invalidateElement(t[e]);
};
jn.invalidateElement = function(t) {
  var e = this, r = e.lookup, n = [], i = r.isInvalid(t);
  if (i) {
    for (var a = Vy; a <= CA; a++) {
      var s = r.getForCachedKey(t, a);
      s && n.push(s);
    }
    var o = r.invalidate(t);
    if (o)
      for (var l = 0; l < n.length; l++) {
        var u = n[l], h = u.texture;
        h.invalidatedWidth += u.width, u.invalidated = !0, e.checkTextureUtility(h);
      }
    e.removeFromQueue(t);
  }
};
jn.checkTextureUtility = function(t) {
  t.invalidatedWidth >= iDe * t.width && this.retireTexture(t);
};
jn.checkTextureFullness = function(t) {
  var e = this, r = e.getTextureQueue(t.height);
  t.usedWidth / t.width > aDe && t.fullnessChecks >= sDe ? bc(r, t) : t.fullnessChecks++;
};
jn.retireTexture = function(t) {
  var e = this, r = t.height, n = e.getTextureQueue(r), i = this.lookup;
  bc(n, t), t.retired = !0;
  for (var a = t.eleCaches, s = 0; s < a.length; s++) {
    var o = a[s];
    i.deleteCache(o.key, o.level);
  }
  bR(a);
  var l = e.getRetiredTextureQueue(r);
  l.push(t);
};
jn.addTexture = function(t, e) {
  var r = this, n = r.getTextureQueue(t), i = {};
  return n.push(i), i.eleCaches = [], i.height = t, i.width = Math.max(tDe, e), i.usedWidth = 0, i.invalidatedWidth = 0, i.fullnessChecks = 0, i.canvas = r.renderer.makeOffscreenCanvas(i.width, i.height), i.context = i.canvas.getContext("2d"), i;
};
jn.recycleTexture = function(t, e) {
  for (var r = this, n = r.getTextureQueue(t), i = r.getRetiredTextureQueue(t), a = 0; a < i.length; a++) {
    var s = i[a];
    if (s.width >= e)
      return s.retired = !1, s.usedWidth = 0, s.invalidatedWidth = 0, s.fullnessChecks = 0, bR(s.eleCaches), s.context.setTransform(1, 0, 0, 1, 0, 0), s.context.clearRect(0, 0, s.width, s.height), bc(i, s), n.push(s), s;
  }
};
jn.queueElement = function(t, e) {
  var r = this, n = r.getElementQueue(), i = r.getElementKeyToQueue(), a = this.getKey(t), s = i[a];
  if (s)
    s.level = Math.max(s.level, e), s.eles.merge(t), s.reqs++, n.updateItem(s);
  else {
    var o = {
      eles: t.spawn().merge(t),
      level: e,
      reqs: 1,
      key: a
    };
    n.push(o), i[a] = o;
  }
};
jn.dequeue = function(t) {
  for (var e = this, r = e.getElementQueue(), n = e.getElementKeyToQueue(), i = [], a = e.lookup, s = 0; s < fDe && r.size() > 0; s++) {
    var o = r.pop(), l = o.key, u = o.eles[0], h = a.hasCache(u, o.level);
    if (n[l] = null, h)
      continue;
    i.push(o);
    var f = e.getBoundingBox(u);
    e.getElement(u, f, t, o.level, Cf.dequeue);
  }
  return i;
};
jn.removeFromQueue = function(t) {
  var e = this, r = e.getElementQueue(), n = e.getElementKeyToQueue(), i = this.getKey(t), a = n[i];
  a != null && (a.eles.length === 1 ? (a.reqs = vR, r.updateItem(a), r.pop(), n[i] = null) : a.eles.unmerge(t));
};
jn.onDequeue = function(t) {
  this.onDequeues.push(t);
};
jn.offDequeue = function(t) {
  bc(this.onDequeues, t);
};
jn.setupDequeueing = tae.setupDequeueing({
  deqRedrawThreshold: hDe,
  deqCost: oDe,
  deqAvgCost: lDe,
  deqNoDrawCost: cDe,
  deqFastCost: uDe,
  deq: function(e, r, n) {
    return e.dequeue(r, n);
  },
  onDeqd: function(e, r) {
    for (var n = 0; n < e.onDequeues.length; n++) {
      var i = e.onDequeues[n];
      i(r);
    }
  },
  shouldRedraw: function(e, r, n, i) {
    for (var a = 0; a < r.length; a++)
      for (var s = r[a].eles, o = 0; o < s.length; o++) {
        var l = s[o].boundingBox();
        if (TR(l, i))
          return !0;
      }
    return !1;
  },
  priority: function(e) {
    return e.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});
var pDe = 1, Ug = -4, $b = 2, gDe = 3.99, mDe = 50, vDe = 50, yDe = 0.15, bDe = 0.1, xDe = 0.9, wDe = 0.9, TDe = 1, pU = 250, EDe = 4e3 * 4e3, gU = 32767, SDe = !0, nae = function(e) {
  var r = this, n = r.renderer = e, i = n.cy;
  r.layersByLevel = {}, r.firstGet = !0, r.lastInvalidationTime = yl() - 2 * pU, r.skipping = !1, r.eleTxrDeqs = i.collection(), r.scheduleElementRefinement = Em(function() {
    r.refineElementTextures(r.eleTxrDeqs), r.eleTxrDeqs.unmerge(r.eleTxrDeqs);
  }, vDe), n.beforeRender(function(s, o) {
    o - r.lastInvalidationTime <= pU ? r.skipping = !0 : r.skipping = !1;
  }, n.beforeRenderPriorities.lyrTxrSkip);
  var a = function(o, l) {
    return l.reqs - o.reqs;
  };
  r.layersQueue = new Sm(a), r.setupDequeueing();
}, yi = nae.prototype, mU = 0, kDe = Math.pow(2, 53) - 1;
yi.makeLayer = function(t, e) {
  var r = Math.pow(2, e), n = Math.ceil(t.w * r), i = Math.ceil(t.h * r), a = this.renderer.makeOffscreenCanvas(n, i), s = {
    id: mU = ++mU % kDe,
    bb: t,
    level: e,
    width: n,
    height: i,
    canvas: a,
    context: a.getContext("2d"),
    eles: [],
    elesQueue: [],
    reqs: 0
  }, o = s.context, l = -s.bb.x1, u = -s.bb.y1;
  return o.scale(r, r), o.translate(l, u), s;
};
yi.getLayers = function(t, e, r) {
  var n = this, i = n.renderer, a = i.cy, s = a.zoom(), o = n.firstGet;
  if (n.firstGet = !1, r == null) {
    if (r = Math.ceil(xR(s * e)), r < Ug)
      r = Ug;
    else if (s >= gDe || r > $b)
      return null;
  }
  n.validateLayersElesOrdering(r, t);
  var l = n.layersByLevel, u = Math.pow(2, r), h = l[r] = l[r] || [], f, d = n.levelIsComplete(r, t), p, g = function() {
    var R = function(I) {
      if (n.validateLayersElesOrdering(I, t), n.levelIsComplete(I, t))
        return p = l[I], !0;
    }, L = function(I) {
      if (!p)
        for (var N = r + I; Ug <= N && N <= $b && !R(N); N += I)
          ;
    };
    L(1), L(-1);
    for (var M = h.length - 1; M >= 0; M--) {
      var P = h[M];
      P.invalid && bc(h, P);
    }
  };
  if (!d)
    g();
  else
    return h;
  var m = function() {
    if (!f) {
      f = ji();
      for (var R = 0; R < t.length; R++)
        TRe(f, t[R].boundingBox());
    }
    return f;
  }, v = function(R) {
    R = R || {};
    var L = R.after;
    m();
    var M = Math.ceil(f.w * u), P = Math.ceil(f.h * u);
    if (M > gU || P > gU)
      return null;
    var C = M * P;
    if (C > EDe)
      return null;
    var I = n.makeLayer(f, r);
    if (L != null) {
      var N = h.indexOf(L) + 1;
      h.splice(N, 0, I);
    } else (R.insert === void 0 || R.insert) && h.unshift(I);
    return I;
  };
  if (n.skipping && !o)
    return null;
  for (var y = null, b = t.length / pDe, x = !o, T = 0; T < t.length; T++) {
    var E = t[T], A = E._private.rscratch, S = A.imgLayerCaches = A.imgLayerCaches || {}, k = S[r];
    if (k) {
      y = k;
      continue;
    }
    if ((!y || y.eles.length >= b || !Zne(y.bb, E.boundingBox())) && (y = v({
      insert: !0,
      after: y
    }), !y))
      return null;
    p || x ? n.queueLayer(y, E) : n.drawEleInLayer(y, E, r, e), y.eles.push(E), S[r] = y;
  }
  return p || (x ? null : h);
};
yi.getEleLevelForLayerLevel = function(t, e) {
  return t;
};
yi.drawEleInLayer = function(t, e, r, n) {
  var i = this, a = this.renderer, s = t.context, o = e.boundingBox();
  o.w === 0 || o.h === 0 || !e.visible() || (r = i.getEleLevelForLayerLevel(r, n), a.setImgSmoothing(s, !1), a.drawCachedElement(s, e, null, null, r, SDe), a.setImgSmoothing(s, !0));
};
yi.levelIsComplete = function(t, e) {
  var r = this, n = r.layersByLevel[t];
  if (!n || n.length === 0)
    return !1;
  for (var i = 0, a = 0; a < n.length; a++) {
    var s = n[a];
    if (s.reqs > 0 || s.invalid)
      return !1;
    i += s.eles.length;
  }
  return i === e.length;
};
yi.validateLayersElesOrdering = function(t, e) {
  var r = this.layersByLevel[t];
  if (r)
    for (var n = 0; n < r.length; n++) {
      for (var i = r[n], a = -1, s = 0; s < e.length; s++)
        if (i.eles[0] === e[s]) {
          a = s;
          break;
        }
      if (a < 0) {
        this.invalidateLayer(i);
        continue;
      }
      for (var o = a, s = 0; s < i.eles.length; s++)
        if (i.eles[s] !== e[o + s]) {
          this.invalidateLayer(i);
          break;
        }
    }
};
yi.updateElementsInLayers = function(t, e) {
  for (var r = this, n = bm(t[0]), i = 0; i < t.length; i++)
    for (var a = n ? null : t[i], s = n ? t[i] : t[i].ele, o = s._private.rscratch, l = o.imgLayerCaches = o.imgLayerCaches || {}, u = Ug; u <= $b; u++) {
      var h = l[u];
      h && (a && r.getEleLevelForLayerLevel(h.level) !== a.level || e(h, s, a));
    }
};
yi.haveLayers = function() {
  for (var t = this, e = !1, r = Ug; r <= $b; r++) {
    var n = t.layersByLevel[r];
    if (n && n.length > 0) {
      e = !0;
      break;
    }
  }
  return e;
};
yi.invalidateElements = function(t) {
  var e = this;
  t.length !== 0 && (e.lastInvalidationTime = yl(), !(t.length === 0 || !e.haveLayers()) && e.updateElementsInLayers(t, function(n, i, a) {
    e.invalidateLayer(n);
  }));
};
yi.invalidateLayer = function(t) {
  if (this.lastInvalidationTime = yl(), !t.invalid) {
    var e = t.level, r = t.eles, n = this.layersByLevel[e];
    bc(n, t), t.elesQueue = [], t.invalid = !0, t.replacement && (t.replacement.invalid = !0);
    for (var i = 0; i < r.length; i++) {
      var a = r[i]._private.rscratch.imgLayerCaches;
      a && (a[e] = null);
    }
  }
};
yi.refineElementTextures = function(t) {
  var e = this;
  e.updateElementsInLayers(t, function(n, i, a) {
    var s = n.replacement;
    if (s || (s = n.replacement = e.makeLayer(n.bb, n.level), s.replaces = n, s.eles = n.eles), !s.reqs)
      for (var o = 0; o < s.eles.length; o++)
        e.queueLayer(s, s.eles[o]);
  });
};
yi.enqueueElementRefinement = function(t) {
  this.eleTxrDeqs.merge(t), this.scheduleElementRefinement();
};
yi.queueLayer = function(t, e) {
  var r = this, n = r.layersQueue, i = t.elesQueue, a = i.hasId = i.hasId || {};
  if (!t.replacement) {
    if (e) {
      if (a[e.id()])
        return;
      i.push(e), a[e.id()] = !0;
    }
    t.reqs ? (t.reqs++, n.updateItem(t)) : (t.reqs = 1, n.push(t));
  }
};
yi.dequeue = function(t) {
  for (var e = this, r = e.layersQueue, n = [], i = 0; i < TDe && r.size() !== 0; ) {
    var a = r.peek();
    if (a.replacement) {
      r.pop();
      continue;
    }
    if (a.replaces && a !== a.replaces.replacement) {
      r.pop();
      continue;
    }
    if (a.invalid) {
      r.pop();
      continue;
    }
    var s = a.elesQueue.shift();
    s && (e.drawEleInLayer(a, s, a.level, t), i++), n.length === 0 && n.push(!0), a.elesQueue.length === 0 && (r.pop(), a.reqs = 0, a.replaces && e.applyLayerReplacement(a), e.requestRedraw());
  }
  return n;
};
yi.applyLayerReplacement = function(t) {
  var e = this, r = e.layersByLevel[t.level], n = t.replaces, i = r.indexOf(n);
  if (!(i < 0 || n.invalid)) {
    r[i] = t;
    for (var a = 0; a < t.eles.length; a++) {
      var s = t.eles[a]._private, o = s.imgLayerCaches = s.imgLayerCaches || {};
      o && (o[t.level] = t);
    }
    e.requestRedraw();
  }
};
yi.requestRedraw = Em(function() {
  var t = this.renderer;
  t.redrawHint("eles", !0), t.redrawHint("drag", !0), t.redraw();
}, 100);
yi.setupDequeueing = tae.setupDequeueing({
  deqRedrawThreshold: mDe,
  deqCost: yDe,
  deqAvgCost: bDe,
  deqNoDrawCost: xDe,
  deqFastCost: wDe,
  deq: function(e, r) {
    return e.dequeue(r);
  },
  onDeqd: yR,
  shouldRedraw: Hne,
  priority: function(e) {
    return e.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});
var iae = {}, vU;
function CDe(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    t.lineTo(n.x, n.y);
  }
}
function _De(t, e, r) {
  for (var n, i = 0; i < e.length; i++) {
    var a = e[i];
    i === 0 && (n = a), t.lineTo(a.x, a.y);
  }
  t.quadraticCurveTo(r.x, r.y, n.x, n.y);
}
function yU(t, e, r) {
  t.beginPath && t.beginPath();
  for (var n = e, i = 0; i < n.length; i++) {
    var a = n[i];
    t.lineTo(a.x, a.y);
  }
  var s = r, o = r[0];
  t.moveTo(o.x, o.y);
  for (var i = 1; i < s.length; i++) {
    var a = s[i];
    t.lineTo(a.x, a.y);
  }
  t.closePath && t.closePath();
}
function ADe(t, e, r, n, i) {
  t.beginPath && t.beginPath(), t.arc(r, n, i, 0, Math.PI * 2, !1);
  var a = e, s = a[0];
  t.moveTo(s.x, s.y);
  for (var o = 0; o < a.length; o++) {
    var l = a[o];
    t.lineTo(l.x, l.y);
  }
  t.closePath && t.closePath();
}
function LDe(t, e, r, n) {
  t.arc(e, r, n, 0, Math.PI * 2, !1);
}
iae.arrowShapeImpl = function(t) {
  return (vU || (vU = {
    polygon: CDe,
    "triangle-backcurve": _De,
    "triangle-tee": yU,
    "circle-triangle": ADe,
    "triangle-cross": yU,
    circle: LDe
  }))[t];
};
var _o = {};
_o.drawElement = function(t, e, r, n, i, a) {
  var s = this;
  e.isNode() ? s.drawNode(t, e, r, n, i, a) : s.drawEdge(t, e, r, n, i, a);
};
_o.drawElementOverlay = function(t, e) {
  var r = this;
  e.isNode() ? r.drawNodeOverlay(t, e) : r.drawEdgeOverlay(t, e);
};
_o.drawElementUnderlay = function(t, e) {
  var r = this;
  e.isNode() ? r.drawNodeUnderlay(t, e) : r.drawEdgeUnderlay(t, e);
};
_o.drawCachedElementPortion = function(t, e, r, n, i, a, s, o) {
  var l = this, u = r.getBoundingBox(e);
  if (!(u.w === 0 || u.h === 0)) {
    var h = r.getElement(e, u, n, i, a);
    if (h != null) {
      var f = o(l, e);
      if (f === 0)
        return;
      var d = s(l, e), p = u.x1, g = u.y1, m = u.w, v = u.h, y, b, x, T, E;
      if (d !== 0) {
        var A = r.getRotationPoint(e);
        x = A.x, T = A.y, t.translate(x, T), t.rotate(d), E = l.getImgSmoothing(t), E || l.setImgSmoothing(t, !0);
        var S = r.getRotationOffset(e);
        y = S.x, b = S.y;
      } else
        y = p, b = g;
      var k;
      f !== 1 && (k = t.globalAlpha, t.globalAlpha = k * f), t.drawImage(h.texture.canvas, h.x, 0, h.width, h.height, y, b, m, v), f !== 1 && (t.globalAlpha = k), d !== 0 && (t.rotate(-d), t.translate(-x, -T), E || l.setImgSmoothing(t, !1));
    } else
      r.drawElement(t, e);
  }
};
var RDe = function() {
  return 0;
}, IDe = function(e, r) {
  return e.getTextAngle(r, null);
}, MDe = function(e, r) {
  return e.getTextAngle(r, "source");
}, NDe = function(e, r) {
  return e.getTextAngle(r, "target");
}, DDe = function(e, r) {
  return r.effectiveOpacity();
}, QC = function(e, r) {
  return r.pstyle("text-opacity").pfValue * r.effectiveOpacity();
};
_o.drawCachedElement = function(t, e, r, n, i, a) {
  var s = this, o = s.data, l = o.eleTxrCache, u = o.lblTxrCache, h = o.slbTxrCache, f = o.tlbTxrCache, d = e.boundingBox(), p = a === !0 ? l.reasons.highQuality : null;
  if (!(d.w === 0 || d.h === 0 || !e.visible()) && (!n || TR(d, n))) {
    var g = e.isEdge(), m = e.element()._private.rscratch.badLine;
    s.drawElementUnderlay(t, e), s.drawCachedElementPortion(t, e, l, r, i, p, RDe, DDe), (!g || !m) && s.drawCachedElementPortion(t, e, u, r, i, p, IDe, QC), g && !m && (s.drawCachedElementPortion(t, e, h, r, i, p, MDe, QC), s.drawCachedElementPortion(t, e, f, r, i, p, NDe, QC)), s.drawElementOverlay(t, e);
  }
};
_o.drawElements = function(t, e) {
  for (var r = this, n = 0; n < e.length; n++) {
    var i = e[n];
    r.drawElement(t, i);
  }
};
_o.drawCachedElements = function(t, e, r, n) {
  for (var i = this, a = 0; a < e.length; a++) {
    var s = e[a];
    i.drawCachedElement(t, s, r, n);
  }
};
_o.drawCachedNodes = function(t, e, r, n) {
  for (var i = this, a = 0; a < e.length; a++) {
    var s = e[a];
    s.isNode() && i.drawCachedElement(t, s, r, n);
  }
};
_o.drawLayeredElements = function(t, e, r, n) {
  var i = this, a = i.data.lyrTxrCache.getLayers(e, r);
  if (a)
    for (var s = 0; s < a.length; s++) {
      var o = a[s], l = o.bb;
      l.w === 0 || l.h === 0 || t.drawImage(o.canvas, l.x1, l.y1, l.w, l.h);
    }
  else
    i.drawCachedElements(t, e, r, n);
};
var Il = {};
Il.drawEdge = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this, o = e._private.rscratch;
  if (!(a && !e.visible()) && !(o.badLine || o.allpts == null || isNaN(o.allpts[0]))) {
    var l;
    r && (l = r, t.translate(-l.x1, -l.y1));
    var u = a ? e.pstyle("opacity").value : 1, h = a ? e.pstyle("line-opacity").value : 1, f = e.pstyle("curve-style").value, d = e.pstyle("line-style").value, p = e.pstyle("width").pfValue, g = e.pstyle("line-cap").value, m = e.pstyle("line-outline-width").value, v = e.pstyle("line-outline-color").value, y = u * h, b = u * h, x = function() {
      var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : y;
      f === "straight-triangle" ? (s.eleStrokeStyle(t, e, I), s.drawEdgeTrianglePath(e, t, o.allpts)) : (t.lineWidth = p, t.lineCap = g, s.eleStrokeStyle(t, e, I), s.drawEdgePath(e, t, o.allpts, d), t.lineCap = "butt");
    }, T = function() {
      var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : y;
      if (t.lineWidth = p + m, t.lineCap = g, m > 0)
        s.colorStrokeStyle(t, v[0], v[1], v[2], I);
      else {
        t.lineCap = "butt";
        return;
      }
      f === "straight-triangle" ? s.drawEdgeTrianglePath(e, t, o.allpts) : (s.drawEdgePath(e, t, o.allpts, d), t.lineCap = "butt");
    }, E = function() {
      i && s.drawEdgeOverlay(t, e);
    }, A = function() {
      i && s.drawEdgeUnderlay(t, e);
    }, S = function() {
      var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : b;
      s.drawArrowheads(t, e, I);
    }, k = function() {
      s.drawElementText(t, e, null, n);
    };
    t.lineJoin = "round";
    var _ = e.pstyle("ghost").value === "yes";
    if (_) {
      var R = e.pstyle("ghost-offset-x").pfValue, L = e.pstyle("ghost-offset-y").pfValue, M = e.pstyle("ghost-opacity").value, P = y * M;
      t.translate(R, L), x(P), S(P), t.translate(-R, -L);
    } else
      T();
    A(), x(), S(), E(), k(), r && t.translate(l.x1, l.y1);
  }
};
var aae = function(e) {
  if (!["overlay", "underlay"].includes(e))
    throw new Error("Invalid state");
  return function(r, n) {
    if (n.visible()) {
      var i = n.pstyle("".concat(e, "-opacity")).value;
      if (i !== 0) {
        var a = this, s = a.usePaths(), o = n._private.rscratch, l = n.pstyle("".concat(e, "-padding")).pfValue, u = 2 * l, h = n.pstyle("".concat(e, "-color")).value;
        r.lineWidth = u, o.edgeType === "self" && !s ? r.lineCap = "butt" : r.lineCap = "round", a.colorStrokeStyle(r, h[0], h[1], h[2], i), a.drawEdgePath(n, r, o.allpts, "solid");
      }
    }
  };
};
Il.drawEdgeOverlay = aae("overlay");
Il.drawEdgeUnderlay = aae("underlay");
Il.drawEdgePath = function(t, e, r, n) {
  var i = t._private.rscratch, a = e, s, o = !1, l = this.usePaths(), u = t.pstyle("line-dash-pattern").pfValue, h = t.pstyle("line-dash-offset").pfValue;
  if (l) {
    var f = r.join("$"), d = i.pathCacheKey && i.pathCacheKey === f;
    d ? (s = e = i.pathCache, o = !0) : (s = e = new Path2D(), i.pathCacheKey = f, i.pathCache = s);
  }
  if (a.setLineDash)
    switch (n) {
      case "dotted":
        a.setLineDash([1, 1]);
        break;
      case "dashed":
        a.setLineDash(u), a.lineDashOffset = h;
        break;
      case "solid":
        a.setLineDash([]);
        break;
    }
  if (!o && !i.badLine)
    switch (e.beginPath && e.beginPath(), e.moveTo(r[0], r[1]), i.edgeType) {
      case "bezier":
      case "self":
      case "compound":
      case "multibezier":
        for (var p = 2; p + 3 < r.length; p += 4)
          e.quadraticCurveTo(r[p], r[p + 1], r[p + 2], r[p + 3]);
        break;
      case "straight":
      case "haystack":
        for (var g = 2; g + 1 < r.length; g += 2)
          e.lineTo(r[g], r[g + 1]);
        break;
      case "segments":
        if (i.isRound) {
          var m = ca(i.roundCorners), v;
          try {
            for (m.s(); !(v = m.n()).done; ) {
              var y = v.value;
              Yie(e, y);
            }
          } catch (x) {
            m.e(x);
          } finally {
            m.f();
          }
          e.lineTo(r[r.length - 2], r[r.length - 1]);
        } else
          for (var b = 2; b + 1 < r.length; b += 2)
            e.lineTo(r[b], r[b + 1]);
        break;
    }
  e = a, l ? e.stroke(s) : e.stroke(), e.setLineDash && e.setLineDash([]);
};
Il.drawEdgeTrianglePath = function(t, e, r) {
  e.fillStyle = e.strokeStyle;
  for (var n = t.pstyle("width").pfValue, i = 0; i + 1 < r.length; i += 2) {
    var a = [r[i + 2] - r[i], r[i + 3] - r[i + 1]], s = Math.sqrt(a[0] * a[0] + a[1] * a[1]), o = [a[1] / s, -a[0] / s], l = [o[0] * n / 2, o[1] * n / 2];
    e.beginPath(), e.moveTo(r[i] - l[0], r[i + 1] - l[1]), e.lineTo(r[i] + l[0], r[i + 1] + l[1]), e.lineTo(r[i + 2], r[i + 3]), e.closePath(), e.fill();
  }
};
Il.drawArrowheads = function(t, e, r) {
  var n = e._private.rscratch, i = n.edgeType === "haystack";
  i || this.drawArrowhead(t, e, "source", n.arrowStartX, n.arrowStartY, n.srcArrowAngle, r), this.drawArrowhead(t, e, "mid-target", n.midX, n.midY, n.midtgtArrowAngle, r), this.drawArrowhead(t, e, "mid-source", n.midX, n.midY, n.midsrcArrowAngle, r), i || this.drawArrowhead(t, e, "target", n.arrowEndX, n.arrowEndY, n.tgtArrowAngle, r);
};
Il.drawArrowhead = function(t, e, r, n, i, a, s) {
  if (!(isNaN(n) || n == null || isNaN(i) || i == null || isNaN(a) || a == null)) {
    var o = this, l = e.pstyle(r + "-arrow-shape").value;
    if (l !== "none") {
      var u = e.pstyle(r + "-arrow-fill").value === "hollow" ? "both" : "filled", h = e.pstyle(r + "-arrow-fill").value, f = e.pstyle("width").pfValue, d = e.pstyle(r + "-arrow-width"), p = d.value === "match-line" ? f : d.pfValue;
      d.units === "%" && (p *= f);
      var g = e.pstyle("opacity").value;
      s === void 0 && (s = g);
      var m = t.globalCompositeOperation;
      (s !== 1 || h === "hollow") && (t.globalCompositeOperation = "destination-out", o.colorFillStyle(t, 255, 255, 255, 1), o.colorStrokeStyle(t, 255, 255, 255, 1), o.drawArrowShape(e, t, u, f, l, p, n, i, a), t.globalCompositeOperation = m);
      var v = e.pstyle(r + "-arrow-color").value;
      o.colorFillStyle(t, v[0], v[1], v[2], s), o.colorStrokeStyle(t, v[0], v[1], v[2], s), o.drawArrowShape(e, t, h, f, l, p, n, i, a);
    }
  }
};
Il.drawArrowShape = function(t, e, r, n, i, a, s, o, l) {
  var u = this, h = this.usePaths() && i !== "triangle-cross", f = !1, d, p = e, g = {
    x: s,
    y: o
  }, m = t.pstyle("arrow-scale").value, v = this.getArrowWidth(n, m), y = u.arrowShapes[i];
  if (h) {
    var b = u.arrowPathCache = u.arrowPathCache || [], x = th(i), T = b[x];
    T != null ? (d = e = T, f = !0) : (d = e = new Path2D(), b[x] = d);
  }
  f || (e.beginPath && e.beginPath(), h ? y.draw(e, 1, 0, {
    x: 0,
    y: 0
  }, 1) : y.draw(e, v, l, g, n), e.closePath && e.closePath()), e = p, h && (e.translate(s, o), e.rotate(l), e.scale(v, v)), (r === "filled" || r === "both") && (h ? e.fill(d) : e.fill()), (r === "hollow" || r === "both") && (e.lineWidth = a / (h ? v : 1), e.lineJoin = "miter", h ? e.stroke(d) : e.stroke()), h && (e.scale(1 / v, 1 / v), e.rotate(-l), e.translate(-s, -o));
};
var PR = {};
PR.safeDrawImage = function(t, e, r, n, i, a, s, o, l, u) {
  if (!(i <= 0 || a <= 0 || l <= 0 || u <= 0))
    try {
      t.drawImage(e, r, n, i, a, s, o, l, u);
    } catch (h) {
      Rr(h);
    }
};
PR.drawInscribedImage = function(t, e, r, n, i) {
  var a = this, s = r.position(), o = s.x, l = s.y, u = r.cy().style(), h = u.getIndexedStyle.bind(u), f = h(r, "background-fit", "value", n), d = h(r, "background-repeat", "value", n), p = r.width(), g = r.height(), m = r.padding() * 2, v = p + (h(r, "background-width-relative-to", "value", n) === "inner" ? 0 : m), y = g + (h(r, "background-height-relative-to", "value", n) === "inner" ? 0 : m), b = r._private.rscratch, x = h(r, "background-clip", "value", n), T = x === "node", E = h(r, "background-image-opacity", "value", n) * i, A = h(r, "background-image-smoothing", "value", n), S = r.pstyle("corner-radius").value;
  S !== "auto" && (S = r.pstyle("corner-radius").pfValue);
  var k = e.width || e.cachedW, _ = e.height || e.cachedH;
  (k == null || _ == null) && (document.body.appendChild(e), k = e.cachedW = e.width || e.offsetWidth, _ = e.cachedH = e.height || e.offsetHeight, document.body.removeChild(e));
  var R = k, L = _;
  if (h(r, "background-width", "value", n) !== "auto" && (h(r, "background-width", "units", n) === "%" ? R = h(r, "background-width", "pfValue", n) * v : R = h(r, "background-width", "pfValue", n)), h(r, "background-height", "value", n) !== "auto" && (h(r, "background-height", "units", n) === "%" ? L = h(r, "background-height", "pfValue", n) * y : L = h(r, "background-height", "pfValue", n)), !(R === 0 || L === 0)) {
    if (f === "contain") {
      var M = Math.min(v / R, y / L);
      R *= M, L *= M;
    } else if (f === "cover") {
      var M = Math.max(v / R, y / L);
      R *= M, L *= M;
    }
    var P = o - v / 2, C = h(r, "background-position-x", "units", n), I = h(r, "background-position-x", "pfValue", n);
    C === "%" ? P += (v - R) * I : P += I;
    var N = h(r, "background-offset-x", "units", n), O = h(r, "background-offset-x", "pfValue", n);
    N === "%" ? P += (v - R) * O : P += O;
    var D = l - y / 2, $ = h(r, "background-position-y", "units", n), z = h(r, "background-position-y", "pfValue", n);
    $ === "%" ? D += (y - L) * z : D += z;
    var B = h(r, "background-offset-y", "units", n), G = h(r, "background-offset-y", "pfValue", n);
    B === "%" ? D += (y - L) * G : D += G, b.pathCache && (P -= o, D -= l, o = 0, l = 0);
    var W = t.globalAlpha;
    t.globalAlpha = E;
    var V = a.getImgSmoothing(t), U = !1;
    if (A === "no" && V ? (a.setImgSmoothing(t, !1), U = !0) : A === "yes" && !V && (a.setImgSmoothing(t, !0), U = !0), d === "no-repeat")
      T && (t.save(), b.pathCache ? t.clip(b.pathCache) : (a.nodeShapes[a.getNodeShape(r)].draw(t, o, l, v, y, S, b), t.clip())), a.safeDrawImage(t, e, 0, 0, k, _, P, D, R, L), T && t.restore();
    else {
      var Z = t.createPattern(e, d);
      t.fillStyle = Z, a.nodeShapes[a.getNodeShape(r)].draw(t, o, l, v, y, S, b), t.translate(P, D), t.fill(), t.translate(-P, -D);
    }
    t.globalAlpha = W, U && a.setImgSmoothing(t, V);
  }
};
var Dh = {};
Dh.eleTextBiggerThanMin = function(t, e) {
  if (!e) {
    var r = t.cy().zoom(), n = this.getPixelRatio(), i = Math.ceil(xR(r * n));
    e = Math.pow(2, i);
  }
  var a = t.pstyle("font-size").pfValue * e, s = t.pstyle("min-zoomed-font-size").pfValue;
  return !(a < s);
};
Dh.drawElementText = function(t, e, r, n, i) {
  var a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this;
  if (n == null) {
    if (a && !s.eleTextBiggerThanMin(e))
      return;
  } else if (n === !1)
    return;
  if (e.isNode()) {
    var o = e.pstyle("label");
    if (!o || !o.value)
      return;
    var l = s.getLabelJustification(e);
    t.textAlign = l, t.textBaseline = "bottom";
  } else {
    var u = e.element()._private.rscratch.badLine, h = e.pstyle("label"), f = e.pstyle("source-label"), d = e.pstyle("target-label");
    if (u || (!h || !h.value) && (!f || !f.value) && (!d || !d.value))
      return;
    t.textAlign = "center", t.textBaseline = "bottom";
  }
  var p = !r, g;
  r && (g = r, t.translate(-g.x1, -g.y1)), i == null ? (s.drawText(t, e, null, p, a), e.isEdge() && (s.drawText(t, e, "source", p, a), s.drawText(t, e, "target", p, a))) : s.drawText(t, e, i, p, a), r && t.translate(g.x1, g.y1);
};
Dh.getFontCache = function(t) {
  var e;
  this.fontCaches = this.fontCaches || [];
  for (var r = 0; r < this.fontCaches.length; r++)
    if (e = this.fontCaches[r], e.context === t)
      return e;
  return e = {
    context: t
  }, this.fontCaches.push(e), e;
};
Dh.setupTextStyle = function(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = e.pstyle("font-style").strValue, i = e.pstyle("font-size").pfValue + "px", a = e.pstyle("font-family").strValue, s = e.pstyle("font-weight").strValue, o = r ? e.effectiveOpacity() * e.pstyle("text-opacity").value : 1, l = e.pstyle("text-outline-opacity").value * o, u = e.pstyle("color").value, h = e.pstyle("text-outline-color").value;
  t.font = n + " " + s + " " + i + " " + a, t.lineJoin = "round", this.colorFillStyle(t, u[0], u[1], u[2], o), this.colorStrokeStyle(t, h[0], h[1], h[2], l);
};
function ODe(t, e, r, n, i) {
  var a = Math.min(n, i), s = a / 2, o = e + n / 2, l = r + i / 2;
  t.beginPath(), t.arc(o, l, s, 0, Math.PI * 2), t.closePath();
}
function bU(t, e, r, n, i) {
  var a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 5, s = Math.min(a, n / 2, i / 2);
  t.beginPath(), t.moveTo(e + s, r), t.lineTo(e + n - s, r), t.quadraticCurveTo(e + n, r, e + n, r + s), t.lineTo(e + n, r + i - s), t.quadraticCurveTo(e + n, r + i, e + n - s, r + i), t.lineTo(e + s, r + i), t.quadraticCurveTo(e, r + i, e, r + i - s), t.lineTo(e, r + s), t.quadraticCurveTo(e, r, e + s, r), t.closePath();
}
Dh.getTextAngle = function(t, e) {
  var r, n = t._private, i = n.rscratch, a = e ? e + "-" : "", s = t.pstyle(a + "text-rotation");
  if (s.strValue === "autorotate") {
    var o = aa(i, "labelAngle", e);
    r = t.isEdge() ? o : 0;
  } else s.strValue === "none" ? r = 0 : r = s.pfValue;
  return r;
};
Dh.drawText = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = e._private, s = a.rscratch, o = i ? e.effectiveOpacity() : 1;
  if (!(i && (o === 0 || e.pstyle("text-opacity").value === 0))) {
    r === "main" && (r = null);
    var l = aa(s, "labelX", r), u = aa(s, "labelY", r), h, f, d = this.getLabelText(e, r);
    if (d != null && d !== "" && !isNaN(l) && !isNaN(u)) {
      this.setupTextStyle(t, e, i);
      var p = r ? r + "-" : "", g = aa(s, "labelWidth", r), m = aa(s, "labelHeight", r), v = e.pstyle(p + "text-margin-x").pfValue, y = e.pstyle(p + "text-margin-y").pfValue, b = e.isEdge(), x = e.pstyle("text-halign").value, T = e.pstyle("text-valign").value;
      b && (x = "center", T = "center"), l += v, u += y;
      var E;
      switch (n ? E = this.getTextAngle(e, r) : E = 0, E !== 0 && (h = l, f = u, t.translate(h, f), t.rotate(E), l = 0, u = 0), T) {
        case "top":
          break;
        case "center":
          u += m / 2;
          break;
        case "bottom":
          u += m;
          break;
      }
      var A = e.pstyle("text-background-opacity").value, S = e.pstyle("text-border-opacity").value, k = e.pstyle("text-border-width").pfValue, _ = e.pstyle("text-background-padding").pfValue, R = e.pstyle("text-background-shape").strValue, L = R === "round-rectangle" || R === "roundrectangle", M = R === "circle", P = 2;
      if (A > 0 || k > 0 && S > 0) {
        var C = t.fillStyle, I = t.strokeStyle, N = t.lineWidth, O = e.pstyle("text-background-color").value, D = e.pstyle("text-border-color").value, $ = e.pstyle("text-border-style").value, z = A > 0, B = k > 0 && S > 0, G = l - _;
        switch (x) {
          case "left":
            G -= g;
            break;
          case "center":
            G -= g / 2;
            break;
        }
        var W = u - m - _, V = g + 2 * _, U = m + 2 * _;
        if (z && (t.fillStyle = "rgba(".concat(O[0], ",").concat(O[1], ",").concat(O[2], ",").concat(A * o, ")")), B && (t.strokeStyle = "rgba(".concat(D[0], ",").concat(D[1], ",").concat(D[2], ",").concat(S * o, ")"), t.lineWidth = k, t.setLineDash))
          switch ($) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash([4, 2]);
              break;
            case "double":
              t.lineWidth = k / 4, t.setLineDash([]);
              break;
            case "solid":
            default:
              t.setLineDash([]);
              break;
          }
        if (L ? (t.beginPath(), bU(t, G, W, V, U, P)) : M ? (t.beginPath(), ODe(t, G, W, V, U)) : (t.beginPath(), t.rect(G, W, V, U)), z && t.fill(), B && t.stroke(), B && $ === "double") {
          var Z = k / 2;
          t.beginPath(), L ? bU(t, G + Z, W + Z, V - 2 * Z, U - 2 * Z, P) : t.rect(G + Z, W + Z, V - 2 * Z, U - 2 * Z), t.stroke();
        }
        t.fillStyle = C, t.strokeStyle = I, t.lineWidth = N, t.setLineDash && t.setLineDash([]);
      }
      var K = 2 * e.pstyle("text-outline-width").pfValue;
      if (K > 0 && (t.lineWidth = K), e.pstyle("text-wrap").value === "wrap") {
        var ce = aa(s, "labelWrapCachedLines", r), J = aa(s, "labelLineHeight", r), ee = g / 2, j = this.getLabelJustification(e);
        switch (j === "auto" || (x === "left" ? j === "left" ? l += -g : j === "center" && (l += -ee) : x === "center" ? j === "left" ? l += -ee : j === "right" && (l += ee) : x === "right" && (j === "center" ? l += ee : j === "right" && (l += g))), T) {
          case "top":
            u -= (ce.length - 1) * J;
            break;
          case "center":
          case "bottom":
            u -= (ce.length - 1) * J;
            break;
        }
        for (var X = 0; X < ce.length; X++)
          K > 0 && t.strokeText(ce[X], l, u), t.fillText(ce[X], l, u), u += J;
      } else
        K > 0 && t.strokeText(d, l, u), t.fillText(d, l, u);
      E !== 0 && (t.rotate(-E), t.translate(-h, -f));
    }
  }
};
var Hc = {};
Hc.drawNode = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this, o, l, u = e._private, h = u.rscratch, f = e.position();
  if (!(!mt(f.x) || !mt(f.y)) && !(a && !e.visible())) {
    var d = a ? e.effectiveOpacity() : 1, p = s.usePaths(), g, m = !1, v = e.padding();
    o = e.width() + 2 * v, l = e.height() + 2 * v;
    var y;
    r && (y = r, t.translate(-y.x1, -y.y1));
    for (var b = e.pstyle("background-image"), x = b.value, T = new Array(x.length), E = new Array(x.length), A = 0, S = 0; S < x.length; S++) {
      var k = x[S], _ = T[S] = k != null && k !== "none";
      if (_) {
        var R = e.cy().style().getIndexedStyle(e, "background-image-crossorigin", "value", S);
        A++, E[S] = s.getCachedImage(k, R, function() {
          u.backgroundTimestamp = Date.now(), e.emitAndNotify("background");
        });
      }
    }
    var L = e.pstyle("background-blacken").value, M = e.pstyle("border-width").pfValue, P = e.pstyle("background-opacity").value * d, C = e.pstyle("border-color").value, I = e.pstyle("border-style").value, N = e.pstyle("border-join").value, O = e.pstyle("border-cap").value, D = e.pstyle("border-position").value, $ = e.pstyle("border-dash-pattern").pfValue, z = e.pstyle("border-dash-offset").pfValue, B = e.pstyle("border-opacity").value * d, G = e.pstyle("outline-width").pfValue, W = e.pstyle("outline-color").value, V = e.pstyle("outline-style").value, U = e.pstyle("outline-opacity").value * d, Z = e.pstyle("outline-offset").value, K = e.pstyle("corner-radius").value;
    K !== "auto" && (K = e.pstyle("corner-radius").pfValue);
    var ce = function() {
      var te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : P;
      s.eleFillStyle(t, e, te);
    }, J = function() {
      var te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : B;
      s.colorStrokeStyle(t, C[0], C[1], C[2], te);
    }, ee = function() {
      var te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : U;
      s.colorStrokeStyle(t, W[0], W[1], W[2], te);
    }, j = function(te, he, F, oe) {
      var se = s.nodePathCache = s.nodePathCache || [], ge = Vne(F === "polygon" ? F + "," + oe.join(",") : F, "" + he, "" + te, "" + K), de = se[ge], we, _e = !1;
      return de != null ? (we = de, _e = !0, h.pathCache = we) : (we = new Path2D(), se[ge] = h.pathCache = we), {
        path: we,
        cacheHit: _e
      };
    }, X = e.pstyle("shape").strValue, re = e.pstyle("shape-polygon-points").pfValue;
    if (p) {
      t.translate(f.x, f.y);
      var Q = j(o, l, X, re);
      g = Q.path, m = Q.cacheHit;
    }
    var ue = function() {
      if (!m) {
        var te = f;
        p && (te = {
          x: 0,
          y: 0
        }), s.nodeShapes[s.getNodeShape(e)].draw(g || t, te.x, te.y, o, l, K, h);
      }
      p ? t.fill(g) : t.fill();
    }, ne = function() {
      for (var te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : d, he = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, F = u.backgrounding, oe = 0, se = 0; se < E.length; se++) {
        var ge = e.cy().style().getIndexedStyle(e, "background-image-containment", "value", se);
        if (he && ge === "over" || !he && ge === "inside") {
          oe++;
          continue;
        }
        T[se] && E[se].complete && !E[se].error && (oe++, s.drawInscribedImage(t, E[se], e, se, te));
      }
      u.backgrounding = oe !== A, F !== u.backgrounding && e.updateStyle(!1);
    }, xe = function() {
      var te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, he = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : d;
      s.hasPie(e) && (s.drawPie(t, e, he), te && (p || s.nodeShapes[s.getNodeShape(e)].draw(t, f.x, f.y, o, l, K, h)));
    }, Y = function() {
      var te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, he = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : d;
      s.hasStripe(e) && (t.save(), p ? t.clip(h.pathCache) : (s.nodeShapes[s.getNodeShape(e)].draw(t, f.x, f.y, o, l, K, h), t.clip()), s.drawStripe(t, e, he), t.restore(), te && (p || s.nodeShapes[s.getNodeShape(e)].draw(t, f.x, f.y, o, l, K, h)));
    }, Ne = function() {
      var te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : d, he = (L > 0 ? L : -L) * te, F = L > 0 ? 0 : 255;
      L !== 0 && (s.colorFillStyle(t, F, F, F, he), p ? t.fill(g) : t.fill());
    }, fe = function() {
      if (M > 0) {
        if (t.lineWidth = M, t.lineCap = O, t.lineJoin = N, t.setLineDash)
          switch (I) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash($), t.lineDashOffset = z;
              break;
            case "solid":
            case "double":
              t.setLineDash([]);
              break;
          }
        if (D !== "center") {
          if (t.save(), t.lineWidth *= 2, D === "inside")
            p ? t.clip(g) : t.clip();
          else {
            var te = new Path2D();
            te.rect(-o / 2 - M, -l / 2 - M, o + 2 * M, l + 2 * M), te.addPath(g), t.clip(te, "evenodd");
          }
          p ? t.stroke(g) : t.stroke(), t.restore();
        } else
          p ? t.stroke(g) : t.stroke();
        if (I === "double") {
          t.lineWidth = M / 3;
          var he = t.globalCompositeOperation;
          t.globalCompositeOperation = "destination-out", p ? t.stroke(g) : t.stroke(), t.globalCompositeOperation = he;
        }
        t.setLineDash && t.setLineDash([]);
      }
    }, qe = function() {
      if (G > 0) {
        if (t.lineWidth = G, t.lineCap = "butt", t.setLineDash)
          switch (V) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash([4, 2]);
              break;
            case "solid":
            case "double":
              t.setLineDash([]);
              break;
          }
        var te = f;
        p && (te = {
          x: 0,
          y: 0
        });
        var he = s.getNodeShape(e), F = M;
        D === "inside" && (F = 0), D === "outside" && (F *= 2);
        var oe = (o + F + (G + Z)) / o, se = (l + F + (G + Z)) / l, ge = o * oe, de = l * se, we = s.nodeShapes[he].points, _e;
        if (p) {
          var Se = j(ge, de, he, we);
          _e = Se.path;
        }
        if (he === "ellipse")
          s.drawEllipsePath(_e || t, te.x, te.y, ge, de);
        else if (["round-diamond", "round-heptagon", "round-hexagon", "round-octagon", "round-pentagon", "round-polygon", "round-triangle", "round-tag"].includes(he)) {
          var Me = 0, Xe = 0, We = 0;
          he === "round-diamond" ? Me = (F + Z + G) * 1.4 : he === "round-heptagon" ? (Me = (F + Z + G) * 1.075, We = -(F / 2 + Z + G) / 35) : he === "round-hexagon" ? Me = (F + Z + G) * 1.12 : he === "round-pentagon" ? (Me = (F + Z + G) * 1.13, We = -(F / 2 + Z + G) / 15) : he === "round-tag" ? (Me = (F + Z + G) * 1.12, Xe = (F / 2 + G + Z) * 0.07) : he === "round-triangle" && (Me = (F + Z + G) * (Math.PI / 2), We = -(F + Z / 2 + G) / Math.PI), Me !== 0 && (oe = (o + Me) / o, ge = o * oe, ["round-hexagon", "round-tag"].includes(he) || (se = (l + Me) / l, de = l * se)), K = K === "auto" ? eie(ge, de) : K;
          for (var Ke = ge / 2, Ze = de / 2, Pe = K + (F + G + Z) / 2, Ve = new Array(we.length / 2), ht = new Array(we.length / 2), st = 0; st < we.length / 2; st++)
            Ve[st] = {
              x: te.x + Xe + Ke * we[st * 2],
              y: te.y + We + Ze * we[st * 2 + 1]
            };
          var Ue, Et, He, rt, ct = Ve.length;
          for (Et = Ve[ct - 1], Ue = 0; Ue < ct; Ue++)
            He = Ve[Ue % ct], rt = Ve[(Ue + 1) % ct], ht[Ue] = DR(Et, He, rt, Pe), Et = He, He = rt;
          s.drawRoundPolygonPath(_e || t, te.x + Xe, te.y + We, o * oe, l * se, we, ht);
        } else if (["roundrectangle", "round-rectangle"].includes(he))
          K = K === "auto" ? xc(ge, de) : K, s.drawRoundRectanglePath(_e || t, te.x, te.y, ge, de, K + (F + G + Z) / 2);
        else if (["cutrectangle", "cut-rectangle"].includes(he))
          K = K === "auto" ? ER() : K, s.drawCutRectanglePath(_e || t, te.x, te.y, ge, de, null, K + (F + G + Z) / 4);
        else if (["bottomroundrectangle", "bottom-round-rectangle"].includes(he))
          K = K === "auto" ? xc(ge, de) : K, s.drawBottomRoundRectanglePath(_e || t, te.x, te.y, ge, de, K + (F + G + Z) / 2);
        else if (he === "barrel")
          s.drawBarrelPath(_e || t, te.x, te.y, ge, de);
        else if (he.startsWith("polygon") || ["rhomboid", "right-rhomboid", "round-tag", "tag", "vee"].includes(he)) {
          var ut = (F + G + Z) / o;
          we = Rb(Ib(we, ut)), s.drawPolygonPath(_e || t, te.x, te.y, o, l, we);
        } else {
          var nt = (F + G + Z) / o;
          we = Rb(Ib(we, -nt)), s.drawPolygonPath(_e || t, te.x, te.y, o, l, we);
        }
        if (p ? t.stroke(_e) : t.stroke(), V === "double") {
          t.lineWidth = F / 3;
          var bt = t.globalCompositeOperation;
          t.globalCompositeOperation = "destination-out", p ? t.stroke(_e) : t.stroke(), t.globalCompositeOperation = bt;
        }
        t.setLineDash && t.setLineDash([]);
      }
    }, ze = function() {
      i && s.drawNodeOverlay(t, e, f, o, l);
    }, Ge = function() {
      i && s.drawNodeUnderlay(t, e, f, o, l);
    }, Ee = function() {
      s.drawElementText(t, e, null, n);
    }, Oe = e.pstyle("ghost").value === "yes";
    if (Oe) {
      var Ce = e.pstyle("ghost-offset-x").pfValue, Ae = e.pstyle("ghost-offset-y").pfValue, $e = e.pstyle("ghost-opacity").value, me = $e * d;
      t.translate(Ce, Ae), ee(), qe(), ce($e * P), ue(), ne(me, !0), J($e * B), fe(), xe(L !== 0 || M !== 0), Y(L !== 0 || M !== 0), ne(me, !1), Ne(me), t.translate(-Ce, -Ae);
    }
    p && t.translate(-f.x, -f.y), Ge(), p && t.translate(f.x, f.y), ee(), qe(), ce(), ue(), ne(d, !0), J(), fe(), xe(L !== 0 || M !== 0), Y(L !== 0 || M !== 0), ne(d, !1), Ne(), p && t.translate(-f.x, -f.y), Ee(), ze(), r && t.translate(y.x1, y.y1);
  }
};
var sae = function(e) {
  if (!["overlay", "underlay"].includes(e))
    throw new Error("Invalid state");
  return function(r, n, i, a, s) {
    var o = this;
    if (n.visible()) {
      var l = n.pstyle("".concat(e, "-padding")).pfValue, u = n.pstyle("".concat(e, "-opacity")).value, h = n.pstyle("".concat(e, "-color")).value, f = n.pstyle("".concat(e, "-shape")).value, d = n.pstyle("".concat(e, "-corner-radius")).value;
      if (u > 0) {
        if (i = i || n.position(), a == null || s == null) {
          var p = n.padding();
          a = n.width() + 2 * p, s = n.height() + 2 * p;
        }
        o.colorFillStyle(r, h[0], h[1], h[2], u), o.nodeShapes[f].draw(r, i.x, i.y, a + l * 2, s + l * 2, d), r.fill();
      }
    }
  };
};
Hc.drawNodeOverlay = sae("overlay");
Hc.drawNodeUnderlay = sae("underlay");
Hc.hasPie = function(t) {
  return t = t[0], t._private.hasPie;
};
Hc.hasStripe = function(t) {
  return t = t[0], t._private.hasStripe;
};
Hc.drawPie = function(t, e, r, n) {
  e = e[0], n = n || e.position();
  var i = e.cy().style(), a = e.pstyle("pie-size"), s = e.pstyle("pie-hole"), o = e.pstyle("pie-start-angle").pfValue, l = n.x, u = n.y, h = e.width(), f = e.height(), d = Math.min(h, f) / 2, p, g = 0, m = this.usePaths();
  if (m && (l = 0, u = 0), a.units === "%" ? d = d * a.pfValue : a.pfValue !== void 0 && (d = a.pfValue / 2), s.units === "%" ? p = d * s.pfValue : s.pfValue !== void 0 && (p = s.pfValue / 2), !(p >= d))
    for (var v = 1; v <= i.pieBackgroundN; v++) {
      var y = e.pstyle("pie-" + v + "-background-size").value, b = e.pstyle("pie-" + v + "-background-color").value, x = e.pstyle("pie-" + v + "-background-opacity").value * r, T = y / 100;
      T + g > 1 && (T = 1 - g);
      var E = 1.5 * Math.PI + 2 * Math.PI * g;
      E += o;
      var A = 2 * Math.PI * T, S = E + A;
      y === 0 || g >= 1 || g + T > 1 || (p === 0 ? (t.beginPath(), t.moveTo(l, u), t.arc(l, u, d, E, S), t.closePath()) : (t.beginPath(), t.arc(l, u, d, E, S), t.arc(l, u, p, S, E, !0), t.closePath()), this.colorFillStyle(t, b[0], b[1], b[2], x), t.fill(), g += T);
    }
};
Hc.drawStripe = function(t, e, r, n) {
  e = e[0], n = n || e.position();
  var i = e.cy().style(), a = n.x, s = n.y, o = e.width(), l = e.height(), u = 0, h = this.usePaths();
  t.save();
  var f = e.pstyle("stripe-direction").value, d = e.pstyle("stripe-size");
  switch (f) {
    case "vertical":
      break;
    // default
    case "righward":
      t.rotate(-Math.PI / 2);
      break;
  }
  var p = o, g = l;
  d.units === "%" ? (p = p * d.pfValue, g = g * d.pfValue) : d.pfValue !== void 0 && (p = d.pfValue, g = d.pfValue), h && (a = 0, s = 0), s -= p / 2, a -= g / 2;
  for (var m = 1; m <= i.stripeBackgroundN; m++) {
    var v = e.pstyle("stripe-" + m + "-background-size").value, y = e.pstyle("stripe-" + m + "-background-color").value, b = e.pstyle("stripe-" + m + "-background-opacity").value * r, x = v / 100;
    x + u > 1 && (x = 1 - u), !(v === 0 || u >= 1 || u + x > 1) && (t.beginPath(), t.rect(a, s + g * u, p, g * x), t.closePath(), this.colorFillStyle(t, y[0], y[1], y[2], b), t.fill(), u += x);
  }
  t.restore();
};
var ea = {}, PDe = 100;
ea.getPixelRatio = function() {
  var t = this.data.contexts[0];
  if (this.forcedPixelRatio != null)
    return this.forcedPixelRatio;
  var e = this.cy.window(), r = t.backingStorePixelRatio || t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
  return (e.devicePixelRatio || 1) / r;
};
ea.paintCache = function(t) {
  for (var e = this.paintCaches = this.paintCaches || [], r = !0, n, i = 0; i < e.length; i++)
    if (n = e[i], n.context === t) {
      r = !1;
      break;
    }
  return r && (n = {
    context: t
  }, e.push(n)), n;
};
ea.createGradientStyleFor = function(t, e, r, n, i) {
  var a, s = this.usePaths(), o = r.pstyle(e + "-gradient-stop-colors").value, l = r.pstyle(e + "-gradient-stop-positions").pfValue;
  if (n === "radial-gradient")
    if (r.isEdge()) {
      var u = r.sourceEndpoint(), h = r.targetEndpoint(), f = r.midpoint(), d = rh(u, f), p = rh(h, f);
      a = t.createRadialGradient(f.x, f.y, 0, f.x, f.y, Math.max(d, p));
    } else {
      var g = s ? {
        x: 0,
        y: 0
      } : r.position(), m = r.paddedWidth(), v = r.paddedHeight();
      a = t.createRadialGradient(g.x, g.y, 0, g.x, g.y, Math.max(m, v));
    }
  else if (r.isEdge()) {
    var y = r.sourceEndpoint(), b = r.targetEndpoint();
    a = t.createLinearGradient(y.x, y.y, b.x, b.y);
  } else {
    var x = s ? {
      x: 0,
      y: 0
    } : r.position(), T = r.paddedWidth(), E = r.paddedHeight(), A = T / 2, S = E / 2, k = r.pstyle("background-gradient-direction").value;
    switch (k) {
      case "to-bottom":
        a = t.createLinearGradient(x.x, x.y - S, x.x, x.y + S);
        break;
      case "to-top":
        a = t.createLinearGradient(x.x, x.y + S, x.x, x.y - S);
        break;
      case "to-left":
        a = t.createLinearGradient(x.x + A, x.y, x.x - A, x.y);
        break;
      case "to-right":
        a = t.createLinearGradient(x.x - A, x.y, x.x + A, x.y);
        break;
      case "to-bottom-right":
      case "to-right-bottom":
        a = t.createLinearGradient(x.x - A, x.y - S, x.x + A, x.y + S);
        break;
      case "to-top-right":
      case "to-right-top":
        a = t.createLinearGradient(x.x - A, x.y + S, x.x + A, x.y - S);
        break;
      case "to-bottom-left":
      case "to-left-bottom":
        a = t.createLinearGradient(x.x + A, x.y - S, x.x - A, x.y + S);
        break;
      case "to-top-left":
      case "to-left-top":
        a = t.createLinearGradient(x.x + A, x.y + S, x.x - A, x.y - S);
        break;
    }
  }
  if (!a) return null;
  for (var _ = l.length === o.length, R = o.length, L = 0; L < R; L++)
    a.addColorStop(_ ? l[L] : L / (R - 1), "rgba(" + o[L][0] + "," + o[L][1] + "," + o[L][2] + "," + i + ")");
  return a;
};
ea.gradientFillStyle = function(t, e, r, n) {
  var i = this.createGradientStyleFor(t, "background", e, r, n);
  if (!i) return null;
  t.fillStyle = i;
};
ea.colorFillStyle = function(t, e, r, n, i) {
  t.fillStyle = "rgba(" + e + "," + r + "," + n + "," + i + ")";
};
ea.eleFillStyle = function(t, e, r) {
  var n = e.pstyle("background-fill").value;
  if (n === "linear-gradient" || n === "radial-gradient")
    this.gradientFillStyle(t, e, n, r);
  else {
    var i = e.pstyle("background-color").value;
    this.colorFillStyle(t, i[0], i[1], i[2], r);
  }
};
ea.gradientStrokeStyle = function(t, e, r, n) {
  var i = this.createGradientStyleFor(t, "line", e, r, n);
  if (!i) return null;
  t.strokeStyle = i;
};
ea.colorStrokeStyle = function(t, e, r, n, i) {
  t.strokeStyle = "rgba(" + e + "," + r + "," + n + "," + i + ")";
};
ea.eleStrokeStyle = function(t, e, r) {
  var n = e.pstyle("line-fill").value;
  if (n === "linear-gradient" || n === "radial-gradient")
    this.gradientStrokeStyle(t, e, n, r);
  else {
    var i = e.pstyle("line-color").value;
    this.colorStrokeStyle(t, i[0], i[1], i[2], r);
  }
};
ea.matchCanvasSize = function(t) {
  var e = this, r = e.data, n = e.findContainerClientCoords(), i = n[2], a = n[3], s = e.getPixelRatio(), o = e.motionBlurPxRatio;
  (t === e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_NODE] || t === e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_DRAG]) && (s = o);
  var l = i * s, u = a * s, h;
  if (!(l === e.canvasWidth && u === e.canvasHeight)) {
    e.fontCaches = null;
    var f = r.canvasContainer;
    f.style.width = i + "px", f.style.height = a + "px";
    for (var d = 0; d < e.CANVAS_LAYERS; d++)
      h = r.canvases[d], h.width = l, h.height = u, h.style.width = i + "px", h.style.height = a + "px";
    for (var d = 0; d < e.BUFFER_COUNT; d++)
      h = r.bufferCanvases[d], h.width = l, h.height = u, h.style.width = i + "px", h.style.height = a + "px";
    e.textureMult = 1, s <= 1 && (h = r.bufferCanvases[e.TEXTURE_BUFFER], e.textureMult = 2, h.width = l * e.textureMult, h.height = u * e.textureMult), e.canvasWidth = l, e.canvasHeight = u, e.pixelRatio = s;
  }
};
ea.renderTo = function(t, e, r, n) {
  this.render({
    forcedContext: t,
    forcedZoom: e,
    forcedPan: r,
    drawAllLayers: !0,
    forcedPxRatio: n
  });
};
ea.clearCanvas = function() {
  var t = this, e = t.data;
  function r(n) {
    n.clearRect(0, 0, t.canvasWidth, t.canvasHeight);
  }
  r(e.contexts[t.NODE]), r(e.contexts[t.DRAG]);
};
ea.render = function(t) {
  var e = this;
  t = t || Xne();
  var r = e.cy, n = t.forcedContext, i = t.drawAllLayers, a = t.drawOnlyNodeLayer, s = t.forcedZoom, o = t.forcedPan, l = t.forcedPxRatio === void 0 ? this.getPixelRatio() : t.forcedPxRatio, u = e.data, h = u.canvasNeedsRedraw, f = e.textureOnViewport && !n && (e.pinching || e.hoverData.dragging || e.swipePanning || e.data.wheelZooming), d = t.motionBlur !== void 0 ? t.motionBlur : e.motionBlur, p = e.motionBlurPxRatio, g = r.hasCompoundNodes(), m = e.hoverData.draggingEles, v = !!(e.hoverData.selecting || e.touchData.selecting);
  d = d && !n && e.motionBlurEnabled && !v;
  var y = d;
  n || (e.prevPxRatio !== l && (e.invalidateContainerClientCoordsCache(), e.matchCanvasSize(e.container), e.redrawHint("eles", !0), e.redrawHint("drag", !0)), e.prevPxRatio = l), !n && e.motionBlurTimeout && clearTimeout(e.motionBlurTimeout), d && (e.mbFrames == null && (e.mbFrames = 0), e.mbFrames++, e.mbFrames < 3 && (y = !1), e.mbFrames > e.minMbLowQualFrames && (e.motionBlurPxRatio = e.mbPxRBlurry)), e.clearingMotionBlur && (e.motionBlurPxRatio = 1), e.textureDrawLastFrame && !f && (h[e.NODE] = !0, h[e.SELECT_BOX] = !0);
  var b = r.style(), x = r.zoom(), T = s !== void 0 ? s : x, E = r.pan(), A = {
    x: E.x,
    y: E.y
  }, S = {
    zoom: x,
    pan: {
      x: E.x,
      y: E.y
    }
  }, k = e.prevViewport, _ = k === void 0 || S.zoom !== k.zoom || S.pan.x !== k.pan.x || S.pan.y !== k.pan.y;
  !_ && !(m && !g) && (e.motionBlurPxRatio = 1), o && (A = o), T *= l, A.x *= l, A.y *= l;
  var R = e.getCachedZSortedEles();
  function L(J, ee, j, X, re) {
    var Q = J.globalCompositeOperation;
    J.globalCompositeOperation = "destination-out", e.colorFillStyle(J, 255, 255, 255, e.motionBlurTransparency), J.fillRect(ee, j, X, re), J.globalCompositeOperation = Q;
  }
  function M(J, ee) {
    var j, X, re, Q;
    !e.clearingMotionBlur && (J === u.bufferContexts[e.MOTIONBLUR_BUFFER_NODE] || J === u.bufferContexts[e.MOTIONBLUR_BUFFER_DRAG]) ? (j = {
      x: E.x * p,
      y: E.y * p
    }, X = x * p, re = e.canvasWidth * p, Q = e.canvasHeight * p) : (j = A, X = T, re = e.canvasWidth, Q = e.canvasHeight), J.setTransform(1, 0, 0, 1, 0, 0), ee === "motionBlur" ? L(J, 0, 0, re, Q) : !n && (ee === void 0 || ee) && J.clearRect(0, 0, re, Q), i || (J.translate(j.x, j.y), J.scale(X, X)), o && J.translate(o.x, o.y), s && J.scale(s, s);
  }
  if (f || (e.textureDrawLastFrame = !1), f) {
    if (e.textureDrawLastFrame = !0, !e.textureCache) {
      e.textureCache = {}, e.textureCache.bb = r.mutableElements().boundingBox(), e.textureCache.texture = e.data.bufferCanvases[e.TEXTURE_BUFFER];
      var P = e.data.bufferContexts[e.TEXTURE_BUFFER];
      P.setTransform(1, 0, 0, 1, 0, 0), P.clearRect(0, 0, e.canvasWidth * e.textureMult, e.canvasHeight * e.textureMult), e.render({
        forcedContext: P,
        drawOnlyNodeLayer: !0,
        forcedPxRatio: l * e.textureMult
      });
      var S = e.textureCache.viewport = {
        zoom: r.zoom(),
        pan: r.pan(),
        width: e.canvasWidth,
        height: e.canvasHeight
      };
      S.mpan = {
        x: (0 - S.pan.x) / S.zoom,
        y: (0 - S.pan.y) / S.zoom
      };
    }
    h[e.DRAG] = !1, h[e.NODE] = !1;
    var C = u.contexts[e.NODE], I = e.textureCache.texture, S = e.textureCache.viewport;
    C.setTransform(1, 0, 0, 1, 0, 0), d ? L(C, 0, 0, S.width, S.height) : C.clearRect(0, 0, S.width, S.height);
    var N = b.core("outside-texture-bg-color").value, O = b.core("outside-texture-bg-opacity").value;
    e.colorFillStyle(C, N[0], N[1], N[2], O), C.fillRect(0, 0, S.width, S.height);
    var x = r.zoom();
    M(C, !1), C.clearRect(S.mpan.x, S.mpan.y, S.width / S.zoom / l, S.height / S.zoom / l), C.drawImage(I, S.mpan.x, S.mpan.y, S.width / S.zoom / l, S.height / S.zoom / l);
  } else e.textureOnViewport && !n && (e.textureCache = null);
  var D = r.extent(), $ = e.pinching || e.hoverData.dragging || e.swipePanning || e.data.wheelZooming || e.hoverData.draggingEles || e.cy.animated(), z = e.hideEdgesOnViewport && $, B = [];
  if (B[e.NODE] = !h[e.NODE] && d && !e.clearedForMotionBlur[e.NODE] || e.clearingMotionBlur, B[e.NODE] && (e.clearedForMotionBlur[e.NODE] = !0), B[e.DRAG] = !h[e.DRAG] && d && !e.clearedForMotionBlur[e.DRAG] || e.clearingMotionBlur, B[e.DRAG] && (e.clearedForMotionBlur[e.DRAG] = !0), h[e.NODE] || i || a || B[e.NODE]) {
    var G = d && !B[e.NODE] && p !== 1, C = n || (G ? e.data.bufferContexts[e.MOTIONBLUR_BUFFER_NODE] : u.contexts[e.NODE]), W = d && !G ? "motionBlur" : void 0;
    M(C, W), z ? e.drawCachedNodes(C, R.nondrag, l, D) : e.drawLayeredElements(C, R.nondrag, l, D), e.debug && e.drawDebugPoints(C, R.nondrag), !i && !d && (h[e.NODE] = !1);
  }
  if (!a && (h[e.DRAG] || i || B[e.DRAG])) {
    var G = d && !B[e.DRAG] && p !== 1, C = n || (G ? e.data.bufferContexts[e.MOTIONBLUR_BUFFER_DRAG] : u.contexts[e.DRAG]);
    M(C, d && !G ? "motionBlur" : void 0), z ? e.drawCachedNodes(C, R.drag, l, D) : e.drawCachedElements(C, R.drag, l, D), e.debug && e.drawDebugPoints(C, R.drag), !i && !d && (h[e.DRAG] = !1);
  }
  if (this.drawSelectionRectangle(t, M), d && p !== 1) {
    var V = u.contexts[e.NODE], U = e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_NODE], Z = u.contexts[e.DRAG], K = e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_DRAG], ce = function(ee, j, X) {
      ee.setTransform(1, 0, 0, 1, 0, 0), X || !y ? ee.clearRect(0, 0, e.canvasWidth, e.canvasHeight) : L(ee, 0, 0, e.canvasWidth, e.canvasHeight);
      var re = p;
      ee.drawImage(
        j,
        // img
        0,
        0,
        // sx, sy
        e.canvasWidth * re,
        e.canvasHeight * re,
        // sw, sh
        0,
        0,
        // x, y
        e.canvasWidth,
        e.canvasHeight
        // w, h
      );
    };
    (h[e.NODE] || B[e.NODE]) && (ce(V, U, B[e.NODE]), h[e.NODE] = !1), (h[e.DRAG] || B[e.DRAG]) && (ce(Z, K, B[e.DRAG]), h[e.DRAG] = !1);
  }
  e.prevViewport = S, e.clearingMotionBlur && (e.clearingMotionBlur = !1, e.motionBlurCleared = !0, e.motionBlur = !0), d && (e.motionBlurTimeout = setTimeout(function() {
    e.motionBlurTimeout = null, e.clearedForMotionBlur[e.NODE] = !1, e.clearedForMotionBlur[e.DRAG] = !1, e.motionBlur = !1, e.clearingMotionBlur = !f, e.mbFrames = 0, h[e.NODE] = !0, h[e.DRAG] = !0, e.redraw();
  }, PDe)), n || r.emit("render");
};
var yp;
ea.drawSelectionRectangle = function(t, e) {
  var r = this, n = r.cy, i = r.data, a = n.style(), s = t.drawOnlyNodeLayer, o = t.drawAllLayers, l = i.canvasNeedsRedraw, u = t.forcedContext;
  if (r.showFps || !s && l[r.SELECT_BOX] && !o) {
    var h = u || i.contexts[r.SELECT_BOX];
    if (e(h), r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var f = r.cy.zoom(), d = a.core("selection-box-border-width").value / f;
      h.lineWidth = d, h.fillStyle = "rgba(" + a.core("selection-box-color").value[0] + "," + a.core("selection-box-color").value[1] + "," + a.core("selection-box-color").value[2] + "," + a.core("selection-box-opacity").value + ")", h.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]), d > 0 && (h.strokeStyle = "rgba(" + a.core("selection-box-border-color").value[0] + "," + a.core("selection-box-border-color").value[1] + "," + a.core("selection-box-border-color").value[2] + "," + a.core("selection-box-opacity").value + ")", h.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]));
    }
    if (i.bgActivePosistion && !r.hoverData.selecting) {
      var f = r.cy.zoom(), p = i.bgActivePosistion;
      h.fillStyle = "rgba(" + a.core("active-bg-color").value[0] + "," + a.core("active-bg-color").value[1] + "," + a.core("active-bg-color").value[2] + "," + a.core("active-bg-opacity").value + ")", h.beginPath(), h.arc(p.x, p.y, a.core("active-bg-size").pfValue / f, 0, 2 * Math.PI), h.fill();
    }
    var g = r.lastRedrawTime;
    if (r.showFps && g) {
      g = Math.round(g);
      var m = Math.round(1e3 / g), v = "1 frame = " + g + " ms = " + m + " fps";
      if (h.setTransform(1, 0, 0, 1, 0, 0), h.fillStyle = "rgba(255, 0, 0, 0.75)", h.strokeStyle = "rgba(255, 0, 0, 0.75)", h.font = "30px Arial", !yp) {
        var y = h.measureText(v);
        yp = y.actualBoundingBoxAscent;
      }
      h.fillText(v, 0, yp);
      var b = 60;
      h.strokeRect(0, yp + 10, 250, 20), h.fillRect(0, yp + 10, 250 * Math.min(m / b, 1), 20);
    }
    o || (l[r.SELECT_BOX] = !1);
  }
};
function xU(t, e, r) {
  var n = t.createShader(e);
  if (t.shaderSource(n, r), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS))
    throw new Error(t.getShaderInfoLog(n));
  return n;
}
function $De(t, e, r) {
  var n = xU(t, t.VERTEX_SHADER, e), i = xU(t, t.FRAGMENT_SHADER, r), a = t.createProgram();
  if (t.attachShader(a, n), t.attachShader(a, i), t.linkProgram(a), !t.getProgramParameter(a, t.LINK_STATUS))
    throw new Error("Could not initialize shaders");
  return a;
}
function BDe(t, e, r) {
  r === void 0 && (r = e);
  var n = t.makeOffscreenCanvas(e, r), i = n.context = n.getContext("2d");
  return n.clear = function() {
    return i.clearRect(0, 0, n.width, n.height);
  }, n.clear(), n;
}
function $R(t) {
  var e = t.pixelRatio, r = t.cy.zoom(), n = t.cy.pan();
  return {
    zoom: r * e,
    pan: {
      x: n.x * e,
      y: n.y * e
    }
  };
}
function FDe(t) {
  var e = t.pixelRatio, r = t.cy.zoom();
  return r * e;
}
function zDe(t, e, r, n, i) {
  var a = n * r + e.x, s = i * r + e.y;
  return s = Math.round(t.canvasHeight - s), [a, s];
}
function qDe(t) {
  return t.pstyle("background-fill").value !== "solid" || t.pstyle("background-image").strValue !== "none" ? !1 : t.pstyle("border-width").value === 0 || t.pstyle("border-opacity").value === 0 ? !0 : t.pstyle("border-style").value === "solid";
}
function GDe(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function du(t, e, r) {
  var n = t[0] / 255, i = t[1] / 255, a = t[2] / 255, s = e, o = r || new Array(4);
  return o[0] = n * s, o[1] = i * s, o[2] = a * s, o[3] = s, o;
}
function sf(t, e) {
  var r = e || new Array(4);
  return r[0] = (t >> 0 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (t >> 16 & 255) / 255, r[3] = (t >> 24 & 255) / 255, r;
}
function UDe(t) {
  return t[0] + (t[1] << 8) + (t[2] << 16) + (t[3] << 24);
}
function VDe(t, e) {
  var r = t.createTexture();
  return r.buffer = function(n) {
    t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR_MIPMAP_NEAREST), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, n), t.generateMipmap(t.TEXTURE_2D), t.bindTexture(t.TEXTURE_2D, null);
  }, r.deleteTexture = function() {
    t.deleteTexture(r);
  }, r;
}
function oae(t, e) {
  switch (e) {
    case "float":
      return [1, t.FLOAT, 4];
    case "vec2":
      return [2, t.FLOAT, 4];
    case "vec3":
      return [3, t.FLOAT, 4];
    case "vec4":
      return [4, t.FLOAT, 4];
    case "int":
      return [1, t.INT, 4];
    case "ivec2":
      return [2, t.INT, 4];
  }
}
function lae(t, e, r) {
  switch (e) {
    case t.FLOAT:
      return new Float32Array(r);
    case t.INT:
      return new Int32Array(r);
  }
}
function HDe(t, e, r, n, i, a) {
  switch (e) {
    case t.FLOAT:
      return new Float32Array(r.buffer, a * n, i);
    case t.INT:
      return new Int32Array(r.buffer, a * n, i);
  }
}
function WDe(t, e, r, n) {
  var i = oae(t, e), a = Cn(i, 2), s = a[0], o = a[1], l = lae(t, o, n), u = t.createBuffer();
  return t.bindBuffer(t.ARRAY_BUFFER, u), t.bufferData(t.ARRAY_BUFFER, l, t.STATIC_DRAW), o === t.FLOAT ? t.vertexAttribPointer(r, s, o, !1, 0, 0) : o === t.INT && t.vertexAttribIPointer(r, s, o, 0, 0), t.enableVertexAttribArray(r), t.bindBuffer(t.ARRAY_BUFFER, null), u;
}
function Hs(t, e, r, n) {
  var i = oae(t, r), a = Cn(i, 3), s = a[0], o = a[1], l = a[2], u = lae(t, o, e * s), h = s * l, f = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, f), t.bufferData(t.ARRAY_BUFFER, e * h, t.DYNAMIC_DRAW), t.enableVertexAttribArray(n), o === t.FLOAT ? t.vertexAttribPointer(n, s, o, !1, h, 0) : o === t.INT && t.vertexAttribIPointer(n, s, o, h, 0), t.vertexAttribDivisor(n, 1), t.bindBuffer(t.ARRAY_BUFFER, null);
  for (var d = new Array(e), p = 0; p < e; p++)
    d[p] = HDe(t, o, u, h, s, p);
  return f.dataArray = u, f.stride = h, f.size = s, f.getView = function(g) {
    return d[g];
  }, f.setPoint = function(g, m, v) {
    var y = d[g];
    y[0] = m, y[1] = v;
  }, f.bufferSubData = function(g) {
    t.bindBuffer(t.ARRAY_BUFFER, f), g ? t.bufferSubData(t.ARRAY_BUFFER, 0, u, 0, g * s) : t.bufferSubData(t.ARRAY_BUFFER, 0, u);
  }, f;
}
function YDe(t, e, r) {
  for (var n = 9, i = new Float32Array(e * n), a = new Array(e), s = 0; s < e; s++) {
    var o = s * n * 4;
    a[s] = new Float32Array(i.buffer, o, n);
  }
  var l = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, l), t.bufferData(t.ARRAY_BUFFER, i.byteLength, t.DYNAMIC_DRAW);
  for (var u = 0; u < 3; u++) {
    var h = r + u;
    t.enableVertexAttribArray(h), t.vertexAttribPointer(h, 3, t.FLOAT, !1, 36, u * 12), t.vertexAttribDivisor(h, 1);
  }
  return t.bindBuffer(t.ARRAY_BUFFER, null), l.getMatrixView = function(f) {
    return a[f];
  }, l.setData = function(f, d) {
    a[d].set(f, 0);
  }, l.bufferSubData = function() {
    t.bindBuffer(t.ARRAY_BUFFER, l), t.bufferSubData(t.ARRAY_BUFFER, 0, i);
  }, l;
}
function XDe(t) {
  var e = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, e);
  var r = t.createTexture();
  return t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), t.bindFramebuffer(t.FRAMEBUFFER, null), e.setFramebufferAttachmentSizes = function(n, i) {
    t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, n, i, 0, t.RGBA, t.UNSIGNED_BYTE, null);
  }, e;
}
var wU = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var t = 0, e = arguments.length; e--; )
    t += arguments[e] * arguments[e];
  return Math.sqrt(t);
});
function JC() {
  var t = new wU(9);
  return wU != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
}
function TU(t) {
  return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
}
function jDe(t, e, r) {
  var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], h = e[7], f = e[8], d = r[0], p = r[1], g = r[2], m = r[3], v = r[4], y = r[5], b = r[6], x = r[7], T = r[8];
  return t[0] = d * n + p * s + g * u, t[1] = d * i + p * o + g * h, t[2] = d * a + p * l + g * f, t[3] = m * n + v * s + y * u, t[4] = m * i + v * o + y * h, t[5] = m * a + v * l + y * f, t[6] = b * n + x * s + T * u, t[7] = b * i + x * o + T * h, t[8] = b * a + x * l + T * f, t;
}
function Hy(t, e, r) {
  var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], h = e[7], f = e[8], d = r[0], p = r[1];
  return t[0] = n, t[1] = i, t[2] = a, t[3] = s, t[4] = o, t[5] = l, t[6] = d * n + p * s + u, t[7] = d * i + p * o + h, t[8] = d * a + p * l + f, t;
}
function EU(t, e, r) {
  var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], h = e[7], f = e[8], d = Math.sin(r), p = Math.cos(r);
  return t[0] = p * n + d * s, t[1] = p * i + d * o, t[2] = p * a + d * l, t[3] = p * s - d * n, t[4] = p * o - d * i, t[5] = p * l - d * a, t[6] = u, t[7] = h, t[8] = f, t;
}
function _A(t, e, r) {
  var n = r[0], i = r[1];
  return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function KDe(t, e, r) {
  return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
}
var ZDe = /* @__PURE__ */ (function() {
  function t(e, r, n, i) {
    Gc(this, t), this.debugID = Math.floor(Math.random() * 1e4), this.r = e, this.texSize = r, this.texRows = n, this.texHeight = Math.floor(r / n), this.enableWrapping = !0, this.locked = !1, this.texture = null, this.needsBuffer = !0, this.freePointer = {
      x: 0,
      row: 0
    }, this.keyToLocation = /* @__PURE__ */ new Map(), this.canvas = i(e, r, r), this.scratch = i(e, r, this.texHeight, "scratch");
  }
  return Uc(t, [{
    key: "lock",
    value: function() {
      this.locked = !0;
    }
  }, {
    key: "getKeys",
    value: function() {
      return new Set(this.keyToLocation.keys());
    }
  }, {
    key: "getScale",
    value: function(r) {
      var n = r.w, i = r.h, a = this.texHeight, s = this.texSize, o = a / i, l = n * o, u = i * o;
      return l > s && (o = s / n, l = n * o, u = i * o), {
        scale: o,
        texW: l,
        texH: u
      };
    }
  }, {
    key: "draw",
    value: function(r, n, i) {
      var a = this;
      if (this.locked) throw new Error("can't draw, atlas is locked");
      var s = this.texSize, o = this.texRows, l = this.texHeight, u = this.getScale(n), h = u.scale, f = u.texW, d = u.texH, p = function(x, T) {
        if (i && T) {
          var E = T.context, A = x.x, S = x.row, k = A, _ = l * S;
          E.save(), E.translate(k, _), E.scale(h, h), i(E, n), E.restore();
        }
      }, g = [null, null], m = function() {
        p(a.freePointer, a.canvas), g[0] = {
          x: a.freePointer.x,
          y: a.freePointer.row * l,
          w: f,
          h: d
        }, g[1] = {
          // create a second location with a width of 0, for convenience
          x: a.freePointer.x + f,
          y: a.freePointer.row * l,
          w: 0,
          h: d
        }, a.freePointer.x += f, a.freePointer.x == s && (a.freePointer.x = 0, a.freePointer.row++);
      }, v = function() {
        var x = a.scratch, T = a.canvas;
        x.clear(), p({
          x: 0,
          row: 0
        }, x);
        var E = s - a.freePointer.x, A = f - E, S = l;
        {
          var k = a.freePointer.x, _ = a.freePointer.row * l, R = E;
          T.context.drawImage(x, 0, 0, R, S, k, _, R, S), g[0] = {
            x: k,
            y: _,
            w: R,
            h: d
          };
        }
        {
          var L = E, M = (a.freePointer.row + 1) * l, P = A;
          T && T.context.drawImage(x, L, 0, P, S, 0, M, P, S), g[1] = {
            x: 0,
            y: M,
            w: P,
            h: d
          };
        }
        a.freePointer.x = A, a.freePointer.row++;
      }, y = function() {
        a.freePointer.x = 0, a.freePointer.row++;
      };
      if (this.freePointer.x + f <= s)
        m();
      else {
        if (this.freePointer.row >= o - 1)
          return !1;
        this.freePointer.x === s ? (y(), m()) : this.enableWrapping ? v() : (y(), m());
      }
      return this.keyToLocation.set(r, g), this.needsBuffer = !0, g;
    }
  }, {
    key: "getOffsets",
    value: function(r) {
      return this.keyToLocation.get(r);
    }
  }, {
    key: "isEmpty",
    value: function() {
      return this.freePointer.x === 0 && this.freePointer.row === 0;
    }
  }, {
    key: "canFit",
    value: function(r) {
      if (this.locked) return !1;
      var n = this.texSize, i = this.texRows, a = this.getScale(r), s = a.texW;
      return this.freePointer.x + s > n ? this.freePointer.row < i - 1 : !0;
    }
    // called on every frame
  }, {
    key: "bufferIfNeeded",
    value: function(r) {
      this.texture || (this.texture = VDe(r, this.debugID)), this.needsBuffer && (this.texture.buffer(this.canvas), this.needsBuffer = !1, this.locked && (this.canvas = null, this.scratch = null));
    }
  }, {
    key: "dispose",
    value: function() {
      this.texture && (this.texture.deleteTexture(), this.texture = null), this.canvas = null, this.scratch = null, this.locked = !0;
    }
  }]);
})(), QDe = /* @__PURE__ */ (function() {
  function t(e, r, n, i) {
    Gc(this, t), this.r = e, this.texSize = r, this.texRows = n, this.createTextureCanvas = i, this.atlases = [], this.styleKeyToAtlas = /* @__PURE__ */ new Map(), this.markedKeys = /* @__PURE__ */ new Set();
  }
  return Uc(t, [{
    key: "getKeys",
    value: function() {
      return new Set(this.styleKeyToAtlas.keys());
    }
  }, {
    key: "_createAtlas",
    value: function() {
      var r = this.r, n = this.texSize, i = this.texRows, a = this.createTextureCanvas;
      return new ZDe(r, n, i, a);
    }
  }, {
    key: "_getScratchCanvas",
    value: function() {
      if (!this.scratch) {
        var r = this.r, n = this.texSize, i = this.texRows, a = this.createTextureCanvas, s = Math.floor(n / i);
        this.scratch = a(r, n, s, "scratch");
      }
      return this.scratch;
    }
  }, {
    key: "draw",
    value: function(r, n, i) {
      var a = this.styleKeyToAtlas.get(r);
      return a || (a = this.atlases[this.atlases.length - 1], (!a || !a.canFit(n)) && (a && a.lock(), a = this._createAtlas(), this.atlases.push(a)), a.draw(r, n, i), this.styleKeyToAtlas.set(r, a)), a;
    }
  }, {
    key: "getAtlas",
    value: function(r) {
      return this.styleKeyToAtlas.get(r);
    }
  }, {
    key: "hasAtlas",
    value: function(r) {
      return this.styleKeyToAtlas.has(r);
    }
  }, {
    key: "markKeyForGC",
    value: function(r) {
      this.markedKeys.add(r);
    }
  }, {
    key: "gc",
    value: function() {
      var r = this, n = this.markedKeys;
      if (n.size === 0) {
        console.log("nothing to garbage collect");
        return;
      }
      var i = [], a = /* @__PURE__ */ new Map(), s = null, o = ca(this.atlases), l;
      try {
        var u = function() {
          var f = l.value, d = f.getKeys(), p = JDe(n, d);
          if (p.size === 0)
            return i.push(f), d.forEach(function(E) {
              return a.set(E, f);
            }), 1;
          s || (s = r._createAtlas(), i.push(s));
          var g = ca(d), m;
          try {
            for (g.s(); !(m = g.n()).done; ) {
              var v = m.value;
              if (!p.has(v)) {
                var y = f.getOffsets(v), b = Cn(y, 2), x = b[0], T = b[1];
                s.canFit({
                  w: x.w + T.w,
                  h: x.h
                }) || (s.lock(), s = r._createAtlas(), i.push(s)), f.canvas && (r._copyTextureToNewAtlas(v, f, s), a.set(v, s));
              }
            }
          } catch (E) {
            g.e(E);
          } finally {
            g.f();
          }
          f.dispose();
        };
        for (o.s(); !(l = o.n()).done; )
          u();
      } catch (h) {
        o.e(h);
      } finally {
        o.f();
      }
      this.atlases = i, this.styleKeyToAtlas = a, this.markedKeys = /* @__PURE__ */ new Set();
    }
  }, {
    key: "_copyTextureToNewAtlas",
    value: function(r, n, i) {
      var a = n.getOffsets(r), s = Cn(a, 2), o = s[0], l = s[1];
      if (l.w === 0)
        i.draw(r, o, function(d) {
          d.drawImage(n.canvas, o.x, o.y, o.w, o.h, 0, 0, o.w, o.h);
        });
      else {
        var u = this._getScratchCanvas();
        u.clear(), u.context.drawImage(n.canvas, o.x, o.y, o.w, o.h, 0, 0, o.w, o.h), u.context.drawImage(n.canvas, l.x, l.y, l.w, l.h, o.w, 0, l.w, l.h);
        var h = o.w + l.w, f = o.h;
        i.draw(r, {
          w: h,
          h: f
        }, function(d) {
          d.drawImage(
            u,
            0,
            0,
            h,
            f,
            0,
            0,
            h,
            f
            // the destination context has already been translated to the correct position
          );
        });
      }
    }
  }, {
    key: "getCounts",
    value: function() {
      return {
        keyCount: this.styleKeyToAtlas.size,
        atlasCount: new Set(this.styleKeyToAtlas.values()).size
      };
    }
  }]);
})();
function JDe(t, e) {
  return t.intersection ? t.intersection(e) : new Set(Cb(t).filter(function(r) {
    return e.has(r);
  }));
}
var eOe = /* @__PURE__ */ (function() {
  function t(e, r) {
    Gc(this, t), this.r = e, this.globalOptions = r, this.atlasSize = r.webglTexSize, this.maxAtlasesPerBatch = r.webglTexPerBatch, this.renderTypes = /* @__PURE__ */ new Map(), this.collections = /* @__PURE__ */ new Map(), this.typeAndIdToKey = /* @__PURE__ */ new Map();
  }
  return Uc(t, [{
    key: "getAtlasSize",
    value: function() {
      return this.atlasSize;
    }
  }, {
    key: "addAtlasCollection",
    value: function(r, n) {
      var i = this.globalOptions, a = i.webglTexSize, s = i.createTextureCanvas, o = n.texRows, l = this._cacheScratchCanvas(s), u = new QDe(this.r, a, o, l);
      this.collections.set(r, u);
    }
  }, {
    key: "addRenderType",
    value: function(r, n) {
      var i = n.collection;
      if (!this.collections.has(i)) throw new Error("invalid atlas collection name '".concat(i, "'"));
      var a = this.collections.get(i), s = Ut({
        type: r,
        atlasCollection: a
      }, n);
      this.renderTypes.set(r, s);
    }
  }, {
    key: "getRenderTypeOpts",
    value: function(r) {
      return this.renderTypes.get(r);
    }
  }, {
    key: "getAtlasCollection",
    value: function(r) {
      return this.collections.get(r);
    }
  }, {
    key: "_cacheScratchCanvas",
    value: function(r) {
      var n = -1, i = -1, a = null;
      return function(s, o, l, u) {
        return u ? ((!a || o != n || l != i) && (n = o, i = l, a = r(s, o, l)), a) : r(s, o, l);
      };
    }
  }, {
    key: "_key",
    value: function(r, n) {
      return "".concat(r, "-").concat(n);
    }
    /** Marks textues associated with the element for garbage collection. */
  }, {
    key: "invalidate",
    value: function(r) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = i.forceRedraw, s = a === void 0 ? !1 : a, o = i.filterEle, l = o === void 0 ? function() {
        return !0;
      } : o, u = i.filterType, h = u === void 0 ? function() {
        return !0;
      } : u, f = !1, d = !1, p = ca(r), g;
      try {
        for (p.s(); !(g = p.n()).done; ) {
          var m = g.value;
          if (l(m)) {
            var v = ca(this.renderTypes.values()), y;
            try {
              var b = function() {
                var T = y.value, E = T.type;
                if (h(E)) {
                  var A = n.collections.get(T.collection), S = T.getKey(m), k = Array.isArray(S) ? S : [S];
                  if (s)
                    k.forEach(function(M) {
                      return A.markKeyForGC(M);
                    }), d = !0;
                  else {
                    var _ = T.getID ? T.getID(m) : m.id(), R = n._key(E, _), L = n.typeAndIdToKey.get(R);
                    L !== void 0 && !GDe(k, L) && (f = !0, n.typeAndIdToKey.delete(R), L.forEach(function(M) {
                      return A.markKeyForGC(M);
                    }));
                  }
                }
              };
              for (v.s(); !(y = v.n()).done; )
                b();
            } catch (x) {
              v.e(x);
            } finally {
              v.f();
            }
          }
        }
      } catch (x) {
        p.e(x);
      } finally {
        p.f();
      }
      return d && (this.gc(), f = !1), f;
    }
    /** Garbage collect */
  }, {
    key: "gc",
    value: function() {
      var r = ca(this.collections.values()), n;
      try {
        for (r.s(); !(n = r.n()).done; ) {
          var i = n.value;
          i.gc();
        }
      } catch (a) {
        r.e(a);
      } finally {
        r.f();
      }
    }
  }, {
    key: "getOrCreateAtlas",
    value: function(r, n, i, a) {
      var s = this.renderTypes.get(n), o = this.collections.get(s.collection), l = !1, u = o.draw(a, i, function(d) {
        s.drawClipped ? (d.save(), d.beginPath(), d.rect(0, 0, i.w, i.h), d.clip(), s.drawElement(d, r, i, !0, !0), d.restore()) : s.drawElement(d, r, i, !0, !0), l = !0;
      });
      if (l) {
        var h = s.getID ? s.getID(r) : r.id(), f = this._key(n, h);
        this.typeAndIdToKey.has(f) ? this.typeAndIdToKey.get(f).push(a) : this.typeAndIdToKey.set(f, [a]);
      }
      return u;
    }
  }, {
    key: "getAtlasInfo",
    value: function(r, n) {
      var i = this, a = this.renderTypes.get(n), s = a.getKey(r), o = Array.isArray(s) ? s : [s];
      return o.map(function(l) {
        var u = a.getBoundingBox(r, l), h = i.getOrCreateAtlas(r, n, u, l), f = h.getOffsets(l), d = Cn(f, 2), p = d[0], g = d[1];
        return {
          atlas: h,
          tex: p,
          tex1: p,
          tex2: g,
          bb: u
        };
      });
    }
  }, {
    key: "getDebugInfo",
    value: function() {
      var r = [], n = ca(this.collections), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var a = Cn(i.value, 2), s = a[0], o = a[1], l = o.getCounts(), u = l.keyCount, h = l.atlasCount;
          r.push({
            type: s,
            keyCount: u,
            atlasCount: h
          });
        }
      } catch (f) {
        n.e(f);
      } finally {
        n.f();
      }
      return r;
    }
  }]);
})(), tOe = /* @__PURE__ */ (function() {
  function t(e) {
    Gc(this, t), this.globalOptions = e, this.atlasSize = e.webglTexSize, this.maxAtlasesPerBatch = e.webglTexPerBatch, this.batchAtlases = [];
  }
  return Uc(t, [{
    key: "getMaxAtlasesPerBatch",
    value: function() {
      return this.maxAtlasesPerBatch;
    }
  }, {
    key: "getAtlasSize",
    value: function() {
      return this.atlasSize;
    }
  }, {
    key: "getIndexArray",
    value: function() {
      return Array.from({
        length: this.maxAtlasesPerBatch
      }, function(r, n) {
        return n;
      });
    }
  }, {
    key: "startBatch",
    value: function() {
      this.batchAtlases = [];
    }
  }, {
    key: "getAtlasCount",
    value: function() {
      return this.batchAtlases.length;
    }
  }, {
    key: "getAtlases",
    value: function() {
      return this.batchAtlases;
    }
  }, {
    key: "canAddToCurrentBatch",
    value: function(r) {
      return this.batchAtlases.length === this.maxAtlasesPerBatch ? this.batchAtlases.includes(r) : !0;
    }
  }, {
    key: "getAtlasIndexForBatch",
    value: function(r) {
      var n = this.batchAtlases.indexOf(r);
      if (n < 0) {
        if (this.batchAtlases.length === this.maxAtlasesPerBatch)
          throw new Error("cannot add more atlases to batch");
        this.batchAtlases.push(r), n = this.batchAtlases.length - 1;
      }
      return n;
    }
  }]);
})(), rOe = `
  float circleSD(vec2 p, float r) {
    return distance(vec2(0), p) - r; // signed distance
  }
`, nOe = `
  float rectangleSD(vec2 p, vec2 b) {
    vec2 d = abs(p)-b;
    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);
  }
`, iOe = `
  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {
    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;
    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;
    vec2 q = abs(p) - b + cr.x;
    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;
  }
`, aOe = `
  float ellipseSD(vec2 p, vec2 ab) {
    p = abs( p ); // symmetry

    // find root with Newton solver
    vec2 q = ab*(p-ab);
    float w = (q.x<q.y)? 1.570796327 : 0.0;
    for( int i=0; i<5; i++ ) {
      vec2 cs = vec2(cos(w),sin(w));
      vec2 u = ab*vec2( cs.x,cs.y);
      vec2 v = ab*vec2(-cs.y,cs.x);
      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));
    }
    
    // compute final point and distance
    float d = length(p-ab*vec2(cos(w),sin(w)));
    
    // return signed distance
    return (dot(p/ab,p/ab)>1.0) ? d : -d;
  }
`, Vg = {
  SCREEN: {
    name: "screen",
    screen: !0
  },
  PICKING: {
    name: "picking",
    picking: !0
  }
}, Bb = {
  // render the texture just like in RENDER_TARGET.SCREEN mode
  IGNORE: 1,
  // don't render the texture at all
  USE_BB: 2
  // render the bounding box as an opaque rectangle
}, e7 = 0, SU = 1, kU = 2, t7 = 3, of = 4, Bv = 5, bp = 6, xp = 7, sOe = /* @__PURE__ */ (function() {
  function t(e, r, n) {
    Gc(this, t), this.r = e, this.gl = r, this.maxInstances = n.webglBatchSize, this.atlasSize = n.webglTexSize, this.bgColor = n.bgColor, this.debug = n.webglDebug, this.batchDebugInfo = [], n.enableWrapping = !0, n.createTextureCanvas = BDe, this.atlasManager = new eOe(e, n), this.batchManager = new tOe(n), this.simpleShapeOptions = /* @__PURE__ */ new Map(), this.program = this._createShaderProgram(Vg.SCREEN), this.pickingProgram = this._createShaderProgram(Vg.PICKING), this.vao = this._createVAO();
  }
  return Uc(t, [{
    key: "addAtlasCollection",
    value: function(r, n) {
      this.atlasManager.addAtlasCollection(r, n);
    }
    /**
     * @typedef { Object } TextureRenderTypeOpts
     * @property { string } collection - name of atlas collection to render textures to
     * @property { function } getKey - returns the "style key" for an element, may be a single value or an array for multi-line lables
     * @property { function } drawElement - uses a canvas renderer to draw the element to the texture atlas
     * @property { boolean  } drawClipped - if true the context will be clipped to the bounding box before drawElement() is called, may affect performance
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } getRotation
     * @property { function } getRotationPoint
     * @property { function } getRotationOffset
     * @property { function } isVisible - an extra check for visibility in addition to ele.visible()
     * @property { function } getTexPickingMode - returns a value from the TEX_PICKING_MODE enum
     */
    /**
     * @param { string } typeName
     * @param { TextureRenderTypeOpts } opts
     */
  }, {
    key: "addTextureAtlasRenderType",
    value: function(r, n) {
      this.atlasManager.addRenderType(r, n);
    }
    /**
     * @typedef { Object } SimpleShapeRenderTypeOpts
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } isVisible - this is an extra check for visibility in addition to ele.visible()
     * @property { function } isSimple - check if element is a simple shape, or if it needs to fall back to texture rendering
     * @property { ShapeVisualProperties } shapeProps
     */
    /**
     * @typedef { Object } ShapeVisualProperties
     * @property { string } shape
     * @property { string } color
     * @property { string } opacity
     * @property { string } padding
     * @property { string } radius
     * @property { boolean } border
    */
    /**
     * @param { string } typeName
     * @param { SimpleShapeRenderTypeOpts } opts
     */
  }, {
    key: "addSimpleShapeRenderType",
    value: function(r, n) {
      this.simpleShapeOptions.set(r, n);
    }
    /**
     * Inform the atlasManager when element style keys may have changed.
     * The atlasManager can then mark unused textures for "garbage collection".
     */
  }, {
    key: "invalidate",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.type, a = this.atlasManager;
      return i ? a.invalidate(r, {
        filterType: function(o) {
          return o === i;
        },
        forceRedraw: !0
      }) : a.invalidate(r);
    }
    /**
     * Run texture garbage collection.
     */
  }, {
    key: "gc",
    value: function() {
      this.atlasManager.gc();
    }
  }, {
    key: "_createShaderProgram",
    value: function(r) {
      var n = this.gl, i = `#version 300 es
      precision highp float;

      uniform mat3 uPanZoomMatrix;
      uniform int  uAtlasSize;
      
      // instanced
      in vec2 aPosition; // a vertex from the unit square
      
      in mat3 aTransform; // used to transform verticies, eg into a bounding box
      in int aVertType; // the type of thing we are rendering

      // the z-index that is output when using picking mode
      in vec4 aIndex;
      
      // For textures
      in int aAtlasId; // which shader unit/atlas to use
      in vec4 aTex; // x/y/w/h of texture in atlas

      // for edges
      in vec4 aPointAPointB;
      in vec4 aPointCPointD;
      in vec2 aLineWidth; // also used for node border width

      // simple shapes
      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]
      in vec4 aColor; // also used for edges
      in vec4 aBorderColor; // aLineWidth is used for border width

      // output values passed to the fragment shader
      out vec2 vTexCoord;
      out vec4 vColor;
      out vec2 vPosition;
      // flat values are not interpolated
      flat out int vAtlasId; 
      flat out int vVertType;
      flat out vec2 vTopRight;
      flat out vec2 vBotLeft;
      flat out vec4 vCornerRadius;
      flat out vec4 vBorderColor;
      flat out vec2 vBorderWidth;
      flat out vec4 vIndex;
      
      void main(void) {
        int vid = gl_VertexID;
        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below

        if(aVertType == `.concat(e7, `) {
          float texX = aTex.x; // texture coordinates
          float texY = aTex.y;
          float texW = aTex.z;
          float texH = aTex.w;

          if(vid == 1 || vid == 2 || vid == 4) {
            texX += texW;
          }
          if(vid == 2 || vid == 4 || vid == 5) {
            texY += texH;
          }

          float d = float(uAtlasSize);
          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(of, " || aVertType == ").concat(xp, ` 
             || aVertType == `).concat(Bv, " || aVertType == ").concat(bp, `) { // simple shapes

          // the bounding box is needed by the fragment shader
          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat
          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat
          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated

          // calculations are done in the fragment shader, just pass these along
          vColor = aColor;
          vCornerRadius = aCornerRadius;
          vBorderColor = aBorderColor;
          vBorderWidth = aLineWidth;

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(SU, `) {
          vec2 source = aPointAPointB.xy;
          vec2 target = aPointAPointB.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          // stretch the unit square into a long skinny rectangle
          vec2 xBasis = target - source;
          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));
          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;

          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);
          vColor = aColor;
        } 
        else if(aVertType == `).concat(kU, `) {
          vec2 pointA = aPointAPointB.xy;
          vec2 pointB = aPointAPointB.zw;
          vec2 pointC = aPointCPointD.xy;
          vec2 pointD = aPointCPointD.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          vec2 p0, p1, p2, pos;
          if(position.x == 0.0) { // The left side of the unit square
            p0 = pointA;
            p1 = pointB;
            p2 = pointC;
            pos = position;
          } else { // The right side of the unit square, use same approach but flip the geometry upside down
            p0 = pointD;
            p1 = pointC;
            p2 = pointB;
            pos = vec2(0.0, -position.y);
          }

          vec2 p01 = p1 - p0;
          vec2 p12 = p2 - p1;
          vec2 p21 = p1 - p2;

          // Find the normal vector.
          vec2 tangent = normalize(normalize(p12) + normalize(p01));
          vec2 normal = vec2(-tangent.y, tangent.x);

          // Find the vector perpendicular to p0 -> p1.
          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));

          // Determine the bend direction.
          float sigma = sign(dot(p01 + p21, normal));
          float width = aLineWidth[0];

          if(sign(pos.y) == -sigma) {
            // This is an intersecting vertex. Adjust the position so that there's no overlap.
            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          } else {
            // This is a non-intersecting vertex. Treat it like a mitre join.
            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          }

          vColor = aColor;
        } 
        else if(aVertType == `).concat(t7, ` && vid < 3) {
          // massage the first triangle into an edge arrow
          if(vid == 0)
            position = vec2(-0.15, -0.3);
          if(vid == 1)
            position = vec2(  0.0,  0.0);
          if(vid == 2)
            position = vec2( 0.15, -0.3);

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
          vColor = aColor;
        }
        else {
          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space
        }

        vAtlasId = aAtlasId;
        vVertType = aVertType;
        vIndex = aIndex;
      }
    `), a = this.batchManager.getIndexArray(), s = `#version 300 es
      precision highp float;

      // declare texture unit for each texture atlas in the batch
      `.concat(a.map(function(u) {
        return "uniform sampler2D uTexture".concat(u, ";");
      }).join(`
	`), `

      uniform vec4 uBGColor;
      uniform float uZoom;

      in vec2 vTexCoord;
      in vec4 vColor;
      in vec2 vPosition; // model coordinates

      flat in int vAtlasId;
      flat in vec4 vIndex;
      flat in int vVertType;
      flat in vec2 vTopRight;
      flat in vec2 vBotLeft;
      flat in vec4 vCornerRadius;
      flat in vec4 vBorderColor;
      flat in vec2 vBorderWidth;

      out vec4 outColor;

      `).concat(rOe, `
      `).concat(nOe, `
      `).concat(iOe, `
      `).concat(aOe, `

      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha
        return vec4( 
          top.rgb + (bot.rgb * (1.0 - top.a)),
          top.a   + (bot.a   * (1.0 - top.a)) 
        );
      }

      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance
        // scale to the zoom level so that borders don't look blurry when zoomed in
        // note 1.5 is an aribitrary value chosen because it looks good
        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); 
      }

      void main(void) {
        if(vVertType == `).concat(e7, `) {
          // look up the texel from the texture unit
          `).concat(a.map(function(u) {
        return "if(vAtlasId == ".concat(u, ") outColor = texture(uTexture").concat(u, ", vTexCoord);");
      }).join(`
	else `), `
        } 
        else if(vVertType == `).concat(t7, `) {
          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';
          outColor = blend(vColor, uBGColor);
          outColor.a = 1.0; // make opaque, masks out line under arrow
        }
        else if(vVertType == `).concat(of, ` && vBorderWidth == vec2(0.0)) { // simple rectangle with no border
          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done
        }
        else if(vVertType == `).concat(of, " || vVertType == ").concat(xp, ` 
          || vVertType == `).concat(Bv, " || vVertType == ").concat(bp, `) { // use SDF

          float outerBorder = vBorderWidth[0];
          float innerBorder = vBorderWidth[1];
          float borderPadding = outerBorder * 2.0;
          float w = vTopRight.x - vBotLeft.x - borderPadding;
          float h = vTopRight.y - vBotLeft.y - borderPadding;
          vec2 b = vec2(w/2.0, h/2.0); // half width, half height
          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center

          float d; // signed distance
          if(vVertType == `).concat(of, `) {
            d = rectangleSD(p, b);
          } else if(vVertType == `).concat(xp, ` && w == h) {
            d = circleSD(p, b.x); // faster than ellipse
          } else if(vVertType == `).concat(xp, `) {
            d = ellipseSD(p, b);
          } else {
            d = roundRectangleSD(p, b, vCornerRadius.wzyx);
          }

          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling
          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box
          if(d > 0.0) {
            if(d > outerBorder) {
              discard;
            } else {
              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);
            }
          } else {
            if(d > innerBorder) {
              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;
              vec4 innerBorderColor = blend(vBorderColor, vColor);
              outColor = distInterp(innerBorderColor, outerColor, d);
            } 
            else {
              vec4 outerColor;
              if(innerBorder == 0.0 && outerBorder == 0.0) {
                outerColor = vec4(0);
              } else if(innerBorder == 0.0) {
                outerColor = vBorderColor;
              } else {
                outerColor = blend(vBorderColor, vColor);
              }
              outColor = distInterp(vColor, outerColor, d - innerBorder);
            }
          }
        }
        else {
          outColor = vColor;
        }

        `).concat(r.picking ? `if(outColor.a == 0.0) discard;
             else outColor = vIndex;` : "", `
      }
    `), o = $De(n, i, s);
      o.aPosition = n.getAttribLocation(o, "aPosition"), o.aIndex = n.getAttribLocation(o, "aIndex"), o.aVertType = n.getAttribLocation(o, "aVertType"), o.aTransform = n.getAttribLocation(o, "aTransform"), o.aAtlasId = n.getAttribLocation(o, "aAtlasId"), o.aTex = n.getAttribLocation(o, "aTex"), o.aPointAPointB = n.getAttribLocation(o, "aPointAPointB"), o.aPointCPointD = n.getAttribLocation(o, "aPointCPointD"), o.aLineWidth = n.getAttribLocation(o, "aLineWidth"), o.aColor = n.getAttribLocation(o, "aColor"), o.aCornerRadius = n.getAttribLocation(o, "aCornerRadius"), o.aBorderColor = n.getAttribLocation(o, "aBorderColor"), o.uPanZoomMatrix = n.getUniformLocation(o, "uPanZoomMatrix"), o.uAtlasSize = n.getUniformLocation(o, "uAtlasSize"), o.uBGColor = n.getUniformLocation(o, "uBGColor"), o.uZoom = n.getUniformLocation(o, "uZoom"), o.uTextures = [];
      for (var l = 0; l < this.batchManager.getMaxAtlasesPerBatch(); l++)
        o.uTextures.push(n.getUniformLocation(o, "uTexture".concat(l)));
      return o;
    }
  }, {
    key: "_createVAO",
    value: function() {
      var r = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1];
      this.vertexCount = r.length / 2;
      var n = this.maxInstances, i = this.gl, a = this.program, s = i.createVertexArray();
      return i.bindVertexArray(s), WDe(i, "vec2", a.aPosition, r), this.transformBuffer = YDe(i, n, a.aTransform), this.indexBuffer = Hs(i, n, "vec4", a.aIndex), this.vertTypeBuffer = Hs(i, n, "int", a.aVertType), this.atlasIdBuffer = Hs(i, n, "int", a.aAtlasId), this.texBuffer = Hs(i, n, "vec4", a.aTex), this.pointAPointBBuffer = Hs(i, n, "vec4", a.aPointAPointB), this.pointCPointDBuffer = Hs(i, n, "vec4", a.aPointCPointD), this.lineWidthBuffer = Hs(i, n, "vec2", a.aLineWidth), this.colorBuffer = Hs(i, n, "vec4", a.aColor), this.cornerRadiusBuffer = Hs(i, n, "vec4", a.aCornerRadius), this.borderColorBuffer = Hs(i, n, "vec4", a.aBorderColor), i.bindVertexArray(null), s;
    }
  }, {
    key: "buffers",
    get: function() {
      var r = this;
      return this._buffers || (this._buffers = Object.keys(this).filter(function(n) {
        return ec(n, "Buffer");
      }).map(function(n) {
        return r[n];
      })), this._buffers;
    }
  }, {
    key: "startFrame",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Vg.SCREEN;
      this.panZoomMatrix = r, this.renderTarget = n, this.batchDebugInfo = [], this.wrappedCount = 0, this.simpleCount = 0, this.startBatch();
    }
  }, {
    key: "startBatch",
    value: function() {
      this.instanceCount = 0, this.batchManager.startBatch();
    }
  }, {
    key: "endFrame",
    value: function() {
      this.endBatch();
    }
  }, {
    key: "_isVisible",
    value: function(r, n) {
      return r.visible() ? n && n.isVisible ? n.isVisible(r) : !0 : !1;
    }
    /**
     * Draws a texture using the texture atlas.
     */
  }, {
    key: "drawTexture",
    value: function(r, n, i) {
      var a = this.atlasManager, s = this.batchManager, o = a.getRenderTypeOpts(i);
      if (this._isVisible(r, o) && !(r.isEdge() && !this._isValidEdge(r))) {
        if (this.renderTarget.picking && o.getTexPickingMode) {
          var l = o.getTexPickingMode(r);
          if (l === Bb.IGNORE)
            return;
          if (l == Bb.USE_BB) {
            this.drawPickingRectangle(r, n, i);
            return;
          }
        }
        var u = a.getAtlasInfo(r, i), h = ca(u), f;
        try {
          for (h.s(); !(f = h.n()).done; ) {
            var d = f.value, p = d.atlas, g = d.tex1, m = d.tex2;
            s.canAddToCurrentBatch(p) || this.endBatch();
            for (var v = s.getAtlasIndexForBatch(p), y = 0, b = [[g, !0], [m, !1]]; y < b.length; y++) {
              var x = Cn(b[y], 2), T = x[0], E = x[1];
              if (T.w != 0) {
                var A = this.instanceCount;
                this.vertTypeBuffer.getView(A)[0] = e7;
                var S = this.indexBuffer.getView(A);
                sf(n, S);
                var k = this.atlasIdBuffer.getView(A);
                k[0] = v;
                var _ = this.texBuffer.getView(A);
                _[0] = T.x, _[1] = T.y, _[2] = T.w, _[3] = T.h;
                var R = this.transformBuffer.getMatrixView(A);
                this.setTransformMatrix(r, R, o, d, E), this.instanceCount++, E || this.wrappedCount++, this.instanceCount >= this.maxInstances && this.endBatch();
              }
            }
          }
        } catch (L) {
          h.e(L);
        } finally {
          h.f();
        }
      }
    }
    /**
     * matrix is expected to be a 9 element array
     * this function follows same pattern as CRp.drawCachedElementPortion(...)
     */
  }, {
    key: "setTransformMatrix",
    value: function(r, n, i, a) {
      var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, o = 0;
      if (i.shapeProps && i.shapeProps.padding && (o = r.pstyle(i.shapeProps.padding).pfValue), a) {
        var l = a.bb, u = a.tex1, h = a.tex2, f = u.w / (u.w + h.w);
        s || (f = 1 - f);
        var d = this._getAdjustedBB(l, o, s, f);
        this._applyTransformMatrix(n, d, i, r);
      } else {
        var p = i.getBoundingBox(r), g = this._getAdjustedBB(p, o, !0, 1);
        this._applyTransformMatrix(n, g, i, r);
      }
    }
  }, {
    key: "_applyTransformMatrix",
    value: function(r, n, i, a) {
      var s, o;
      TU(r);
      var l = i.getRotation ? i.getRotation(a) : 0;
      if (l !== 0) {
        var u = i.getRotationPoint(a), h = u.x, f = u.y;
        Hy(r, r, [h, f]), EU(r, r, l);
        var d = i.getRotationOffset(a);
        s = d.x + (n.xOffset || 0), o = d.y + (n.yOffset || 0);
      } else
        s = n.x1, o = n.y1;
      Hy(r, r, [s, o]), _A(r, r, [n.w, n.h]);
    }
    /**
     * Adjusts a node or label BB to accomodate padding and split for wrapped textures.
     * @param bb - the original bounding box
     * @param padding - the padding to add to the bounding box
     * @param first - whether this is the first part of a wrapped texture
     * @param ratio - the ratio of the texture width of part of the text to the entire texture
     */
  }, {
    key: "_getAdjustedBB",
    value: function(r, n, i, a) {
      var s = r.x1, o = r.y1, l = r.w, u = r.h, h = r.yOffset;
      n && (s -= n, o -= n, l += 2 * n, u += 2 * n);
      var f = 0, d = l * a;
      return i && a < 1 ? l = d : !i && a < 1 && (f = l - d, s += f, l = d), {
        x1: s,
        y1: o,
        w: l,
        h: u,
        xOffset: f,
        yOffset: h
      };
    }
    /**
     * Draw a solid opaque rectangle matching the element's Bounding Box.
     * Used by the PICKING mode to make the entire BB of a label clickable.
     */
  }, {
    key: "drawPickingRectangle",
    value: function(r, n, i) {
      var a = this.atlasManager.getRenderTypeOpts(i), s = this.instanceCount;
      this.vertTypeBuffer.getView(s)[0] = of;
      var o = this.indexBuffer.getView(s);
      sf(n, o);
      var l = this.colorBuffer.getView(s);
      du([0, 0, 0], 1, l);
      var u = this.transformBuffer.getMatrixView(s);
      this.setTransformMatrix(r, u, a), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
    }
    /**
     * Draw a node using either a texture or a "simple shape".
     */
  }, {
    key: "drawNode",
    value: function(r, n, i) {
      var a = this.simpleShapeOptions.get(i);
      if (this._isVisible(r, a)) {
        var s = a.shapeProps, o = this._getVertTypeForShape(r, s.shape);
        if (o === void 0 || a.isSimple && !a.isSimple(r)) {
          this.drawTexture(r, n, i);
          return;
        }
        var l = this.instanceCount;
        if (this.vertTypeBuffer.getView(l)[0] = o, o === Bv || o === bp) {
          var u = a.getBoundingBox(r), h = this._getCornerRadius(r, s.radius, u), f = this.cornerRadiusBuffer.getView(l);
          f[0] = h, f[1] = h, f[2] = h, f[3] = h, o === bp && (f[0] = 0, f[2] = 0);
        }
        var d = this.indexBuffer.getView(l);
        sf(n, d);
        var p = r.pstyle(s.color).value, g = r.pstyle(s.opacity).value, m = this.colorBuffer.getView(l);
        du(p, g, m);
        var v = this.lineWidthBuffer.getView(l);
        if (v[0] = 0, v[1] = 0, s.border) {
          var y = r.pstyle("border-width").value;
          if (y > 0) {
            var b = r.pstyle("border-color").value, x = r.pstyle("border-opacity").value, T = this.borderColorBuffer.getView(l);
            du(b, x, T);
            var E = r.pstyle("border-position").value;
            if (E === "inside")
              v[0] = 0, v[1] = -y;
            else if (E === "outside")
              v[0] = y, v[1] = 0;
            else {
              var A = y / 2;
              v[0] = A, v[1] = -A;
            }
          }
        }
        var S = this.transformBuffer.getMatrixView(l);
        this.setTransformMatrix(r, S, a), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
      }
    }
  }, {
    key: "_getVertTypeForShape",
    value: function(r, n) {
      var i = r.pstyle(n).value;
      switch (i) {
        case "rectangle":
          return of;
        case "ellipse":
          return xp;
        case "roundrectangle":
        case "round-rectangle":
          return Bv;
        case "bottom-round-rectangle":
          return bp;
        default:
          return;
      }
    }
  }, {
    key: "_getCornerRadius",
    value: function(r, n, i) {
      var a = i.w, s = i.h;
      if (r.pstyle(n).value === "auto")
        return xc(a, s);
      var o = r.pstyle(n).pfValue, l = a / 2, u = s / 2;
      return Math.min(o, u, l);
    }
    /**
     * Only supports drawing triangles at the moment.
     */
  }, {
    key: "drawEdgeArrow",
    value: function(r, n, i) {
      if (r.visible()) {
        var a = r._private.rscratch, s, o, l;
        if (i === "source" ? (s = a.arrowStartX, o = a.arrowStartY, l = a.srcArrowAngle) : (s = a.arrowEndX, o = a.arrowEndY, l = a.tgtArrowAngle), !(isNaN(s) || s == null || isNaN(o) || o == null || isNaN(l) || l == null)) {
          var u = r.pstyle(i + "-arrow-shape").value;
          if (u !== "none") {
            var h = r.pstyle(i + "-arrow-color").value, f = r.pstyle("opacity").value, d = r.pstyle("line-opacity").value, p = f * d, g = r.pstyle("width").pfValue, m = r.pstyle("arrow-scale").value, v = this.r.getArrowWidth(g, m), y = this.instanceCount, b = this.transformBuffer.getMatrixView(y);
            TU(b), Hy(b, b, [s, o]), _A(b, b, [v, v]), EU(b, b, l), this.vertTypeBuffer.getView(y)[0] = t7;
            var x = this.indexBuffer.getView(y);
            sf(n, x);
            var T = this.colorBuffer.getView(y);
            du(h, p, T), this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
          }
        }
      }
    }
    /**
     * Draw straight-line or bezier curve edges.
     */
  }, {
    key: "drawEdgeLine",
    value: function(r, n) {
      if (r.visible()) {
        var i = this._getEdgePoints(r);
        if (i) {
          var a = r.pstyle("opacity").value, s = r.pstyle("line-opacity").value, o = r.pstyle("width").pfValue, l = r.pstyle("line-color").value, u = a * s;
          if (i.length / 2 + this.instanceCount > this.maxInstances && this.endBatch(), i.length == 4) {
            var h = this.instanceCount;
            this.vertTypeBuffer.getView(h)[0] = SU;
            var f = this.indexBuffer.getView(h);
            sf(n, f);
            var d = this.colorBuffer.getView(h);
            du(l, u, d);
            var p = this.lineWidthBuffer.getView(h);
            p[0] = o;
            var g = this.pointAPointBBuffer.getView(h);
            g[0] = i[0], g[1] = i[1], g[2] = i[2], g[3] = i[3], this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
          } else
            for (var m = 0; m < i.length - 2; m += 2) {
              var v = this.instanceCount;
              this.vertTypeBuffer.getView(v)[0] = kU;
              var y = this.indexBuffer.getView(v);
              sf(n, y);
              var b = this.colorBuffer.getView(v);
              du(l, u, b);
              var x = this.lineWidthBuffer.getView(v);
              x[0] = o;
              var T = i[m - 2], E = i[m - 1], A = i[m], S = i[m + 1], k = i[m + 2], _ = i[m + 3], R = i[m + 4], L = i[m + 5];
              m == 0 && (T = 2 * A - k + 1e-3, E = 2 * S - _ + 1e-3), m == i.length - 4 && (R = 2 * k - A + 1e-3, L = 2 * _ - S + 1e-3);
              var M = this.pointAPointBBuffer.getView(v);
              M[0] = T, M[1] = E, M[2] = A, M[3] = S;
              var P = this.pointCPointDBuffer.getView(v);
              P[0] = k, P[1] = _, P[2] = R, P[3] = L, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
            }
        }
      }
    }
  }, {
    key: "_isValidEdge",
    value: function(r) {
      var n = r._private.rscratch;
      return !(n.badLine || n.allpts == null || isNaN(n.allpts[0]));
    }
  }, {
    key: "_getEdgePoints",
    value: function(r) {
      var n = r._private.rscratch;
      if (this._isValidEdge(r)) {
        var i = n.allpts;
        if (i.length == 4)
          return i;
        var a = this._getNumSegments(r);
        return this._getCurveSegmentPoints(i, a);
      }
    }
  }, {
    key: "_getNumSegments",
    value: function(r) {
      var n = 15;
      return Math.min(Math.max(n, 5), this.maxInstances);
    }
  }, {
    key: "_getCurveSegmentPoints",
    value: function(r, n) {
      if (r.length == 4)
        return r;
      for (var i = Array((n + 1) * 2), a = 0; a <= n; a++)
        if (a == 0)
          i[0] = r[0], i[1] = r[1];
        else if (a == n)
          i[a * 2] = r[r.length - 2], i[a * 2 + 1] = r[r.length - 1];
        else {
          var s = a / n;
          this._setCurvePoint(r, s, i, a * 2);
        }
      return i;
    }
  }, {
    key: "_setCurvePoint",
    value: function(r, n, i, a) {
      if (r.length <= 2)
        i[a] = r[0], i[a + 1] = r[1];
      else {
        for (var s = Array(r.length - 2), o = 0; o < s.length; o += 2) {
          var l = (1 - n) * r[o] + n * r[o + 2], u = (1 - n) * r[o + 1] + n * r[o + 3];
          s[o] = l, s[o + 1] = u;
        }
        return this._setCurvePoint(s, n, i, a);
      }
    }
  }, {
    key: "endBatch",
    value: function() {
      var r = this.gl, n = this.vao, i = this.vertexCount, a = this.instanceCount;
      if (a !== 0) {
        var s = this.renderTarget.picking ? this.pickingProgram : this.program;
        r.useProgram(s), r.bindVertexArray(n);
        var o = ca(this.buffers), l;
        try {
          for (o.s(); !(l = o.n()).done; ) {
            var u = l.value;
            u.bufferSubData(a);
          }
        } catch (g) {
          o.e(g);
        } finally {
          o.f();
        }
        for (var h = this.batchManager.getAtlases(), f = 0; f < h.length; f++)
          h[f].bufferIfNeeded(r);
        for (var d = 0; d < h.length; d++)
          r.activeTexture(r.TEXTURE0 + d), r.bindTexture(r.TEXTURE_2D, h[d].texture), r.uniform1i(s.uTextures[d], d);
        r.uniform1f(s.uZoom, FDe(this.r)), r.uniformMatrix3fv(s.uPanZoomMatrix, !1, this.panZoomMatrix), r.uniform1i(s.uAtlasSize, this.batchManager.getAtlasSize());
        var p = du(this.bgColor, 1);
        r.uniform4fv(s.uBGColor, p), r.drawArraysInstanced(r.TRIANGLES, 0, i, a), r.bindVertexArray(null), r.bindTexture(r.TEXTURE_2D, null), this.debug && this.batchDebugInfo.push({
          count: a,
          // instance count
          atlasCount: h.length
        }), this.startBatch();
      }
    }
  }, {
    key: "getDebugInfo",
    value: function() {
      var r = this.atlasManager.getDebugInfo(), n = r.reduce(function(s, o) {
        return s + o.atlasCount;
      }, 0), i = this.batchDebugInfo, a = i.reduce(function(s, o) {
        return s + o.count;
      }, 0);
      return {
        atlasInfo: r,
        totalAtlases: n,
        wrappedCount: this.wrappedCount,
        simpleCount: this.simpleCount,
        batchCount: i.length,
        batchInfo: i,
        totalInstances: a
      };
    }
  }]);
})(), cae = {};
cae.initWebgl = function(t, e) {
  var r = this, n = r.data.contexts[r.WEBGL];
  t.bgColor = oOe(r), t.webglTexSize = Math.min(t.webglTexSize, n.getParameter(n.MAX_TEXTURE_SIZE)), t.webglTexRows = Math.min(t.webglTexRows, 54), t.webglTexRowsNodes = Math.min(t.webglTexRowsNodes, 54), t.webglBatchSize = Math.min(t.webglBatchSize, 16384), t.webglTexPerBatch = Math.min(t.webglTexPerBatch, n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)), r.webglDebug = t.webglDebug, r.webglDebugShowAtlases = t.webglDebugShowAtlases, r.pickingFrameBuffer = XDe(n), r.pickingFrameBuffer.needsDraw = !0, r.drawing = new sOe(r, n, t);
  var i = function(f) {
    return function(d) {
      return r.getTextAngle(d, f);
    };
  }, a = function(f) {
    return function(d) {
      var p = d.pstyle(f);
      return p && p.value;
    };
  }, s = function(f) {
    return function(d) {
      return d.pstyle("".concat(f, "-opacity")).value > 0;
    };
  }, o = function(f) {
    var d = f.pstyle("text-events").strValue === "yes";
    return d ? Bb.USE_BB : Bb.IGNORE;
  }, l = function(f) {
    var d = f.position(), p = d.x, g = d.y, m = f.outerWidth(), v = f.outerHeight();
    return {
      w: m,
      h: v,
      x1: p - m / 2,
      y1: g - v / 2
    };
  };
  r.drawing.addAtlasCollection("node", {
    texRows: t.webglTexRowsNodes
  }), r.drawing.addAtlasCollection("label", {
    texRows: t.webglTexRows
  }), r.drawing.addTextureAtlasRenderType("node-body", {
    collection: "node",
    getKey: e.getStyleKey,
    getBoundingBox: e.getElementBox,
    drawElement: e.drawElement
  }), r.drawing.addSimpleShapeRenderType("node-body", {
    getBoundingBox: l,
    isSimple: qDe,
    shapeProps: {
      shape: "shape",
      color: "background-color",
      opacity: "background-opacity",
      radius: "corner-radius",
      border: !0
    }
  }), r.drawing.addSimpleShapeRenderType("node-overlay", {
    getBoundingBox: l,
    isVisible: s("overlay"),
    shapeProps: {
      shape: "overlay-shape",
      color: "overlay-color",
      opacity: "overlay-opacity",
      padding: "overlay-padding",
      radius: "overlay-corner-radius"
    }
  }), r.drawing.addSimpleShapeRenderType("node-underlay", {
    getBoundingBox: l,
    isVisible: s("underlay"),
    shapeProps: {
      shape: "underlay-shape",
      color: "underlay-color",
      opacity: "underlay-opacity",
      padding: "underlay-padding",
      radius: "underlay-corner-radius"
    }
  }), r.drawing.addTextureAtlasRenderType("label", {
    // node label or edge mid label
    collection: "label",
    getTexPickingMode: o,
    getKey: r7(e.getLabelKey, null),
    getBoundingBox: n7(e.getLabelBox, null),
    drawClipped: !0,
    drawElement: e.drawLabel,
    getRotation: i(null),
    getRotationPoint: e.getLabelRotationPoint,
    getRotationOffset: e.getLabelRotationOffset,
    isVisible: a("label")
  }), r.drawing.addTextureAtlasRenderType("edge-source-label", {
    collection: "label",
    getTexPickingMode: o,
    getKey: r7(e.getSourceLabelKey, "source"),
    getBoundingBox: n7(e.getSourceLabelBox, "source"),
    drawClipped: !0,
    drawElement: e.drawSourceLabel,
    getRotation: i("source"),
    getRotationPoint: e.getSourceLabelRotationPoint,
    getRotationOffset: e.getSourceLabelRotationOffset,
    isVisible: a("source-label")
  }), r.drawing.addTextureAtlasRenderType("edge-target-label", {
    collection: "label",
    getTexPickingMode: o,
    getKey: r7(e.getTargetLabelKey, "target"),
    getBoundingBox: n7(e.getTargetLabelBox, "target"),
    drawClipped: !0,
    drawElement: e.drawTargetLabel,
    getRotation: i("target"),
    getRotationPoint: e.getTargetLabelRotationPoint,
    getRotationOffset: e.getTargetLabelRotationOffset,
    isVisible: a("target-label")
  });
  var u = Em(function() {
    console.log("garbage collect flag set"), r.data.gc = !0;
  }, 1e4);
  r.onUpdateEleCalcs(function(h, f) {
    var d = !1;
    f && f.length > 0 && (d |= r.drawing.invalidate(f)), d && u();
  }), lOe(r);
};
function oOe(t) {
  var e = t.cy.container(), r = e && e.style && e.style.backgroundColor || "white";
  return $ne(r);
}
function uae(t, e) {
  var r = t._private.rscratch;
  return aa(r, "labelWrapCachedLines", e) || [];
}
var r7 = function(e, r) {
  return function(n) {
    var i = e(n), a = uae(n, r);
    return a.length > 1 ? a.map(function(s, o) {
      return "".concat(i, "_").concat(o);
    }) : i;
  };
}, n7 = function(e, r) {
  return function(n, i) {
    var a = e(n);
    if (typeof i == "string") {
      var s = i.indexOf("_");
      if (s > 0) {
        var o = Number(i.substring(s + 1)), l = uae(n, r), u = a.h / l.length, h = u * o, f = a.y1 + h;
        return {
          x1: a.x1,
          w: a.w,
          y1: f,
          h: u,
          yOffset: h
        };
      }
    }
    return a;
  };
};
function lOe(t) {
  {
    var e = t.render;
    t.render = function(a) {
      a = a || {};
      var s = t.cy;
      t.webgl && (s.zoom() > rae ? (cOe(t), e.call(t, a)) : (uOe(t), fae(t, a, Vg.SCREEN)));
    };
  }
  {
    var r = t.matchCanvasSize;
    t.matchCanvasSize = function(a) {
      r.call(t, a), t.pickingFrameBuffer.setFramebufferAttachmentSizes(t.canvasWidth, t.canvasHeight), t.pickingFrameBuffer.needsDraw = !0;
    };
  }
  t.findNearestElements = function(a, s, o, l) {
    return mOe(t, a, s);
  };
  {
    var n = t.invalidateCachedZSortedEles;
    t.invalidateCachedZSortedEles = function() {
      n.call(t), t.pickingFrameBuffer.needsDraw = !0;
    };
  }
  {
    var i = t.notify;
    t.notify = function(a, s) {
      i.call(t, a, s), a === "viewport" || a === "bounds" ? t.pickingFrameBuffer.needsDraw = !0 : a === "background" && t.drawing.invalidate(s, {
        type: "node-body"
      });
    };
  }
}
function cOe(t) {
  var e = t.data.contexts[t.WEBGL];
  e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT);
}
function uOe(t) {
  var e = function(n) {
    n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, t.canvasWidth, t.canvasHeight), n.restore();
  };
  e(t.data.contexts[t.NODE]), e(t.data.contexts[t.DRAG]);
}
function hOe(t) {
  var e = t.canvasWidth, r = t.canvasHeight, n = $R(t), i = n.pan, a = n.zoom, s = JC();
  Hy(s, s, [i.x, i.y]), _A(s, s, [a, a]);
  var o = JC();
  KDe(o, e, r);
  var l = JC();
  return jDe(l, o, s), l;
}
function hae(t, e) {
  var r = t.canvasWidth, n = t.canvasHeight, i = $R(t), a = i.pan, s = i.zoom;
  e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, r, n), e.translate(a.x, a.y), e.scale(s, s);
}
function fOe(t, e) {
  t.drawSelectionRectangle(e, function(r) {
    return hae(t, r);
  });
}
function dOe(t) {
  var e = t.data.contexts[t.NODE];
  e.save(), hae(t, e), e.strokeStyle = "rgba(0, 0, 0, 0.3)", e.beginPath(), e.moveTo(-1e3, 0), e.lineTo(1e3, 0), e.stroke(), e.beginPath(), e.moveTo(0, -1e3), e.lineTo(0, 1e3), e.stroke(), e.restore();
}
function pOe(t) {
  var e = function(i, a, s) {
    for (var o = i.atlasManager.getAtlasCollection(a), l = t.data.contexts[t.NODE], u = o.atlases, h = 0; h < u.length; h++) {
      var f = u[h], d = f.canvas;
      if (d) {
        var p = d.width, g = d.height, m = p * h, v = d.height * s, y = 0.4;
        l.save(), l.scale(y, y), l.drawImage(d, m, v), l.strokeStyle = "black", l.rect(m, v, p, g), l.stroke(), l.restore();
      }
    }
  }, r = 0;
  e(t.drawing, "node", r++), e(t.drawing, "label", r++);
}
function gOe(t, e, r, n, i) {
  var a, s, o, l, u = $R(t), h = u.pan, f = u.zoom;
  {
    var d = zDe(t, h, f, e, r), p = Cn(d, 2), g = p[0], m = p[1], v = 6;
    a = g - v / 2, s = m - v / 2, o = v, l = v;
  }
  if (o === 0 || l === 0)
    return [];
  var y = t.data.contexts[t.WEBGL];
  y.bindFramebuffer(y.FRAMEBUFFER, t.pickingFrameBuffer), t.pickingFrameBuffer.needsDraw && (y.viewport(0, 0, y.canvas.width, y.canvas.height), fae(t, null, Vg.PICKING), t.pickingFrameBuffer.needsDraw = !1);
  var b = o * l, x = new Uint8Array(b * 4);
  y.readPixels(a, s, o, l, y.RGBA, y.UNSIGNED_BYTE, x), y.bindFramebuffer(y.FRAMEBUFFER, null);
  for (var T = /* @__PURE__ */ new Set(), E = 0; E < b; E++) {
    var A = x.slice(E * 4, E * 4 + 4), S = UDe(A) - 1;
    S >= 0 && T.add(S);
  }
  return T;
}
function mOe(t, e, r) {
  var n = gOe(t, e, r), i = t.getCachedZSortedEles(), a, s, o = ca(n), l;
  try {
    for (o.s(); !(l = o.n()).done; ) {
      var u = l.value, h = i[u];
      if (!a && h.isNode() && (a = h), !s && h.isEdge() && (s = h), a && s)
        break;
    }
  } catch (f) {
    o.e(f);
  } finally {
    o.f();
  }
  return [a, s].filter(Boolean);
}
function i7(t, e, r) {
  var n = t.drawing;
  e += 1, r.isNode() ? (n.drawNode(r, e, "node-underlay"), n.drawNode(r, e, "node-body"), n.drawTexture(r, e, "label"), n.drawNode(r, e, "node-overlay")) : (n.drawEdgeLine(r, e), n.drawEdgeArrow(r, e, "source"), n.drawEdgeArrow(r, e, "target"), n.drawTexture(r, e, "label"), n.drawTexture(r, e, "edge-source-label"), n.drawTexture(r, e, "edge-target-label"));
}
function fae(t, e, r) {
  var n;
  t.webglDebug && (n = performance.now());
  var i = t.drawing, a = 0;
  if (r.screen && t.data.canvasNeedsRedraw[t.SELECT_BOX] && fOe(t, e), t.data.canvasNeedsRedraw[t.NODE] || r.picking) {
    var s = t.data.contexts[t.WEBGL];
    r.screen ? (s.clearColor(0, 0, 0, 0), s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA)) : s.disable(s.BLEND), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT), s.viewport(0, 0, s.canvas.width, s.canvas.height);
    var o = hOe(t), l = t.getCachedZSortedEles();
    if (a = l.length, i.startFrame(o, r), r.screen) {
      for (var u = 0; u < l.nondrag.length; u++)
        i7(t, u, l.nondrag[u]);
      for (var h = 0; h < l.drag.length; h++)
        i7(t, h, l.drag[h]);
    } else if (r.picking)
      for (var f = 0; f < l.length; f++)
        i7(t, f, l[f]);
    i.endFrame(), r.screen && t.webglDebugShowAtlases && (dOe(t), pOe(t)), t.data.canvasNeedsRedraw[t.NODE] = !1, t.data.canvasNeedsRedraw[t.DRAG] = !1;
  }
  if (t.webglDebug) {
    var d = performance.now(), p = !1, g = Math.ceil(d - n), m = i.getDebugInfo(), v = ["".concat(a, " elements"), "".concat(m.totalInstances, " instances"), "".concat(m.batchCount, " batches"), "".concat(m.totalAtlases, " atlases"), "".concat(m.wrappedCount, " wrapped textures"), "".concat(m.simpleCount, " simple shapes")].join(", ");
    if (p)
      console.log("WebGL (".concat(r.name, ") - time ").concat(g, "ms, ").concat(v));
    else {
      console.log("WebGL (".concat(r.name, ") - frame time ").concat(g, "ms")), console.log("Totals:"), console.log("  ".concat(v)), console.log("Texture Atlases Used:");
      var y = m.atlasInfo, b = ca(y), x;
      try {
        for (b.s(); !(x = b.n()).done; ) {
          var T = x.value;
          console.log("  ".concat(T.type, ": ").concat(T.keyCount, " keys, ").concat(T.atlasCount, " atlases"));
        }
      } catch (E) {
        b.e(E);
      } finally {
        b.f();
      }
      console.log("");
    }
  }
  t.data.gc && (console.log("Garbage Collect!"), t.data.gc = !1, i.gc());
}
var Wc = {};
Wc.drawPolygonPath = function(t, e, r, n, i, a) {
  var s = n / 2, o = i / 2;
  t.beginPath && t.beginPath(), t.moveTo(e + s * a[0], r + o * a[1]);
  for (var l = 1; l < a.length / 2; l++)
    t.lineTo(e + s * a[l * 2], r + o * a[l * 2 + 1]);
  t.closePath();
};
Wc.drawRoundPolygonPath = function(t, e, r, n, i, a, s) {
  s.forEach(function(o) {
    return Yie(t, o);
  }), t.closePath();
};
Wc.drawRoundRectanglePath = function(t, e, r, n, i, a) {
  var s = n / 2, o = i / 2, l = a === "auto" ? xc(n, i) : Math.min(a, o, s);
  t.beginPath && t.beginPath(), t.moveTo(e, r - o), t.arcTo(e + s, r - o, e + s, r, l), t.arcTo(e + s, r + o, e, r + o, l), t.arcTo(e - s, r + o, e - s, r, l), t.arcTo(e - s, r - o, e, r - o, l), t.lineTo(e, r - o), t.closePath();
};
Wc.drawBottomRoundRectanglePath = function(t, e, r, n, i, a) {
  var s = n / 2, o = i / 2, l = a === "auto" ? xc(n, i) : a;
  t.beginPath && t.beginPath(), t.moveTo(e, r - o), t.lineTo(e + s, r - o), t.lineTo(e + s, r), t.arcTo(e + s, r + o, e, r + o, l), t.arcTo(e - s, r + o, e - s, r, l), t.lineTo(e - s, r - o), t.lineTo(e, r - o), t.closePath();
};
Wc.drawCutRectanglePath = function(t, e, r, n, i, a, s) {
  var o = n / 2, l = i / 2, u = s === "auto" ? ER() : s;
  t.beginPath && t.beginPath(), t.moveTo(e - o + u, r - l), t.lineTo(e + o - u, r - l), t.lineTo(e + o, r - l + u), t.lineTo(e + o, r + l - u), t.lineTo(e + o - u, r + l), t.lineTo(e - o + u, r + l), t.lineTo(e - o, r + l - u), t.lineTo(e - o, r - l + u), t.closePath();
};
Wc.drawBarrelPath = function(t, e, r, n, i) {
  var a = n / 2, s = i / 2, o = e - a, l = e + a, u = r - s, h = r + s, f = dA(n, i), d = f.widthOffset, p = f.heightOffset, g = f.ctrlPtOffsetPct * d;
  t.beginPath && t.beginPath(), t.moveTo(o, u + p), t.lineTo(o, h - p), t.quadraticCurveTo(o + g, h, o + d, h), t.lineTo(l - d, h), t.quadraticCurveTo(l - g, h, l, h - p), t.lineTo(l, u + p), t.quadraticCurveTo(l - g, u, l - d, u), t.lineTo(o + d, u), t.quadraticCurveTo(o + g, u, o, u + p), t.closePath();
};
var CU = Math.sin(0), _U = Math.cos(0), AA = {}, LA = {}, dae = Math.PI / 40;
for (var lf = 0 * Math.PI; lf < 2 * Math.PI; lf += dae)
  AA[lf] = Math.sin(lf), LA[lf] = Math.cos(lf);
Wc.drawEllipsePath = function(t, e, r, n, i) {
  if (t.beginPath && t.beginPath(), t.ellipse)
    t.ellipse(e, r, n / 2, i / 2, 0, 0, 2 * Math.PI);
  else
    for (var a, s, o = n / 2, l = i / 2, u = 0 * Math.PI; u < 2 * Math.PI; u += dae)
      a = e - o * AA[u] * CU + o * LA[u] * _U, s = r + l * LA[u] * CU + l * AA[u] * _U, u === 0 ? t.moveTo(a, s) : t.lineTo(a, s);
  t.closePath();
};
var Lm = {};
Lm.createBuffer = function(t, e) {
  var r = document.createElement("canvas");
  return r.width = t, r.height = e, [r, r.getContext("2d")];
};
Lm.bufferCanvasImage = function(t) {
  var e = this.cy, r = e.mutableElements(), n = r.boundingBox(), i = this.findContainerClientCoords(), a = t.full ? Math.ceil(n.w) : i[2], s = t.full ? Math.ceil(n.h) : i[3], o = mt(t.maxWidth) || mt(t.maxHeight), l = this.getPixelRatio(), u = 1;
  if (t.scale !== void 0)
    a *= t.scale, s *= t.scale, u = t.scale;
  else if (o) {
    var h = 1 / 0, f = 1 / 0;
    mt(t.maxWidth) && (h = u * t.maxWidth / a), mt(t.maxHeight) && (f = u * t.maxHeight / s), u = Math.min(h, f), a *= u, s *= u;
  }
  o || (a *= l, s *= l, u *= l);
  var d = document.createElement("canvas");
  d.width = a, d.height = s, d.style.width = a + "px", d.style.height = s + "px";
  var p = d.getContext("2d");
  if (a > 0 && s > 0) {
    p.clearRect(0, 0, a, s), p.globalCompositeOperation = "source-over";
    var g = this.getCachedZSortedEles();
    if (t.full)
      p.translate(-n.x1 * u, -n.y1 * u), p.scale(u, u), this.drawElements(p, g), p.scale(1 / u, 1 / u), p.translate(n.x1 * u, n.y1 * u);
    else {
      var m = e.pan(), v = {
        x: m.x * u,
        y: m.y * u
      };
      u *= e.zoom(), p.translate(v.x, v.y), p.scale(u, u), this.drawElements(p, g), p.scale(1 / u, 1 / u), p.translate(-v.x, -v.y);
    }
    t.bg && (p.globalCompositeOperation = "destination-over", p.fillStyle = t.bg, p.rect(0, 0, a, s), p.fill());
  }
  return d;
};
function vOe(t, e) {
  for (var r = atob(t), n = new ArrayBuffer(r.length), i = new Uint8Array(n), a = 0; a < r.length; a++)
    i[a] = r.charCodeAt(a);
  return new Blob([n], {
    type: e
  });
}
function AU(t) {
  var e = t.indexOf(",");
  return t.substr(e + 1);
}
function pae(t, e, r) {
  var n = function() {
    return e.toDataURL(r, t.quality);
  };
  switch (t.output) {
    case "blob-promise":
      return new G0(function(i, a) {
        try {
          e.toBlob(function(s) {
            s != null ? i(s) : a(new Error("`canvas.toBlob()` sent a null value in its callback"));
          }, r, t.quality);
        } catch (s) {
          a(s);
        }
      });
    case "blob":
      return vOe(AU(n()), r);
    case "base64":
      return AU(n());
    case "base64uri":
    default:
      return n();
  }
}
Lm.png = function(t) {
  return pae(t, this.bufferCanvasImage(t), "image/png");
};
Lm.jpg = function(t) {
  return pae(t, this.bufferCanvasImage(t), "image/jpeg");
};
var gae = {};
gae.nodeShapeImpl = function(t, e, r, n, i, a, s, o) {
  switch (t) {
    case "ellipse":
      return this.drawEllipsePath(e, r, n, i, a);
    case "polygon":
      return this.drawPolygonPath(e, r, n, i, a, s);
    case "round-polygon":
      return this.drawRoundPolygonPath(e, r, n, i, a, s, o);
    case "roundrectangle":
    case "round-rectangle":
      return this.drawRoundRectanglePath(e, r, n, i, a, o);
    case "cutrectangle":
    case "cut-rectangle":
      return this.drawCutRectanglePath(e, r, n, i, a, s, o);
    case "bottomroundrectangle":
    case "bottom-round-rectangle":
      return this.drawBottomRoundRectanglePath(e, r, n, i, a, o);
    case "barrel":
      return this.drawBarrelPath(e, r, n, i, a);
  }
};
var yOe = mae, rr = mae.prototype;
rr.CANVAS_LAYERS = 3;
rr.SELECT_BOX = 0;
rr.DRAG = 1;
rr.NODE = 2;
rr.WEBGL = 3;
rr.CANVAS_TYPES = ["2d", "2d", "2d", "webgl2"];
rr.BUFFER_COUNT = 3;
rr.TEXTURE_BUFFER = 0;
rr.MOTIONBLUR_BUFFER_NODE = 1;
rr.MOTIONBLUR_BUFFER_DRAG = 2;
function mae(t) {
  var e = this, r = e.cy.window(), n = r.document;
  t.webgl && (rr.CANVAS_LAYERS = e.CANVAS_LAYERS = 4, console.log("webgl rendering enabled")), e.data = {
    canvases: new Array(rr.CANVAS_LAYERS),
    contexts: new Array(rr.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(rr.CANVAS_LAYERS),
    bufferCanvases: new Array(rr.BUFFER_COUNT),
    bufferContexts: new Array(rr.CANVAS_LAYERS)
  };
  var i = "-webkit-tap-highlight-color", a = "rgba(0,0,0,0)";
  e.data.canvasContainer = n.createElement("div");
  var s = e.data.canvasContainer.style;
  e.data.canvasContainer.style[i] = a, s.position = "relative", s.zIndex = "0", s.overflow = "hidden";
  var o = t.cy.container();
  o.appendChild(e.data.canvasContainer), o.style[i] = a;
  var l = {
    "-webkit-user-select": "none",
    "-moz-user-select": "-moz-none",
    "user-select": "none",
    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
    "outline-style": "none"
  };
  fLe() && (l["-ms-touch-action"] = "none", l["touch-action"] = "none");
  for (var u = 0; u < rr.CANVAS_LAYERS; u++) {
    var h = e.data.canvases[u] = n.createElement("canvas"), f = rr.CANVAS_TYPES[u];
    e.data.contexts[u] = h.getContext(f), e.data.contexts[u] || Jr("Could not create canvas of type " + f), Object.keys(l).forEach(function(J) {
      h.style[J] = l[J];
    }), h.style.position = "absolute", h.setAttribute("data-id", "layer" + u), h.style.zIndex = String(rr.CANVAS_LAYERS - u), e.data.canvasContainer.appendChild(h), e.data.canvasNeedsRedraw[u] = !1;
  }
  e.data.topCanvas = e.data.canvases[0], e.data.canvases[rr.NODE].setAttribute("data-id", "layer" + rr.NODE + "-node"), e.data.canvases[rr.SELECT_BOX].setAttribute("data-id", "layer" + rr.SELECT_BOX + "-selectbox"), e.data.canvases[rr.DRAG].setAttribute("data-id", "layer" + rr.DRAG + "-drag"), e.data.canvases[rr.WEBGL] && e.data.canvases[rr.WEBGL].setAttribute("data-id", "layer" + rr.WEBGL + "-webgl");
  for (var u = 0; u < rr.BUFFER_COUNT; u++)
    e.data.bufferCanvases[u] = n.createElement("canvas"), e.data.bufferContexts[u] = e.data.bufferCanvases[u].getContext("2d"), e.data.bufferCanvases[u].style.position = "absolute", e.data.bufferCanvases[u].setAttribute("data-id", "buffer" + u), e.data.bufferCanvases[u].style.zIndex = String(-u - 1), e.data.bufferCanvases[u].style.visibility = "hidden";
  e.pathsEnabled = !0;
  var d = ji(), p = function(ee) {
    return {
      x: (ee.x1 + ee.x2) / 2,
      y: (ee.y1 + ee.y2) / 2
    };
  }, g = function(ee) {
    return {
      x: -ee.w / 2,
      y: -ee.h / 2
    };
  }, m = function(ee) {
    var j = ee[0]._private, X = j.oldBackgroundTimestamp === j.backgroundTimestamp;
    return !X;
  }, v = function(ee) {
    return ee[0]._private.nodeKey;
  }, y = function(ee) {
    return ee[0]._private.labelStyleKey;
  }, b = function(ee) {
    return ee[0]._private.sourceLabelStyleKey;
  }, x = function(ee) {
    return ee[0]._private.targetLabelStyleKey;
  }, T = function(ee, j, X, re, Q) {
    return e.drawElement(ee, j, X, !1, !1, Q);
  }, E = function(ee, j, X, re, Q) {
    return e.drawElementText(ee, j, X, re, "main", Q);
  }, A = function(ee, j, X, re, Q) {
    return e.drawElementText(ee, j, X, re, "source", Q);
  }, S = function(ee, j, X, re, Q) {
    return e.drawElementText(ee, j, X, re, "target", Q);
  }, k = function(ee) {
    return ee.boundingBox(), ee[0]._private.bodyBounds;
  }, _ = function(ee) {
    return ee.boundingBox(), ee[0]._private.labelBounds.main || d;
  }, R = function(ee) {
    return ee.boundingBox(), ee[0]._private.labelBounds.source || d;
  }, L = function(ee) {
    return ee.boundingBox(), ee[0]._private.labelBounds.target || d;
  }, M = function(ee, j) {
    return j;
  }, P = function(ee) {
    return p(k(ee));
  }, C = function(ee, j, X) {
    var re = ee ? ee + "-" : "";
    return {
      x: j.x + X.pstyle(re + "text-margin-x").pfValue,
      y: j.y + X.pstyle(re + "text-margin-y").pfValue
    };
  }, I = function(ee, j, X) {
    var re = ee[0]._private.rscratch;
    return {
      x: re[j],
      y: re[X]
    };
  }, N = function(ee) {
    return C("", I(ee, "labelX", "labelY"), ee);
  }, O = function(ee) {
    return C("source", I(ee, "sourceLabelX", "sourceLabelY"), ee);
  }, D = function(ee) {
    return C("target", I(ee, "targetLabelX", "targetLabelY"), ee);
  }, $ = function(ee) {
    return g(k(ee));
  }, z = function(ee) {
    return g(R(ee));
  }, B = function(ee) {
    return g(L(ee));
  }, G = function(ee) {
    var j = _(ee), X = g(_(ee));
    if (ee.isNode()) {
      switch (ee.pstyle("text-halign").value) {
        case "left":
          X.x = -j.w - (j.leftPad || 0);
          break;
        case "right":
          X.x = -(j.rightPad || 0);
          break;
      }
      switch (ee.pstyle("text-valign").value) {
        case "top":
          X.y = -j.h - (j.topPad || 0);
          break;
        case "bottom":
          X.y = -(j.botPad || 0);
          break;
      }
    }
    return X;
  }, W = e.data.eleTxrCache = new Vp(e, {
    getKey: v,
    doesEleInvalidateKey: m,
    drawElement: T,
    getBoundingBox: k,
    getRotationPoint: P,
    getRotationOffset: $,
    allowEdgeTxrCaching: !1,
    allowParentTxrCaching: !1
  }), V = e.data.lblTxrCache = new Vp(e, {
    getKey: y,
    drawElement: E,
    getBoundingBox: _,
    getRotationPoint: N,
    getRotationOffset: G,
    isVisible: M
  }), U = e.data.slbTxrCache = new Vp(e, {
    getKey: b,
    drawElement: A,
    getBoundingBox: R,
    getRotationPoint: O,
    getRotationOffset: z,
    isVisible: M
  }), Z = e.data.tlbTxrCache = new Vp(e, {
    getKey: x,
    drawElement: S,
    getBoundingBox: L,
    getRotationPoint: D,
    getRotationOffset: B,
    isVisible: M
  }), K = e.data.lyrTxrCache = new nae(e);
  e.onUpdateEleCalcs(function(ee, j) {
    W.invalidateElements(j), V.invalidateElements(j), U.invalidateElements(j), Z.invalidateElements(j), K.invalidateElements(j);
    for (var X = 0; X < j.length; X++) {
      var re = j[X]._private;
      re.oldBackgroundTimestamp = re.backgroundTimestamp;
    }
  });
  var ce = function(ee) {
    for (var j = 0; j < ee.length; j++)
      K.enqueueElementRefinement(ee[j].ele);
  };
  W.onDequeue(ce), V.onDequeue(ce), U.onDequeue(ce), Z.onDequeue(ce), t.webgl && e.initWebgl(t, {
    getStyleKey: v,
    getLabelKey: y,
    getSourceLabelKey: b,
    getTargetLabelKey: x,
    drawElement: T,
    drawLabel: E,
    drawSourceLabel: A,
    drawTargetLabel: S,
    getElementBox: k,
    getLabelBox: _,
    getSourceLabelBox: R,
    getTargetLabelBox: L,
    getElementRotationPoint: P,
    getElementRotationOffset: $,
    getLabelRotationPoint: N,
    getSourceLabelRotationPoint: O,
    getTargetLabelRotationPoint: D,
    getLabelRotationOffset: G,
    getSourceLabelRotationOffset: z,
    getTargetLabelRotationOffset: B
  });
}
rr.redrawHint = function(t, e) {
  var r = this;
  switch (t) {
    case "eles":
      r.data.canvasNeedsRedraw[rr.NODE] = e;
      break;
    case "drag":
      r.data.canvasNeedsRedraw[rr.DRAG] = e;
      break;
    case "select":
      r.data.canvasNeedsRedraw[rr.SELECT_BOX] = e;
      break;
    case "gc":
      r.data.gc = !0;
      break;
  }
};
var bOe = typeof Path2D < "u";
rr.path2dEnabled = function(t) {
  if (t === void 0)
    return this.pathsEnabled;
  this.pathsEnabled = !!t;
};
rr.usePaths = function() {
  return bOe && this.pathsEnabled;
};
rr.setImgSmoothing = function(t, e) {
  t.imageSmoothingEnabled != null ? t.imageSmoothingEnabled = e : (t.webkitImageSmoothingEnabled = e, t.mozImageSmoothingEnabled = e, t.msImageSmoothingEnabled = e);
};
rr.getImgSmoothing = function(t) {
  return t.imageSmoothingEnabled != null ? t.imageSmoothingEnabled : t.webkitImageSmoothingEnabled || t.mozImageSmoothingEnabled || t.msImageSmoothingEnabled;
};
rr.makeOffscreenCanvas = function(t, e) {
  var r;
  if ((typeof OffscreenCanvas > "u" ? "undefined" : Vn(OffscreenCanvas)) !== "undefined")
    r = new OffscreenCanvas(t, e);
  else {
    var n = this.cy.window(), i = n.document;
    r = i.createElement("canvas"), r.width = t, r.height = e;
  }
  return r;
};
[iae, _o, Il, PR, Dh, Hc, ea, cae, Wc, Lm, gae].forEach(function(t) {
  Ut(rr, t);
});
var xOe = [{
  name: "null",
  impl: Vie
}, {
  name: "base",
  impl: eae
}, {
  name: "canvas",
  impl: yOe
}], wOe = [{
  type: "layout",
  extensions: WNe
}, {
  type: "renderer",
  extensions: xOe
}], vae = {}, yae = {};
function bae(t, e, r) {
  var n = r, i = function(k) {
    Rr("Can not register `" + e + "` for `" + t + "` since `" + k + "` already exists in the prototype and can not be overridden");
  };
  if (t === "core") {
    if (R1.prototype[e])
      return i(e);
    R1.prototype[e] = r;
  } else if (t === "collection") {
    if (pi.prototype[e])
      return i(e);
    pi.prototype[e] = r;
  } else if (t === "layout") {
    for (var a = function(k) {
      this.options = k, r.call(this, k), yr(this._private) || (this._private = {}), this._private.cy = k.cy, this._private.listeners = [], this.createEmitter();
    }, s = a.prototype = Object.create(r.prototype), o = [], l = 0; l < o.length; l++) {
      var u = o[l];
      s[u] = s[u] || function() {
        return this;
      };
    }
    s.start && !s.run ? s.run = function() {
      return this.start(), this;
    } : !s.start && s.run && (s.start = function() {
      return this.run(), this;
    });
    var h = r.prototype.stop;
    s.stop = function() {
      var S = this.options;
      if (S && S.animate) {
        var k = this.animations;
        if (k)
          for (var _ = 0; _ < k.length; _++)
            k[_].stop();
      }
      return h ? h.call(this) : this.emit("layoutstop"), this;
    }, s.destroy || (s.destroy = function() {
      return this;
    }), s.cy = function() {
      return this._private.cy;
    };
    var f = function(k) {
      return k._private.cy;
    }, d = {
      addEventFields: function(k, _) {
        _.layout = k, _.cy = f(k), _.target = k;
      },
      bubble: function() {
        return !0;
      },
      parent: function(k) {
        return f(k);
      }
    };
    Ut(s, {
      createEmitter: function() {
        return this._private.emitter = new n3(d, this), this;
      },
      emitter: function() {
        return this._private.emitter;
      },
      on: function(k, _) {
        return this.emitter().on(k, _), this;
      },
      one: function(k, _) {
        return this.emitter().one(k, _), this;
      },
      once: function(k, _) {
        return this.emitter().one(k, _), this;
      },
      removeListener: function(k, _) {
        return this.emitter().removeListener(k, _), this;
      },
      removeAllListeners: function() {
        return this.emitter().removeAllListeners(), this;
      },
      emit: function(k, _) {
        return this.emitter().emit(k, _), this;
      }
    }), Ar.eventAliasesOn(s), n = a;
  } else if (t === "renderer" && e !== "null" && e !== "base") {
    var p = xae("renderer", "base"), g = p.prototype, m = r, v = r.prototype, y = function() {
      p.apply(this, arguments), m.apply(this, arguments);
    }, b = y.prototype;
    for (var x in g) {
      var T = g[x], E = v[x] != null;
      if (E)
        return i(x);
      b[x] = T;
    }
    for (var A in v)
      b[A] = v[A];
    g.clientFunctions.forEach(function(S) {
      b[S] = b[S] || function() {
        Jr("Renderer does not implement `renderer." + S + "()` on its prototype");
      };
    }), n = y;
  } else if (t === "__proto__" || t === "constructor" || t === "prototype")
    return Jr(t + " is an illegal type to be registered, possibly lead to prototype pollutions");
  return Bne({
    map: vae,
    keys: [t, e],
    value: n
  });
}
function xae(t, e) {
  return Fne({
    map: vae,
    keys: [t, e]
  });
}
function TOe(t, e, r, n, i) {
  return Bne({
    map: yae,
    keys: [t, e, r, n],
    value: i
  });
}
function EOe(t, e, r, n) {
  return Fne({
    map: yae,
    keys: [t, e, r, n]
  });
}
var RA = function() {
  if (arguments.length === 2)
    return xae.apply(null, arguments);
  if (arguments.length === 3)
    return bae.apply(null, arguments);
  if (arguments.length === 4)
    return EOe.apply(null, arguments);
  if (arguments.length === 5)
    return TOe.apply(null, arguments);
  Jr("Invalid extension access syntax");
};
R1.prototype.extension = RA;
wOe.forEach(function(t) {
  t.extensions.forEach(function(e) {
    bae(t.type, e.name, e.impl);
  });
});
var Fb = function() {
  if (!(this instanceof Fb))
    return new Fb();
  this.length = 0;
}, ah = Fb.prototype;
ah.instanceString = function() {
  return "stylesheet";
};
ah.selector = function(t) {
  var e = this.length++;
  return this[e] = {
    selector: t,
    properties: []
  }, this;
};
ah.css = function(t, e) {
  var r = this.length - 1;
  if (Pt(t))
    this[r].properties.push({
      name: t,
      value: e
    });
  else if (yr(t))
    for (var n = t, i = Object.keys(n), a = 0; a < i.length; a++) {
      var s = i[a], o = n[s];
      if (o != null) {
        var l = Jn.properties[s] || Jn.properties[Y4(s)];
        if (l != null) {
          var u = l.name, h = o;
          this[r].properties.push({
            name: u,
            value: h
          });
        }
      }
    }
  return this;
};
ah.style = ah.css;
ah.generateStyle = function(t) {
  var e = new Jn(t);
  return this.appendToStyle(e);
};
ah.appendToStyle = function(t) {
  for (var e = 0; e < this.length; e++) {
    var r = this[e], n = r.selector, i = r.properties;
    t.selector(n);
    for (var a = 0; a < i.length; a++) {
      var s = i[a];
      t.css(s.name, s.value);
    }
  }
  return t;
};
var SOe = "3.33.1", yo = function(e) {
  if (e === void 0 && (e = {}), yr(e))
    return new R1(e);
  if (Pt(e))
    return RA.apply(RA, arguments);
};
yo.use = function(t) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.unshift(yo), t.apply(null, e), this;
};
yo.warnings = function(t) {
  return Wne(t);
};
yo.version = SOe;
yo.stylesheet = yo.Stylesheet = Fb;
var Wy = { exports: {} }, Yy = { exports: {} }, Xy = { exports: {} }, kOe = Xy.exports, LU;
function COe() {
  return LU || (LU = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i();
    })(kOe, function() {
      return (
        /******/
        (function(r) {
          var n = {};
          function i(a) {
            if (n[a])
              return n[a].exports;
            var s = n[a] = {
              /******/
              i: a,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return r[a].call(s.exports, s, s.exports, i), s.l = !0, s.exports;
          }
          return i.m = r, i.c = n, i.i = function(a) {
            return a;
          }, i.d = function(a, s, o) {
            i.o(a, s) || Object.defineProperty(a, s, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: o
              /******/
            });
          }, i.n = function(a) {
            var s = a && a.__esModule ? (
              /******/
              function() {
                return a.default;
              }
            ) : (
              /******/
              function() {
                return a;
              }
            );
            return i.d(s, "a", s), s;
          }, i.o = function(a, s) {
            return Object.prototype.hasOwnProperty.call(a, s);
          }, i.p = "", i(i.s = 26);
        })([
          /* 0 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.QUALITY = 1, a.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, a.DEFAULT_INCREMENTAL = !1, a.DEFAULT_ANIMATION_ON_LAYOUT = !0, a.DEFAULT_ANIMATION_DURING_LAYOUT = !1, a.DEFAULT_ANIMATION_PERIOD = 50, a.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, a.DEFAULT_GRAPH_MARGIN = 15, a.NODE_DIMENSIONS_INCLUDE_LABELS = !1, a.SIMPLE_NODE_SIZE = 40, a.SIMPLE_NODE_HALF_SIZE = a.SIMPLE_NODE_SIZE / 2, a.EMPTY_COMPOUND_NODE_SIZE = 40, a.MIN_EDGE_LENGTH = 1, a.WORLD_BOUNDARY = 1e6, a.INITIAL_WORLD_BOUNDARY = a.WORLD_BOUNDARY / 1e3, a.WORLD_CENTER_X = 1200, a.WORLD_CENTER_Y = 900, r.exports = a;
          }),
          /* 1 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(8), o = i(9);
            function l(h, f, d) {
              a.call(this, d), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = d, this.bendpoints = [], this.source = h, this.target = f;
            }
            l.prototype = Object.create(a.prototype);
            for (var u in a)
              l[u] = a[u];
            l.prototype.getSource = function() {
              return this.source;
            }, l.prototype.getTarget = function() {
              return this.target;
            }, l.prototype.isInterGraph = function() {
              return this.isInterGraph;
            }, l.prototype.getLength = function() {
              return this.length;
            }, l.prototype.isOverlapingSourceAndTarget = function() {
              return this.isOverlapingSourceAndTarget;
            }, l.prototype.getBendpoints = function() {
              return this.bendpoints;
            }, l.prototype.getLca = function() {
              return this.lca;
            }, l.prototype.getSourceInLca = function() {
              return this.sourceInLca;
            }, l.prototype.getTargetInLca = function() {
              return this.targetInLca;
            }, l.prototype.getOtherEnd = function(h) {
              if (this.source === h)
                return this.target;
              if (this.target === h)
                return this.source;
              throw "Node is not incident with this edge";
            }, l.prototype.getOtherEndInGraph = function(h, f) {
              for (var d = this.getOtherEnd(h), p = f.getGraphManager().getRoot(); ; ) {
                if (d.getOwner() == f)
                  return d;
                if (d.getOwner() == p)
                  break;
                d = d.getOwner().getParent();
              }
              return null;
            }, l.prototype.updateLength = function() {
              var h = new Array(4);
              this.isOverlapingSourceAndTarget = s.getIntersection(this.target.getRect(), this.source.getRect(), h), this.isOverlapingSourceAndTarget || (this.lengthX = h[0] - h[2], this.lengthY = h[1] - h[3], Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
            }, l.prototype.updateLengthSimple = function() {
              this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            }, r.exports = l;
          }),
          /* 2 */
          /***/
          (function(r, n, i) {
            function a(s) {
              this.vGraphObject = s;
            }
            r.exports = a;
          }),
          /* 3 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(13), l = i(0), u = i(16), h = i(4);
            function f(p, g, m, v) {
              m == null && v == null && (v = g), a.call(this, v), p.graphManager != null && (p = p.graphManager), this.estimatedSize = s.MIN_VALUE, this.inclusionTreeDepth = s.MAX_VALUE, this.vGraphObject = v, this.edges = [], this.graphManager = p, m != null && g != null ? this.rect = new o(g.x, g.y, m.width, m.height) : this.rect = new o();
            }
            f.prototype = Object.create(a.prototype);
            for (var d in a)
              f[d] = a[d];
            f.prototype.getEdges = function() {
              return this.edges;
            }, f.prototype.getChild = function() {
              return this.child;
            }, f.prototype.getOwner = function() {
              return this.owner;
            }, f.prototype.getWidth = function() {
              return this.rect.width;
            }, f.prototype.setWidth = function(p) {
              this.rect.width = p;
            }, f.prototype.getHeight = function() {
              return this.rect.height;
            }, f.prototype.setHeight = function(p) {
              this.rect.height = p;
            }, f.prototype.getCenterX = function() {
              return this.rect.x + this.rect.width / 2;
            }, f.prototype.getCenterY = function() {
              return this.rect.y + this.rect.height / 2;
            }, f.prototype.getCenter = function() {
              return new h(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            }, f.prototype.getLocation = function() {
              return new h(this.rect.x, this.rect.y);
            }, f.prototype.getRect = function() {
              return this.rect;
            }, f.prototype.getDiagonal = function() {
              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            }, f.prototype.getHalfTheDiagonal = function() {
              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            }, f.prototype.setRect = function(p, g) {
              this.rect.x = p.x, this.rect.y = p.y, this.rect.width = g.width, this.rect.height = g.height;
            }, f.prototype.setCenter = function(p, g) {
              this.rect.x = p - this.rect.width / 2, this.rect.y = g - this.rect.height / 2;
            }, f.prototype.setLocation = function(p, g) {
              this.rect.x = p, this.rect.y = g;
            }, f.prototype.moveBy = function(p, g) {
              this.rect.x += p, this.rect.y += g;
            }, f.prototype.getEdgeListToNode = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (v.target == p) {
                  if (v.source != m) throw "Incorrect edge source!";
                  g.push(v);
                }
              }), g;
            }, f.prototype.getEdgesBetween = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (!(v.source == m || v.target == m)) throw "Incorrect edge source and/or target";
                (v.target == p || v.source == p) && g.push(v);
              }), g;
            }, f.prototype.getNeighborsList = function() {
              var p = /* @__PURE__ */ new Set(), g = this;
              return g.edges.forEach(function(m) {
                if (m.source == g)
                  p.add(m.target);
                else {
                  if (m.target != g)
                    throw "Incorrect incidency!";
                  p.add(m.source);
                }
              }), p;
            }, f.prototype.withChildren = function() {
              var p = /* @__PURE__ */ new Set(), g, m;
              if (p.add(this), this.child != null)
                for (var v = this.child.getNodes(), y = 0; y < v.length; y++)
                  g = v[y], m = g.withChildren(), m.forEach(function(b) {
                    p.add(b);
                  });
              return p;
            }, f.prototype.getNoOfChildren = function() {
              var p = 0, g;
              if (this.child == null)
                p = 1;
              else
                for (var m = this.child.getNodes(), v = 0; v < m.length; v++)
                  g = m[v], p += g.getNoOfChildren();
              return p == 0 && (p = 1), p;
            }, f.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, f.prototype.calcEstimatedSize = function() {
              return this.child == null ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
            }, f.prototype.scatter = function() {
              var p, g, m = -l.INITIAL_WORLD_BOUNDARY, v = l.INITIAL_WORLD_BOUNDARY;
              p = l.WORLD_CENTER_X + u.nextDouble() * (v - m) + m;
              var y = -l.INITIAL_WORLD_BOUNDARY, b = l.INITIAL_WORLD_BOUNDARY;
              g = l.WORLD_CENTER_Y + u.nextDouble() * (b - y) + y, this.rect.x = p, this.rect.y = g;
            }, f.prototype.updateBounds = function() {
              if (this.getChild() == null)
                throw "assert failed";
              if (this.getChild().getNodes().length != 0) {
                var p = this.getChild();
                if (p.updateBounds(!0), this.rect.x = p.getLeft(), this.rect.y = p.getTop(), this.setWidth(p.getRight() - p.getLeft()), this.setHeight(p.getBottom() - p.getTop()), l.NODE_DIMENSIONS_INCLUDE_LABELS) {
                  var g = p.getRight() - p.getLeft(), m = p.getBottom() - p.getTop();
                  this.labelWidth > g && (this.rect.x -= (this.labelWidth - g) / 2, this.setWidth(this.labelWidth)), this.labelHeight > m && (this.labelPos == "center" ? this.rect.y -= (this.labelHeight - m) / 2 : this.labelPos == "top" && (this.rect.y -= this.labelHeight - m), this.setHeight(this.labelHeight));
                }
              }
            }, f.prototype.getInclusionTreeDepth = function() {
              if (this.inclusionTreeDepth == s.MAX_VALUE)
                throw "assert failed";
              return this.inclusionTreeDepth;
            }, f.prototype.transform = function(p) {
              var g = this.rect.x;
              g > l.WORLD_BOUNDARY ? g = l.WORLD_BOUNDARY : g < -l.WORLD_BOUNDARY && (g = -l.WORLD_BOUNDARY);
              var m = this.rect.y;
              m > l.WORLD_BOUNDARY ? m = l.WORLD_BOUNDARY : m < -l.WORLD_BOUNDARY && (m = -l.WORLD_BOUNDARY);
              var v = new h(g, m), y = p.inverseTransformPoint(v);
              this.setLocation(y.x, y.y);
            }, f.prototype.getLeft = function() {
              return this.rect.x;
            }, f.prototype.getRight = function() {
              return this.rect.x + this.rect.width;
            }, f.prototype.getTop = function() {
              return this.rect.y;
            }, f.prototype.getBottom = function() {
              return this.rect.y + this.rect.height;
            }, f.prototype.getParent = function() {
              return this.owner == null ? null : this.owner.getParent();
            }, r.exports = f;
          }),
          /* 4 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              s == null && o == null ? (this.x = 0, this.y = 0) : (this.x = s, this.y = o);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getDifference = function(s) {
              return new DimensionD(this.x - s.x, this.y - s.y);
            }, a.prototype.getCopy = function() {
              return new a(this.x, this.y);
            }, a.prototype.translate = function(s) {
              return this.x += s.width, this.y += s.height, this;
            }, r.exports = a;
          }),
          /* 5 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(0), l = i(6), u = i(3), h = i(1), f = i(13), d = i(12), p = i(11);
            function g(v, y, b) {
              a.call(this, b), this.estimatedSize = s.MIN_VALUE, this.margin = o.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = v, y != null && y instanceof l ? this.graphManager = y : y != null && y instanceof Layout && (this.graphManager = y.graphManager);
            }
            g.prototype = Object.create(a.prototype);
            for (var m in a)
              g[m] = a[m];
            g.prototype.getNodes = function() {
              return this.nodes;
            }, g.prototype.getEdges = function() {
              return this.edges;
            }, g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getParent = function() {
              return this.parent;
            }, g.prototype.getLeft = function() {
              return this.left;
            }, g.prototype.getRight = function() {
              return this.right;
            }, g.prototype.getTop = function() {
              return this.top;
            }, g.prototype.getBottom = function() {
              return this.bottom;
            }, g.prototype.isConnected = function() {
              return this.isConnected;
            }, g.prototype.add = function(v, y, b) {
              if (y == null && b == null) {
                var x = v;
                if (this.graphManager == null)
                  throw "Graph has no graph mgr!";
                if (this.getNodes().indexOf(x) > -1)
                  throw "Node already in graph!";
                return x.owner = this, this.getNodes().push(x), x;
              } else {
                var T = v;
                if (!(this.getNodes().indexOf(y) > -1 && this.getNodes().indexOf(b) > -1))
                  throw "Source or target not in graph!";
                if (!(y.owner == b.owner && y.owner == this))
                  throw "Both owners must be this graph!";
                return y.owner != b.owner ? null : (T.source = y, T.target = b, T.isInterGraph = !1, this.getEdges().push(T), y.edges.push(T), b != y && b.edges.push(T), T);
              }
            }, g.prototype.remove = function(v) {
              var y = v;
              if (v instanceof u) {
                if (y == null)
                  throw "Node is null!";
                if (!(y.owner != null && y.owner == this))
                  throw "Owner graph is invalid!";
                if (this.graphManager == null)
                  throw "Owner graph manager is invalid!";
                for (var b = y.edges.slice(), x, T = b.length, E = 0; E < T; E++)
                  x = b[E], x.isInterGraph ? this.graphManager.remove(x) : x.source.owner.remove(x);
                var A = this.nodes.indexOf(y);
                if (A == -1)
                  throw "Node not in owner node list!";
                this.nodes.splice(A, 1);
              } else if (v instanceof h) {
                var x = v;
                if (x == null)
                  throw "Edge is null!";
                if (!(x.source != null && x.target != null))
                  throw "Source and/or target is null!";
                if (!(x.source.owner != null && x.target.owner != null && x.source.owner == this && x.target.owner == this))
                  throw "Source and/or target owner is invalid!";
                var S = x.source.edges.indexOf(x), k = x.target.edges.indexOf(x);
                if (!(S > -1 && k > -1))
                  throw "Source and/or target doesn't know this edge!";
                x.source.edges.splice(S, 1), x.target != x.source && x.target.edges.splice(k, 1);
                var A = x.source.owner.getEdges().indexOf(x);
                if (A == -1)
                  throw "Not in owner's edge list!";
                x.source.owner.getEdges().splice(A, 1);
              }
            }, g.prototype.updateLeftTop = function() {
              for (var v = s.MAX_VALUE, y = s.MAX_VALUE, b, x, T, E = this.getNodes(), A = E.length, S = 0; S < A; S++) {
                var k = E[S];
                b = k.getTop(), x = k.getLeft(), v > b && (v = b), y > x && (y = x);
              }
              return v == s.MAX_VALUE ? null : (E[0].getParent().paddingLeft != null ? T = E[0].getParent().paddingLeft : T = this.margin, this.left = y - T, this.top = v - T, new d(this.left, this.top));
            }, g.prototype.updateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, x = s.MAX_VALUE, T = -s.MAX_VALUE, E, A, S, k, _, R = this.nodes, L = R.length, M = 0; M < L; M++) {
                var P = R[M];
                v && P.child != null && P.updateBounds(), E = P.getLeft(), A = P.getRight(), S = P.getTop(), k = P.getBottom(), y > E && (y = E), b < A && (b = A), x > S && (x = S), T < k && (T = k);
              }
              var C = new f(y, x, b - y, T - x);
              y == s.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), R[0].getParent().paddingLeft != null ? _ = R[0].getParent().paddingLeft : _ = this.margin, this.left = C.x - _, this.right = C.x + C.width + _, this.top = C.y - _, this.bottom = C.y + C.height + _;
            }, g.calculateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, x = s.MAX_VALUE, T = -s.MAX_VALUE, E, A, S, k, _ = v.length, R = 0; R < _; R++) {
                var L = v[R];
                E = L.getLeft(), A = L.getRight(), S = L.getTop(), k = L.getBottom(), y > E && (y = E), b < A && (b = A), x > S && (x = S), T < k && (T = k);
              }
              var M = new f(y, x, b - y, T - x);
              return M;
            }, g.prototype.getInclusionTreeDepth = function() {
              return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
            }, g.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, g.prototype.calcEstimatedSize = function() {
              for (var v = 0, y = this.nodes, b = y.length, x = 0; x < b; x++) {
                var T = y[x];
                v += T.calcEstimatedSize();
              }
              return v == 0 ? this.estimatedSize = o.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = v / Math.sqrt(this.nodes.length), this.estimatedSize;
            }, g.prototype.updateConnected = function() {
              var v = this;
              if (this.nodes.length == 0) {
                this.isConnected = !0;
                return;
              }
              var y = new p(), b = /* @__PURE__ */ new Set(), x = this.nodes[0], T, E, A = x.withChildren();
              for (A.forEach(function(M) {
                y.push(M), b.add(M);
              }); y.length !== 0; ) {
                x = y.shift(), T = x.getEdges();
                for (var S = T.length, k = 0; k < S; k++) {
                  var _ = T[k];
                  if (E = _.getOtherEndInGraph(x, this), E != null && !b.has(E)) {
                    var R = E.withChildren();
                    R.forEach(function(M) {
                      y.push(M), b.add(M);
                    });
                  }
                }
              }
              if (this.isConnected = !1, b.size >= this.nodes.length) {
                var L = 0;
                b.forEach(function(M) {
                  M.owner == v && L++;
                }), L == this.nodes.length && (this.isConnected = !0);
              }
            }, r.exports = g;
          }),
          /* 6 */
          /***/
          (function(r, n, i) {
            var a, s = i(1);
            function o(l) {
              a = i(5), this.layout = l, this.graphs = [], this.edges = [];
            }
            o.prototype.addRoot = function() {
              var l = this.layout.newGraph(), u = this.layout.newNode(null), h = this.add(l, u);
              return this.setRootGraph(h), this.rootGraph;
            }, o.prototype.add = function(l, u, h, f, d) {
              if (h == null && f == null && d == null) {
                if (l == null)
                  throw "Graph is null!";
                if (u == null)
                  throw "Parent node is null!";
                if (this.graphs.indexOf(l) > -1)
                  throw "Graph already in this graph mgr!";
                if (this.graphs.push(l), l.parent != null)
                  throw "Already has a parent!";
                if (u.child != null)
                  throw "Already has a child!";
                return l.parent = u, u.child = l, l;
              } else {
                d = h, f = u, h = l;
                var p = f.getOwner(), g = d.getOwner();
                if (!(p != null && p.getGraphManager() == this))
                  throw "Source not in this graph mgr!";
                if (!(g != null && g.getGraphManager() == this))
                  throw "Target not in this graph mgr!";
                if (p == g)
                  return h.isInterGraph = !1, p.add(h, f, d);
                if (h.isInterGraph = !0, h.source = f, h.target = d, this.edges.indexOf(h) > -1)
                  throw "Edge already in inter-graph edge list!";
                if (this.edges.push(h), !(h.source != null && h.target != null))
                  throw "Edge source and/or target is null!";
                if (!(h.source.edges.indexOf(h) == -1 && h.target.edges.indexOf(h) == -1))
                  throw "Edge already in source and/or target incidency list!";
                return h.source.edges.push(h), h.target.edges.push(h), h;
              }
            }, o.prototype.remove = function(l) {
              if (l instanceof a) {
                var u = l;
                if (u.getGraphManager() != this)
                  throw "Graph not in this graph mgr";
                if (!(u == this.rootGraph || u.parent != null && u.parent.graphManager == this))
                  throw "Invalid parent node!";
                var h = [];
                h = h.concat(u.getEdges());
                for (var f, d = h.length, p = 0; p < d; p++)
                  f = h[p], u.remove(f);
                var g = [];
                g = g.concat(u.getNodes());
                var m;
                d = g.length;
                for (var p = 0; p < d; p++)
                  m = g[p], u.remove(m);
                u == this.rootGraph && this.setRootGraph(null);
                var v = this.graphs.indexOf(u);
                this.graphs.splice(v, 1), u.parent = null;
              } else if (l instanceof s) {
                if (f = l, f == null)
                  throw "Edge is null!";
                if (!f.isInterGraph)
                  throw "Not an inter-graph edge!";
                if (!(f.source != null && f.target != null))
                  throw "Source and/or target is null!";
                if (!(f.source.edges.indexOf(f) != -1 && f.target.edges.indexOf(f) != -1))
                  throw "Source and/or target doesn't know this edge!";
                var v = f.source.edges.indexOf(f);
                if (f.source.edges.splice(v, 1), v = f.target.edges.indexOf(f), f.target.edges.splice(v, 1), !(f.source.owner != null && f.source.owner.getGraphManager() != null))
                  throw "Edge owner graph or owner graph manager is null!";
                if (f.source.owner.getGraphManager().edges.indexOf(f) == -1)
                  throw "Not in owner graph manager's edge list!";
                var v = f.source.owner.getGraphManager().edges.indexOf(f);
                f.source.owner.getGraphManager().edges.splice(v, 1);
              }
            }, o.prototype.updateBounds = function() {
              this.rootGraph.updateBounds(!0);
            }, o.prototype.getGraphs = function() {
              return this.graphs;
            }, o.prototype.getAllNodes = function() {
              if (this.allNodes == null) {
                for (var l = [], u = this.getGraphs(), h = u.length, f = 0; f < h; f++)
                  l = l.concat(u[f].getNodes());
                this.allNodes = l;
              }
              return this.allNodes;
            }, o.prototype.resetAllNodes = function() {
              this.allNodes = null;
            }, o.prototype.resetAllEdges = function() {
              this.allEdges = null;
            }, o.prototype.resetAllNodesToApplyGravitation = function() {
              this.allNodesToApplyGravitation = null;
            }, o.prototype.getAllEdges = function() {
              if (this.allEdges == null) {
                var l = [], u = this.getGraphs();
                u.length;
                for (var h = 0; h < u.length; h++)
                  l = l.concat(u[h].getEdges());
                l = l.concat(this.edges), this.allEdges = l;
              }
              return this.allEdges;
            }, o.prototype.getAllNodesToApplyGravitation = function() {
              return this.allNodesToApplyGravitation;
            }, o.prototype.setAllNodesToApplyGravitation = function(l) {
              if (this.allNodesToApplyGravitation != null)
                throw "assert failed";
              this.allNodesToApplyGravitation = l;
            }, o.prototype.getRoot = function() {
              return this.rootGraph;
            }, o.prototype.setRootGraph = function(l) {
              if (l.getGraphManager() != this)
                throw "Root not in this graph mgr!";
              this.rootGraph = l, l.parent == null && (l.parent = this.layout.newNode("Root node"));
            }, o.prototype.getLayout = function() {
              return this.layout;
            }, o.prototype.isOneAncestorOfOther = function(l, u) {
              if (!(l != null && u != null))
                throw "assert failed";
              if (l == u)
                return !0;
              var h = l.getOwner(), f;
              do {
                if (f = h.getParent(), f == null)
                  break;
                if (f == u)
                  return !0;
                if (h = f.getOwner(), h == null)
                  break;
              } while (!0);
              h = u.getOwner();
              do {
                if (f = h.getParent(), f == null)
                  break;
                if (f == l)
                  return !0;
                if (h = f.getOwner(), h == null)
                  break;
              } while (!0);
              return !1;
            }, o.prototype.calcLowestCommonAncestors = function() {
              for (var l, u, h, f, d, p = this.getAllEdges(), g = p.length, m = 0; m < g; m++) {
                if (l = p[m], u = l.source, h = l.target, l.lca = null, l.sourceInLca = u, l.targetInLca = h, u == h) {
                  l.lca = u.getOwner();
                  continue;
                }
                for (f = u.getOwner(); l.lca == null; ) {
                  for (l.targetInLca = h, d = h.getOwner(); l.lca == null; ) {
                    if (d == f) {
                      l.lca = d;
                      break;
                    }
                    if (d == this.rootGraph)
                      break;
                    if (l.lca != null)
                      throw "assert failed";
                    l.targetInLca = d.getParent(), d = l.targetInLca.getOwner();
                  }
                  if (f == this.rootGraph)
                    break;
                  l.lca == null && (l.sourceInLca = f.getParent(), f = l.sourceInLca.getOwner());
                }
                if (l.lca == null)
                  throw "assert failed";
              }
            }, o.prototype.calcLowestCommonAncestor = function(l, u) {
              if (l == u)
                return l.getOwner();
              var h = l.getOwner();
              do {
                if (h == null)
                  break;
                var f = u.getOwner();
                do {
                  if (f == null)
                    break;
                  if (f == h)
                    return f;
                  f = f.getParent().getOwner();
                } while (!0);
                h = h.getParent().getOwner();
              } while (!0);
              return h;
            }, o.prototype.calcInclusionTreeDepths = function(l, u) {
              l == null && u == null && (l = this.rootGraph, u = 1);
              for (var h, f = l.getNodes(), d = f.length, p = 0; p < d; p++)
                h = f[p], h.inclusionTreeDepth = u, h.child != null && this.calcInclusionTreeDepths(h.child, u + 1);
            }, o.prototype.includesInvalidEdge = function() {
              for (var l, u = this.edges.length, h = 0; h < u; h++)
                if (l = this.edges[h], this.isOneAncestorOfOther(l.source, l.target))
                  return !0;
              return !1;
            }, r.exports = o;
          }),
          /* 7 */
          /***/
          (function(r, n, i) {
            var a = i(0);
            function s() {
            }
            for (var o in a)
              s[o] = a[o];
            s.MAX_ITERATIONS = 2500, s.DEFAULT_EDGE_LENGTH = 50, s.DEFAULT_SPRING_STRENGTH = 0.45, s.DEFAULT_REPULSION_STRENGTH = 4500, s.DEFAULT_GRAVITY_STRENGTH = 0.4, s.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, s.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, s.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, s.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, s.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, s.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3, s.COOLING_ADAPTATION_FACTOR = 0.33, s.ADAPTATION_LOWER_NODE_LIMIT = 1e3, s.ADAPTATION_UPPER_NODE_LIMIT = 5e3, s.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, s.MAX_NODE_DISPLACEMENT = s.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3, s.MIN_REPULSION_DIST = s.DEFAULT_EDGE_LENGTH / 10, s.CONVERGENCE_CHECK_PERIOD = 100, s.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1, s.MIN_EDGE_LENGTH = 1, s.GRID_CALCULATION_CHECK_PERIOD = 10, r.exports = s;
          }),
          /* 8 */
          /***/
          (function(r, n, i) {
            var a = i(12);
            function s() {
            }
            s.calcSeparationAmount = function(o, l, u, h) {
              if (!o.intersects(l))
                throw "assert failed";
              var f = new Array(2);
              this.decideDirectionsForOverlappingNodes(o, l, f), u[0] = Math.min(o.getRight(), l.getRight()) - Math.max(o.x, l.x), u[1] = Math.min(o.getBottom(), l.getBottom()) - Math.max(o.y, l.y), o.getX() <= l.getX() && o.getRight() >= l.getRight() ? u[0] += Math.min(l.getX() - o.getX(), o.getRight() - l.getRight()) : l.getX() <= o.getX() && l.getRight() >= o.getRight() && (u[0] += Math.min(o.getX() - l.getX(), l.getRight() - o.getRight())), o.getY() <= l.getY() && o.getBottom() >= l.getBottom() ? u[1] += Math.min(l.getY() - o.getY(), o.getBottom() - l.getBottom()) : l.getY() <= o.getY() && l.getBottom() >= o.getBottom() && (u[1] += Math.min(o.getY() - l.getY(), l.getBottom() - o.getBottom()));
              var d = Math.abs((l.getCenterY() - o.getCenterY()) / (l.getCenterX() - o.getCenterX()));
              l.getCenterY() === o.getCenterY() && l.getCenterX() === o.getCenterX() && (d = 1);
              var p = d * u[0], g = u[1] / d;
              u[0] < g ? g = u[0] : p = u[1], u[0] = -1 * f[0] * (g / 2 + h), u[1] = -1 * f[1] * (p / 2 + h);
            }, s.decideDirectionsForOverlappingNodes = function(o, l, u) {
              o.getCenterX() < l.getCenterX() ? u[0] = -1 : u[0] = 1, o.getCenterY() < l.getCenterY() ? u[1] = -1 : u[1] = 1;
            }, s.getIntersection2 = function(o, l, u) {
              var h = o.getCenterX(), f = o.getCenterY(), d = l.getCenterX(), p = l.getCenterY();
              if (o.intersects(l))
                return u[0] = h, u[1] = f, u[2] = d, u[3] = p, !0;
              var g = o.getX(), m = o.getY(), v = o.getRight(), y = o.getX(), b = o.getBottom(), x = o.getRight(), T = o.getWidthHalf(), E = o.getHeightHalf(), A = l.getX(), S = l.getY(), k = l.getRight(), _ = l.getX(), R = l.getBottom(), L = l.getRight(), M = l.getWidthHalf(), P = l.getHeightHalf(), C = !1, I = !1;
              if (h === d) {
                if (f > p)
                  return u[0] = h, u[1] = m, u[2] = d, u[3] = R, !1;
                if (f < p)
                  return u[0] = h, u[1] = b, u[2] = d, u[3] = S, !1;
              } else if (f === p) {
                if (h > d)
                  return u[0] = g, u[1] = f, u[2] = k, u[3] = p, !1;
                if (h < d)
                  return u[0] = v, u[1] = f, u[2] = A, u[3] = p, !1;
              } else {
                var N = o.height / o.width, O = l.height / l.width, D = (p - f) / (d - h), $ = void 0, z = void 0, B = void 0, G = void 0, W = void 0, V = void 0;
                if (-N === D ? h > d ? (u[0] = y, u[1] = b, C = !0) : (u[0] = v, u[1] = m, C = !0) : N === D && (h > d ? (u[0] = g, u[1] = m, C = !0) : (u[0] = x, u[1] = b, C = !0)), -O === D ? d > h ? (u[2] = _, u[3] = R, I = !0) : (u[2] = k, u[3] = S, I = !0) : O === D && (d > h ? (u[2] = A, u[3] = S, I = !0) : (u[2] = L, u[3] = R, I = !0)), C && I)
                  return !1;
                if (h > d ? f > p ? ($ = this.getCardinalDirection(N, D, 4), z = this.getCardinalDirection(O, D, 2)) : ($ = this.getCardinalDirection(-N, D, 3), z = this.getCardinalDirection(-O, D, 1)) : f > p ? ($ = this.getCardinalDirection(-N, D, 1), z = this.getCardinalDirection(-O, D, 3)) : ($ = this.getCardinalDirection(N, D, 2), z = this.getCardinalDirection(O, D, 4)), !C)
                  switch ($) {
                    case 1:
                      G = m, B = h + -E / D, u[0] = B, u[1] = G;
                      break;
                    case 2:
                      B = x, G = f + T * D, u[0] = B, u[1] = G;
                      break;
                    case 3:
                      G = b, B = h + E / D, u[0] = B, u[1] = G;
                      break;
                    case 4:
                      B = y, G = f + -T * D, u[0] = B, u[1] = G;
                      break;
                  }
                if (!I)
                  switch (z) {
                    case 1:
                      V = S, W = d + -P / D, u[2] = W, u[3] = V;
                      break;
                    case 2:
                      W = L, V = p + M * D, u[2] = W, u[3] = V;
                      break;
                    case 3:
                      V = R, W = d + P / D, u[2] = W, u[3] = V;
                      break;
                    case 4:
                      W = _, V = p + -M * D, u[2] = W, u[3] = V;
                      break;
                  }
              }
              return !1;
            }, s.getCardinalDirection = function(o, l, u) {
              return o > l ? u : 1 + u % 4;
            }, s.getIntersection = function(o, l, u, h) {
              if (h == null)
                return this.getIntersection2(o, l, u);
              var f = o.x, d = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, x = void 0, T = void 0, E = void 0, A = void 0, S = void 0, k = void 0, _ = void 0, R = void 0, L = void 0;
              return E = g - d, S = f - p, _ = p * d - f * g, A = b - v, k = m - y, R = y * v - m * b, L = E * k - A * S, L === 0 ? null : (x = (S * R - k * _) / L, T = (A * _ - E * R) / L, new a(x, T));
            }, s.angleOfVector = function(o, l, u, h) {
              var f = void 0;
              return o !== u ? (f = Math.atan((h - l) / (u - o)), u < o ? f += Math.PI : h < l && (f += this.TWO_PI)) : h < l ? f = this.ONE_AND_HALF_PI : f = this.HALF_PI, f;
            }, s.doIntersect = function(o, l, u, h) {
              var f = o.x, d = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, x = (p - f) * (b - v) - (y - m) * (g - d);
              if (x === 0)
                return !1;
              var T = ((b - v) * (y - f) + (m - y) * (b - d)) / x, E = ((d - g) * (y - f) + (p - f) * (b - d)) / x;
              return 0 < T && T < 1 && 0 < E && E < 1;
            }, s.HALF_PI = 0.5 * Math.PI, s.ONE_AND_HALF_PI = 1.5 * Math.PI, s.TWO_PI = 2 * Math.PI, s.THREE_PI = 3 * Math.PI, r.exports = s;
          }),
          /* 9 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.sign = function(s) {
              return s > 0 ? 1 : s < 0 ? -1 : 0;
            }, a.floor = function(s) {
              return s < 0 ? Math.ceil(s) : Math.floor(s);
            }, a.ceil = function(s) {
              return s < 0 ? Math.floor(s) : Math.ceil(s);
            }, r.exports = a;
          }),
          /* 10 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.MAX_VALUE = 2147483647, a.MIN_VALUE = -2147483648, r.exports = a;
          }),
          /* 11 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function f(d, p) {
                for (var g = 0; g < p.length; g++) {
                  var m = p[g];
                  m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(d, m.key, m);
                }
              }
              return function(d, p, g) {
                return p && f(d.prototype, p), g && f(d, g), d;
              };
            })();
            function s(f, d) {
              if (!(f instanceof d))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function(d) {
              return { value: d, next: null, prev: null };
            }, l = function(d, p, g, m) {
              return d !== null ? d.next = p : m.head = p, g !== null ? g.prev = p : m.tail = p, p.prev = d, p.next = g, m.length++, p;
            }, u = function(d, p) {
              var g = d.prev, m = d.next;
              return g !== null ? g.next = m : p.head = m, m !== null ? m.prev = g : p.tail = g, d.prev = d.next = null, p.length--, d;
            }, h = (function() {
              function f(d) {
                var p = this;
                s(this, f), this.length = 0, this.head = null, this.tail = null, d?.forEach(function(g) {
                  return p.push(g);
                });
              }
              return a(f, [{
                key: "size",
                value: function() {
                  return this.length;
                }
              }, {
                key: "insertBefore",
                value: function(p, g) {
                  return l(g.prev, o(p), g, this);
                }
              }, {
                key: "insertAfter",
                value: function(p, g) {
                  return l(g, o(p), g.next, this);
                }
              }, {
                key: "insertNodeBefore",
                value: function(p, g) {
                  return l(g.prev, p, g, this);
                }
              }, {
                key: "insertNodeAfter",
                value: function(p, g) {
                  return l(g, p, g.next, this);
                }
              }, {
                key: "push",
                value: function(p) {
                  return l(this.tail, o(p), null, this);
                }
              }, {
                key: "unshift",
                value: function(p) {
                  return l(null, o(p), this.head, this);
                }
              }, {
                key: "remove",
                value: function(p) {
                  return u(p, this);
                }
              }, {
                key: "pop",
                value: function() {
                  return u(this.tail, this).value;
                }
              }, {
                key: "popNode",
                value: function() {
                  return u(this.tail, this);
                }
              }, {
                key: "shift",
                value: function() {
                  return u(this.head, this).value;
                }
              }, {
                key: "shiftNode",
                value: function() {
                  return u(this.head, this);
                }
              }, {
                key: "get_object_at",
                value: function(p) {
                  if (p <= this.length()) {
                    for (var g = 1, m = this.head; g < p; )
                      m = m.next, g++;
                    return m.value;
                  }
                }
              }, {
                key: "set_object_at",
                value: function(p, g) {
                  if (p <= this.length()) {
                    for (var m = 1, v = this.head; m < p; )
                      v = v.next, m++;
                    v.value = g;
                  }
                }
              }]), f;
            })();
            r.exports = h;
          }),
          /* 12 */
          /***/
          (function(r, n, i) {
            function a(s, o, l) {
              this.x = null, this.y = null, s == null && o == null && l == null ? (this.x = 0, this.y = 0) : typeof s == "number" && typeof o == "number" && l == null ? (this.x = s, this.y = o) : s.constructor.name == "Point" && o == null && l == null && (l = s, this.x = l.x, this.y = l.y);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.getLocation = function() {
              return new a(this.x, this.y);
            }, a.prototype.setLocation = function(s, o, l) {
              s.constructor.name == "Point" && o == null && l == null ? (l = s, this.setLocation(l.x, l.y)) : typeof s == "number" && typeof o == "number" && l == null && (parseInt(s) == s && parseInt(o) == o ? this.move(s, o) : (this.x = Math.floor(s + 0.5), this.y = Math.floor(o + 0.5)));
            }, a.prototype.move = function(s, o) {
              this.x = s, this.y = o;
            }, a.prototype.translate = function(s, o) {
              this.x += s, this.y += o;
            }, a.prototype.equals = function(s) {
              if (s.constructor.name == "Point") {
                var o = s;
                return this.x == o.x && this.y == o.y;
              }
              return this == s;
            }, a.prototype.toString = function() {
              return new a().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            }, r.exports = a;
          }),
          /* 13 */
          /***/
          (function(r, n, i) {
            function a(s, o, l, u) {
              this.x = 0, this.y = 0, this.width = 0, this.height = 0, s != null && o != null && l != null && u != null && (this.x = s, this.y = o, this.width = l, this.height = u);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, a.prototype.getRight = function() {
              return this.x + this.width;
            }, a.prototype.getBottom = function() {
              return this.y + this.height;
            }, a.prototype.intersects = function(s) {
              return !(this.getRight() < s.x || this.getBottom() < s.y || s.getRight() < this.x || s.getBottom() < this.y);
            }, a.prototype.getCenterX = function() {
              return this.x + this.width / 2;
            }, a.prototype.getMinX = function() {
              return this.getX();
            }, a.prototype.getMaxX = function() {
              return this.getX() + this.width;
            }, a.prototype.getCenterY = function() {
              return this.y + this.height / 2;
            }, a.prototype.getMinY = function() {
              return this.getY();
            }, a.prototype.getMaxY = function() {
              return this.getY() + this.height;
            }, a.prototype.getWidthHalf = function() {
              return this.width / 2;
            }, a.prototype.getHeightHalf = function() {
              return this.height / 2;
            }, r.exports = a;
          }),
          /* 14 */
          /***/
          (function(r, n, i) {
            var a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
              return typeof o;
            } : function(o) {
              return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            };
            function s() {
            }
            s.lastID = 0, s.createID = function(o) {
              return s.isPrimitive(o) ? o : (o.uniqueID != null || (o.uniqueID = s.getString(), s.lastID++), o.uniqueID);
            }, s.getString = function(o) {
              return o == null && (o = s.lastID), "Object#" + o;
            }, s.isPrimitive = function(o) {
              var l = typeof o > "u" ? "undefined" : a(o);
              return o == null || l != "object" && l != "function";
            }, r.exports = s;
          }),
          /* 15 */
          /***/
          (function(r, n, i) {
            function a(m) {
              if (Array.isArray(m)) {
                for (var v = 0, y = Array(m.length); v < m.length; v++)
                  y[v] = m[v];
                return y;
              } else
                return Array.from(m);
            }
            var s = i(0), o = i(6), l = i(3), u = i(1), h = i(5), f = i(4), d = i(17), p = i(27);
            function g(m) {
              p.call(this), this.layoutQuality = s.QUALITY, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = s.DEFAULT_INCREMENTAL, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new o(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, m != null && (this.isRemoteUse = m);
            }
            g.RANDOM_SEED = 1, g.prototype = Object.create(p.prototype), g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getAllNodes = function() {
              return this.graphManager.getAllNodes();
            }, g.prototype.getAllEdges = function() {
              return this.graphManager.getAllEdges();
            }, g.prototype.getAllNodesToApplyGravitation = function() {
              return this.graphManager.getAllNodesToApplyGravitation();
            }, g.prototype.newGraphManager = function() {
              var m = new o(this);
              return this.graphManager = m, m;
            }, g.prototype.newGraph = function(m) {
              return new h(null, this.graphManager, m);
            }, g.prototype.newNode = function(m) {
              return new l(this.graphManager, m);
            }, g.prototype.newEdge = function(m) {
              return new u(null, null, m);
            }, g.prototype.checkLayoutSuccess = function() {
              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            }, g.prototype.runLayout = function() {
              this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters();
              var m;
              return this.checkLayoutSuccess() ? m = !1 : m = this.layout(), s.ANIMATE === "during" ? !1 : (m && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, m);
            }, g.prototype.doPostLayout = function() {
              this.incremental || this.transform(), this.update();
            }, g.prototype.update2 = function() {
              if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
                for (var m = this.graphManager.getAllEdges(), v = 0; v < m.length; v++)
                  m[v];
                for (var y = this.graphManager.getRoot().getNodes(), v = 0; v < y.length; v++)
                  y[v];
                this.update(this.graphManager.getRoot());
              }
            }, g.prototype.update = function(m) {
              if (m == null)
                this.update2();
              else if (m instanceof l) {
                var v = m;
                if (v.getChild() != null)
                  for (var y = v.getChild().getNodes(), b = 0; b < y.length; b++)
                    update(y[b]);
                if (v.vGraphObject != null) {
                  var x = v.vGraphObject;
                  x.update(v);
                }
              } else if (m instanceof u) {
                var T = m;
                if (T.vGraphObject != null) {
                  var E = T.vGraphObject;
                  E.update(T);
                }
              } else if (m instanceof h) {
                var A = m;
                if (A.vGraphObject != null) {
                  var S = A.vGraphObject;
                  S.update(A);
                }
              }
            }, g.prototype.initParameters = function() {
              this.isSubLayout || (this.layoutQuality = s.QUALITY, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = s.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
            }, g.prototype.transform = function(m) {
              if (m == null)
                this.transform(new f(0, 0));
              else {
                var v = new d(), y = this.graphManager.getRoot().updateLeftTop();
                if (y != null) {
                  v.setWorldOrgX(m.x), v.setWorldOrgY(m.y), v.setDeviceOrgX(y.x), v.setDeviceOrgY(y.y);
                  for (var b = this.getAllNodes(), x, T = 0; T < b.length; T++)
                    x = b[T], x.transform(v);
                }
              }
            }, g.prototype.positionNodesRandomly = function(m) {
              if (m == null)
                this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
              else
                for (var v, y, b = m.getNodes(), x = 0; x < b.length; x++)
                  v = b[x], y = v.getChild(), y == null || y.getNodes().length == 0 ? v.scatter() : (this.positionNodesRandomly(y), v.updateBounds());
            }, g.prototype.getFlatForest = function() {
              for (var m = [], v = !0, y = this.graphManager.getRoot().getNodes(), b = !0, x = 0; x < y.length; x++)
                y[x].getChild() != null && (b = !1);
              if (!b)
                return m;
              var T = /* @__PURE__ */ new Set(), E = [], A = /* @__PURE__ */ new Map(), S = [];
              for (S = S.concat(y); S.length > 0 && v; ) {
                for (E.push(S[0]); E.length > 0 && v; ) {
                  var k = E[0];
                  E.splice(0, 1), T.add(k);
                  for (var _ = k.getEdges(), x = 0; x < _.length; x++) {
                    var R = _[x].getOtherEnd(k);
                    if (A.get(k) != R)
                      if (!T.has(R))
                        E.push(R), A.set(R, k);
                      else {
                        v = !1;
                        break;
                      }
                  }
                }
                if (!v)
                  m = [];
                else {
                  var L = [].concat(a(T));
                  m.push(L);
                  for (var x = 0; x < L.length; x++) {
                    var M = L[x], P = S.indexOf(M);
                    P > -1 && S.splice(P, 1);
                  }
                  T = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ new Map();
                }
              }
              return m;
            }, g.prototype.createDummyNodesForBendpoints = function(m) {
              for (var v = [], y = m.source, b = this.graphManager.calcLowestCommonAncestor(m.source, m.target), x = 0; x < m.bendpoints.length; x++) {
                var T = this.newNode(null);
                T.setRect(new Point(0, 0), new Dimension(1, 1)), b.add(T);
                var E = this.newEdge(null);
                this.graphManager.add(E, y, T), v.add(T), y = T;
              }
              var E = this.newEdge(null);
              return this.graphManager.add(E, y, m.target), this.edgeToDummyNodes.set(m, v), m.isInterGraph() ? this.graphManager.remove(m) : b.remove(m), v;
            }, g.prototype.createBendpointsFromDummyNodes = function() {
              var m = [];
              m = m.concat(this.graphManager.getAllEdges()), m = [].concat(a(this.edgeToDummyNodes.keys())).concat(m);
              for (var v = 0; v < m.length; v++) {
                var y = m[v];
                if (y.bendpoints.length > 0) {
                  for (var b = this.edgeToDummyNodes.get(y), x = 0; x < b.length; x++) {
                    var T = b[x], E = new f(T.getCenterX(), T.getCenterY()), A = y.bendpoints.get(x);
                    A.x = E.x, A.y = E.y, T.getOwner().remove(T);
                  }
                  this.graphManager.add(y, y.source, y.target);
                }
              }
            }, g.transform = function(m, v, y, b) {
              if (y != null && b != null) {
                var x = v;
                if (m <= 50) {
                  var T = v / y;
                  x -= (v - T) / 50 * (50 - m);
                } else {
                  var E = v * b;
                  x += (E - v) / 50 * (m - 50);
                }
                return x;
              } else {
                var A, S;
                return m <= 50 ? (A = 9 * v / 500, S = v / 10) : (A = 9 * v / 50, S = -8 * v), A * m + S;
              }
            }, g.findCenterOfTree = function(m) {
              var v = [];
              v = v.concat(m);
              var y = [], b = /* @__PURE__ */ new Map(), x = !1, T = null;
              (v.length == 1 || v.length == 2) && (x = !0, T = v[0]);
              for (var E = 0; E < v.length; E++) {
                var A = v[E], S = A.getNeighborsList().size;
                b.set(A, A.getNeighborsList().size), S == 1 && y.push(A);
              }
              var k = [];
              for (k = k.concat(y); !x; ) {
                var _ = [];
                _ = _.concat(k), k = [];
                for (var E = 0; E < v.length; E++) {
                  var A = v[E], R = v.indexOf(A);
                  R >= 0 && v.splice(R, 1);
                  var L = A.getNeighborsList();
                  L.forEach(function(C) {
                    if (y.indexOf(C) < 0) {
                      var I = b.get(C), N = I - 1;
                      N == 1 && k.push(C), b.set(C, N);
                    }
                  });
                }
                y = y.concat(k), (v.length == 1 || v.length == 2) && (x = !0, T = v[0]);
              }
              return T;
            }, g.prototype.setGraphManager = function(m) {
              this.graphManager = m;
            }, r.exports = g;
          }),
          /* 16 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.seed = 1, a.x = 0, a.nextDouble = function() {
              return a.x = Math.sin(a.seed++) * 1e4, a.x - Math.floor(a.x);
            }, r.exports = a;
          }),
          /* 17 */
          /***/
          (function(r, n, i) {
            var a = i(4);
            function s(o, l) {
              this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
            }
            s.prototype.getWorldOrgX = function() {
              return this.lworldOrgX;
            }, s.prototype.setWorldOrgX = function(o) {
              this.lworldOrgX = o;
            }, s.prototype.getWorldOrgY = function() {
              return this.lworldOrgY;
            }, s.prototype.setWorldOrgY = function(o) {
              this.lworldOrgY = o;
            }, s.prototype.getWorldExtX = function() {
              return this.lworldExtX;
            }, s.prototype.setWorldExtX = function(o) {
              this.lworldExtX = o;
            }, s.prototype.getWorldExtY = function() {
              return this.lworldExtY;
            }, s.prototype.setWorldExtY = function(o) {
              this.lworldExtY = o;
            }, s.prototype.getDeviceOrgX = function() {
              return this.ldeviceOrgX;
            }, s.prototype.setDeviceOrgX = function(o) {
              this.ldeviceOrgX = o;
            }, s.prototype.getDeviceOrgY = function() {
              return this.ldeviceOrgY;
            }, s.prototype.setDeviceOrgY = function(o) {
              this.ldeviceOrgY = o;
            }, s.prototype.getDeviceExtX = function() {
              return this.ldeviceExtX;
            }, s.prototype.setDeviceExtX = function(o) {
              this.ldeviceExtX = o;
            }, s.prototype.getDeviceExtY = function() {
              return this.ldeviceExtY;
            }, s.prototype.setDeviceExtY = function(o) {
              this.ldeviceExtY = o;
            }, s.prototype.transformX = function(o) {
              var l = 0, u = this.lworldExtX;
              return u != 0 && (l = this.ldeviceOrgX + (o - this.lworldOrgX) * this.ldeviceExtX / u), l;
            }, s.prototype.transformY = function(o) {
              var l = 0, u = this.lworldExtY;
              return u != 0 && (l = this.ldeviceOrgY + (o - this.lworldOrgY) * this.ldeviceExtY / u), l;
            }, s.prototype.inverseTransformX = function(o) {
              var l = 0, u = this.ldeviceExtX;
              return u != 0 && (l = this.lworldOrgX + (o - this.ldeviceOrgX) * this.lworldExtX / u), l;
            }, s.prototype.inverseTransformY = function(o) {
              var l = 0, u = this.ldeviceExtY;
              return u != 0 && (l = this.lworldOrgY + (o - this.ldeviceOrgY) * this.lworldExtY / u), l;
            }, s.prototype.inverseTransformPoint = function(o) {
              var l = new a(this.inverseTransformX(o.x), this.inverseTransformY(o.y));
              return l;
            }, r.exports = s;
          }),
          /* 18 */
          /***/
          (function(r, n, i) {
            function a(p) {
              if (Array.isArray(p)) {
                for (var g = 0, m = Array(p.length); g < p.length; g++)
                  m[g] = p[g];
                return m;
              } else
                return Array.from(p);
            }
            var s = i(15), o = i(7), l = i(0), u = i(8), h = i(9);
            function f() {
              s.call(this), this.useSmartIdealEdgeLengthCalculation = o.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.idealEdgeLength = o.DEFAULT_EDGE_LENGTH, this.springConstant = o.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = o.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = o.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = o.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = o.MAX_ITERATIONS;
            }
            f.prototype = Object.create(s.prototype);
            for (var d in s)
              f[d] = s[d];
            f.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = o.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
            }, f.prototype.calcIdealEdgeLengths = function() {
              for (var p, g, m, v, y, b, x = this.getGraphManager().getAllEdges(), T = 0; T < x.length; T++)
                p = x[T], p.idealLength = this.idealEdgeLength, p.isInterGraph && (m = p.getSource(), v = p.getTarget(), y = p.getSourceInLca().getEstimatedSize(), b = p.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (p.idealLength += y + b - 2 * l.SIMPLE_NODE_SIZE), g = p.getLca().getInclusionTreeDepth(), p.idealLength += o.DEFAULT_EDGE_LENGTH * o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (m.getInclusionTreeDepth() + v.getInclusionTreeDepth() - 2 * g));
            }, f.prototype.initSpringEmbedder = function() {
              var p = this.getAllNodes().length;
              this.incremental ? (p > o.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * o.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - o.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (p > o.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(o.COOLING_ADAPTATION_FACTOR, 1 - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * (1 - o.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations), this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
            }, f.prototype.calcSpringForces = function() {
              for (var p = this.getAllEdges(), g, m = 0; m < p.length; m++)
                g = p[m], this.calcSpringForce(g, g.idealLength);
            }, f.prototype.calcRepulsionForces = function() {
              var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, m, v, y, b, x = this.getAllNodes(), T;
              if (this.useFRGridVariant)
                for (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && p && this.updateGrid(), T = /* @__PURE__ */ new Set(), m = 0; m < x.length; m++)
                  y = x[m], this.calculateRepulsionForceOfANode(y, T, p, g), T.add(y);
              else
                for (m = 0; m < x.length; m++)
                  for (y = x[m], v = m + 1; v < x.length; v++)
                    b = x[v], y.getOwner() == b.getOwner() && this.calcRepulsionForce(y, b);
            }, f.prototype.calcGravitationalForces = function() {
              for (var p, g = this.getAllNodesToApplyGravitation(), m = 0; m < g.length; m++)
                p = g[m], this.calcGravitationalForce(p);
            }, f.prototype.moveNodes = function() {
              for (var p = this.getAllNodes(), g, m = 0; m < p.length; m++)
                g = p[m], g.move();
            }, f.prototype.calcSpringForce = function(p, g) {
              var m = p.getSource(), v = p.getTarget(), y, b, x, T;
              if (this.uniformLeafNodeSizes && m.getChild() == null && v.getChild() == null)
                p.updateLengthSimple();
              else if (p.updateLength(), p.isOverlapingSourceAndTarget)
                return;
              y = p.getLength(), y != 0 && (b = this.springConstant * (y - g), x = b * (p.lengthX / y), T = b * (p.lengthY / y), m.springForceX += x, m.springForceY += T, v.springForceX -= x, v.springForceY -= T);
            }, f.prototype.calcRepulsionForce = function(p, g) {
              var m = p.getRect(), v = g.getRect(), y = new Array(2), b = new Array(4), x, T, E, A, S, k, _;
              if (m.intersects(v)) {
                u.calcSeparationAmount(m, v, y, o.DEFAULT_EDGE_LENGTH / 2), k = 2 * y[0], _ = 2 * y[1];
                var R = p.noOfChildren * g.noOfChildren / (p.noOfChildren + g.noOfChildren);
                p.repulsionForceX -= R * k, p.repulsionForceY -= R * _, g.repulsionForceX += R * k, g.repulsionForceY += R * _;
              } else
                this.uniformLeafNodeSizes && p.getChild() == null && g.getChild() == null ? (x = v.getCenterX() - m.getCenterX(), T = v.getCenterY() - m.getCenterY()) : (u.getIntersection(m, v, b), x = b[2] - b[0], T = b[3] - b[1]), Math.abs(x) < o.MIN_REPULSION_DIST && (x = h.sign(x) * o.MIN_REPULSION_DIST), Math.abs(T) < o.MIN_REPULSION_DIST && (T = h.sign(T) * o.MIN_REPULSION_DIST), E = x * x + T * T, A = Math.sqrt(E), S = this.repulsionConstant * p.noOfChildren * g.noOfChildren / E, k = S * x / A, _ = S * T / A, p.repulsionForceX -= k, p.repulsionForceY -= _, g.repulsionForceX += k, g.repulsionForceY += _;
            }, f.prototype.calcGravitationalForce = function(p) {
              var g, m, v, y, b, x, T, E;
              g = p.getOwner(), m = (g.getRight() + g.getLeft()) / 2, v = (g.getTop() + g.getBottom()) / 2, y = p.getCenterX() - m, b = p.getCenterY() - v, x = Math.abs(y) + p.getWidth() / 2, T = Math.abs(b) + p.getHeight() / 2, p.getOwner() == this.graphManager.getRoot() ? (E = g.getEstimatedSize() * this.gravityRangeFactor, (x > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y, p.gravitationForceY = -this.gravityConstant * b)) : (E = g.getEstimatedSize() * this.compoundGravityRangeFactor, (x > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y * this.compoundGravityConstant, p.gravitationForceY = -this.gravityConstant * b * this.compoundGravityConstant));
            }, f.prototype.isConverged = function() {
              var p, g = !1;
              return this.totalIterations > this.maxIterations / 3 && (g = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2), p = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, p || g;
            }, f.prototype.animate = function() {
              this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
            }, f.prototype.calcNoOfChildrenForAllNodes = function() {
              for (var p, g = this.graphManager.getAllNodes(), m = 0; m < g.length; m++)
                p = g[m], p.noOfChildren = p.getNoOfChildren();
            }, f.prototype.calcGrid = function(p) {
              var g = 0, m = 0;
              g = parseInt(Math.ceil((p.getRight() - p.getLeft()) / this.repulsionRange)), m = parseInt(Math.ceil((p.getBottom() - p.getTop()) / this.repulsionRange));
              for (var v = new Array(g), y = 0; y < g; y++)
                v[y] = new Array(m);
              for (var y = 0; y < g; y++)
                for (var b = 0; b < m; b++)
                  v[y][b] = new Array();
              return v;
            }, f.prototype.addNodeToGrid = function(p, g, m) {
              var v = 0, y = 0, b = 0, x = 0;
              v = parseInt(Math.floor((p.getRect().x - g) / this.repulsionRange)), y = parseInt(Math.floor((p.getRect().width + p.getRect().x - g) / this.repulsionRange)), b = parseInt(Math.floor((p.getRect().y - m) / this.repulsionRange)), x = parseInt(Math.floor((p.getRect().height + p.getRect().y - m) / this.repulsionRange));
              for (var T = v; T <= y; T++)
                for (var E = b; E <= x; E++)
                  this.grid[T][E].push(p), p.setGridCoordinates(v, y, b, x);
            }, f.prototype.updateGrid = function() {
              var p, g, m = this.getAllNodes();
              for (this.grid = this.calcGrid(this.graphManager.getRoot()), p = 0; p < m.length; p++)
                g = m[p], this.addNodeToGrid(g, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
            }, f.prototype.calculateRepulsionForceOfANode = function(p, g, m, v) {
              if (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && m || v) {
                var y = /* @__PURE__ */ new Set();
                p.surrounding = new Array();
                for (var b, x = this.grid, T = p.startX - 1; T < p.finishX + 2; T++)
                  for (var E = p.startY - 1; E < p.finishY + 2; E++)
                    if (!(T < 0 || E < 0 || T >= x.length || E >= x[0].length)) {
                      for (var A = 0; A < x[T][E].length; A++)
                        if (b = x[T][E][A], !(p.getOwner() != b.getOwner() || p == b) && !g.has(b) && !y.has(b)) {
                          var S = Math.abs(p.getCenterX() - b.getCenterX()) - (p.getWidth() / 2 + b.getWidth() / 2), k = Math.abs(p.getCenterY() - b.getCenterY()) - (p.getHeight() / 2 + b.getHeight() / 2);
                          S <= this.repulsionRange && k <= this.repulsionRange && y.add(b);
                        }
                    }
                p.surrounding = [].concat(a(y));
              }
              for (T = 0; T < p.surrounding.length; T++)
                this.calcRepulsionForce(p, p.surrounding[T]);
            }, f.prototype.calcRepulsionRange = function() {
              return 0;
            }, r.exports = f;
          }),
          /* 19 */
          /***/
          (function(r, n, i) {
            var a = i(1), s = i(7);
            function o(u, h, f) {
              a.call(this, u, h, f), this.idealLength = s.DEFAULT_EDGE_LENGTH;
            }
            o.prototype = Object.create(a.prototype);
            for (var l in a)
              o[l] = a[l];
            r.exports = o;
          }),
          /* 20 */
          /***/
          (function(r, n, i) {
            var a = i(3);
            function s(l, u, h, f) {
              a.call(this, l, u, h, f), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
            }
            s.prototype = Object.create(a.prototype);
            for (var o in a)
              s[o] = a[o];
            s.prototype.setGridCoordinates = function(l, u, h, f) {
              this.startX = l, this.finishX = u, this.startY = h, this.finishY = f;
            }, r.exports = s;
          }),
          /* 21 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              this.width = 0, this.height = 0, s !== null && o !== null && (this.height = o, this.width = s);
            }
            a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, r.exports = a;
          }),
          /* 22 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.map = {}, this.keys = [];
            }
            s.prototype.put = function(o, l) {
              var u = a.createID(o);
              this.contains(u) || (this.map[u] = l, this.keys.push(o));
            }, s.prototype.contains = function(o) {
              return a.createID(o), this.map[o] != null;
            }, s.prototype.get = function(o) {
              var l = a.createID(o);
              return this.map[l];
            }, s.prototype.keySet = function() {
              return this.keys;
            }, r.exports = s;
          }),
          /* 23 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.set = {};
            }
            s.prototype.add = function(o) {
              var l = a.createID(o);
              this.contains(l) || (this.set[l] = o);
            }, s.prototype.remove = function(o) {
              delete this.set[a.createID(o)];
            }, s.prototype.clear = function() {
              this.set = {};
            }, s.prototype.contains = function(o) {
              return this.set[a.createID(o)] == o;
            }, s.prototype.isEmpty = function() {
              return this.size() === 0;
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAllTo = function(o) {
              for (var l = Object.keys(this.set), u = l.length, h = 0; h < u; h++)
                o.push(this.set[l[h]]);
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAll = function(o) {
              for (var l = o.length, u = 0; u < l; u++) {
                var h = o[u];
                this.add(h);
              }
            }, r.exports = s;
          }),
          /* 24 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function u(h, f) {
                for (var d = 0; d < f.length; d++) {
                  var p = f[d];
                  p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(h, p.key, p);
                }
              }
              return function(h, f, d) {
                return f && u(h.prototype, f), d && u(h, d), h;
              };
            })();
            function s(u, h) {
              if (!(u instanceof h))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = i(11), l = (function() {
              function u(h, f) {
                s(this, u), (f !== null || f !== void 0) && (this.compareFunction = this._defaultCompareFunction);
                var d = void 0;
                h instanceof o ? d = h.size() : d = h.length, this._quicksort(h, 0, d - 1);
              }
              return a(u, [{
                key: "_quicksort",
                value: function(f, d, p) {
                  if (d < p) {
                    var g = this._partition(f, d, p);
                    this._quicksort(f, d, g), this._quicksort(f, g + 1, p);
                  }
                }
              }, {
                key: "_partition",
                value: function(f, d, p) {
                  for (var g = this._get(f, d), m = d, v = p; ; ) {
                    for (; this.compareFunction(g, this._get(f, v)); )
                      v--;
                    for (; this.compareFunction(this._get(f, m), g); )
                      m++;
                    if (m < v)
                      this._swap(f, m, v), m++, v--;
                    else return v;
                  }
                }
              }, {
                key: "_get",
                value: function(f, d) {
                  return f instanceof o ? f.get_object_at(d) : f[d];
                }
              }, {
                key: "_set",
                value: function(f, d, p) {
                  f instanceof o ? f.set_object_at(d, p) : f[d] = p;
                }
              }, {
                key: "_swap",
                value: function(f, d, p) {
                  var g = this._get(f, d);
                  this._set(f, d, this._get(f, p)), this._set(f, p, g);
                }
              }, {
                key: "_defaultCompareFunction",
                value: function(f, d) {
                  return d > f;
                }
              }]), u;
            })();
            r.exports = l;
          }),
          /* 25 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function l(u, h) {
                for (var f = 0; f < h.length; f++) {
                  var d = h[f];
                  d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(u, d.key, d);
                }
              }
              return function(u, h, f) {
                return h && l(u.prototype, h), f && l(u, f), u;
              };
            })();
            function s(l, u) {
              if (!(l instanceof u))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = (function() {
              function l(u, h) {
                var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
                s(this, l), this.sequence1 = u, this.sequence2 = h, this.match_score = f, this.mismatch_penalty = d, this.gap_penalty = p, this.iMax = u.length + 1, this.jMax = h.length + 1, this.grid = new Array(this.iMax);
                for (var g = 0; g < this.iMax; g++) {
                  this.grid[g] = new Array(this.jMax);
                  for (var m = 0; m < this.jMax; m++)
                    this.grid[g][m] = 0;
                }
                this.tracebackGrid = new Array(this.iMax);
                for (var v = 0; v < this.iMax; v++) {
                  this.tracebackGrid[v] = new Array(this.jMax);
                  for (var y = 0; y < this.jMax; y++)
                    this.tracebackGrid[v][y] = [null, null, null];
                }
                this.alignments = [], this.score = -1, this.computeGrids();
              }
              return a(l, [{
                key: "getScore",
                value: function() {
                  return this.score;
                }
              }, {
                key: "getAlignments",
                value: function() {
                  return this.alignments;
                }
                // Main dynamic programming procedure
              }, {
                key: "computeGrids",
                value: function() {
                  for (var h = 1; h < this.jMax; h++)
                    this.grid[0][h] = this.grid[0][h - 1] + this.gap_penalty, this.tracebackGrid[0][h] = [!1, !1, !0];
                  for (var f = 1; f < this.iMax; f++)
                    this.grid[f][0] = this.grid[f - 1][0] + this.gap_penalty, this.tracebackGrid[f][0] = [!1, !0, !1];
                  for (var d = 1; d < this.iMax; d++)
                    for (var p = 1; p < this.jMax; p++) {
                      var g = void 0;
                      this.sequence1[d - 1] === this.sequence2[p - 1] ? g = this.grid[d - 1][p - 1] + this.match_score : g = this.grid[d - 1][p - 1] + this.mismatch_penalty;
                      var m = this.grid[d - 1][p] + this.gap_penalty, v = this.grid[d][p - 1] + this.gap_penalty, y = [g, m, v], b = this.arrayAllMaxIndexes(y);
                      this.grid[d][p] = y[b[0]], this.tracebackGrid[d][p] = [b.includes(0), b.includes(1), b.includes(2)];
                    }
                  this.score = this.grid[this.iMax - 1][this.jMax - 1];
                }
                // Gets all possible valid sequence combinations
              }, {
                key: "alignmentTraceback",
                value: function() {
                  var h = [];
                  for (h.push({
                    pos: [this.sequence1.length, this.sequence2.length],
                    seq1: "",
                    seq2: ""
                  }); h[0]; ) {
                    var f = h[0], d = this.tracebackGrid[f.pos[0]][f.pos[1]];
                    d[0] && h.push({
                      pos: [f.pos[0] - 1, f.pos[1] - 1],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), d[1] && h.push({
                      pos: [f.pos[0] - 1, f.pos[1]],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: "-" + f.seq2
                    }), d[2] && h.push({
                      pos: [f.pos[0], f.pos[1] - 1],
                      seq1: "-" + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), f.pos[0] === 0 && f.pos[1] === 0 && this.alignments.push({
                      sequence1: f.seq1,
                      sequence2: f.seq2
                    }), h.shift();
                  }
                  return this.alignments;
                }
                // Helper Functions
              }, {
                key: "getAllIndexes",
                value: function(h, f) {
                  for (var d = [], p = -1; (p = h.indexOf(f, p + 1)) !== -1; )
                    d.push(p);
                  return d;
                }
              }, {
                key: "arrayAllMaxIndexes",
                value: function(h) {
                  return this.getAllIndexes(h, Math.max.apply(null, h));
                }
              }]), l;
            })();
            r.exports = o;
          }),
          /* 26 */
          /***/
          (function(r, n, i) {
            var a = function() {
            };
            a.FDLayout = i(18), a.FDLayoutConstants = i(7), a.FDLayoutEdge = i(19), a.FDLayoutNode = i(20), a.DimensionD = i(21), a.HashMap = i(22), a.HashSet = i(23), a.IGeometry = i(8), a.IMath = i(9), a.Integer = i(10), a.Point = i(12), a.PointD = i(4), a.RandomSeed = i(16), a.RectangleD = i(13), a.Transform = i(17), a.UniqueIDGeneretor = i(14), a.Quicksort = i(24), a.LinkedList = i(11), a.LGraphObject = i(2), a.LGraph = i(5), a.LEdge = i(1), a.LGraphManager = i(6), a.LNode = i(3), a.Layout = i(15), a.LayoutConstants = i(0), a.NeedlemanWunsch = i(25), r.exports = a;
          }),
          /* 27 */
          /***/
          (function(r, n, i) {
            function a() {
              this.listeners = [];
            }
            var s = a.prototype;
            s.addListener = function(o, l) {
              this.listeners.push({
                event: o,
                callback: l
              });
            }, s.removeListener = function(o, l) {
              for (var u = this.listeners.length; u >= 0; u--) {
                var h = this.listeners[u];
                h.event === o && h.callback === l && this.listeners.splice(u, 1);
              }
            }, s.emit = function(o, l) {
              for (var u = 0; u < this.listeners.length; u++) {
                var h = this.listeners[u];
                o === h.event && h.callback(l);
              }
            }, r.exports = a;
          })
          /******/
        ])
      );
    });
  })(Xy)), Xy.exports;
}
var _Oe = Yy.exports, RU;
function AOe() {
  return RU || (RU = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(COe());
    })(_Oe, function(r) {
      return (
        /******/
        (function(n) {
          var i = {};
          function a(s) {
            if (i[s])
              return i[s].exports;
            var o = i[s] = {
              /******/
              i: s,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return n[s].call(o.exports, o, o.exports, a), o.l = !0, o.exports;
          }
          return a.m = n, a.c = i, a.i = function(s) {
            return s;
          }, a.d = function(s, o, l) {
            a.o(s, o) || Object.defineProperty(s, o, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: l
              /******/
            });
          }, a.n = function(s) {
            var o = s && s.__esModule ? (
              /******/
              function() {
                return s.default;
              }
            ) : (
              /******/
              function() {
                return s;
              }
            );
            return a.d(o, "a", o), o;
          }, a.o = function(s, o) {
            return Object.prototype.hasOwnProperty.call(s, o);
          }, a.p = "", a(a.s = 7);
        })([
          /* 0 */
          /***/
          (function(n, i) {
            n.exports = r;
          }),
          /* 1 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayoutConstants;
            function o() {
            }
            for (var l in s)
              o[l] = s[l];
            o.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, o.DEFAULT_RADIAL_SEPARATION = s.DEFAULT_EDGE_LENGTH, o.DEFAULT_COMPONENT_SEPERATION = 60, o.TILE = !0, o.TILING_PADDING_VERTICAL = 10, o.TILING_PADDING_HORIZONTAL = 10, o.TREE_REDUCTION_ON_INCREMENTAL = !1, n.exports = o;
          }),
          /* 2 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayoutEdge;
            function o(u, h, f) {
              s.call(this, u, h, f);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          }),
          /* 3 */
          /***/
          (function(n, i, a) {
            var s = a(0).LGraph;
            function o(u, h, f) {
              s.call(this, u, h, f);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          }),
          /* 4 */
          /***/
          (function(n, i, a) {
            var s = a(0).LGraphManager;
            function o(u) {
              s.call(this, u);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          }),
          /* 5 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayoutNode, o = a(0).IMath;
            function l(h, f, d, p) {
              s.call(this, h, f, d, p);
            }
            l.prototype = Object.create(s.prototype);
            for (var u in s)
              l[u] = s[u];
            l.prototype.move = function() {
              var h = this.graphManager.getLayout();
              this.displacementX = h.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY = h.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren, Math.abs(this.displacementX) > h.coolingFactor * h.maxNodeDisplacement && (this.displacementX = h.coolingFactor * h.maxNodeDisplacement * o.sign(this.displacementX)), Math.abs(this.displacementY) > h.coolingFactor * h.maxNodeDisplacement && (this.displacementY = h.coolingFactor * h.maxNodeDisplacement * o.sign(this.displacementY)), this.child == null ? this.moveBy(this.displacementX, this.displacementY) : this.child.getNodes().length == 0 ? this.moveBy(this.displacementX, this.displacementY) : this.propogateDisplacementToChildren(this.displacementX, this.displacementY), h.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
            }, l.prototype.propogateDisplacementToChildren = function(h, f) {
              for (var d = this.getChild().getNodes(), p, g = 0; g < d.length; g++)
                p = d[g], p.getChild() == null ? (p.moveBy(h, f), p.displacementX += h, p.displacementY += f) : p.propogateDisplacementToChildren(h, f);
            }, l.prototype.setPred1 = function(h) {
              this.pred1 = h;
            }, l.prototype.getPred1 = function() {
              return pred1;
            }, l.prototype.getPred2 = function() {
              return pred2;
            }, l.prototype.setNext = function(h) {
              this.next = h;
            }, l.prototype.getNext = function() {
              return next;
            }, l.prototype.setProcessed = function(h) {
              this.processed = h;
            }, l.prototype.isProcessed = function() {
              return processed;
            }, n.exports = l;
          }),
          /* 6 */
          /***/
          (function(n, i, a) {
            var s = a(0).FDLayout, o = a(4), l = a(3), u = a(5), h = a(2), f = a(1), d = a(0).FDLayoutConstants, p = a(0).LayoutConstants, g = a(0).Point, m = a(0).PointD, v = a(0).Layout, y = a(0).Integer, b = a(0).IGeometry, x = a(0).LGraph, T = a(0).Transform;
            function E() {
              s.call(this), this.toBeTiled = {};
            }
            E.prototype = Object.create(s.prototype);
            for (var A in s)
              E[A] = s[A];
            E.prototype.newGraphManager = function() {
              var S = new o(this);
              return this.graphManager = S, S;
            }, E.prototype.newGraph = function(S) {
              return new l(null, this.graphManager, S);
            }, E.prototype.newNode = function(S) {
              return new u(this.graphManager, S);
            }, E.prototype.newEdge = function(S) {
              return new h(null, null, S);
            }, E.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.isSubLayout || (f.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = f.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = f.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.springConstant = d.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = d.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = d.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = d.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = d.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = d.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1, this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / d.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = d.CONVERGENCE_CHECK_PERIOD / this.maxIterations, this.coolingAdjuster = 1);
            }, E.prototype.layout = function() {
              var S = p.DEFAULT_CREATE_BENDS_AS_NEEDED;
              return S && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
            }, E.prototype.classicLayout = function() {
              if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
                if (f.TREE_REDUCTION_ON_INCREMENTAL) {
                  this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                  var k = new Set(this.getAllNodes()), _ = this.nodesWithGravity.filter(function(M) {
                    return k.has(M);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(_);
                }
              } else {
                var S = this.getFlatForest();
                if (S.length > 0)
                  this.positionNodesRadially(S);
                else {
                  this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                  var k = new Set(this.getAllNodes()), _ = this.nodesWithGravity.filter(function(R) {
                    return k.has(R);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(_), this.positionNodesRandomly();
                }
              }
              return this.initSpringEmbedder(), this.runSpringEmbedder(), !0;
            }, E.prototype.tick = function() {
              if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished)
                if (this.prunedNodesAll.length > 0)
                  this.isTreeGrowing = !0;
                else
                  return !0;
              if (this.totalIterations % d.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                if (this.isConverged())
                  if (this.prunedNodesAll.length > 0)
                    this.isTreeGrowing = !0;
                  else
                    return !0;
                this.coolingCycle++, this.layoutQuality == 0 ? this.coolingAdjuster = this.coolingCycle : this.layoutQuality == 1 && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
              }
              if (this.isTreeGrowing) {
                if (this.growTreeIterations % 10 == 0)
                  if (this.prunedNodesAll.length > 0) {
                    this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
                    var S = new Set(this.getAllNodes()), k = this.nodesWithGravity.filter(function(L) {
                      return S.has(L);
                    });
                    this.graphManager.setAllNodesToApplyGravitation(k), this.graphManager.updateBounds(), this.updateGrid(), this.coolingFactor = d.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                  } else
                    this.isTreeGrowing = !1, this.isGrowthFinished = !0;
                this.growTreeIterations++;
              }
              if (this.isGrowthFinished) {
                if (this.isConverged())
                  return !0;
                this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), this.coolingFactor = d.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
              }
              var _ = !this.isTreeGrowing && !this.isGrowthFinished, R = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
              return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(_, R), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
            }, E.prototype.getPositionsData = function() {
              for (var S = this.graphManager.getAllNodes(), k = {}, _ = 0; _ < S.length; _++) {
                var R = S[_].rect, L = S[_].id;
                k[L] = {
                  id: L,
                  x: R.getCenterX(),
                  y: R.getCenterY(),
                  w: R.width,
                  h: R.height
                };
              }
              return k;
            }, E.prototype.runSpringEmbedder = function() {
              this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
              var S = !1;
              if (d.ANIMATE === "during")
                this.emit("layoutstarted");
              else {
                for (; !S; )
                  S = this.tick();
                this.graphManager.updateBounds();
              }
            }, E.prototype.calculateNodesToApplyGravitationTo = function() {
              var S = [], k, _ = this.graphManager.getGraphs(), R = _.length, L;
              for (L = 0; L < R; L++)
                k = _[L], k.updateConnected(), k.isConnected || (S = S.concat(k.getNodes()));
              return S;
            }, E.prototype.createBendpoints = function() {
              var S = [];
              S = S.concat(this.graphManager.getAllEdges());
              var k = /* @__PURE__ */ new Set(), _;
              for (_ = 0; _ < S.length; _++) {
                var R = S[_];
                if (!k.has(R)) {
                  var L = R.getSource(), M = R.getTarget();
                  if (L == M)
                    R.getBendpoints().push(new m()), R.getBendpoints().push(new m()), this.createDummyNodesForBendpoints(R), k.add(R);
                  else {
                    var P = [];
                    if (P = P.concat(L.getEdgeListToNode(M)), P = P.concat(M.getEdgeListToNode(L)), !k.has(P[0])) {
                      if (P.length > 1) {
                        var C;
                        for (C = 0; C < P.length; C++) {
                          var I = P[C];
                          I.getBendpoints().push(new m()), this.createDummyNodesForBendpoints(I);
                        }
                      }
                      P.forEach(function(N) {
                        k.add(N);
                      });
                    }
                  }
                }
                if (k.size == S.length)
                  break;
              }
            }, E.prototype.positionNodesRadially = function(S) {
              for (var k = new g(0, 0), _ = Math.ceil(Math.sqrt(S.length)), R = 0, L = 0, M = 0, P = new m(0, 0), C = 0; C < S.length; C++) {
                C % _ == 0 && (M = 0, L = R, C != 0 && (L += f.DEFAULT_COMPONENT_SEPERATION), R = 0);
                var I = S[C], N = v.findCenterOfTree(I);
                k.x = M, k.y = L, P = E.radialLayout(I, N, k), P.y > R && (R = Math.floor(P.y)), M = Math.floor(P.x + f.DEFAULT_COMPONENT_SEPERATION);
              }
              this.transform(new m(p.WORLD_CENTER_X - P.x / 2, p.WORLD_CENTER_Y - P.y / 2));
            }, E.radialLayout = function(S, k, _) {
              var R = Math.max(this.maxDiagonalInTree(S), f.DEFAULT_RADIAL_SEPARATION);
              E.branchRadialLayout(k, null, 0, 359, 0, R);
              var L = x.calculateBounds(S), M = new T();
              M.setDeviceOrgX(L.getMinX()), M.setDeviceOrgY(L.getMinY()), M.setWorldOrgX(_.x), M.setWorldOrgY(_.y);
              for (var P = 0; P < S.length; P++) {
                var C = S[P];
                C.transform(M);
              }
              var I = new m(L.getMaxX(), L.getMaxY());
              return M.inverseTransformPoint(I);
            }, E.branchRadialLayout = function(S, k, _, R, L, M) {
              var P = (R - _ + 1) / 2;
              P < 0 && (P += 180);
              var C = (P + _) % 360, I = C * b.TWO_PI / 360, N = L * Math.cos(I), O = L * Math.sin(I);
              S.setCenter(N, O);
              var D = [];
              D = D.concat(S.getEdges());
              var $ = D.length;
              k != null && $--;
              for (var z = 0, B = D.length, G, W = S.getEdgesBetween(k); W.length > 1; ) {
                var V = W[0];
                W.splice(0, 1);
                var U = D.indexOf(V);
                U >= 0 && D.splice(U, 1), B--, $--;
              }
              k != null ? G = (D.indexOf(W[0]) + 1) % B : G = 0;
              for (var Z = Math.abs(R - _) / $, K = G; z != $; K = ++K % B) {
                var ce = D[K].getOtherEnd(S);
                if (ce != k) {
                  var J = (_ + z * Z) % 360, ee = (J + Z) % 360;
                  E.branchRadialLayout(ce, S, J, ee, L + M, M), z++;
                }
              }
            }, E.maxDiagonalInTree = function(S) {
              for (var k = y.MIN_VALUE, _ = 0; _ < S.length; _++) {
                var R = S[_], L = R.getDiagonal();
                L > k && (k = L);
              }
              return k;
            }, E.prototype.calcRepulsionRange = function() {
              return 2 * (this.level + 1) * this.idealEdgeLength;
            }, E.prototype.groupZeroDegreeMembers = function() {
              var S = this, k = {};
              this.memberGroups = {}, this.idToDummyNode = {};
              for (var _ = [], R = this.graphManager.getAllNodes(), L = 0; L < R.length; L++) {
                var M = R[L], P = M.getParent();
                this.getNodeDegreeWithChildren(M) === 0 && (P.id == null || !this.getToBeTiled(P)) && _.push(M);
              }
              for (var L = 0; L < _.length; L++) {
                var M = _[L], C = M.getParent().id;
                typeof k[C] > "u" && (k[C] = []), k[C] = k[C].concat(M);
              }
              Object.keys(k).forEach(function(I) {
                if (k[I].length > 1) {
                  var N = "DummyCompound_" + I;
                  S.memberGroups[N] = k[I];
                  var O = k[I][0].getParent(), D = new u(S.graphManager);
                  D.id = N, D.paddingLeft = O.paddingLeft || 0, D.paddingRight = O.paddingRight || 0, D.paddingBottom = O.paddingBottom || 0, D.paddingTop = O.paddingTop || 0, S.idToDummyNode[N] = D;
                  var $ = S.getGraphManager().add(S.newGraph(), D), z = O.getChild();
                  z.add(D);
                  for (var B = 0; B < k[I].length; B++) {
                    var G = k[I][B];
                    z.remove(G), $.add(G);
                  }
                }
              });
            }, E.prototype.clearCompounds = function() {
              var S = {}, k = {};
              this.performDFSOnCompounds();
              for (var _ = 0; _ < this.compoundOrder.length; _++)
                k[this.compoundOrder[_].id] = this.compoundOrder[_], S[this.compoundOrder[_].id] = [].concat(this.compoundOrder[_].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[_].getChild()), this.compoundOrder[_].child = null;
              this.graphManager.resetAllNodes(), this.tileCompoundMembers(S, k);
            }, E.prototype.clearZeroDegreeMembers = function() {
              var S = this, k = this.tiledZeroDegreePack = [];
              Object.keys(this.memberGroups).forEach(function(_) {
                var R = S.idToDummyNode[_];
                k[_] = S.tileNodes(S.memberGroups[_], R.paddingLeft + R.paddingRight), R.rect.width = k[_].width, R.rect.height = k[_].height;
              });
            }, E.prototype.repopulateCompounds = function() {
              for (var S = this.compoundOrder.length - 1; S >= 0; S--) {
                var k = this.compoundOrder[S], _ = k.id, R = k.paddingLeft, L = k.paddingTop;
                this.adjustLocations(this.tiledMemberPack[_], k.rect.x, k.rect.y, R, L);
              }
            }, E.prototype.repopulateZeroDegreeMembers = function() {
              var S = this, k = this.tiledZeroDegreePack;
              Object.keys(k).forEach(function(_) {
                var R = S.idToDummyNode[_], L = R.paddingLeft, M = R.paddingTop;
                S.adjustLocations(k[_], R.rect.x, R.rect.y, L, M);
              });
            }, E.prototype.getToBeTiled = function(S) {
              var k = S.id;
              if (this.toBeTiled[k] != null)
                return this.toBeTiled[k];
              var _ = S.getChild();
              if (_ == null)
                return this.toBeTiled[k] = !1, !1;
              for (var R = _.getNodes(), L = 0; L < R.length; L++) {
                var M = R[L];
                if (this.getNodeDegree(M) > 0)
                  return this.toBeTiled[k] = !1, !1;
                if (M.getChild() == null) {
                  this.toBeTiled[M.id] = !1;
                  continue;
                }
                if (!this.getToBeTiled(M))
                  return this.toBeTiled[k] = !1, !1;
              }
              return this.toBeTiled[k] = !0, !0;
            }, E.prototype.getNodeDegree = function(S) {
              S.id;
              for (var k = S.getEdges(), _ = 0, R = 0; R < k.length; R++) {
                var L = k[R];
                L.getSource().id !== L.getTarget().id && (_ = _ + 1);
              }
              return _;
            }, E.prototype.getNodeDegreeWithChildren = function(S) {
              var k = this.getNodeDegree(S);
              if (S.getChild() == null)
                return k;
              for (var _ = S.getChild().getNodes(), R = 0; R < _.length; R++) {
                var L = _[R];
                k += this.getNodeDegreeWithChildren(L);
              }
              return k;
            }, E.prototype.performDFSOnCompounds = function() {
              this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
            }, E.prototype.fillCompexOrderByDFS = function(S) {
              for (var k = 0; k < S.length; k++) {
                var _ = S[k];
                _.getChild() != null && this.fillCompexOrderByDFS(_.getChild().getNodes()), this.getToBeTiled(_) && this.compoundOrder.push(_);
              }
            }, E.prototype.adjustLocations = function(S, k, _, R, L) {
              k += R, _ += L;
              for (var M = k, P = 0; P < S.rows.length; P++) {
                var C = S.rows[P];
                k = M;
                for (var I = 0, N = 0; N < C.length; N++) {
                  var O = C[N];
                  O.rect.x = k, O.rect.y = _, k += O.rect.width + S.horizontalPadding, O.rect.height > I && (I = O.rect.height);
                }
                _ += I + S.verticalPadding;
              }
            }, E.prototype.tileCompoundMembers = function(S, k) {
              var _ = this;
              this.tiledMemberPack = [], Object.keys(S).forEach(function(R) {
                var L = k[R];
                _.tiledMemberPack[R] = _.tileNodes(S[R], L.paddingLeft + L.paddingRight), L.rect.width = _.tiledMemberPack[R].width, L.rect.height = _.tiledMemberPack[R].height;
              });
            }, E.prototype.tileNodes = function(S, k) {
              var _ = f.TILING_PADDING_VERTICAL, R = f.TILING_PADDING_HORIZONTAL, L = {
                rows: [],
                rowWidth: [],
                rowHeight: [],
                width: 0,
                height: k,
                // assume minHeight equals to minWidth
                verticalPadding: _,
                horizontalPadding: R
              };
              S.sort(function(C, I) {
                return C.rect.width * C.rect.height > I.rect.width * I.rect.height ? -1 : C.rect.width * C.rect.height < I.rect.width * I.rect.height ? 1 : 0;
              });
              for (var M = 0; M < S.length; M++) {
                var P = S[M];
                L.rows.length == 0 ? this.insertNodeToRow(L, P, 0, k) : this.canAddHorizontal(L, P.rect.width, P.rect.height) ? this.insertNodeToRow(L, P, this.getShortestRowIndex(L), k) : this.insertNodeToRow(L, P, L.rows.length, k), this.shiftToLastRow(L);
              }
              return L;
            }, E.prototype.insertNodeToRow = function(S, k, _, R) {
              var L = R;
              if (_ == S.rows.length) {
                var M = [];
                S.rows.push(M), S.rowWidth.push(L), S.rowHeight.push(0);
              }
              var P = S.rowWidth[_] + k.rect.width;
              S.rows[_].length > 0 && (P += S.horizontalPadding), S.rowWidth[_] = P, S.width < P && (S.width = P);
              var C = k.rect.height;
              _ > 0 && (C += S.verticalPadding);
              var I = 0;
              C > S.rowHeight[_] && (I = S.rowHeight[_], S.rowHeight[_] = C, I = S.rowHeight[_] - I), S.height += I, S.rows[_].push(k);
            }, E.prototype.getShortestRowIndex = function(S) {
              for (var k = -1, _ = Number.MAX_VALUE, R = 0; R < S.rows.length; R++)
                S.rowWidth[R] < _ && (k = R, _ = S.rowWidth[R]);
              return k;
            }, E.prototype.getLongestRowIndex = function(S) {
              for (var k = -1, _ = Number.MIN_VALUE, R = 0; R < S.rows.length; R++)
                S.rowWidth[R] > _ && (k = R, _ = S.rowWidth[R]);
              return k;
            }, E.prototype.canAddHorizontal = function(S, k, _) {
              var R = this.getShortestRowIndex(S);
              if (R < 0)
                return !0;
              var L = S.rowWidth[R];
              if (L + S.horizontalPadding + k <= S.width) return !0;
              var M = 0;
              S.rowHeight[R] < _ && R > 0 && (M = _ + S.verticalPadding - S.rowHeight[R]);
              var P;
              S.width - L >= k + S.horizontalPadding ? P = (S.height + M) / (L + k + S.horizontalPadding) : P = (S.height + M) / S.width, M = _ + S.verticalPadding;
              var C;
              return S.width < k ? C = (S.height + M) / k : C = (S.height + M) / S.width, C < 1 && (C = 1 / C), P < 1 && (P = 1 / P), P < C;
            }, E.prototype.shiftToLastRow = function(S) {
              var k = this.getLongestRowIndex(S), _ = S.rowWidth.length - 1, R = S.rows[k], L = R[R.length - 1], M = L.width + S.horizontalPadding;
              if (S.width - S.rowWidth[_] > M && k != _) {
                R.splice(-1, 1), S.rows[_].push(L), S.rowWidth[k] = S.rowWidth[k] - M, S.rowWidth[_] = S.rowWidth[_] + M, S.width = S.rowWidth[instance.getLongestRowIndex(S)];
                for (var P = Number.MIN_VALUE, C = 0; C < R.length; C++)
                  R[C].height > P && (P = R[C].height);
                k > 0 && (P += S.verticalPadding);
                var I = S.rowHeight[k] + S.rowHeight[_];
                S.rowHeight[k] = P, S.rowHeight[_] < L.height + S.verticalPadding && (S.rowHeight[_] = L.height + S.verticalPadding);
                var N = S.rowHeight[k] + S.rowHeight[_];
                S.height += N - I, this.shiftToLastRow(S);
              }
            }, E.prototype.tilingPreLayout = function() {
              f.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
            }, E.prototype.tilingPostLayout = function() {
              f.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
            }, E.prototype.reduceTrees = function() {
              for (var S = [], k = !0, _; k; ) {
                var R = this.graphManager.getAllNodes(), L = [];
                k = !1;
                for (var M = 0; M < R.length; M++)
                  _ = R[M], _.getEdges().length == 1 && !_.getEdges()[0].isInterGraph && _.getChild() == null && (L.push([_, _.getEdges()[0], _.getOwner()]), k = !0);
                if (k == !0) {
                  for (var P = [], C = 0; C < L.length; C++)
                    L[C][0].getEdges().length == 1 && (P.push(L[C]), L[C][0].getOwner().remove(L[C][0]));
                  S.push(P), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                }
              }
              this.prunedNodesAll = S;
            }, E.prototype.growTree = function(S) {
              for (var k = S.length, _ = S[k - 1], R, L = 0; L < _.length; L++)
                R = _[L], this.findPlaceforPrunedNode(R), R[2].add(R[0]), R[2].add(R[1], R[1].source, R[1].target);
              S.splice(S.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
            }, E.prototype.findPlaceforPrunedNode = function(S) {
              var k, _, R = S[0];
              R == S[1].source ? _ = S[1].target : _ = S[1].source;
              var L = _.startX, M = _.finishX, P = _.startY, C = _.finishY, I = 0, N = 0, O = 0, D = 0, $ = [I, O, N, D];
              if (P > 0)
                for (var z = L; z <= M; z++)
                  $[0] += this.grid[z][P - 1].length + this.grid[z][P].length - 1;
              if (M < this.grid.length - 1)
                for (var z = P; z <= C; z++)
                  $[1] += this.grid[M + 1][z].length + this.grid[M][z].length - 1;
              if (C < this.grid[0].length - 1)
                for (var z = L; z <= M; z++)
                  $[2] += this.grid[z][C + 1].length + this.grid[z][C].length - 1;
              if (L > 0)
                for (var z = P; z <= C; z++)
                  $[3] += this.grid[L - 1][z].length + this.grid[L][z].length - 1;
              for (var B = y.MAX_VALUE, G, W, V = 0; V < $.length; V++)
                $[V] < B ? (B = $[V], G = 1, W = V) : $[V] == B && G++;
              if (G == 3 && B == 0)
                $[0] == 0 && $[1] == 0 && $[2] == 0 ? k = 1 : $[0] == 0 && $[1] == 0 && $[3] == 0 ? k = 0 : $[0] == 0 && $[2] == 0 && $[3] == 0 ? k = 3 : $[1] == 0 && $[2] == 0 && $[3] == 0 && (k = 2);
              else if (G == 2 && B == 0) {
                var U = Math.floor(Math.random() * 2);
                $[0] == 0 && $[1] == 0 ? U == 0 ? k = 0 : k = 1 : $[0] == 0 && $[2] == 0 ? U == 0 ? k = 0 : k = 2 : $[0] == 0 && $[3] == 0 ? U == 0 ? k = 0 : k = 3 : $[1] == 0 && $[2] == 0 ? U == 0 ? k = 1 : k = 2 : $[1] == 0 && $[3] == 0 ? U == 0 ? k = 1 : k = 3 : U == 0 ? k = 2 : k = 3;
              } else if (G == 4 && B == 0) {
                var U = Math.floor(Math.random() * 4);
                k = U;
              } else
                k = W;
              k == 0 ? R.setCenter(_.getCenterX(), _.getCenterY() - _.getHeight() / 2 - d.DEFAULT_EDGE_LENGTH - R.getHeight() / 2) : k == 1 ? R.setCenter(_.getCenterX() + _.getWidth() / 2 + d.DEFAULT_EDGE_LENGTH + R.getWidth() / 2, _.getCenterY()) : k == 2 ? R.setCenter(_.getCenterX(), _.getCenterY() + _.getHeight() / 2 + d.DEFAULT_EDGE_LENGTH + R.getHeight() / 2) : R.setCenter(_.getCenterX() - _.getWidth() / 2 - d.DEFAULT_EDGE_LENGTH - R.getWidth() / 2, _.getCenterY());
            }, n.exports = E;
          }),
          /* 7 */
          /***/
          (function(n, i, a) {
            var s = {};
            s.layoutBase = a(0), s.CoSEConstants = a(1), s.CoSEEdge = a(2), s.CoSEGraph = a(3), s.CoSEGraphManager = a(4), s.CoSELayout = a(6), s.CoSENode = a(5), n.exports = s;
          })
          /******/
        ])
      );
    });
  })(Yy)), Yy.exports;
}
var LOe = Wy.exports, IU;
function ROe() {
  return IU || (IU = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(AOe());
    })(LOe, function(r) {
      return (
        /******/
        (function(n) {
          var i = {};
          function a(s) {
            if (i[s])
              return i[s].exports;
            var o = i[s] = {
              /******/
              i: s,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return n[s].call(o.exports, o, o.exports, a), o.l = !0, o.exports;
          }
          return a.m = n, a.c = i, a.i = function(s) {
            return s;
          }, a.d = function(s, o, l) {
            a.o(s, o) || Object.defineProperty(s, o, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: l
              /******/
            });
          }, a.n = function(s) {
            var o = s && s.__esModule ? (
              /******/
              function() {
                return s.default;
              }
            ) : (
              /******/
              function() {
                return s;
              }
            );
            return a.d(o, "a", o), o;
          }, a.o = function(s, o) {
            return Object.prototype.hasOwnProperty.call(s, o);
          }, a.p = "", a(a.s = 1);
        })([
          /* 0 */
          /***/
          (function(n, i) {
            n.exports = r;
          }),
          /* 1 */
          /***/
          (function(n, i, a) {
            var s = a(0).layoutBase.LayoutConstants, o = a(0).layoutBase.FDLayoutConstants, l = a(0).CoSEConstants, u = a(0).CoSELayout, h = a(0).CoSENode, f = a(0).layoutBase.PointD, d = a(0).layoutBase.DimensionD, p = {
              // Called on `layoutready`
              ready: function() {
              },
              // Called on `layoutstop`
              stop: function() {
              },
              // 'draft', 'default' or 'proof" 
              // - 'draft' fast cooling rate 
              // - 'default' moderate cooling rate 
              // - "proof" slow cooling rate
              quality: "default",
              // include labels in node dimensions
              nodeDimensionsIncludeLabels: !1,
              // number of ticks per frame; higher is faster but more jerky
              refresh: 30,
              // Whether to fit the network view after when done
              fit: !0,
              // Padding on fit
              padding: 10,
              // Whether to enable incremental mode
              randomize: !0,
              // Node repulsion (non overlapping) multiplier
              nodeRepulsion: 4500,
              // Ideal edge (non nested) length
              idealEdgeLength: 50,
              // Divisor to compute edge forces
              edgeElasticity: 0.45,
              // Nesting factor (multiplier) to compute ideal edge length for nested edges
              nestingFactor: 0.1,
              // Gravity force (constant)
              gravity: 0.25,
              // Maximum number of iterations to perform
              numIter: 2500,
              // For enabling tiling
              tile: !0,
              // Type of layout animation. The option set is {'during', 'end', false}
              animate: "end",
              // Duration for animate:end
              animationDuration: 500,
              // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
              tilingPaddingVertical: 10,
              // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
              tilingPaddingHorizontal: 10,
              // Gravity range (constant) for compounds
              gravityRangeCompound: 1.5,
              // Gravity force (constant) for compounds
              gravityCompound: 1,
              // Gravity range (constant)
              gravityRange: 3.8,
              // Initial cooling factor for incremental layout
              initialEnergyOnIncremental: 0.5
            };
            function g(b, x) {
              var T = {};
              for (var E in b)
                T[E] = b[E];
              for (var E in x)
                T[E] = x[E];
              return T;
            }
            function m(b) {
              this.options = g(p, b), v(this.options);
            }
            var v = function(x) {
              x.nodeRepulsion != null && (l.DEFAULT_REPULSION_STRENGTH = o.DEFAULT_REPULSION_STRENGTH = x.nodeRepulsion), x.idealEdgeLength != null && (l.DEFAULT_EDGE_LENGTH = o.DEFAULT_EDGE_LENGTH = x.idealEdgeLength), x.edgeElasticity != null && (l.DEFAULT_SPRING_STRENGTH = o.DEFAULT_SPRING_STRENGTH = x.edgeElasticity), x.nestingFactor != null && (l.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = x.nestingFactor), x.gravity != null && (l.DEFAULT_GRAVITY_STRENGTH = o.DEFAULT_GRAVITY_STRENGTH = x.gravity), x.numIter != null && (l.MAX_ITERATIONS = o.MAX_ITERATIONS = x.numIter), x.gravityRange != null && (l.DEFAULT_GRAVITY_RANGE_FACTOR = o.DEFAULT_GRAVITY_RANGE_FACTOR = x.gravityRange), x.gravityCompound != null && (l.DEFAULT_COMPOUND_GRAVITY_STRENGTH = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH = x.gravityCompound), x.gravityRangeCompound != null && (l.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = x.gravityRangeCompound), x.initialEnergyOnIncremental != null && (l.DEFAULT_COOLING_FACTOR_INCREMENTAL = o.DEFAULT_COOLING_FACTOR_INCREMENTAL = x.initialEnergyOnIncremental), x.quality == "draft" ? s.QUALITY = 0 : x.quality == "proof" ? s.QUALITY = 2 : s.QUALITY = 1, l.NODE_DIMENSIONS_INCLUDE_LABELS = o.NODE_DIMENSIONS_INCLUDE_LABELS = s.NODE_DIMENSIONS_INCLUDE_LABELS = x.nodeDimensionsIncludeLabels, l.DEFAULT_INCREMENTAL = o.DEFAULT_INCREMENTAL = s.DEFAULT_INCREMENTAL = !x.randomize, l.ANIMATE = o.ANIMATE = s.ANIMATE = x.animate, l.TILE = x.tile, l.TILING_PADDING_VERTICAL = typeof x.tilingPaddingVertical == "function" ? x.tilingPaddingVertical.call() : x.tilingPaddingVertical, l.TILING_PADDING_HORIZONTAL = typeof x.tilingPaddingHorizontal == "function" ? x.tilingPaddingHorizontal.call() : x.tilingPaddingHorizontal;
            };
            m.prototype.run = function() {
              var b, x, T = this.options;
              this.idToLNode = {};
              var E = this.layout = new u(), A = this;
              A.stopped = !1, this.cy = this.options.cy, this.cy.trigger({ type: "layoutstart", layout: this });
              var S = E.newGraphManager();
              this.gm = S;
              var k = this.options.eles.nodes(), _ = this.options.eles.edges();
              this.root = S.addRoot(), this.processChildrenList(this.root, this.getTopMostNodes(k), E);
              for (var R = 0; R < _.length; R++) {
                var L = _[R], M = this.idToLNode[L.data("source")], P = this.idToLNode[L.data("target")];
                if (M !== P && M.getEdgesBetween(P).length == 0) {
                  var C = S.add(E.newEdge(), M, P);
                  C.id = L.id();
                }
              }
              var I = function(D, $) {
                typeof D == "number" && (D = $);
                var z = D.data("id"), B = A.idToLNode[z];
                return {
                  x: B.getRect().getCenterX(),
                  y: B.getRect().getCenterY()
                };
              }, N = function O() {
                for (var D = function() {
                  T.fit && T.cy.fit(T.eles, T.padding), b || (b = !0, A.cy.one("layoutready", T.ready), A.cy.trigger({ type: "layoutready", layout: A }));
                }, $ = A.options.refresh, z, B = 0; B < $ && !z; B++)
                  z = A.stopped || A.layout.tick();
                if (z) {
                  E.checkLayoutSuccess() && !E.isSubLayout && E.doPostLayout(), E.tilingPostLayout && E.tilingPostLayout(), E.isLayoutFinished = !0, A.options.eles.nodes().positions(I), D(), A.cy.one("layoutstop", A.options.stop), A.cy.trigger({ type: "layoutstop", layout: A }), x && cancelAnimationFrame(x), b = !1;
                  return;
                }
                var G = A.layout.getPositionsData();
                T.eles.nodes().positions(function(W, V) {
                  if (typeof W == "number" && (W = V), !W.isParent()) {
                    for (var U = W.id(), Z = G[U], K = W; Z == null && (Z = G[K.data("parent")] || G["DummyCompound_" + K.data("parent")], G[U] = Z, K = K.parent()[0], K != null); )
                      ;
                    return Z != null ? {
                      x: Z.x,
                      y: Z.y
                    } : {
                      x: W.position("x"),
                      y: W.position("y")
                    };
                  }
                }), D(), x = requestAnimationFrame(O);
              };
              return E.addListener("layoutstarted", function() {
                A.options.animate === "during" && (x = requestAnimationFrame(N));
              }), E.runLayout(), this.options.animate !== "during" && (A.options.eles.nodes().not(":parent").layoutPositions(A, A.options, I), b = !1), this;
            }, m.prototype.getTopMostNodes = function(b) {
              for (var x = {}, T = 0; T < b.length; T++)
                x[b[T].id()] = !0;
              var E = b.filter(function(A, S) {
                typeof A == "number" && (A = S);
                for (var k = A.parent()[0]; k != null; ) {
                  if (x[k.id()])
                    return !1;
                  k = k.parent()[0];
                }
                return !0;
              });
              return E;
            }, m.prototype.processChildrenList = function(b, x, T) {
              for (var E = x.length, A = 0; A < E; A++) {
                var S = x[A], k = S.children(), _, R = S.layoutDimensions({
                  nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels
                });
                if (S.outerWidth() != null && S.outerHeight() != null ? _ = b.add(new h(T.graphManager, new f(S.position("x") - R.w / 2, S.position("y") - R.h / 2), new d(parseFloat(R.w), parseFloat(R.h)))) : _ = b.add(new h(this.graphManager)), _.id = S.data("id"), _.paddingLeft = parseInt(S.css("padding")), _.paddingTop = parseInt(S.css("padding")), _.paddingRight = parseInt(S.css("padding")), _.paddingBottom = parseInt(S.css("padding")), this.options.nodeDimensionsIncludeLabels && S.isParent()) {
                  var L = S.boundingBox({ includeLabels: !0, includeNodes: !1 }).w, M = S.boundingBox({ includeLabels: !0, includeNodes: !1 }).h, P = S.css("text-halign");
                  _.labelWidth = L, _.labelHeight = M, _.labelPos = P;
                }
                if (this.idToLNode[S.data("id")] = _, isNaN(_.rect.x) && (_.rect.x = 0), isNaN(_.rect.y) && (_.rect.y = 0), k != null && k.length > 0) {
                  var C;
                  C = T.getGraphManager().add(T.newGraph(), _), this.processChildrenList(C, k, T);
                }
              }
            }, m.prototype.stop = function() {
              return this.stopped = !0, this;
            };
            var y = function(x) {
              x("layout", "cose-bilkent", m);
            };
            typeof cytoscape < "u" && y(cytoscape), n.exports = y;
          })
          /******/
        ])
      );
    });
  })(Wy)), Wy.exports;
}
var IOe = ROe();
const MOe = /* @__PURE__ */ Oc(IOe);
yo.use(MOe);
function wae(t, e) {
  t.forEach((r) => {
    const n = {
      id: r.id,
      labelText: r.label,
      height: r.height,
      width: r.width,
      padding: r.padding ?? 0
    };
    Object.keys(r).forEach((i) => {
      ["id", "label", "height", "width", "padding", "x", "y"].includes(i) || (n[i] = r[i]);
    }), e.add({
      group: "nodes",
      data: n,
      position: {
        x: r.x ?? 0,
        y: r.y ?? 0
      }
    });
  });
}
w(wae, "addNodes");
function Tae(t, e) {
  t.forEach((r) => {
    const n = {
      id: r.id,
      source: r.start,
      target: r.end
    };
    Object.keys(r).forEach((i) => {
      ["id", "start", "end"].includes(i) || (n[i] = r[i]);
    }), e.add({
      group: "edges",
      data: n
    });
  });
}
w(Tae, "addEdges");
function Eae(t) {
  return new Promise((e) => {
    const r = Qe("body").append("div").attr("id", "cy").attr("style", "display:none"), n = yo({
      container: document.getElementById("cy"),
      // container to render in
      style: [
        {
          selector: "edge",
          style: {
            "curve-style": "bezier"
          }
        }
      ]
    });
    r.remove(), wae(t.nodes, n), Tae(t.edges, n), n.nodes().forEach(function(a) {
      a.layoutDimensions = () => {
        const s = a.data();
        return { w: s.width, h: s.height };
      };
    });
    const i = {
      name: "cose-bilkent",
      // @ts-ignore Types for cose-bilkent are not correct?
      quality: "proof",
      styleEnabled: !1,
      animate: !1
    };
    n.layout(i).run(), n.ready((a) => {
      ae.info("Cytoscape ready", a), e(n);
    });
  });
}
w(Eae, "createCytoscapeInstance");
function Sae(t) {
  return t.nodes().map((e) => {
    const r = e.data(), n = e.position(), i = {
      id: r.id,
      x: n.x,
      y: n.y
    };
    return Object.keys(r).forEach((a) => {
      a !== "id" && (i[a] = r[a]);
    }), i;
  });
}
w(Sae, "extractPositionedNodes");
function kae(t) {
  return t.edges().map((e) => {
    const r = e.data(), n = e._private.rscratch, i = {
      id: r.id,
      source: r.source,
      target: r.target,
      startX: n.startX,
      startY: n.startY,
      midX: n.midX,
      midY: n.midY,
      endX: n.endX,
      endY: n.endY
    };
    return Object.keys(r).forEach((a) => {
      ["id", "source", "target"].includes(a) || (i[a] = r[a]);
    }), i;
  });
}
w(kae, "extractPositionedEdges");
async function Cae(t, e) {
  ae.debug("Starting cose-bilkent layout algorithm");
  try {
    _ae(t);
    const r = await Eae(t), n = Sae(r), i = kae(r);
    return ae.debug(`Layout completed: ${n.length} nodes, ${i.length} edges`), {
      nodes: n,
      edges: i
    };
  } catch (r) {
    throw ae.error("Error in cose-bilkent layout algorithm:", r), r;
  }
}
w(Cae, "executeCoseBilkentLayout");
function _ae(t) {
  if (!t)
    throw new Error("Layout data is required");
  if (!t.config)
    throw new Error("Configuration is required in layout data");
  if (!t.rootNode)
    throw new Error("Root node is required");
  if (!t.nodes || !Array.isArray(t.nodes))
    throw new Error("No nodes found in layout data");
  if (!Array.isArray(t.edges))
    throw new Error("Edges array is required in layout data");
  return !0;
}
w(_ae, "validateLayoutData");
var NOe = /* @__PURE__ */ w(async (t, e, {
  insertCluster: r,
  insertEdge: n,
  insertEdgeLabel: i,
  insertMarkers: a,
  insertNode: s,
  log: o,
  positionEdgeLabel: l
}, { algorithm: u }) => {
  const h = {}, f = {}, d = e.select("g");
  a(d, t.markers, t.type, t.diagramId);
  const p = d.insert("g").attr("class", "subgraphs"), g = d.insert("g").attr("class", "edgePaths"), m = d.insert("g").attr("class", "edgeLabels"), v = d.insert("g").attr("class", "nodes");
  o.debug("Inserting nodes into DOM for dimension calculation"), await Promise.all(
    t.nodes.map(async (x) => {
      if (x.isGroup) {
        const T = { ...x };
        f[x.id] = T, h[x.id] = T, await r(p, x);
      } else {
        const T = { ...x };
        h[x.id] = T;
        const E = await s(v, x, {
          config: t.config,
          dir: t.direction || "TB"
        }), A = E.node().getBBox();
        T.width = A.width, T.height = A.height, T.domId = E, o.debug(`Node ${x.id} dimensions: ${A.width}x${A.height}`);
      }
    })
  ), o.debug("Running cose-bilkent layout algorithm");
  const y = {
    ...t,
    nodes: t.nodes.map((x) => {
      const T = h[x.id];
      return {
        ...x,
        width: T.width,
        height: T.height
      };
    })
  }, b = await Cae(y, t.config);
  o.debug("Positioning nodes based on layout results"), b.nodes.forEach((x) => {
    const T = h[x.id];
    T?.domId && (T.domId.attr(
      "transform",
      `translate(${x.x}, ${x.y})`
    ), T.x = x.x, T.y = x.y, o.debug(`Positioned node ${T.id} at center (${x.x}, ${x.y})`));
  }), b.edges.forEach((x) => {
    const T = t.edges.find((E) => E.id === x.id);
    T && (T.points = [
      { x: x.startX, y: x.startY },
      { x: x.midX, y: x.midY },
      { x: x.endX, y: x.endY }
    ]);
  }), o.debug("Inserting and positioning edges"), await Promise.all(
    t.edges.map(async (x) => {
      await i(m, x);
      const T = h[x.start ?? ""], E = h[x.end ?? ""];
      if (T && E) {
        const A = b.edges.find((S) => S.id === x.id);
        if (A) {
          o.debug("APA01 positionedEdge", A);
          const S = { ...x }, k = n(
            g,
            S,
            f,
            t.type,
            T,
            E,
            t.diagramId
          );
          l(S, k);
        } else {
          const S = {
            ...x,
            points: [
              { x: T.x || 0, y: T.y || 0 },
              { x: E.x || 0, y: E.y || 0 }
            ]
          }, k = n(
            g,
            S,
            f,
            t.type,
            T,
            E,
            t.diagramId
          );
          l(S, k);
        }
      }
    })
  ), o.debug("Cose-bilkent rendering completed");
}, "render"), DOe = NOe;
const OOe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: DOe
}, Symbol.toStringTag, { value: "Module" }));
var h3 = /* @__PURE__ */ w((t, e) => {
  const r = t.append("rect");
  if (r.attr("x", e.x), r.attr("y", e.y), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("width", e.width), r.attr("height", e.height), e.name && r.attr("name", e.name), e.rx && r.attr("rx", e.rx), e.ry && r.attr("ry", e.ry), e.attrs !== void 0)
    for (const n in e.attrs)
      r.attr(n, e.attrs[n]);
  return e.class && r.attr("class", e.class), r;
}, "drawRect"), Aae = /* @__PURE__ */ w((t, e) => {
  const r = {
    x: e.startx,
    y: e.starty,
    width: e.stopx - e.startx,
    height: e.stopy - e.starty,
    fill: e.fill,
    stroke: e.stroke,
    class: "rect"
  };
  h3(t, r).lower();
}, "drawBackgroundRect"), POe = /* @__PURE__ */ w((t, e) => {
  const r = e.text.replace(C0, " "), n = t.append("text");
  n.attr("x", e.x), n.attr("y", e.y), n.attr("class", "legend"), n.style("text-anchor", e.anchor), e.class && n.attr("class", e.class);
  const i = n.append("tspan");
  return i.attr("x", e.x + e.textMargin * 2), i.text(r), n;
}, "drawText"), BR = /* @__PURE__ */ w((t, e, r, n) => {
  const i = t.append("image");
  i.attr("x", e), i.attr("y", r);
  const a = yh.sanitizeUrl(n);
  i.attr("xlink:href", a);
}, "drawImage"), FR = /* @__PURE__ */ w((t, e, r, n) => {
  const i = t.append("use");
  i.attr("x", e), i.attr("y", r);
  const a = yh.sanitizeUrl(n);
  i.attr("xlink:href", `#${a}`);
}, "drawEmbeddedImage"), Oa = /* @__PURE__ */ w(() => ({
  x: 0,
  y: 0,
  width: 100,
  height: 100,
  fill: "#EDF2AE",
  stroke: "#666",
  anchor: "start",
  rx: 0,
  ry: 0
}), "getNoteRect"), zR = /* @__PURE__ */ w(() => ({
  x: 0,
  y: 0,
  width: 100,
  height: 100,
  "text-anchor": "start",
  style: "#666",
  textMargin: 0,
  rx: 0,
  ry: 0,
  tspan: !0
}), "getTextObj"), zb = (function() {
  var t = /* @__PURE__ */ w(function(Ge, Ee, Oe, Ce) {
    for (Oe = Oe || {}, Ce = Ge.length; Ce--; Oe[Ge[Ce]] = Ee) ;
    return Oe;
  }, "o"), e = [1, 24], r = [1, 25], n = [1, 26], i = [1, 27], a = [1, 28], s = [1, 63], o = [1, 64], l = [1, 65], u = [1, 66], h = [1, 67], f = [1, 68], d = [1, 69], p = [1, 29], g = [1, 30], m = [1, 31], v = [1, 32], y = [1, 33], b = [1, 34], x = [1, 35], T = [1, 36], E = [1, 37], A = [1, 38], S = [1, 39], k = [1, 40], _ = [1, 41], R = [1, 42], L = [1, 43], M = [1, 44], P = [1, 45], C = [1, 46], I = [1, 47], N = [1, 48], O = [1, 50], D = [1, 51], $ = [1, 52], z = [1, 53], B = [1, 54], G = [1, 55], W = [1, 56], V = [1, 57], U = [1, 58], Z = [1, 59], K = [1, 60], ce = [14, 42], J = [14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], ee = [12, 14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], j = [1, 82], X = [1, 83], re = [1, 84], Q = [1, 85], ue = [12, 14, 42], ne = [12, 14, 33, 42], xe = [12, 14, 33, 42, 76, 77, 79, 80], Y = [12, 33], Ne = [34, 36, 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], fe = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, direction: 5, direction_tb: 6, direction_bt: 7, direction_rl: 8, direction_lr: 9, graphConfig: 10, C4_CONTEXT: 11, NEWLINE: 12, statements: 13, EOF: 14, C4_CONTAINER: 15, C4_COMPONENT: 16, C4_DYNAMIC: 17, C4_DEPLOYMENT: 18, otherStatements: 19, diagramStatements: 20, otherStatement: 21, title: 22, accDescription: 23, acc_title: 24, acc_title_value: 25, acc_descr: 26, acc_descr_value: 27, acc_descr_multiline_value: 28, boundaryStatement: 29, boundaryStartStatement: 30, boundaryStopStatement: 31, boundaryStart: 32, LBRACE: 33, ENTERPRISE_BOUNDARY: 34, attributes: 35, SYSTEM_BOUNDARY: 36, BOUNDARY: 37, CONTAINER_BOUNDARY: 38, NODE: 39, NODE_L: 40, NODE_R: 41, RBRACE: 42, diagramStatement: 43, PERSON: 44, PERSON_EXT: 45, SYSTEM: 46, SYSTEM_DB: 47, SYSTEM_QUEUE: 48, SYSTEM_EXT: 49, SYSTEM_EXT_DB: 50, SYSTEM_EXT_QUEUE: 51, CONTAINER: 52, CONTAINER_DB: 53, CONTAINER_QUEUE: 54, CONTAINER_EXT: 55, CONTAINER_EXT_DB: 56, CONTAINER_EXT_QUEUE: 57, COMPONENT: 58, COMPONENT_DB: 59, COMPONENT_QUEUE: 60, COMPONENT_EXT: 61, COMPONENT_EXT_DB: 62, COMPONENT_EXT_QUEUE: 63, REL: 64, BIREL: 65, REL_U: 66, REL_D: 67, REL_L: 68, REL_R: 69, REL_B: 70, REL_INDEX: 71, UPDATE_EL_STYLE: 72, UPDATE_REL_STYLE: 73, UPDATE_LAYOUT_CONFIG: 74, attribute: 75, STR: 76, STR_KEY: 77, STR_VALUE: 78, ATTRIBUTE: 79, ATTRIBUTE_EMPTY: 80, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "direction_tb", 7: "direction_bt", 8: "direction_rl", 9: "direction_lr", 11: "C4_CONTEXT", 12: "NEWLINE", 14: "EOF", 15: "C4_CONTAINER", 16: "C4_COMPONENT", 17: "C4_DYNAMIC", 18: "C4_DEPLOYMENT", 22: "title", 23: "accDescription", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "LBRACE", 34: "ENTERPRISE_BOUNDARY", 36: "SYSTEM_BOUNDARY", 37: "BOUNDARY", 38: "CONTAINER_BOUNDARY", 39: "NODE", 40: "NODE_L", 41: "NODE_R", 42: "RBRACE", 44: "PERSON", 45: "PERSON_EXT", 46: "SYSTEM", 47: "SYSTEM_DB", 48: "SYSTEM_QUEUE", 49: "SYSTEM_EXT", 50: "SYSTEM_EXT_DB", 51: "SYSTEM_EXT_QUEUE", 52: "CONTAINER", 53: "CONTAINER_DB", 54: "CONTAINER_QUEUE", 55: "CONTAINER_EXT", 56: "CONTAINER_EXT_DB", 57: "CONTAINER_EXT_QUEUE", 58: "COMPONENT", 59: "COMPONENT_DB", 60: "COMPONENT_QUEUE", 61: "COMPONENT_EXT", 62: "COMPONENT_EXT_DB", 63: "COMPONENT_EXT_QUEUE", 64: "REL", 65: "BIREL", 66: "REL_U", 67: "REL_D", 68: "REL_L", 69: "REL_R", 70: "REL_B", 71: "REL_INDEX", 72: "UPDATE_EL_STYLE", 73: "UPDATE_REL_STYLE", 74: "UPDATE_LAYOUT_CONFIG", 76: "STR", 77: "STR_KEY", 78: "STR_VALUE", 79: "ATTRIBUTE", 80: "ATTRIBUTE_EMPTY" },
    productions_: [0, [3, 1], [3, 1], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [13, 1], [13, 1], [13, 2], [19, 1], [19, 2], [19, 3], [21, 1], [21, 1], [21, 2], [21, 2], [21, 1], [29, 3], [30, 3], [30, 3], [30, 4], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [31, 1], [20, 1], [20, 2], [20, 3], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 1], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [35, 1], [35, 2], [75, 1], [75, 2], [75, 1], [75, 1]],
    performAction: /* @__PURE__ */ w(function(Ee, Oe, Ce, Ae, $e, me, Ie) {
      var te = me.length - 1;
      switch ($e) {
        case 3:
          Ae.setDirection("TB");
          break;
        case 4:
          Ae.setDirection("BT");
          break;
        case 5:
          Ae.setDirection("RL");
          break;
        case 6:
          Ae.setDirection("LR");
          break;
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          Ae.setC4Type(me[te - 3]);
          break;
        case 19:
          Ae.setTitle(me[te].substring(6)), this.$ = me[te].substring(6);
          break;
        case 20:
          Ae.setAccDescription(me[te].substring(15)), this.$ = me[te].substring(15);
          break;
        case 21:
          this.$ = me[te].trim(), Ae.setTitle(this.$);
          break;
        case 22:
        case 23:
          this.$ = me[te].trim(), Ae.setAccDescription(this.$);
          break;
        case 28:
          me[te].splice(2, 0, "ENTERPRISE"), Ae.addPersonOrSystemBoundary(...me[te]), this.$ = me[te];
          break;
        case 29:
          me[te].splice(2, 0, "SYSTEM"), Ae.addPersonOrSystemBoundary(...me[te]), this.$ = me[te];
          break;
        case 30:
          Ae.addPersonOrSystemBoundary(...me[te]), this.$ = me[te];
          break;
        case 31:
          me[te].splice(2, 0, "CONTAINER"), Ae.addContainerBoundary(...me[te]), this.$ = me[te];
          break;
        case 32:
          Ae.addDeploymentNode("node", ...me[te]), this.$ = me[te];
          break;
        case 33:
          Ae.addDeploymentNode("nodeL", ...me[te]), this.$ = me[te];
          break;
        case 34:
          Ae.addDeploymentNode("nodeR", ...me[te]), this.$ = me[te];
          break;
        case 35:
          Ae.popBoundaryParseStack();
          break;
        case 39:
          Ae.addPersonOrSystem("person", ...me[te]), this.$ = me[te];
          break;
        case 40:
          Ae.addPersonOrSystem("external_person", ...me[te]), this.$ = me[te];
          break;
        case 41:
          Ae.addPersonOrSystem("system", ...me[te]), this.$ = me[te];
          break;
        case 42:
          Ae.addPersonOrSystem("system_db", ...me[te]), this.$ = me[te];
          break;
        case 43:
          Ae.addPersonOrSystem("system_queue", ...me[te]), this.$ = me[te];
          break;
        case 44:
          Ae.addPersonOrSystem("external_system", ...me[te]), this.$ = me[te];
          break;
        case 45:
          Ae.addPersonOrSystem("external_system_db", ...me[te]), this.$ = me[te];
          break;
        case 46:
          Ae.addPersonOrSystem("external_system_queue", ...me[te]), this.$ = me[te];
          break;
        case 47:
          Ae.addContainer("container", ...me[te]), this.$ = me[te];
          break;
        case 48:
          Ae.addContainer("container_db", ...me[te]), this.$ = me[te];
          break;
        case 49:
          Ae.addContainer("container_queue", ...me[te]), this.$ = me[te];
          break;
        case 50:
          Ae.addContainer("external_container", ...me[te]), this.$ = me[te];
          break;
        case 51:
          Ae.addContainer("external_container_db", ...me[te]), this.$ = me[te];
          break;
        case 52:
          Ae.addContainer("external_container_queue", ...me[te]), this.$ = me[te];
          break;
        case 53:
          Ae.addComponent("component", ...me[te]), this.$ = me[te];
          break;
        case 54:
          Ae.addComponent("component_db", ...me[te]), this.$ = me[te];
          break;
        case 55:
          Ae.addComponent("component_queue", ...me[te]), this.$ = me[te];
          break;
        case 56:
          Ae.addComponent("external_component", ...me[te]), this.$ = me[te];
          break;
        case 57:
          Ae.addComponent("external_component_db", ...me[te]), this.$ = me[te];
          break;
        case 58:
          Ae.addComponent("external_component_queue", ...me[te]), this.$ = me[te];
          break;
        case 60:
          Ae.addRel("rel", ...me[te]), this.$ = me[te];
          break;
        case 61:
          Ae.addRel("birel", ...me[te]), this.$ = me[te];
          break;
        case 62:
          Ae.addRel("rel_u", ...me[te]), this.$ = me[te];
          break;
        case 63:
          Ae.addRel("rel_d", ...me[te]), this.$ = me[te];
          break;
        case 64:
          Ae.addRel("rel_l", ...me[te]), this.$ = me[te];
          break;
        case 65:
          Ae.addRel("rel_r", ...me[te]), this.$ = me[te];
          break;
        case 66:
          Ae.addRel("rel_b", ...me[te]), this.$ = me[te];
          break;
        case 67:
          me[te].splice(0, 1), Ae.addRel("rel", ...me[te]), this.$ = me[te];
          break;
        case 68:
          Ae.updateElStyle("update_el_style", ...me[te]), this.$ = me[te];
          break;
        case 69:
          Ae.updateRelStyle("update_rel_style", ...me[te]), this.$ = me[te];
          break;
        case 70:
          Ae.updateLayoutConfig("update_layout_config", ...me[te]), this.$ = me[te];
          break;
        case 71:
          this.$ = [me[te]];
          break;
        case 72:
          me[te].unshift(me[te - 1]), this.$ = me[te];
          break;
        case 73:
        case 75:
          this.$ = me[te].trim();
          break;
        case 74:
          let he = {};
          he[me[te - 1].trim()] = me[te].trim(), this.$ = he;
          break;
        case 76:
          this.$ = "";
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 7: [1, 6], 8: [1, 7], 9: [1, 8], 10: 4, 11: [1, 9], 15: [1, 10], 16: [1, 11], 17: [1, 12], 18: [1, 13] }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 7] }, { 1: [2, 3] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 12: [1, 14] }, { 12: [1, 15] }, { 12: [1, 16] }, { 12: [1, 17] }, { 12: [1, 18] }, { 13: 19, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }, { 13: 70, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }, { 13: 71, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }, { 13: 72, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }, { 13: 73, 19: 20, 20: 21, 21: 22, 22: e, 23: r, 24: n, 26: i, 28: a, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }, { 14: [1, 74] }, t(ce, [2, 13], { 43: 23, 29: 49, 30: 61, 32: 62, 20: 75, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }), t(ce, [2, 14]), t(J, [2, 16], { 12: [1, 76] }), t(ce, [2, 36], { 12: [1, 77] }), t(ee, [2, 19]), t(ee, [2, 20]), { 25: [1, 78] }, { 27: [1, 79] }, t(ee, [2, 23]), { 35: 80, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 86, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 87, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 88, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 89, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 90, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 91, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 92, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 93, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 94, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 95, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 96, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 97, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 98, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 99, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 100, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 101, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 102, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 103, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 104, 75: 81, 76: j, 77: X, 79: re, 80: Q }, t(ue, [2, 59]), { 35: 105, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 106, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 107, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 108, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 109, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 110, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 111, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 112, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 113, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 114, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 115, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 20: 116, 29: 49, 30: 61, 32: 62, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 43: 23, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }, { 12: [1, 118], 33: [1, 117] }, { 35: 119, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 120, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 121, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 122, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 123, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 124, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 35: 125, 75: 81, 76: j, 77: X, 79: re, 80: Q }, { 14: [1, 126] }, { 14: [1, 127] }, { 14: [1, 128] }, { 14: [1, 129] }, { 1: [2, 8] }, t(ce, [2, 15]), t(J, [2, 17], { 21: 22, 19: 130, 22: e, 23: r, 24: n, 26: i, 28: a }), t(ce, [2, 37], { 19: 20, 20: 21, 21: 22, 43: 23, 29: 49, 30: 61, 32: 62, 13: 131, 22: e, 23: r, 24: n, 26: i, 28: a, 34: s, 36: o, 37: l, 38: u, 39: h, 40: f, 41: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x, 51: T, 52: E, 53: A, 54: S, 55: k, 56: _, 57: R, 58: L, 59: M, 60: P, 61: C, 62: I, 63: N, 64: O, 65: D, 66: $, 67: z, 68: B, 69: G, 70: W, 71: V, 72: U, 73: Z, 74: K }), t(ee, [2, 21]), t(ee, [2, 22]), t(ue, [2, 39]), t(ne, [2, 71], { 75: 81, 35: 132, 76: j, 77: X, 79: re, 80: Q }), t(xe, [2, 73]), { 78: [1, 133] }, t(xe, [2, 75]), t(xe, [2, 76]), t(ue, [2, 40]), t(ue, [2, 41]), t(ue, [2, 42]), t(ue, [2, 43]), t(ue, [2, 44]), t(ue, [2, 45]), t(ue, [2, 46]), t(ue, [2, 47]), t(ue, [2, 48]), t(ue, [2, 49]), t(ue, [2, 50]), t(ue, [2, 51]), t(ue, [2, 52]), t(ue, [2, 53]), t(ue, [2, 54]), t(ue, [2, 55]), t(ue, [2, 56]), t(ue, [2, 57]), t(ue, [2, 58]), t(ue, [2, 60]), t(ue, [2, 61]), t(ue, [2, 62]), t(ue, [2, 63]), t(ue, [2, 64]), t(ue, [2, 65]), t(ue, [2, 66]), t(ue, [2, 67]), t(ue, [2, 68]), t(ue, [2, 69]), t(ue, [2, 70]), { 31: 134, 42: [1, 135] }, { 12: [1, 136] }, { 33: [1, 137] }, t(Y, [2, 28]), t(Y, [2, 29]), t(Y, [2, 30]), t(Y, [2, 31]), t(Y, [2, 32]), t(Y, [2, 33]), t(Y, [2, 34]), { 1: [2, 9] }, { 1: [2, 10] }, { 1: [2, 11] }, { 1: [2, 12] }, t(J, [2, 18]), t(ce, [2, 38]), t(ne, [2, 72]), t(xe, [2, 74]), t(ue, [2, 24]), t(ue, [2, 35]), t(Ne, [2, 25]), t(Ne, [2, 26], { 12: [1, 138] }), t(Ne, [2, 27])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 7], 5: [2, 3], 6: [2, 4], 7: [2, 5], 8: [2, 6], 74: [2, 8], 126: [2, 9], 127: [2, 10], 128: [2, 11], 129: [2, 12] },
    parseError: /* @__PURE__ */ w(function(Ee, Oe) {
      if (Oe.recoverable)
        this.trace(Ee);
      else {
        var Ce = new Error(Ee);
        throw Ce.hash = Oe, Ce;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(Ee) {
      var Oe = this, Ce = [0], Ae = [], $e = [null], me = [], Ie = this.table, te = "", he = 0, F = 0, oe = 2, se = 1, ge = me.slice.call(arguments, 1), de = Object.create(this.lexer), we = { yy: {} };
      for (var _e in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, _e) && (we.yy[_e] = this.yy[_e]);
      de.setInput(Ee, we.yy), we.yy.lexer = de, we.yy.parser = this, typeof de.yylloc > "u" && (de.yylloc = {});
      var Se = de.yylloc;
      me.push(Se);
      var Me = de.options && de.options.ranges;
      typeof we.yy.parseError == "function" ? this.parseError = we.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Xe(ct) {
        Ce.length = Ce.length - 2 * ct, $e.length = $e.length - ct, me.length = me.length - ct;
      }
      w(Xe, "popStack");
      function We() {
        var ct;
        return ct = Ae.pop() || de.lex() || se, typeof ct != "number" && (ct instanceof Array && (Ae = ct, ct = Ae.pop()), ct = Oe.symbols_[ct] || ct), ct;
      }
      w(We, "lex");
      for (var Ke, Ze, Pe, Ve, ht = {}, st, Ue, Et, He; ; ) {
        if (Ze = Ce[Ce.length - 1], this.defaultActions[Ze] ? Pe = this.defaultActions[Ze] : ((Ke === null || typeof Ke > "u") && (Ke = We()), Pe = Ie[Ze] && Ie[Ze][Ke]), typeof Pe > "u" || !Pe.length || !Pe[0]) {
          var rt = "";
          He = [];
          for (st in Ie[Ze])
            this.terminals_[st] && st > oe && He.push("'" + this.terminals_[st] + "'");
          de.showPosition ? rt = "Parse error on line " + (he + 1) + `:
` + de.showPosition() + `
Expecting ` + He.join(", ") + ", got '" + (this.terminals_[Ke] || Ke) + "'" : rt = "Parse error on line " + (he + 1) + ": Unexpected " + (Ke == se ? "end of input" : "'" + (this.terminals_[Ke] || Ke) + "'"), this.parseError(rt, {
            text: de.match,
            token: this.terminals_[Ke] || Ke,
            line: de.yylineno,
            loc: Se,
            expected: He
          });
        }
        if (Pe[0] instanceof Array && Pe.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ze + ", token: " + Ke);
        switch (Pe[0]) {
          case 1:
            Ce.push(Ke), $e.push(de.yytext), me.push(de.yylloc), Ce.push(Pe[1]), Ke = null, F = de.yyleng, te = de.yytext, he = de.yylineno, Se = de.yylloc;
            break;
          case 2:
            if (Ue = this.productions_[Pe[1]][1], ht.$ = $e[$e.length - Ue], ht._$ = {
              first_line: me[me.length - (Ue || 1)].first_line,
              last_line: me[me.length - 1].last_line,
              first_column: me[me.length - (Ue || 1)].first_column,
              last_column: me[me.length - 1].last_column
            }, Me && (ht._$.range = [
              me[me.length - (Ue || 1)].range[0],
              me[me.length - 1].range[1]
            ]), Ve = this.performAction.apply(ht, [
              te,
              F,
              he,
              we.yy,
              Pe[1],
              $e,
              me
            ].concat(ge)), typeof Ve < "u")
              return Ve;
            Ue && (Ce = Ce.slice(0, -1 * Ue * 2), $e = $e.slice(0, -1 * Ue), me = me.slice(0, -1 * Ue)), Ce.push(this.productions_[Pe[1]][0]), $e.push(ht.$), me.push(ht._$), Et = Ie[Ce[Ce.length - 2]][Ce[Ce.length - 1]], Ce.push(Et);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, qe = /* @__PURE__ */ (function() {
    var Ge = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(Oe, Ce) {
        if (this.yy.parser)
          this.yy.parser.parseError(Oe, Ce);
        else
          throw new Error(Oe);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(Ee, Oe) {
        return this.yy = Oe || this.yy || {}, this._input = Ee, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var Ee = this._input[0];
        this.yytext += Ee, this.yyleng++, this.offset++, this.match += Ee, this.matched += Ee;
        var Oe = Ee.match(/(?:\r\n?|\n).*/g);
        return Oe ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Ee;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(Ee) {
        var Oe = Ee.length, Ce = Ee.split(/(?:\r\n?|\n)/g);
        this._input = Ee + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Oe), this.offset -= Oe;
        var Ae = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), Ce.length - 1 && (this.yylineno -= Ce.length - 1);
        var $e = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: Ce ? (Ce.length === Ae.length ? this.yylloc.first_column : 0) + Ae[Ae.length - Ce.length].length - Ce[0].length : this.yylloc.first_column - Oe
        }, this.options.ranges && (this.yylloc.range = [$e[0], $e[0] + this.yyleng - Oe]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(Ee) {
        this.unput(this.match.slice(Ee));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var Ee = this.matched.substr(0, this.matched.length - this.match.length);
        return (Ee.length > 20 ? "..." : "") + Ee.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var Ee = this.match;
        return Ee.length < 20 && (Ee += this._input.substr(0, 20 - Ee.length)), (Ee.substr(0, 20) + (Ee.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var Ee = this.pastInput(), Oe = new Array(Ee.length + 1).join("-");
        return Ee + this.upcomingInput() + `
` + Oe + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(Ee, Oe) {
        var Ce, Ae, $e;
        if (this.options.backtrack_lexer && ($e = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && ($e.yylloc.range = this.yylloc.range.slice(0))), Ae = Ee[0].match(/(?:\r\n?|\n).*/g), Ae && (this.yylineno += Ae.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: Ae ? Ae[Ae.length - 1].length - Ae[Ae.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Ee[0].length
        }, this.yytext += Ee[0], this.match += Ee[0], this.matches = Ee, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Ee[0].length), this.matched += Ee[0], Ce = this.performAction.call(this, this.yy, this, Oe, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), Ce)
          return Ce;
        if (this._backtrack) {
          for (var me in $e)
            this[me] = $e[me];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Ee, Oe, Ce, Ae;
        this._more || (this.yytext = "", this.match = "");
        for (var $e = this._currentRules(), me = 0; me < $e.length; me++)
          if (Ce = this._input.match(this.rules[$e[me]]), Ce && (!Oe || Ce[0].length > Oe[0].length)) {
            if (Oe = Ce, Ae = me, this.options.backtrack_lexer) {
              if (Ee = this.test_match(Ce, $e[me]), Ee !== !1)
                return Ee;
              if (this._backtrack) {
                Oe = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Oe ? (Ee = this.test_match(Oe, $e[Ae]), Ee !== !1 ? Ee : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var Oe = this.next();
        return Oe || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(Oe) {
        this.conditionStack.push(Oe);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var Oe = this.conditionStack.length - 1;
        return Oe > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(Oe) {
        return Oe = this.conditionStack.length - 1 - Math.abs(Oe || 0), Oe >= 0 ? this.conditionStack[Oe] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(Oe) {
        this.begin(Oe);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ w(function(Oe, Ce, Ae, $e) {
        switch (Ae) {
          case 0:
            return 6;
          case 1:
            return 7;
          case 2:
            return 8;
          case 3:
            return 9;
          case 4:
            return 22;
          case 5:
            return 23;
          case 6:
            return this.begin("acc_title"), 24;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 26;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            break;
          case 14:
            c;
            break;
          case 15:
            return 12;
          case 16:
            break;
          case 17:
            return 11;
          case 18:
            return 15;
          case 19:
            return 16;
          case 20:
            return 17;
          case 21:
            return 18;
          case 22:
            return this.begin("person_ext"), 45;
          case 23:
            return this.begin("person"), 44;
          case 24:
            return this.begin("system_ext_queue"), 51;
          case 25:
            return this.begin("system_ext_db"), 50;
          case 26:
            return this.begin("system_ext"), 49;
          case 27:
            return this.begin("system_queue"), 48;
          case 28:
            return this.begin("system_db"), 47;
          case 29:
            return this.begin("system"), 46;
          case 30:
            return this.begin("boundary"), 37;
          case 31:
            return this.begin("enterprise_boundary"), 34;
          case 32:
            return this.begin("system_boundary"), 36;
          case 33:
            return this.begin("container_ext_queue"), 57;
          case 34:
            return this.begin("container_ext_db"), 56;
          case 35:
            return this.begin("container_ext"), 55;
          case 36:
            return this.begin("container_queue"), 54;
          case 37:
            return this.begin("container_db"), 53;
          case 38:
            return this.begin("container"), 52;
          case 39:
            return this.begin("container_boundary"), 38;
          case 40:
            return this.begin("component_ext_queue"), 63;
          case 41:
            return this.begin("component_ext_db"), 62;
          case 42:
            return this.begin("component_ext"), 61;
          case 43:
            return this.begin("component_queue"), 60;
          case 44:
            return this.begin("component_db"), 59;
          case 45:
            return this.begin("component"), 58;
          case 46:
            return this.begin("node"), 39;
          case 47:
            return this.begin("node"), 39;
          case 48:
            return this.begin("node_l"), 40;
          case 49:
            return this.begin("node_r"), 41;
          case 50:
            return this.begin("rel"), 64;
          case 51:
            return this.begin("birel"), 65;
          case 52:
            return this.begin("rel_u"), 66;
          case 53:
            return this.begin("rel_u"), 66;
          case 54:
            return this.begin("rel_d"), 67;
          case 55:
            return this.begin("rel_d"), 67;
          case 56:
            return this.begin("rel_l"), 68;
          case 57:
            return this.begin("rel_l"), 68;
          case 58:
            return this.begin("rel_r"), 69;
          case 59:
            return this.begin("rel_r"), 69;
          case 60:
            return this.begin("rel_b"), 70;
          case 61:
            return this.begin("rel_index"), 71;
          case 62:
            return this.begin("update_el_style"), 72;
          case 63:
            return this.begin("update_rel_style"), 73;
          case 64:
            return this.begin("update_layout_config"), 74;
          case 65:
            return "EOF_IN_STRUCT";
          case 66:
            return this.begin("attribute"), "ATTRIBUTE_EMPTY";
          case 67:
            this.begin("attribute");
            break;
          case 68:
            this.popState(), this.popState();
            break;
          case 69:
            return 80;
          case 70:
            break;
          case 71:
            return 80;
          case 72:
            this.begin("string");
            break;
          case 73:
            this.popState();
            break;
          case 74:
            return "STR";
          case 75:
            this.begin("string_kv");
            break;
          case 76:
            return this.begin("string_kv_key"), "STR_KEY";
          case 77:
            this.popState(), this.begin("string_kv_value");
            break;
          case 78:
            return "STR_VALUE";
          case 79:
            this.popState(), this.popState();
            break;
          case 80:
            return "STR";
          case 81:
            return "LBRACE";
          case 82:
            return "RBRACE";
          case 83:
            return "SPACE";
          case 84:
            return "EOL";
          case 85:
            return 14;
        }
      }, "anonymous"),
      rules: [/^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
      conditions: { acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, string_kv_value: { rules: [78, 79], inclusive: !1 }, string_kv_key: { rules: [77], inclusive: !1 }, string_kv: { rules: [76], inclusive: !1 }, string: { rules: [73, 74], inclusive: !1 }, attribute: { rules: [68, 69, 70, 71, 72, 75, 80], inclusive: !1 }, update_layout_config: { rules: [65, 66, 67, 68], inclusive: !1 }, update_rel_style: { rules: [65, 66, 67, 68], inclusive: !1 }, update_el_style: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_b: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_r: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_l: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_d: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_u: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_bi: { rules: [], inclusive: !1 }, rel: { rules: [65, 66, 67, 68], inclusive: !1 }, node_r: { rules: [65, 66, 67, 68], inclusive: !1 }, node_l: { rules: [65, 66, 67, 68], inclusive: !1 }, node: { rules: [65, 66, 67, 68], inclusive: !1 }, index: { rules: [], inclusive: !1 }, rel_index: { rules: [65, 66, 67, 68], inclusive: !1 }, component_ext_queue: { rules: [], inclusive: !1 }, component_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, component_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, component_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, component_db: { rules: [65, 66, 67, 68], inclusive: !1 }, component: { rules: [65, 66, 67, 68], inclusive: !1 }, container_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, container_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, container_db: { rules: [65, 66, 67, 68], inclusive: !1 }, container: { rules: [65, 66, 67, 68], inclusive: !1 }, birel: { rules: [65, 66, 67, 68], inclusive: !1 }, system_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, enterprise_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, system_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, system_db: { rules: [65, 66, 67, 68], inclusive: !1 }, system: { rules: [65, 66, 67, 68], inclusive: !1 }, person_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, person: { rules: [65, 66, 67, 68], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 81, 82, 83, 84, 85], inclusive: !0 } }
    };
    return Ge;
  })();
  fe.lexer = qe;
  function ze() {
    this.yy = {};
  }
  return w(ze, "Parser"), ze.prototype = fe, fe.Parser = ze, new ze();
})();
zb.parser = zb;
var $Oe = zb, Ds = [], cc = [""], Hi = "global", As = "", bo = [
  {
    alias: "global",
    label: { text: "global" },
    type: { text: "global" },
    tags: null,
    link: null,
    parentBoundary: ""
  }
], M1 = [], qR = "", GR = !1, qb = 4, Gb = 2, Lae, BOe = /* @__PURE__ */ w(function() {
  return Lae;
}, "getC4Type"), FOe = /* @__PURE__ */ w(function(t) {
  Lae = pr(t, Te());
}, "setC4Type"), zOe = /* @__PURE__ */ w(function(t, e, r, n, i, a, s, o, l) {
  if (t == null || e === void 0 || e === null || r === void 0 || r === null || n === void 0 || n === null)
    return;
  let u = {};
  const h = M1.find((f) => f.from === e && f.to === r);
  if (h ? u = h : M1.push(u), u.type = t, u.from = e, u.to = r, u.label = { text: n }, i == null)
    u.techn = { text: "" };
  else if (typeof i == "object") {
    let [f, d] = Object.entries(i)[0];
    u[f] = { text: d };
  } else
    u.techn = { text: i };
  if (a == null)
    u.descr = { text: "" };
  else if (typeof a == "object") {
    let [f, d] = Object.entries(a)[0];
    u[f] = { text: d };
  } else
    u.descr = { text: a };
  if (typeof s == "object") {
    let [f, d] = Object.entries(s)[0];
    u[f] = d;
  } else
    u.sprite = s;
  if (typeof o == "object") {
    let [f, d] = Object.entries(o)[0];
    u[f] = d;
  } else
    u.tags = o;
  if (typeof l == "object") {
    let [f, d] = Object.entries(l)[0];
    u[f] = d;
  } else
    u.link = l;
  u.wrap = Yc();
}, "addRel"), qOe = /* @__PURE__ */ w(function(t, e, r, n, i, a, s) {
  if (e === null || r === null)
    return;
  let o = {};
  const l = Ds.find((u) => u.alias === e);
  if (l && e === l.alias ? o = l : (o.alias = e, Ds.push(o)), r == null ? o.label = { text: "" } : o.label = { text: r }, n == null)
    o.descr = { text: "" };
  else if (typeof n == "object") {
    let [u, h] = Object.entries(n)[0];
    o[u] = { text: h };
  } else
    o.descr = { text: n };
  if (typeof i == "object") {
    let [u, h] = Object.entries(i)[0];
    o[u] = h;
  } else
    o.sprite = i;
  if (typeof a == "object") {
    let [u, h] = Object.entries(a)[0];
    o[u] = h;
  } else
    o.tags = a;
  if (typeof s == "object") {
    let [u, h] = Object.entries(s)[0];
    o[u] = h;
  } else
    o.link = s;
  o.typeC4Shape = { text: t }, o.parentBoundary = Hi, o.wrap = Yc();
}, "addPersonOrSystem"), GOe = /* @__PURE__ */ w(function(t, e, r, n, i, a, s, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = Ds.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, Ds.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.techn = { text: "" };
  else if (typeof n == "object") {
    let [h, f] = Object.entries(n)[0];
    l[h] = { text: f };
  } else
    l.techn = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, f] = Object.entries(i)[0];
    l[h] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof a == "object") {
    let [h, f] = Object.entries(a)[0];
    l[h] = f;
  } else
    l.sprite = a;
  if (typeof s == "object") {
    let [h, f] = Object.entries(s)[0];
    l[h] = f;
  } else
    l.tags = s;
  if (typeof o == "object") {
    let [h, f] = Object.entries(o)[0];
    l[h] = f;
  } else
    l.link = o;
  l.wrap = Yc(), l.typeC4Shape = { text: t }, l.parentBoundary = Hi;
}, "addContainer"), UOe = /* @__PURE__ */ w(function(t, e, r, n, i, a, s, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = Ds.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, Ds.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.techn = { text: "" };
  else if (typeof n == "object") {
    let [h, f] = Object.entries(n)[0];
    l[h] = { text: f };
  } else
    l.techn = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, f] = Object.entries(i)[0];
    l[h] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof a == "object") {
    let [h, f] = Object.entries(a)[0];
    l[h] = f;
  } else
    l.sprite = a;
  if (typeof s == "object") {
    let [h, f] = Object.entries(s)[0];
    l[h] = f;
  } else
    l.tags = s;
  if (typeof o == "object") {
    let [h, f] = Object.entries(o)[0];
    l[h] = f;
  } else
    l.link = o;
  l.wrap = Yc(), l.typeC4Shape = { text: t }, l.parentBoundary = Hi;
}, "addComponent"), VOe = /* @__PURE__ */ w(function(t, e, r, n, i) {
  if (t === null || e === null)
    return;
  let a = {};
  const s = bo.find((o) => o.alias === t);
  if (s && t === s.alias ? a = s : (a.alias = t, bo.push(a)), e == null ? a.label = { text: "" } : a.label = { text: e }, r == null)
    a.type = { text: "system" };
  else if (typeof r == "object") {
    let [o, l] = Object.entries(r)[0];
    a[o] = { text: l };
  } else
    a.type = { text: r };
  if (typeof n == "object") {
    let [o, l] = Object.entries(n)[0];
    a[o] = l;
  } else
    a.tags = n;
  if (typeof i == "object") {
    let [o, l] = Object.entries(i)[0];
    a[o] = l;
  } else
    a.link = i;
  a.parentBoundary = Hi, a.wrap = Yc(), As = Hi, Hi = t, cc.push(As);
}, "addPersonOrSystemBoundary"), HOe = /* @__PURE__ */ w(function(t, e, r, n, i) {
  if (t === null || e === null)
    return;
  let a = {};
  const s = bo.find((o) => o.alias === t);
  if (s && t === s.alias ? a = s : (a.alias = t, bo.push(a)), e == null ? a.label = { text: "" } : a.label = { text: e }, r == null)
    a.type = { text: "container" };
  else if (typeof r == "object") {
    let [o, l] = Object.entries(r)[0];
    a[o] = { text: l };
  } else
    a.type = { text: r };
  if (typeof n == "object") {
    let [o, l] = Object.entries(n)[0];
    a[o] = l;
  } else
    a.tags = n;
  if (typeof i == "object") {
    let [o, l] = Object.entries(i)[0];
    a[o] = l;
  } else
    a.link = i;
  a.parentBoundary = Hi, a.wrap = Yc(), As = Hi, Hi = t, cc.push(As);
}, "addContainerBoundary"), WOe = /* @__PURE__ */ w(function(t, e, r, n, i, a, s, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = bo.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, bo.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.type = { text: "node" };
  else if (typeof n == "object") {
    let [h, f] = Object.entries(n)[0];
    l[h] = { text: f };
  } else
    l.type = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, f] = Object.entries(i)[0];
    l[h] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof s == "object") {
    let [h, f] = Object.entries(s)[0];
    l[h] = f;
  } else
    l.tags = s;
  if (typeof o == "object") {
    let [h, f] = Object.entries(o)[0];
    l[h] = f;
  } else
    l.link = o;
  l.nodeType = t, l.parentBoundary = Hi, l.wrap = Yc(), As = Hi, Hi = e, cc.push(As);
}, "addDeploymentNode"), YOe = /* @__PURE__ */ w(function() {
  Hi = As, cc.pop(), As = cc.pop(), cc.push(As);
}, "popBoundaryParseStack"), XOe = /* @__PURE__ */ w(function(t, e, r, n, i, a, s, o, l, u, h) {
  let f = Ds.find((d) => d.alias === e);
  if (!(f === void 0 && (f = bo.find((d) => d.alias === e), f === void 0))) {
    if (r != null)
      if (typeof r == "object") {
        let [d, p] = Object.entries(r)[0];
        f[d] = p;
      } else
        f.bgColor = r;
    if (n != null)
      if (typeof n == "object") {
        let [d, p] = Object.entries(n)[0];
        f[d] = p;
      } else
        f.fontColor = n;
    if (i != null)
      if (typeof i == "object") {
        let [d, p] = Object.entries(i)[0];
        f[d] = p;
      } else
        f.borderColor = i;
    if (a != null)
      if (typeof a == "object") {
        let [d, p] = Object.entries(a)[0];
        f[d] = p;
      } else
        f.shadowing = a;
    if (s != null)
      if (typeof s == "object") {
        let [d, p] = Object.entries(s)[0];
        f[d] = p;
      } else
        f.shape = s;
    if (o != null)
      if (typeof o == "object") {
        let [d, p] = Object.entries(o)[0];
        f[d] = p;
      } else
        f.sprite = o;
    if (l != null)
      if (typeof l == "object") {
        let [d, p] = Object.entries(l)[0];
        f[d] = p;
      } else
        f.techn = l;
    if (u != null)
      if (typeof u == "object") {
        let [d, p] = Object.entries(u)[0];
        f[d] = p;
      } else
        f.legendText = u;
    if (h != null)
      if (typeof h == "object") {
        let [d, p] = Object.entries(h)[0];
        f[d] = p;
      } else
        f.legendSprite = h;
  }
}, "updateElStyle"), jOe = /* @__PURE__ */ w(function(t, e, r, n, i, a, s) {
  const o = M1.find((l) => l.from === e && l.to === r);
  if (o !== void 0) {
    if (n != null)
      if (typeof n == "object") {
        let [l, u] = Object.entries(n)[0];
        o[l] = u;
      } else
        o.textColor = n;
    if (i != null)
      if (typeof i == "object") {
        let [l, u] = Object.entries(i)[0];
        o[l] = u;
      } else
        o.lineColor = i;
    if (a != null)
      if (typeof a == "object") {
        let [l, u] = Object.entries(a)[0];
        o[l] = parseInt(u);
      } else
        o.offsetX = parseInt(a);
    if (s != null)
      if (typeof s == "object") {
        let [l, u] = Object.entries(s)[0];
        o[l] = parseInt(u);
      } else
        o.offsetY = parseInt(s);
  }
}, "updateRelStyle"), KOe = /* @__PURE__ */ w(function(t, e, r) {
  let n = qb, i = Gb;
  if (typeof e == "object") {
    const a = Object.values(e)[0];
    n = parseInt(a);
  } else
    n = parseInt(e);
  if (typeof r == "object") {
    const a = Object.values(r)[0];
    i = parseInt(a);
  } else
    i = parseInt(r);
  n >= 1 && (qb = n), i >= 1 && (Gb = i);
}, "updateLayoutConfig"), ZOe = /* @__PURE__ */ w(function() {
  return qb;
}, "getC4ShapeInRow"), QOe = /* @__PURE__ */ w(function() {
  return Gb;
}, "getC4BoundaryInRow"), JOe = /* @__PURE__ */ w(function() {
  return Hi;
}, "getCurrentBoundaryParse"), ePe = /* @__PURE__ */ w(function() {
  return As;
}, "getParentBoundaryParse"), Rae = /* @__PURE__ */ w(function(t) {
  return t == null ? Ds : Ds.filter((e) => e.parentBoundary === t);
}, "getC4ShapeArray"), tPe = /* @__PURE__ */ w(function(t) {
  return Ds.find((e) => e.alias === t);
}, "getC4Shape"), rPe = /* @__PURE__ */ w(function(t) {
  return Object.keys(Rae(t));
}, "getC4ShapeKeys"), Iae = /* @__PURE__ */ w(function(t) {
  return t == null ? bo : bo.filter((e) => e.parentBoundary === t);
}, "getBoundaries"), nPe = Iae, iPe = /* @__PURE__ */ w(function() {
  return M1;
}, "getRels"), aPe = /* @__PURE__ */ w(function() {
  return qR;
}, "getTitle"), sPe = /* @__PURE__ */ w(function(t) {
  GR = t;
}, "setWrap"), Yc = /* @__PURE__ */ w(function() {
  return GR;
}, "autoWrap"), oPe = /* @__PURE__ */ w(function() {
  Ds = [], bo = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ], As = "", Hi = "global", cc = [""], M1 = [], cc = [""], qR = "", GR = !1, qb = 4, Gb = 2;
}, "clear"), lPe = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
}, cPe = {
  FILLED: 0,
  OPEN: 1
}, uPe = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, hPe = /* @__PURE__ */ w(function(t) {
  qR = pr(t, Te());
}, "setTitle"), IA = {
  addPersonOrSystem: qOe,
  addPersonOrSystemBoundary: VOe,
  addContainer: GOe,
  addContainerBoundary: HOe,
  addComponent: UOe,
  addDeploymentNode: WOe,
  popBoundaryParseStack: YOe,
  addRel: zOe,
  updateElStyle: XOe,
  updateRelStyle: jOe,
  updateLayoutConfig: KOe,
  autoWrap: Yc,
  setWrap: sPe,
  getC4ShapeArray: Rae,
  getC4Shape: tPe,
  getC4ShapeKeys: rPe,
  getBoundaries: Iae,
  getBoundarys: nPe,
  getCurrentBoundaryParse: JOe,
  getParentBoundaryParse: ePe,
  getRels: iPe,
  getTitle: aPe,
  getC4Type: BOe,
  getC4ShapeInRow: ZOe,
  getC4BoundaryInRow: QOe,
  setAccTitle: Ln,
  getAccTitle: Hn,
  getAccDescription: Yn,
  setAccDescription: Wn,
  getConfig: /* @__PURE__ */ w(() => Te().c4, "getConfig"),
  clear: oPe,
  LINETYPE: lPe,
  ARROWTYPE: cPe,
  PLACEMENT: uPe,
  setTitle: hPe,
  setC4Type: FOe
  // apply,
}, UR = /* @__PURE__ */ w(function(t, e) {
  return h3(t, e);
}, "drawRect"), Mae = /* @__PURE__ */ w(function(t, e, r, n, i, a) {
  const s = t.append("image");
  s.attr("width", e), s.attr("height", r), s.attr("x", n), s.attr("y", i);
  let o = a.startsWith("data:image/png;base64") ? a : yh.sanitizeUrl(a);
  s.attr("xlink:href", o);
}, "drawImage"), fPe = /* @__PURE__ */ w((t, e, r) => {
  const n = t.append("g");
  let i = 0;
  for (let a of e) {
    let s = a.textColor ? a.textColor : "#444444", o = a.lineColor ? a.lineColor : "#444444", l = a.offsetX ? parseInt(a.offsetX) : 0, u = a.offsetY ? parseInt(a.offsetY) : 0, h = "";
    if (i === 0) {
      let d = n.append("line");
      d.attr("x1", a.startPoint.x), d.attr("y1", a.startPoint.y), d.attr("x2", a.endPoint.x), d.attr("y2", a.endPoint.y), d.attr("stroke-width", "1"), d.attr("stroke", o), d.style("fill", "none"), a.type !== "rel_b" && d.attr("marker-end", "url(" + h + "#arrowhead)"), (a.type === "birel" || a.type === "rel_b") && d.attr("marker-start", "url(" + h + "#arrowend)"), i = -1;
    } else {
      let d = n.append("path");
      d.attr("fill", "none").attr("stroke-width", "1").attr("stroke", o).attr(
        "d",
        "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", a.startPoint.x).replaceAll("starty", a.startPoint.y).replaceAll(
          "controlx",
          a.startPoint.x + (a.endPoint.x - a.startPoint.x) / 2 - (a.endPoint.x - a.startPoint.x) / 4
        ).replaceAll("controly", a.startPoint.y + (a.endPoint.y - a.startPoint.y) / 2).replaceAll("stopx", a.endPoint.x).replaceAll("stopy", a.endPoint.y)
      ), a.type !== "rel_b" && d.attr("marker-end", "url(" + h + "#arrowhead)"), (a.type === "birel" || a.type === "rel_b") && d.attr("marker-start", "url(" + h + "#arrowend)");
    }
    let f = r.messageFont();
    tl(r)(
      a.label.text,
      n,
      Math.min(a.startPoint.x, a.endPoint.x) + Math.abs(a.endPoint.x - a.startPoint.x) / 2 + l,
      Math.min(a.startPoint.y, a.endPoint.y) + Math.abs(a.endPoint.y - a.startPoint.y) / 2 + u,
      a.label.width,
      a.label.height,
      { fill: s },
      f
    ), a.techn && a.techn.text !== "" && (f = r.messageFont(), tl(r)(
      "[" + a.techn.text + "]",
      n,
      Math.min(a.startPoint.x, a.endPoint.x) + Math.abs(a.endPoint.x - a.startPoint.x) / 2 + l,
      Math.min(a.startPoint.y, a.endPoint.y) + Math.abs(a.endPoint.y - a.startPoint.y) / 2 + r.messageFontSize + 5 + u,
      Math.max(a.label.width, a.techn.width),
      a.techn.height,
      { fill: s, "font-style": "italic" },
      f
    ));
  }
}, "drawRels"), dPe = /* @__PURE__ */ w(function(t, e, r) {
  const n = t.append("g");
  let i = e.bgColor ? e.bgColor : "none", a = e.borderColor ? e.borderColor : "#444444", s = e.fontColor ? e.fontColor : "black", o = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
  e.nodeType && (o = { "stroke-width": 1 });
  let l = {
    x: e.x,
    y: e.y,
    fill: i,
    stroke: a,
    width: e.width,
    height: e.height,
    rx: 2.5,
    ry: 2.5,
    attrs: o
  };
  UR(n, l);
  let u = r.boundaryFont();
  u.fontWeight = "bold", u.fontSize = u.fontSize + 2, u.fontColor = s, tl(r)(
    e.label.text,
    n,
    e.x,
    e.y + e.label.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  ), e.type && e.type.text !== "" && (u = r.boundaryFont(), u.fontColor = s, tl(r)(
    e.type.text,
    n,
    e.x,
    e.y + e.type.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  )), e.descr && e.descr.text !== "" && (u = r.boundaryFont(), u.fontSize = u.fontSize - 2, u.fontColor = s, tl(r)(
    e.descr.text,
    n,
    e.x,
    e.y + e.descr.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  ));
}, "drawBoundary"), pPe = /* @__PURE__ */ w(function(t, e, r) {
  let n = e.bgColor ? e.bgColor : r[e.typeC4Shape.text + "_bg_color"], i = e.borderColor ? e.borderColor : r[e.typeC4Shape.text + "_border_color"], a = e.fontColor ? e.fontColor : "#FFFFFF", s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
  switch (e.typeC4Shape.text) {
    case "person":
      s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
      break;
    case "external_person":
      s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
      break;
  }
  const o = t.append("g");
  o.attr("class", "person-man");
  const l = Oa();
  switch (e.typeC4Shape.text) {
    case "person":
    case "external_person":
    case "system":
    case "external_system":
    case "container":
    case "external_container":
    case "component":
    case "external_component":
      l.x = e.x, l.y = e.y, l.fill = n, l.width = e.width, l.height = e.height, l.stroke = i, l.rx = 2.5, l.ry = 2.5, l.attrs = { "stroke-width": 0.5 }, UR(o, l);
      break;
    case "system_db":
    case "external_system_db":
    case "container_db":
    case "external_container_db":
    case "component_db":
    case "external_component_db":
      o.append("path").attr("fill", n).attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("half", e.width / 2).replaceAll("height", e.height)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("half", e.width / 2)
      );
      break;
    case "system_queue":
    case "external_system_queue":
    case "container_queue":
    case "external_container_queue":
    case "component_queue":
    case "external_component_queue":
      o.append("path").attr("fill", n).attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("width", e.width).replaceAll("half", e.height / 2)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", e.x + e.width).replaceAll("starty", e.y).replaceAll("half", e.height / 2)
      );
      break;
  }
  let u = EPe(r, e.typeC4Shape.text);
  switch (o.append("text").attr("fill", a).attr("font-family", u.fontFamily).attr("font-size", u.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", e.typeC4Shape.width).attr("x", e.x + e.width / 2 - e.typeC4Shape.width / 2).attr("y", e.y + e.typeC4Shape.Y).text("<<" + e.typeC4Shape.text + ">>"), e.typeC4Shape.text) {
    case "person":
    case "external_person":
      Mae(
        o,
        48,
        48,
        e.x + e.width / 2 - 24,
        e.y + e.image.Y,
        s
      );
      break;
  }
  let h = r[e.typeC4Shape.text + "Font"]();
  return h.fontWeight = "bold", h.fontSize = h.fontSize + 2, h.fontColor = a, tl(r)(
    e.label.text,
    o,
    e.x,
    e.y + e.label.Y,
    e.width,
    e.height,
    { fill: a },
    h
  ), h = r[e.typeC4Shape.text + "Font"](), h.fontColor = a, e.techn && e.techn?.text !== "" ? tl(r)(
    e.techn.text,
    o,
    e.x,
    e.y + e.techn.Y,
    e.width,
    e.height,
    { fill: a, "font-style": "italic" },
    h
  ) : e.type && e.type.text !== "" && tl(r)(
    e.type.text,
    o,
    e.x,
    e.y + e.type.Y,
    e.width,
    e.height,
    { fill: a, "font-style": "italic" },
    h
  ), e.descr && e.descr.text !== "" && (h = r.personFont(), h.fontColor = a, tl(r)(
    e.descr.text,
    o,
    e.x,
    e.y + e.descr.Y,
    e.width,
    e.height,
    { fill: a },
    h
  )), e.height;
}, "drawC4Shape"), gPe = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, "insertDatabaseIcon"), mPe = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, "insertComputerIcon"), vPe = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, "insertClockIcon"), yPe = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), bPe = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
}, "insertArrowEnd"), xPe = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), wPe = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, "insertDynamicNumber"), TPe = /* @__PURE__ */ w(function(t) {
  const r = t.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  r.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z"), r.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
}, "insertArrowCrossHead"), EPe = /* @__PURE__ */ w((t, e) => ({
  fontFamily: t[e + "FontFamily"],
  fontSize: t[e + "FontSize"],
  fontWeight: t[e + "FontWeight"]
}), "getC4ShapeFont"), tl = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h) {
    const f = a.append("text").attr("x", s + l / 2).attr("y", o + u / 2 + 5).style("text-anchor", "middle").text(i);
    n(f, h);
  }
  w(t, "byText");
  function e(i, a, s, o, l, u, h, f) {
    const { fontSize: d, fontFamily: p, fontWeight: g } = f, m = i.split(at.lineBreakRegex);
    for (let v = 0; v < m.length; v++) {
      const y = v * d - d * (m.length - 1) / 2, b = a.append("text").attr("x", s + l / 2).attr("y", o).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", d).style("font-weight", g).style("font-family", p);
      b.append("tspan").attr("dy", y).text(m[v]).attr("alignment-baseline", "mathematical"), n(b, h);
    }
  }
  w(e, "byTspan");
  function r(i, a, s, o, l, u, h, f) {
    const d = a.append("switch"), g = d.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, s, o, l, u, h, f), n(g, h);
  }
  w(r, "byFo");
  function n(i, a) {
    for (const s in a)
      a.hasOwnProperty(s) && i.attr(s, a[s]);
  }
  return w(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), Qs = {
  drawRect: UR,
  drawBoundary: dPe,
  drawC4Shape: pPe,
  drawRels: fPe,
  drawImage: Mae,
  insertArrowHead: yPe,
  insertArrowEnd: bPe,
  insertArrowFilledHead: xPe,
  insertDynamicNumber: wPe,
  insertArrowCrossHead: TPe,
  insertDatabaseIcon: gPe,
  insertComputerIcon: mPe,
  insertClockIcon: vPe
}, Ub = 0, Vb = 0, Nae = 4, MA = 2;
zb.yy = IA;
var Mt = {}, td, Dae = (td = class {
  constructor(e) {
    this.name = "", this.data = {}, this.data.startx = void 0, this.data.stopx = void 0, this.data.starty = void 0, this.data.stopy = void 0, this.data.widthLimit = void 0, this.nextData = {}, this.nextData.startx = void 0, this.nextData.stopx = void 0, this.nextData.starty = void 0, this.nextData.stopy = void 0, this.nextData.cnt = 0, NA(e.db.getConfig());
  }
  setData(e, r, n, i) {
    this.nextData.startx = this.data.startx = e, this.nextData.stopx = this.data.stopx = r, this.nextData.starty = this.data.starty = n, this.nextData.stopy = this.data.stopy = i;
  }
  updateVal(e, r, n, i) {
    e[r] === void 0 ? e[r] = n : e[r] = i(n, e[r]);
  }
  insert(e) {
    this.nextData.cnt = this.nextData.cnt + 1;
    let r = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + e.margin : this.nextData.stopx + e.margin * 2, n = r + e.width, i = this.nextData.starty + e.margin * 2, a = i + e.height;
    (r >= this.data.widthLimit || n >= this.data.widthLimit || this.nextData.cnt > Nae) && (r = this.nextData.startx + e.margin + Mt.nextLinePaddingX, i = this.nextData.stopy + e.margin * 2, this.nextData.stopx = n = r + e.width, this.nextData.starty = this.nextData.stopy, this.nextData.stopy = a = i + e.height, this.nextData.cnt = 1), e.x = r, e.y = i, this.updateVal(this.data, "startx", r, Math.min), this.updateVal(this.data, "starty", i, Math.min), this.updateVal(this.data, "stopx", n, Math.max), this.updateVal(this.data, "stopy", a, Math.max), this.updateVal(this.nextData, "startx", r, Math.min), this.updateVal(this.nextData, "starty", i, Math.min), this.updateVal(this.nextData, "stopx", n, Math.max), this.updateVal(this.nextData, "stopy", a, Math.max);
  }
  init(e) {
    this.name = "", this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      widthLimit: void 0
    }, this.nextData = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      cnt: 0
    }, NA(e.db.getConfig());
  }
  bumpLastMargin(e) {
    this.data.stopx += e, this.data.stopy += e;
  }
}, w(td, "Bounds"), td), NA = /* @__PURE__ */ w(function(t) {
  bn(Mt, t), t.fontFamily && (Mt.personFontFamily = Mt.systemFontFamily = Mt.messageFontFamily = t.fontFamily), t.fontSize && (Mt.personFontSize = Mt.systemFontSize = Mt.messageFontSize = t.fontSize), t.fontWeight && (Mt.personFontWeight = Mt.systemFontWeight = Mt.messageFontWeight = t.fontWeight);
}, "setConf"), wp = /* @__PURE__ */ w((t, e) => ({
  fontFamily: t[e + "FontFamily"],
  fontSize: t[e + "FontSize"],
  fontWeight: t[e + "FontWeight"]
}), "c4ShapeFont"), jy = /* @__PURE__ */ w((t) => ({
  fontFamily: t.boundaryFontFamily,
  fontSize: t.boundaryFontSize,
  fontWeight: t.boundaryFontWeight
}), "boundaryFont"), SPe = /* @__PURE__ */ w((t) => ({
  fontFamily: t.messageFontFamily,
  fontSize: t.messageFontSize,
  fontWeight: t.messageFontWeight
}), "messageFont");
function Ja(t, e, r, n, i) {
  if (!e[t].width)
    if (r)
      e[t].text = NZ(e[t].text, i, n), e[t].textLines = e[t].text.split(at.lineBreakRegex).length, e[t].width = i, e[t].height = ab(e[t].text, n);
    else {
      let a = e[t].text.split(at.lineBreakRegex);
      e[t].textLines = a.length;
      let s = 0;
      e[t].height = 0, e[t].width = 0;
      for (const o of a)
        e[t].width = Math.max(
          Vi(o, n),
          e[t].width
        ), s = ab(o, n), e[t].height = e[t].height + s;
    }
}
w(Ja, "calcC4ShapeTextWH");
var Oae = /* @__PURE__ */ w(function(t, e, r) {
  e.x = r.data.startx, e.y = r.data.starty, e.width = r.data.stopx - r.data.startx, e.height = r.data.stopy - r.data.starty, e.label.y = Mt.c4ShapeMargin - 35;
  let n = e.wrap && Mt.wrap, i = jy(Mt);
  i.fontSize = i.fontSize + 2, i.fontWeight = "bold";
  let a = Vi(e.label.text, i);
  Ja("label", e, n, i, a), Qs.drawBoundary(t, e, Mt);
}, "drawBoundary"), Pae = /* @__PURE__ */ w(function(t, e, r, n) {
  let i = 0;
  for (const a of n) {
    i = 0;
    const s = r[a];
    let o = wp(Mt, s.typeC4Shape.text);
    switch (o.fontSize = o.fontSize - 2, s.typeC4Shape.width = Vi(
      "\xAB" + s.typeC4Shape.text + "\xBB",
      o
    ), s.typeC4Shape.height = o.fontSize + 2, s.typeC4Shape.Y = Mt.c4ShapePadding, i = s.typeC4Shape.Y + s.typeC4Shape.height - 4, s.image = { width: 0, height: 0, Y: 0 }, s.typeC4Shape.text) {
      case "person":
      case "external_person":
        s.image.width = 48, s.image.height = 48, s.image.Y = i, i = s.image.Y + s.image.height;
        break;
    }
    s.sprite && (s.image.width = 48, s.image.height = 48, s.image.Y = i, i = s.image.Y + s.image.height);
    let l = s.wrap && Mt.wrap, u = Mt.width - Mt.c4ShapePadding * 2, h = wp(Mt, s.typeC4Shape.text);
    if (h.fontSize = h.fontSize + 2, h.fontWeight = "bold", Ja("label", s, l, h, u), s.label.Y = i + 8, i = s.label.Y + s.label.height, s.type && s.type.text !== "") {
      s.type.text = "[" + s.type.text + "]";
      let p = wp(Mt, s.typeC4Shape.text);
      Ja("type", s, l, p, u), s.type.Y = i + 5, i = s.type.Y + s.type.height;
    } else if (s.techn && s.techn.text !== "") {
      s.techn.text = "[" + s.techn.text + "]";
      let p = wp(Mt, s.techn.text);
      Ja("techn", s, l, p, u), s.techn.Y = i + 5, i = s.techn.Y + s.techn.height;
    }
    let f = i, d = s.label.width;
    if (s.descr && s.descr.text !== "") {
      let p = wp(Mt, s.typeC4Shape.text);
      Ja("descr", s, l, p, u), s.descr.Y = i + 20, i = s.descr.Y + s.descr.height, d = Math.max(s.label.width, s.descr.width), f = i - s.descr.textLines * 5;
    }
    d = d + Mt.c4ShapePadding, s.width = Math.max(s.width || Mt.width, d, Mt.width), s.height = Math.max(s.height || Mt.height, f, Mt.height), s.margin = s.margin || Mt.c4ShapeMargin, t.insert(s), Qs.drawC4Shape(e, s, Mt);
  }
  t.bumpLastMargin(Mt.c4ShapeMargin);
}, "drawC4ShapeArray"), rd, qa = (rd = class {
  constructor(e, r) {
    this.x = e, this.y = r;
  }
}, w(rd, "Point"), rd), MU = /* @__PURE__ */ w(function(t, e) {
  let r = t.x, n = t.y, i = e.x, a = e.y, s = r + t.width / 2, o = n + t.height / 2, l = Math.abs(r - i), u = Math.abs(n - a), h = u / l, f = t.height / t.width, d = null;
  return n == a && r < i ? d = new qa(r + t.width, o) : n == a && r > i ? d = new qa(r, o) : r == i && n < a ? d = new qa(s, n + t.height) : r == i && n > a && (d = new qa(s, n)), r > i && n < a ? f >= h ? d = new qa(r, o + h * t.width / 2) : d = new qa(
    s - l / u * t.height / 2,
    n + t.height
  ) : r < i && n < a ? f >= h ? d = new qa(r + t.width, o + h * t.width / 2) : d = new qa(
    s + l / u * t.height / 2,
    n + t.height
  ) : r < i && n > a ? f >= h ? d = new qa(r + t.width, o - h * t.width / 2) : d = new qa(s + t.height / 2 * l / u, n) : r > i && n > a && (f >= h ? d = new qa(r, o - t.width / 2 * h) : d = new qa(s - t.height / 2 * l / u, n)), d;
}, "getIntersectPoint"), kPe = /* @__PURE__ */ w(function(t, e) {
  let r = { x: 0, y: 0 };
  r.x = e.x + e.width / 2, r.y = e.y + e.height / 2;
  let n = MU(t, r);
  r.x = t.x + t.width / 2, r.y = t.y + t.height / 2;
  let i = MU(e, r);
  return { startPoint: n, endPoint: i };
}, "getIntersectPoints"), CPe = /* @__PURE__ */ w(function(t, e, r, n) {
  let i = 0;
  for (let a of e) {
    i = i + 1;
    let s = a.wrap && Mt.wrap, o = SPe(Mt);
    n.db.getC4Type() === "C4Dynamic" && (a.label.text = i + ": " + a.label.text);
    let u = Vi(a.label.text, o);
    Ja("label", a, s, o, u), a.techn && a.techn.text !== "" && (u = Vi(a.techn.text, o), Ja("techn", a, s, o, u)), a.descr && a.descr.text !== "" && (u = Vi(a.descr.text, o), Ja("descr", a, s, o, u));
    let h = r(a.from), f = r(a.to), d = kPe(h, f);
    a.startPoint = d.startPoint, a.endPoint = d.endPoint;
  }
  Qs.drawRels(t, e, Mt);
}, "drawRels");
function VR(t, e, r, n, i) {
  let a = new Dae(i);
  a.data.widthLimit = r.data.widthLimit / Math.min(MA, n.length);
  for (let [s, o] of n.entries()) {
    let l = 0;
    o.image = { width: 0, height: 0, Y: 0 }, o.sprite && (o.image.width = 48, o.image.height = 48, o.image.Y = l, l = o.image.Y + o.image.height);
    let u = o.wrap && Mt.wrap, h = jy(Mt);
    if (h.fontSize = h.fontSize + 2, h.fontWeight = "bold", Ja(
      "label",
      o,
      u,
      h,
      a.data.widthLimit
    ), o.label.Y = l + 8, l = o.label.Y + o.label.height, o.type && o.type.text !== "") {
      o.type.text = "[" + o.type.text + "]";
      let g = jy(Mt);
      Ja(
        "type",
        o,
        u,
        g,
        a.data.widthLimit
      ), o.type.Y = l + 5, l = o.type.Y + o.type.height;
    }
    if (o.descr && o.descr.text !== "") {
      let g = jy(Mt);
      g.fontSize = g.fontSize - 2, Ja(
        "descr",
        o,
        u,
        g,
        a.data.widthLimit
      ), o.descr.Y = l + 20, l = o.descr.Y + o.descr.height;
    }
    if (s == 0 || s % MA === 0) {
      let g = r.data.startx + Mt.diagramMarginX, m = r.data.stopy + Mt.diagramMarginY + l;
      a.setData(g, g, m, m);
    } else {
      let g = a.data.stopx !== a.data.startx ? a.data.stopx + Mt.diagramMarginX : a.data.startx, m = a.data.starty;
      a.setData(g, g, m, m);
    }
    a.name = o.alias;
    let f = i.db.getC4ShapeArray(o.alias), d = i.db.getC4ShapeKeys(o.alias);
    d.length > 0 && Pae(
      a,
      t,
      f,
      d
    ), e = o.alias;
    let p = i.db.getBoundaries(e);
    p.length > 0 && VR(
      t,
      e,
      a,
      p,
      i
    ), o.alias !== "global" && Oae(t, o, a), r.data.stopy = Math.max(
      a.data.stopy + Mt.c4ShapeMargin,
      r.data.stopy
    ), r.data.stopx = Math.max(
      a.data.stopx + Mt.c4ShapeMargin,
      r.data.stopx
    ), Ub = Math.max(Ub, r.data.stopx), Vb = Math.max(Vb, r.data.stopy);
  }
}
w(VR, "drawInsideBoundary");
var _Pe = /* @__PURE__ */ w(function(t, e, r, n) {
  Mt = Te().c4;
  const i = Te().securityLevel;
  let a;
  i === "sandbox" && (a = Qe("#i" + e));
  const s = Qe(i === "sandbox" ? a.nodes()[0].contentDocument.body : "body");
  let o = n.db;
  n.db.setWrap(Mt.wrap), Nae = o.getC4ShapeInRow(), MA = o.getC4BoundaryInRow(), ae.debug(`C:${JSON.stringify(Mt, null, 2)}`);
  const l = i === "sandbox" ? s.select(`[id="${e}"]`) : Qe(`[id="${e}"]`);
  Qs.insertComputerIcon(l), Qs.insertDatabaseIcon(l), Qs.insertClockIcon(l);
  let u = new Dae(n);
  u.setData(
    Mt.diagramMarginX,
    Mt.diagramMarginX,
    Mt.diagramMarginY,
    Mt.diagramMarginY
  ), u.data.widthLimit = screen.availWidth, Ub = Mt.diagramMarginX, Vb = Mt.diagramMarginY;
  const h = n.db.getTitle();
  let f = n.db.getBoundaries("");
  VR(l, "", u, f, n), Qs.insertArrowHead(l), Qs.insertArrowEnd(l), Qs.insertArrowCrossHead(l), Qs.insertArrowFilledHead(l), CPe(l, n.db.getRels(), n.db.getC4Shape, n), u.data.stopx = Ub, u.data.stopy = Vb;
  const d = u.data;
  let g = d.stopy - d.starty + 2 * Mt.diagramMarginY;
  const v = d.stopx - d.startx + 2 * Mt.diagramMarginX;
  h && l.append("text").text(h).attr("x", (d.stopx - d.startx) / 2 - 4 * Mt.diagramMarginX).attr("y", d.starty + Mt.diagramMarginY), Qi(l, g, v, Mt.useMaxWidth);
  const y = h ? 60 : 0;
  l.attr(
    "viewBox",
    d.startx - Mt.diagramMarginX + " -" + (Mt.diagramMarginY + y) + " " + v + " " + (g + y)
  ), ae.debug("models:", d);
}, "draw"), NU = {
  drawPersonOrSystemArray: Pae,
  drawBoundary: Oae,
  setConf: NA,
  draw: _Pe
}, APe = /* @__PURE__ */ w((t) => `.person {
    stroke: ${t.personBorder};
    fill: ${t.personBkg};
  }
`, "getStyles"), LPe = APe, RPe = {
  parser: $Oe,
  db: IA,
  renderer: NU,
  styles: LPe,
  init: /* @__PURE__ */ w(({ c4: t, wrap: e }) => {
    NU.setConf(t), IA.setWrap(e);
  }, "init")
};
const IPe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: RPe
}, Symbol.toStringTag, { value: "Module" }));
var Rm = /* @__PURE__ */ w(() => `
  /* Font Awesome icon styling - consolidated */
  .label-icon {
    display: inline-block;
    height: 1em;
    overflow: visible;
    vertical-align: -0.125em;
  }
  
  .node .label-icon path {
    fill: currentColor;
    stroke: revert;
    stroke-width: revert;
  }
`, "getIconStyles"), Y0 = /* @__PURE__ */ w((t, e) => {
  let r;
  return e === "sandbox" && (r = Qe("#i" + t)), Qe(e === "sandbox" ? r.nodes()[0].contentDocument.body : "body").select(`[id="${t}"]`);
}, "getDiagramElement"), Oh = /* @__PURE__ */ w((t, e, r, n) => {
  t.attr("class", r);
  const { width: i, height: a, x: s, y: o } = MPe(t, e);
  Qi(t, a, i, n);
  const l = NPe(s, o, i, a, e);
  t.attr("viewBox", l), ae.debug(`viewBox configured: ${l} with padding: ${e}`);
}, "setupViewPortForSVG"), MPe = /* @__PURE__ */ w((t, e) => {
  const r = t.node()?.getBBox() || { width: 0, height: 0, x: 0, y: 0 };
  return {
    width: r.width + e * 2,
    height: r.height + e * 2,
    x: r.x,
    y: r.y
  };
}, "calculateDimensionsWithPadding"), NPe = /* @__PURE__ */ w((t, e, r, n, i) => `${t - i} ${e - i} ${r} ${n}`, "createViewBox"), DPe = "flowchart-", nd, OPe = (nd = class {
  // cspell:ignore funs
  constructor() {
    this.vertexCounter = 0, this.config = Te(), this.vertices = /* @__PURE__ */ new Map(), this.edges = [], this.classes = /* @__PURE__ */ new Map(), this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.tooltips = /* @__PURE__ */ new Map(), this.subCount = 0, this.firstGraphFlag = !0, this.secCount = -1, this.posCrossRef = [], this.funs = [], this.setAccTitle = Ln, this.setAccDescription = Wn, this.setDiagramTitle = ti, this.getAccTitle = Hn, this.getAccDescription = Yn, this.getDiagramTitle = Mn, this.funs.push(this.setupToolTips.bind(this)), this.addVertex = this.addVertex.bind(this), this.firstGraph = this.firstGraph.bind(this), this.setDirection = this.setDirection.bind(this), this.addSubGraph = this.addSubGraph.bind(this), this.addLink = this.addLink.bind(this), this.setLink = this.setLink.bind(this), this.updateLink = this.updateLink.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.destructLink = this.destructLink.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setTooltip = this.setTooltip.bind(this), this.updateLinkInterpolate = this.updateLinkInterpolate.bind(this), this.setClickFun = this.setClickFun.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.lex = {
      firstGraph: this.firstGraph.bind(this)
    }, this.clear(), this.setGen("gen-2");
  }
  sanitizeText(e) {
    return at.sanitizeText(e, this.config);
  }
  /**
   * Function to lookup domId from id in the graph definition.
   *
   * @param id - id of the node
   */
  lookUpDomId(e) {
    for (const r of this.vertices.values())
      if (r.id === e)
        return r.domId;
    return e;
  }
  /**
   * Function called by parser when a node definition has been found
   */
  addVertex(e, r, n, i, a, s, o = {}, l) {
    if (!e || e.trim().length === 0)
      return;
    let u;
    if (l !== void 0) {
      let p;
      l.includes(`
`) ? p = l + `
` : p = `{
` + l + `
}`, u = Kx(p, { schema: jx });
    }
    const h = this.edges.find((p) => p.id === e);
    if (h) {
      const p = u;
      p?.animate !== void 0 && (h.animate = p.animate), p?.animation !== void 0 && (h.animation = p.animation), p?.curve !== void 0 && (h.interpolate = p.curve);
      return;
    }
    let f, d = this.vertices.get(e);
    if (d === void 0 && (d = {
      id: e,
      labelType: "text",
      domId: DPe + e + "-" + this.vertexCounter,
      styles: [],
      classes: []
    }, this.vertices.set(e, d)), this.vertexCounter++, r !== void 0 ? (this.config = Te(), f = this.sanitizeText(r.text.trim()), d.labelType = r.type, f.startsWith('"') && f.endsWith('"') && (f = f.substring(1, f.length - 1)), d.text = f) : d.text === void 0 && (d.text = e), n !== void 0 && (d.type = n), i?.forEach((p) => {
      d.styles.push(p);
    }), a?.forEach((p) => {
      d.classes.push(p);
    }), s !== void 0 && (d.dir = s), d.props === void 0 ? d.props = o : o !== void 0 && Object.assign(d.props, o), u !== void 0) {
      if (u.shape) {
        if (u.shape !== u.shape.toLowerCase() || u.shape.includes("_"))
          throw new Error(`No such shape: ${u.shape}. Shape names should be lowercase.`);
        if (!OJ(u.shape))
          throw new Error(`No such shape: ${u.shape}.`);
        d.type = u?.shape;
      }
      u?.label && (d.text = u?.label), u?.icon && (d.icon = u?.icon, !u.label?.trim() && d.text === e && (d.text = "")), u?.form && (d.form = u?.form), u?.pos && (d.pos = u?.pos), u?.img && (d.img = u?.img, !u.label?.trim() && d.text === e && (d.text = "")), u?.constraint && (d.constraint = u.constraint), u.w && (d.assetWidth = Number(u.w)), u.h && (d.assetHeight = Number(u.h));
    }
  }
  /**
   * Function called by parser when a link/edge definition has been found
   *
   */
  addSingleLink(e, r, n, i) {
    const o = {
      start: e,
      end: r,
      type: void 0,
      text: "",
      labelType: "text",
      classes: [],
      isUserDefinedId: !1,
      interpolate: this.edges.defaultInterpolate
    };
    ae.info("abc78 Got edge...", o);
    const l = n.text;
    if (l !== void 0 && (o.text = this.sanitizeText(l.text.trim()), o.text.startsWith('"') && o.text.endsWith('"') && (o.text = o.text.substring(1, o.text.length - 1)), o.labelType = l.type), n !== void 0 && (o.type = n.type, o.stroke = n.stroke, o.length = n.length > 10 ? 10 : n.length), i && !this.edges.some((u) => u.id === i))
      o.id = i, o.isUserDefinedId = !0;
    else {
      const u = this.edges.filter((h) => h.start === o.start && h.end === o.end);
      u.length === 0 ? o.id = Nf(o.start, o.end, { counter: 0, prefix: "L" }) : o.id = Nf(o.start, o.end, {
        counter: u.length + 1,
        prefix: "L"
      });
    }
    if (this.edges.length < (this.config.maxEdges ?? 500))
      ae.info("Pushing edge..."), this.edges.push(o);
    else
      throw new Error(
        `Edge limit exceeded. ${this.edges.length} edges found, but the limit is ${this.config.maxEdges}.

Initialize mermaid with maxEdges set to a higher number to allow more edges.
You cannot set this config via configuration inside the diagram as it is a secure config.
You have to call mermaid.initialize.`
      );
  }
  isLinkData(e) {
    return e !== null && typeof e == "object" && "id" in e && typeof e.id == "string";
  }
  addLink(e, r, n) {
    const i = this.isLinkData(n) ? n.id.replace("@", "") : void 0;
    ae.info("addLink", e, r, i);
    for (const a of e)
      for (const s of r) {
        const o = a === e[e.length - 1], l = s === r[0];
        o && l ? this.addSingleLink(a, s, n, i) : this.addSingleLink(a, s, n, void 0);
      }
  }
  /**
   * Updates a link's line interpolation algorithm
   */
  updateLinkInterpolate(e, r) {
    e.forEach((n) => {
      n === "default" ? this.edges.defaultInterpolate = r : this.edges[n].interpolate = r;
    });
  }
  /**
   * Updates a link with a style
   *
   */
  updateLink(e, r) {
    e.forEach((n) => {
      if (typeof n == "number" && n >= this.edges.length)
        throw new Error(
          `The index ${n} for linkStyle is out of bounds. Valid indices for linkStyle are between 0 and ${this.edges.length - 1}. (Help: Ensure that the index is within the range of existing edges.)`
        );
      n === "default" ? this.edges.defaultStyle = r : (this.edges[n].style = r, (this.edges[n]?.style?.length ?? 0) > 0 && !this.edges[n]?.style?.some((i) => i?.startsWith("fill")) && this.edges[n]?.style?.push("fill:none"));
    });
  }
  addClass(e, r) {
    const n = r.join().replace(/\\,/g, "\xA7\xA7\xA7").replace(/,/g, ";").replace(//g, ",").split(";");
    e.split(",").forEach((i) => {
      let a = this.classes.get(i);
      a === void 0 && (a = { id: i, styles: [], textStyles: [] }, this.classes.set(i, a)), n?.forEach((s) => {
        if (/color/.exec(s)) {
          const o = s.replace("fill", "bgFill");
          a.textStyles.push(o);
        }
        a.styles.push(s);
      });
    });
  }
  /**
   * Called by parser when a graph definition is found, stores the direction of the chart.
   *
   */
  setDirection(e) {
    this.direction = e.trim(), /.*</.exec(this.direction) && (this.direction = "RL"), /.*\^/.exec(this.direction) && (this.direction = "BT"), /.*>/.exec(this.direction) && (this.direction = "LR"), /.*v/.exec(this.direction) && (this.direction = "TB"), this.direction === "TD" && (this.direction = "TB");
  }
  /**
   * Called by parser when a special node is found, e.g. a clickable element.
   *
   * @param ids - Comma separated list of ids
   * @param className - Class to add
   */
  setClass(e, r) {
    for (const n of e.split(",")) {
      const i = this.vertices.get(n);
      i && i.classes.push(r);
      const a = this.edges.find((o) => o.id === n);
      a && a.classes.push(r);
      const s = this.subGraphLookup.get(n);
      s && s.classes.push(r);
    }
  }
  setTooltip(e, r) {
    if (r !== void 0) {
      r = this.sanitizeText(r);
      for (const n of e.split(","))
        this.tooltips.set(this.version === "gen-1" ? this.lookUpDomId(n) : n, r);
    }
  }
  setClickFun(e, r, n) {
    const i = this.lookUpDomId(e);
    if (Te().securityLevel !== "loose" || r === void 0)
      return;
    let a = [];
    if (typeof n == "string") {
      a = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let o = 0; o < a.length; o++) {
        let l = a[o].trim();
        l.startsWith('"') && l.endsWith('"') && (l = l.substr(1, l.length - 2)), a[o] = l;
      }
    }
    a.length === 0 && a.push(e);
    const s = this.vertices.get(e);
    s && (s.haveCallback = !0, this.funs.push(() => {
      const o = document.querySelector(`[id="${i}"]`);
      o !== null && o.addEventListener(
        "click",
        () => {
          Jt.runFunc(r, ...a);
        },
        !1
      );
    }));
  }
  /**
   * Called by parser when a link is found. Adds the URL to the vertex data.
   *
   * @param ids - Comma separated list of ids
   * @param linkStr - URL to create a link for
   * @param target - Target attribute for the link
   */
  setLink(e, r, n) {
    e.split(",").forEach((i) => {
      const a = this.vertices.get(i);
      a !== void 0 && (a.link = Jt.formatUrl(r, this.config), a.linkTarget = n);
    }), this.setClass(e, "clickable");
  }
  getTooltip(e) {
    return this.tooltips.get(e);
  }
  /**
   * Called by parser when a click definition is found. Registers an event handler.
   *
   * @param ids - Comma separated list of ids
   * @param functionName - Function to be called on click
   * @param functionArgs - Arguments to be passed to the function
   */
  setClickEvent(e, r, n) {
    e.split(",").forEach((i) => {
      this.setClickFun(i, r, n);
    }), this.setClass(e, "clickable");
  }
  bindFunctions(e) {
    this.funs.forEach((r) => {
      r(e);
    });
  }
  getDirection() {
    return this.direction?.trim();
  }
  /**
   * Retrieval function for fetching the found nodes after parsing has completed.
   *
   */
  getVertices() {
    return this.vertices;
  }
  /**
   * Retrieval function for fetching the found links after parsing has completed.
   *
   */
  getEdges() {
    return this.edges;
  }
  /**
   * Retrieval function for fetching the found class definitions after parsing has completed.
   *
   */
  getClasses() {
    return this.classes;
  }
  setupToolTips(e) {
    let r = Qe(".mermaidTooltip");
    (r._groups || r)[0][0] === null && (r = Qe("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), Qe(e).select("svg").selectAll("g.node").on("mouseover", (a) => {
      const s = Qe(a.currentTarget);
      if (s.attr("title") === null)
        return;
      const l = a.currentTarget?.getBoundingClientRect();
      r.transition().duration(200).style("opacity", ".9"), r.text(s.attr("title")).style("left", window.scrollX + l.left + (l.right - l.left) / 2 + "px").style("top", window.scrollY + l.bottom + "px"), r.html(r.html().replace(/&lt;br\/&gt;/g, "<br/>")), s.classed("hover", !0);
    }).on("mouseout", (a) => {
      r.transition().duration(500).style("opacity", 0), Qe(a.currentTarget).classed("hover", !1);
    });
  }
  /**
   * Clears the internal graph db so that a new graph can be parsed.
   *
   */
  clear(e = "gen-2") {
    this.vertices = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.edges = [], this.funs = [this.setupToolTips.bind(this)], this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.subCount = 0, this.tooltips = /* @__PURE__ */ new Map(), this.firstGraphFlag = !0, this.version = e, this.config = Te(), In();
  }
  setGen(e) {
    this.version = e || "gen-2";
  }
  defaultStyle() {
    return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
  }
  addSubGraph(e, r, n) {
    let i = e.text.trim(), a = n.text;
    e === n && /\s/.exec(n.text) && (i = void 0);
    const o = (/* @__PURE__ */ w((d) => {
      const p = { boolean: {}, number: {}, string: {} }, g = [];
      let m;
      return { nodeList: d.filter(function(y) {
        const b = typeof y;
        return y.stmt && y.stmt === "dir" ? (m = y.value, !1) : y.trim() === "" ? !1 : b in p ? p[b].hasOwnProperty(y) ? !1 : p[b][y] = !0 : g.includes(y) ? !1 : g.push(y);
      }), dir: m };
    }, "uniq"))(r.flat()), l = o.nodeList;
    let u = o.dir;
    const h = Te().flowchart ?? {};
    if (u = u ?? (h.inheritDir ? this.getDirection() ?? Te().direction ?? void 0 : void 0), this.version === "gen-1")
      for (let d = 0; d < l.length; d++)
        l[d] = this.lookUpDomId(l[d]);
    i = i ?? "subGraph" + this.subCount, a = a || "", a = this.sanitizeText(a), this.subCount = this.subCount + 1;
    const f = {
      id: i,
      nodes: l,
      title: a.trim(),
      classes: [],
      dir: u,
      labelType: n.type
    };
    return ae.info("Adding", f.id, f.nodes, f.dir), f.nodes = this.makeUniq(f, this.subGraphs).nodes, this.subGraphs.push(f), this.subGraphLookup.set(i, f), i;
  }
  getPosForId(e) {
    for (const [r, n] of this.subGraphs.entries())
      if (n.id === e)
        return r;
    return -1;
  }
  indexNodes2(e, r) {
    const n = this.subGraphs[r].nodes;
    if (this.secCount = this.secCount + 1, this.secCount > 2e3)
      return {
        result: !1,
        count: 0
      };
    if (this.posCrossRef[this.secCount] = r, this.subGraphs[r].id === e)
      return {
        result: !0,
        count: 0
      };
    let i = 0, a = 1;
    for (; i < n.length; ) {
      const s = this.getPosForId(n[i]);
      if (s >= 0) {
        const o = this.indexNodes2(e, s);
        if (o.result)
          return {
            result: !0,
            count: a + o.count
          };
        a = a + o.count;
      }
      i = i + 1;
    }
    return {
      result: !1,
      count: a
    };
  }
  getDepthFirstPos(e) {
    return this.posCrossRef[e];
  }
  indexNodes() {
    this.secCount = -1, this.subGraphs.length > 0 && this.indexNodes2("none", this.subGraphs.length - 1);
  }
  getSubGraphs() {
    return this.subGraphs;
  }
  firstGraph() {
    return this.firstGraphFlag ? (this.firstGraphFlag = !1, !0) : !1;
  }
  destructStartLink(e) {
    let r = e.trim(), n = "arrow_open";
    switch (r[0]) {
      case "<":
        n = "arrow_point", r = r.slice(1);
        break;
      case "x":
        n = "arrow_cross", r = r.slice(1);
        break;
      case "o":
        n = "arrow_circle", r = r.slice(1);
        break;
    }
    let i = "normal";
    return r.includes("=") && (i = "thick"), r.includes(".") && (i = "dotted"), { type: n, stroke: i };
  }
  countChar(e, r) {
    const n = r.length;
    let i = 0;
    for (let a = 0; a < n; ++a)
      r[a] === e && ++i;
    return i;
  }
  destructEndLink(e) {
    const r = e.trim();
    let n = r.slice(0, -1), i = "arrow_open";
    switch (r.slice(-1)) {
      case "x":
        i = "arrow_cross", r.startsWith("x") && (i = "double_" + i, n = n.slice(1));
        break;
      case ">":
        i = "arrow_point", r.startsWith("<") && (i = "double_" + i, n = n.slice(1));
        break;
      case "o":
        i = "arrow_circle", r.startsWith("o") && (i = "double_" + i, n = n.slice(1));
        break;
    }
    let a = "normal", s = n.length - 1;
    n.startsWith("=") && (a = "thick"), n.startsWith("~") && (a = "invisible");
    const o = this.countChar(".", n);
    return o && (a = "dotted", s = o), { type: i, stroke: a, length: s };
  }
  destructLink(e, r) {
    const n = this.destructEndLink(e);
    let i;
    if (r) {
      if (i = this.destructStartLink(r), i.stroke !== n.stroke)
        return { type: "INVALID", stroke: "INVALID" };
      if (i.type === "arrow_open")
        i.type = n.type;
      else {
        if (i.type !== n.type)
          return { type: "INVALID", stroke: "INVALID" };
        i.type = "double_" + i.type;
      }
      return i.type === "double_arrow" && (i.type = "double_arrow_point"), i.length = n.length, i;
    }
    return n;
  }
  // Todo optimizer this by caching existing nodes
  exists(e, r) {
    for (const n of e)
      if (n.nodes.includes(r))
        return !0;
    return !1;
  }
  /**
   * Deletes an id from all subgraphs
   *
   */
  makeUniq(e, r) {
    const n = [];
    return e.nodes.forEach((i, a) => {
      this.exists(r, i) || n.push(e.nodes[a]);
    }), { nodes: n };
  }
  getTypeFromVertex(e) {
    if (e.img)
      return "imageSquare";
    if (e.icon)
      return e.form === "circle" ? "iconCircle" : e.form === "square" ? "iconSquare" : e.form === "rounded" ? "iconRounded" : "icon";
    switch (e.type) {
      case "square":
      case void 0:
        return "squareRect";
      case "round":
        return "roundedRect";
      case "ellipse":
        return "ellipse";
      default:
        return e.type;
    }
  }
  findNode(e, r) {
    return e.find((n) => n.id === r);
  }
  destructEdgeType(e) {
    let r = "none", n = "arrow_point";
    switch (e) {
      case "arrow_point":
      case "arrow_circle":
      case "arrow_cross":
        n = e;
        break;
      case "double_arrow_point":
      case "double_arrow_circle":
      case "double_arrow_cross":
        r = e.replace("double_", ""), n = r;
        break;
    }
    return { arrowTypeStart: r, arrowTypeEnd: n };
  }
  addNodeFromVertex(e, r, n, i, a, s) {
    const o = n.get(e.id), l = i.get(e.id) ?? !1, u = this.findNode(r, e.id);
    if (u)
      u.cssStyles = e.styles, u.cssCompiledStyles = this.getCompiledStyles(e.classes), u.cssClasses = e.classes.join(" ");
    else {
      const h = {
        id: e.id,
        label: e.text,
        labelStyle: "",
        parentId: o,
        padding: a.flowchart?.padding || 8,
        cssStyles: e.styles,
        cssCompiledStyles: this.getCompiledStyles(["default", "node", ...e.classes]),
        cssClasses: "default " + e.classes.join(" "),
        dir: e.dir,
        domId: e.domId,
        look: s,
        link: e.link,
        linkTarget: e.linkTarget,
        tooltip: this.getTooltip(e.id),
        icon: e.icon,
        pos: e.pos,
        img: e.img,
        assetWidth: e.assetWidth,
        assetHeight: e.assetHeight,
        constraint: e.constraint
      };
      l ? r.push({
        ...h,
        isGroup: !0,
        shape: "rect"
      }) : r.push({
        ...h,
        isGroup: !1,
        shape: this.getTypeFromVertex(e)
      });
    }
  }
  getCompiledStyles(e) {
    let r = [];
    for (const n of e) {
      const i = this.classes.get(n);
      i?.styles && (r = [...r, ...i.styles ?? []].map((a) => a.trim())), i?.textStyles && (r = [...r, ...i.textStyles ?? []].map((a) => a.trim()));
    }
    return r;
  }
  getData() {
    const e = Te(), r = [], n = [], i = this.getSubGraphs(), a = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
    for (let u = i.length - 1; u >= 0; u--) {
      const h = i[u];
      h.nodes.length > 0 && s.set(h.id, !0);
      for (const f of h.nodes)
        a.set(f, h.id);
    }
    for (let u = i.length - 1; u >= 0; u--) {
      const h = i[u];
      r.push({
        id: h.id,
        label: h.title,
        labelStyle: "",
        parentId: a.get(h.id),
        padding: 8,
        cssCompiledStyles: this.getCompiledStyles(h.classes),
        cssClasses: h.classes.join(" "),
        shape: "rect",
        dir: h.dir,
        isGroup: !0,
        look: e.look
      });
    }
    this.getVertices().forEach((u) => {
      this.addNodeFromVertex(u, r, a, s, e, e.look || "classic");
    });
    const l = this.getEdges();
    return l.forEach((u, h) => {
      const { arrowTypeStart: f, arrowTypeEnd: d } = this.destructEdgeType(u.type), p = [...l.defaultStyle ?? []];
      u.style && p.push(...u.style);
      const g = {
        id: Nf(u.start, u.end, { counter: h, prefix: "L" }, u.id),
        isUserDefinedId: u.isUserDefinedId,
        start: u.start,
        end: u.end,
        type: u.type ?? "normal",
        label: u.text,
        labelpos: "c",
        thickness: u.stroke,
        minlen: u.length,
        classes: u?.stroke === "invisible" ? "" : "edge-thickness-normal edge-pattern-solid flowchart-link",
        arrowTypeStart: u?.stroke === "invisible" || u?.type === "arrow_open" ? "none" : f,
        arrowTypeEnd: u?.stroke === "invisible" || u?.type === "arrow_open" ? "none" : d,
        arrowheadStyle: "fill: #333",
        cssCompiledStyles: this.getCompiledStyles(u.classes),
        labelStyle: p,
        style: p,
        pattern: u.stroke,
        look: e.look,
        animate: u.animate,
        animation: u.animation,
        curve: u.interpolate || this.edges.defaultInterpolate || e.flowchart?.curve
      };
      n.push(g);
    }), { nodes: r, edges: n, other: {}, config: e };
  }
  defaultConfig() {
    return aX.flowchart;
  }
}, w(nd, "FlowDB"), nd), PPe = /* @__PURE__ */ w(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), $Pe = /* @__PURE__ */ w(async function(t, e, r, n) {
  ae.info("REF0:"), ae.info("Drawing state diagram (v2)", e);
  const { securityLevel: i, flowchart: a, layout: s } = Te();
  let o;
  i === "sandbox" && (o = Qe("#i" + e));
  const l = i === "sandbox" ? o.nodes()[0].contentDocument : document;
  ae.debug("Before getData: ");
  const u = n.db.getData();
  ae.debug("Data: ", u);
  const h = Y0(e, i), f = n.db.getDirection();
  u.type = n.type, u.layoutAlgorithm = om(s), u.layoutAlgorithm === "dagre" && s === "elk" && ae.warn(
    "flowchart-elk was moved to an external package in Mermaid v11. Please refer [release notes](https://github.com/mermaid-js/mermaid/releases/tag/v11.0.0) for more details. This diagram will be rendered using `dagre` layout as a fallback."
  ), u.direction = f, u.nodeSpacing = a?.nodeSpacing || 50, u.rankSpacing = a?.rankSpacing || 50, u.markers = ["point", "circle", "cross"], u.diagramId = e, ae.debug("REF1:", u), await I0(u, h);
  const d = u.config.flowchart?.diagramPadding ?? 8;
  Jt.insertTitle(
    h,
    "flowchartTitleText",
    a?.titleTopMargin || 0,
    n.db.getDiagramTitle()
  ), Oh(h, d, "flowchart", a?.useMaxWidth || !1);
  for (const p of u.nodes) {
    const g = Qe(`#${e} [id="${p.id}"]`);
    if (!g || !p.link)
      continue;
    const m = l.createElementNS("http://www.w3.org/2000/svg", "a");
    m.setAttributeNS("http://www.w3.org/2000/svg", "class", p.cssClasses), m.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), i === "sandbox" ? m.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : p.linkTarget && m.setAttributeNS("http://www.w3.org/2000/svg", "target", p.linkTarget);
    const v = g.insert(function() {
      return m;
    }, ":first-child"), y = g.select(".label-container");
    y && v.append(function() {
      return y.node();
    });
    const b = g.select(".label");
    b && v.append(function() {
      return b.node();
    });
  }
}, "draw"), BPe = {
  getClasses: PPe,
  draw: $Pe
}, DA = (function() {
  var t = /* @__PURE__ */ w(function(Sn, dt, wt, lt) {
    for (wt = wt || {}, lt = Sn.length; lt--; wt[Sn[lt]] = dt) ;
    return wt;
  }, "o"), e = [1, 4], r = [1, 3], n = [1, 5], i = [1, 8, 9, 10, 11, 27, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], a = [2, 2], s = [1, 13], o = [1, 14], l = [1, 15], u = [1, 16], h = [1, 23], f = [1, 25], d = [1, 26], p = [1, 27], g = [1, 49], m = [1, 48], v = [1, 29], y = [1, 30], b = [1, 31], x = [1, 32], T = [1, 33], E = [1, 44], A = [1, 46], S = [1, 42], k = [1, 47], _ = [1, 43], R = [1, 50], L = [1, 45], M = [1, 51], P = [1, 52], C = [1, 34], I = [1, 35], N = [1, 36], O = [1, 37], D = [1, 57], $ = [1, 8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], z = [1, 61], B = [1, 60], G = [1, 62], W = [8, 9, 11, 75, 77, 78], V = [1, 78], U = [1, 91], Z = [1, 96], K = [1, 95], ce = [1, 92], J = [1, 88], ee = [1, 94], j = [1, 90], X = [1, 97], re = [1, 93], Q = [1, 98], ue = [1, 89], ne = [8, 9, 10, 11, 40, 75, 77, 78], xe = [8, 9, 10, 11, 40, 46, 75, 77, 78], Y = [8, 9, 10, 11, 29, 40, 44, 46, 48, 50, 52, 54, 56, 58, 60, 63, 65, 67, 68, 70, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116], Ne = [8, 9, 11, 44, 60, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116], fe = [44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116], qe = [1, 121], ze = [1, 122], Ge = [1, 124], Ee = [1, 123], Oe = [44, 60, 62, 74, 89, 102, 105, 106, 109, 111, 114, 115, 116], Ce = [1, 133], Ae = [1, 147], $e = [1, 148], me = [1, 149], Ie = [1, 150], te = [1, 135], he = [1, 137], F = [1, 141], oe = [1, 142], se = [1, 143], ge = [1, 144], de = [1, 145], we = [1, 146], _e = [1, 151], Se = [1, 152], Me = [1, 131], Xe = [1, 132], We = [1, 139], Ke = [1, 134], Ze = [1, 138], Pe = [1, 136], Ve = [8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], ht = [1, 154], st = [1, 156], Ue = [8, 9, 11], Et = [8, 9, 10, 11, 14, 44, 60, 89, 105, 106, 109, 111, 114, 115, 116], He = [1, 176], rt = [1, 172], ct = [1, 173], ut = [1, 177], nt = [1, 174], bt = [1, 175], er = [77, 116, 119], Dt = [8, 9, 10, 11, 12, 14, 27, 29, 32, 44, 60, 75, 84, 85, 86, 87, 88, 89, 90, 105, 109, 111, 114, 115, 116], ir = [10, 106], wr = [31, 49, 51, 53, 55, 57, 62, 64, 66, 67, 69, 71, 116, 117, 118], ar = [1, 247], Wt = [1, 245], ur = [1, 249], cn = [1, 243], ft = [1, 244], ke = [1, 246], Je = [1, 248], xt = [1, 250], lr = [1, 268], Vr = [8, 9, 11, 106], hr = [8, 9, 10, 11, 60, 84, 105, 106, 109, 110, 111, 112], Kr = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, graphConfig: 4, document: 5, line: 6, statement: 7, SEMI: 8, NEWLINE: 9, SPACE: 10, EOF: 11, GRAPH: 12, NODIR: 13, DIR: 14, FirstStmtSeparator: 15, ending: 16, endToken: 17, spaceList: 18, spaceListNewline: 19, vertexStatement: 20, separator: 21, styleStatement: 22, linkStyleStatement: 23, classDefStatement: 24, classStatement: 25, clickStatement: 26, subgraph: 27, textNoTags: 28, SQS: 29, text: 30, SQE: 31, end: 32, direction: 33, acc_title: 34, acc_title_value: 35, acc_descr: 36, acc_descr_value: 37, acc_descr_multiline_value: 38, shapeData: 39, SHAPE_DATA: 40, link: 41, node: 42, styledVertex: 43, AMP: 44, vertex: 45, STYLE_SEPARATOR: 46, idString: 47, DOUBLECIRCLESTART: 48, DOUBLECIRCLEEND: 49, PS: 50, PE: 51, "(-": 52, "-)": 53, STADIUMSTART: 54, STADIUMEND: 55, SUBROUTINESTART: 56, SUBROUTINEEND: 57, VERTEX_WITH_PROPS_START: 58, "NODE_STRING[field]": 59, COLON: 60, "NODE_STRING[value]": 61, PIPE: 62, CYLINDERSTART: 63, CYLINDEREND: 64, DIAMOND_START: 65, DIAMOND_STOP: 66, TAGEND: 67, TRAPSTART: 68, TRAPEND: 69, INVTRAPSTART: 70, INVTRAPEND: 71, linkStatement: 72, arrowText: 73, TESTSTR: 74, START_LINK: 75, edgeText: 76, LINK: 77, LINK_ID: 78, edgeTextToken: 79, STR: 80, MD_STR: 81, textToken: 82, keywords: 83, STYLE: 84, LINKSTYLE: 85, CLASSDEF: 86, CLASS: 87, CLICK: 88, DOWN: 89, UP: 90, textNoTagsToken: 91, stylesOpt: 92, "idString[vertex]": 93, "idString[class]": 94, CALLBACKNAME: 95, CALLBACKARGS: 96, HREF: 97, LINK_TARGET: 98, "STR[link]": 99, "STR[tooltip]": 100, alphaNum: 101, DEFAULT: 102, numList: 103, INTERPOLATE: 104, NUM: 105, COMMA: 106, style: 107, styleComponent: 108, NODE_STRING: 109, UNIT: 110, BRKT: 111, PCT: 112, idStringToken: 113, MINUS: 114, MULT: 115, UNICODE_TEXT: 116, TEXT: 117, TAGSTART: 118, EDGE_TEXT: 119, alphaNumToken: 120, direction_tb: 121, direction_bt: 122, direction_rl: 123, direction_lr: 124, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 8: "SEMI", 9: "NEWLINE", 10: "SPACE", 11: "EOF", 12: "GRAPH", 13: "NODIR", 14: "DIR", 27: "subgraph", 29: "SQS", 31: "SQE", 32: "end", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 40: "SHAPE_DATA", 44: "AMP", 46: "STYLE_SEPARATOR", 48: "DOUBLECIRCLESTART", 49: "DOUBLECIRCLEEND", 50: "PS", 51: "PE", 52: "(-", 53: "-)", 54: "STADIUMSTART", 55: "STADIUMEND", 56: "SUBROUTINESTART", 57: "SUBROUTINEEND", 58: "VERTEX_WITH_PROPS_START", 59: "NODE_STRING[field]", 60: "COLON", 61: "NODE_STRING[value]", 62: "PIPE", 63: "CYLINDERSTART", 64: "CYLINDEREND", 65: "DIAMOND_START", 66: "DIAMOND_STOP", 67: "TAGEND", 68: "TRAPSTART", 69: "TRAPEND", 70: "INVTRAPSTART", 71: "INVTRAPEND", 74: "TESTSTR", 75: "START_LINK", 77: "LINK", 78: "LINK_ID", 80: "STR", 81: "MD_STR", 84: "STYLE", 85: "LINKSTYLE", 86: "CLASSDEF", 87: "CLASS", 88: "CLICK", 89: "DOWN", 90: "UP", 93: "idString[vertex]", 94: "idString[class]", 95: "CALLBACKNAME", 96: "CALLBACKARGS", 97: "HREF", 98: "LINK_TARGET", 99: "STR[link]", 100: "STR[tooltip]", 102: "DEFAULT", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "NODE_STRING", 110: "UNIT", 111: "BRKT", 112: "PCT", 114: "MINUS", 115: "MULT", 116: "UNICODE_TEXT", 117: "TEXT", 118: "TAGSTART", 119: "EDGE_TEXT", 121: "direction_tb", 122: "direction_bt", 123: "direction_rl", 124: "direction_lr" },
    productions_: [0, [3, 2], [5, 0], [5, 2], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [4, 2], [4, 2], [4, 2], [4, 3], [16, 2], [16, 1], [17, 1], [17, 1], [17, 1], [15, 1], [15, 1], [15, 2], [19, 2], [19, 2], [19, 1], [19, 1], [18, 2], [18, 1], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 9], [7, 6], [7, 4], [7, 1], [7, 2], [7, 2], [7, 1], [21, 1], [21, 1], [21, 1], [39, 2], [39, 1], [20, 4], [20, 3], [20, 4], [20, 2], [20, 2], [20, 1], [42, 1], [42, 6], [42, 5], [43, 1], [43, 3], [45, 4], [45, 4], [45, 6], [45, 4], [45, 4], [45, 4], [45, 8], [45, 4], [45, 4], [45, 4], [45, 6], [45, 4], [45, 4], [45, 4], [45, 4], [45, 4], [45, 1], [41, 2], [41, 3], [41, 3], [41, 1], [41, 3], [41, 4], [76, 1], [76, 2], [76, 1], [76, 1], [72, 1], [72, 2], [73, 3], [30, 1], [30, 2], [30, 1], [30, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [28, 1], [28, 2], [28, 1], [28, 1], [24, 5], [25, 5], [26, 2], [26, 4], [26, 3], [26, 5], [26, 3], [26, 5], [26, 5], [26, 7], [26, 2], [26, 4], [26, 2], [26, 4], [26, 4], [26, 6], [22, 5], [23, 5], [23, 5], [23, 9], [23, 9], [23, 7], [23, 7], [103, 1], [103, 3], [92, 1], [92, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [82, 1], [82, 1], [82, 1], [82, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [79, 1], [79, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [47, 1], [47, 2], [101, 1], [101, 2], [33, 1], [33, 1], [33, 1], [33, 1]],
    performAction: /* @__PURE__ */ w(function(dt, wt, lt, je, Qt, pe, Fl) {
      var ve = pe.length - 1;
      switch (Qt) {
        case 2:
          this.$ = [];
          break;
        case 3:
          (!Array.isArray(pe[ve]) || pe[ve].length > 0) && pe[ve - 1].push(pe[ve]), this.$ = pe[ve - 1];
          break;
        case 4:
        case 183:
          this.$ = pe[ve];
          break;
        case 11:
          je.setDirection("TB"), this.$ = "TB";
          break;
        case 12:
          je.setDirection(pe[ve - 1]), this.$ = pe[ve - 1];
          break;
        case 27:
          this.$ = pe[ve - 1].nodes;
          break;
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
          this.$ = [];
          break;
        case 33:
          this.$ = je.addSubGraph(pe[ve - 6], pe[ve - 1], pe[ve - 4]);
          break;
        case 34:
          this.$ = je.addSubGraph(pe[ve - 3], pe[ve - 1], pe[ve - 3]);
          break;
        case 35:
          this.$ = je.addSubGraph(void 0, pe[ve - 1], void 0);
          break;
        case 37:
          this.$ = pe[ve].trim(), je.setAccTitle(this.$);
          break;
        case 38:
        case 39:
          this.$ = pe[ve].trim(), je.setAccDescription(this.$);
          break;
        case 43:
          this.$ = pe[ve - 1] + pe[ve];
          break;
        case 44:
          this.$ = pe[ve];
          break;
        case 45:
          je.addVertex(pe[ve - 1][pe[ve - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, pe[ve]), je.addLink(pe[ve - 3].stmt, pe[ve - 1], pe[ve - 2]), this.$ = { stmt: pe[ve - 1], nodes: pe[ve - 1].concat(pe[ve - 3].nodes) };
          break;
        case 46:
          je.addLink(pe[ve - 2].stmt, pe[ve], pe[ve - 1]), this.$ = { stmt: pe[ve], nodes: pe[ve].concat(pe[ve - 2].nodes) };
          break;
        case 47:
          je.addLink(pe[ve - 3].stmt, pe[ve - 1], pe[ve - 2]), this.$ = { stmt: pe[ve - 1], nodes: pe[ve - 1].concat(pe[ve - 3].nodes) };
          break;
        case 48:
          this.$ = { stmt: pe[ve - 1], nodes: pe[ve - 1] };
          break;
        case 49:
          je.addVertex(pe[ve - 1][pe[ve - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, pe[ve]), this.$ = { stmt: pe[ve - 1], nodes: pe[ve - 1], shapeData: pe[ve] };
          break;
        case 50:
          this.$ = { stmt: pe[ve], nodes: pe[ve] };
          break;
        case 51:
          this.$ = [pe[ve]];
          break;
        case 52:
          je.addVertex(pe[ve - 5][pe[ve - 5].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, pe[ve - 4]), this.$ = pe[ve - 5].concat(pe[ve]);
          break;
        case 53:
          this.$ = pe[ve - 4].concat(pe[ve]);
          break;
        case 54:
          this.$ = pe[ve];
          break;
        case 55:
          this.$ = pe[ve - 2], je.setClass(pe[ve - 2], pe[ve]);
          break;
        case 56:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "square");
          break;
        case 57:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "doublecircle");
          break;
        case 58:
          this.$ = pe[ve - 5], je.addVertex(pe[ve - 5], pe[ve - 2], "circle");
          break;
        case 59:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "ellipse");
          break;
        case 60:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "stadium");
          break;
        case 61:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "subroutine");
          break;
        case 62:
          this.$ = pe[ve - 7], je.addVertex(pe[ve - 7], pe[ve - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[pe[ve - 5], pe[ve - 3]]]));
          break;
        case 63:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "cylinder");
          break;
        case 64:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "round");
          break;
        case 65:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "diamond");
          break;
        case 66:
          this.$ = pe[ve - 5], je.addVertex(pe[ve - 5], pe[ve - 2], "hexagon");
          break;
        case 67:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "odd");
          break;
        case 68:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "trapezoid");
          break;
        case 69:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "inv_trapezoid");
          break;
        case 70:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "lean_right");
          break;
        case 71:
          this.$ = pe[ve - 3], je.addVertex(pe[ve - 3], pe[ve - 1], "lean_left");
          break;
        case 72:
          this.$ = pe[ve], je.addVertex(pe[ve]);
          break;
        case 73:
          pe[ve - 1].text = pe[ve], this.$ = pe[ve - 1];
          break;
        case 74:
        case 75:
          pe[ve - 2].text = pe[ve - 1], this.$ = pe[ve - 2];
          break;
        case 76:
          this.$ = pe[ve];
          break;
        case 77:
          var Tr = je.destructLink(pe[ve], pe[ve - 2]);
          this.$ = { type: Tr.type, stroke: Tr.stroke, length: Tr.length, text: pe[ve - 1] };
          break;
        case 78:
          var Tr = je.destructLink(pe[ve], pe[ve - 2]);
          this.$ = { type: Tr.type, stroke: Tr.stroke, length: Tr.length, text: pe[ve - 1], id: pe[ve - 3] };
          break;
        case 79:
          this.$ = { text: pe[ve], type: "text" };
          break;
        case 80:
          this.$ = { text: pe[ve - 1].text + "" + pe[ve], type: pe[ve - 1].type };
          break;
        case 81:
          this.$ = { text: pe[ve], type: "string" };
          break;
        case 82:
          this.$ = { text: pe[ve], type: "markdown" };
          break;
        case 83:
          var Tr = je.destructLink(pe[ve]);
          this.$ = { type: Tr.type, stroke: Tr.stroke, length: Tr.length };
          break;
        case 84:
          var Tr = je.destructLink(pe[ve]);
          this.$ = { type: Tr.type, stroke: Tr.stroke, length: Tr.length, id: pe[ve - 1] };
          break;
        case 85:
          this.$ = pe[ve - 1];
          break;
        case 86:
          this.$ = { text: pe[ve], type: "text" };
          break;
        case 87:
          this.$ = { text: pe[ve - 1].text + "" + pe[ve], type: pe[ve - 1].type };
          break;
        case 88:
          this.$ = { text: pe[ve], type: "string" };
          break;
        case 89:
        case 104:
          this.$ = { text: pe[ve], type: "markdown" };
          break;
        case 101:
          this.$ = { text: pe[ve], type: "text" };
          break;
        case 102:
          this.$ = { text: pe[ve - 1].text + "" + pe[ve], type: pe[ve - 1].type };
          break;
        case 103:
          this.$ = { text: pe[ve], type: "text" };
          break;
        case 105:
          this.$ = pe[ve - 4], je.addClass(pe[ve - 2], pe[ve]);
          break;
        case 106:
          this.$ = pe[ve - 4], je.setClass(pe[ve - 2], pe[ve]);
          break;
        case 107:
        case 115:
          this.$ = pe[ve - 1], je.setClickEvent(pe[ve - 1], pe[ve]);
          break;
        case 108:
        case 116:
          this.$ = pe[ve - 3], je.setClickEvent(pe[ve - 3], pe[ve - 2]), je.setTooltip(pe[ve - 3], pe[ve]);
          break;
        case 109:
          this.$ = pe[ve - 2], je.setClickEvent(pe[ve - 2], pe[ve - 1], pe[ve]);
          break;
        case 110:
          this.$ = pe[ve - 4], je.setClickEvent(pe[ve - 4], pe[ve - 3], pe[ve - 2]), je.setTooltip(pe[ve - 4], pe[ve]);
          break;
        case 111:
          this.$ = pe[ve - 2], je.setLink(pe[ve - 2], pe[ve]);
          break;
        case 112:
          this.$ = pe[ve - 4], je.setLink(pe[ve - 4], pe[ve - 2]), je.setTooltip(pe[ve - 4], pe[ve]);
          break;
        case 113:
          this.$ = pe[ve - 4], je.setLink(pe[ve - 4], pe[ve - 2], pe[ve]);
          break;
        case 114:
          this.$ = pe[ve - 6], je.setLink(pe[ve - 6], pe[ve - 4], pe[ve]), je.setTooltip(pe[ve - 6], pe[ve - 2]);
          break;
        case 117:
          this.$ = pe[ve - 1], je.setLink(pe[ve - 1], pe[ve]);
          break;
        case 118:
          this.$ = pe[ve - 3], je.setLink(pe[ve - 3], pe[ve - 2]), je.setTooltip(pe[ve - 3], pe[ve]);
          break;
        case 119:
          this.$ = pe[ve - 3], je.setLink(pe[ve - 3], pe[ve - 2], pe[ve]);
          break;
        case 120:
          this.$ = pe[ve - 5], je.setLink(pe[ve - 5], pe[ve - 4], pe[ve]), je.setTooltip(pe[ve - 5], pe[ve - 2]);
          break;
        case 121:
          this.$ = pe[ve - 4], je.addVertex(pe[ve - 2], void 0, void 0, pe[ve]);
          break;
        case 122:
          this.$ = pe[ve - 4], je.updateLink([pe[ve - 2]], pe[ve]);
          break;
        case 123:
          this.$ = pe[ve - 4], je.updateLink(pe[ve - 2], pe[ve]);
          break;
        case 124:
          this.$ = pe[ve - 8], je.updateLinkInterpolate([pe[ve - 6]], pe[ve - 2]), je.updateLink([pe[ve - 6]], pe[ve]);
          break;
        case 125:
          this.$ = pe[ve - 8], je.updateLinkInterpolate(pe[ve - 6], pe[ve - 2]), je.updateLink(pe[ve - 6], pe[ve]);
          break;
        case 126:
          this.$ = pe[ve - 6], je.updateLinkInterpolate([pe[ve - 4]], pe[ve]);
          break;
        case 127:
          this.$ = pe[ve - 6], je.updateLinkInterpolate(pe[ve - 4], pe[ve]);
          break;
        case 128:
        case 130:
          this.$ = [pe[ve]];
          break;
        case 129:
        case 131:
          pe[ve - 2].push(pe[ve]), this.$ = pe[ve - 2];
          break;
        case 133:
          this.$ = pe[ve - 1] + pe[ve];
          break;
        case 181:
          this.$ = pe[ve];
          break;
        case 182:
          this.$ = pe[ve - 1] + "" + pe[ve];
          break;
        case 184:
          this.$ = pe[ve - 1] + "" + pe[ve];
          break;
        case 185:
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 186:
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 187:
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 188:
          this.$ = { stmt: "dir", value: "LR" };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 9: e, 10: r, 12: n }, { 1: [3] }, t(i, a, { 5: 6 }), { 4: 7, 9: e, 10: r, 12: n }, { 4: 8, 9: e, 10: r, 12: n }, { 13: [1, 9], 14: [1, 10] }, { 1: [2, 1], 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 33: 24, 34: f, 36: d, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: x, 88: T, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P, 121: C, 122: I, 123: N, 124: O }, t(i, [2, 9]), t(i, [2, 10]), t(i, [2, 11]), { 8: [1, 54], 9: [1, 55], 10: D, 15: 53, 18: 56 }, t($, [2, 3]), t($, [2, 4]), t($, [2, 5]), t($, [2, 6]), t($, [2, 7]), t($, [2, 8]), { 8: z, 9: B, 11: G, 21: 58, 41: 59, 72: 63, 75: [1, 64], 77: [1, 66], 78: [1, 65] }, { 8: z, 9: B, 11: G, 21: 67 }, { 8: z, 9: B, 11: G, 21: 68 }, { 8: z, 9: B, 11: G, 21: 69 }, { 8: z, 9: B, 11: G, 21: 70 }, { 8: z, 9: B, 11: G, 21: 71 }, { 8: z, 9: B, 10: [1, 72], 11: G, 21: 73 }, t($, [2, 36]), { 35: [1, 74] }, { 37: [1, 75] }, t($, [2, 39]), t(W, [2, 50], { 18: 76, 39: 77, 10: D, 40: V }), { 10: [1, 79] }, { 10: [1, 80] }, { 10: [1, 81] }, { 10: [1, 82] }, { 14: U, 44: Z, 60: K, 80: [1, 86], 89: ce, 95: [1, 83], 97: [1, 84], 101: 85, 105: J, 106: ee, 109: j, 111: X, 114: re, 115: Q, 116: ue, 120: 87 }, t($, [2, 185]), t($, [2, 186]), t($, [2, 187]), t($, [2, 188]), t(ne, [2, 51]), t(ne, [2, 54], { 46: [1, 99] }), t(xe, [2, 72], { 113: 112, 29: [1, 100], 44: g, 48: [1, 101], 50: [1, 102], 52: [1, 103], 54: [1, 104], 56: [1, 105], 58: [1, 106], 60: m, 63: [1, 107], 65: [1, 108], 67: [1, 109], 68: [1, 110], 70: [1, 111], 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 114: L, 115: M, 116: P }), t(Y, [2, 181]), t(Y, [2, 142]), t(Y, [2, 143]), t(Y, [2, 144]), t(Y, [2, 145]), t(Y, [2, 146]), t(Y, [2, 147]), t(Y, [2, 148]), t(Y, [2, 149]), t(Y, [2, 150]), t(Y, [2, 151]), t(Y, [2, 152]), t(i, [2, 12]), t(i, [2, 18]), t(i, [2, 19]), { 9: [1, 113] }, t(Ne, [2, 26], { 18: 114, 10: D }), t($, [2, 27]), { 42: 115, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, t($, [2, 40]), t($, [2, 41]), t($, [2, 42]), t(fe, [2, 76], { 73: 116, 62: [1, 118], 74: [1, 117] }), { 76: 119, 79: 120, 80: qe, 81: ze, 116: Ge, 119: Ee }, { 75: [1, 125], 77: [1, 126] }, t(Oe, [2, 83]), t($, [2, 28]), t($, [2, 29]), t($, [2, 30]), t($, [2, 31]), t($, [2, 32]), { 10: Ce, 12: Ae, 14: $e, 27: me, 28: 127, 32: Ie, 44: te, 60: he, 75: F, 80: [1, 129], 81: [1, 130], 83: 140, 84: oe, 85: se, 86: ge, 87: de, 88: we, 89: _e, 90: Se, 91: 128, 105: Me, 109: Xe, 111: We, 114: Ke, 115: Ze, 116: Pe }, t(Ve, a, { 5: 153 }), t($, [2, 37]), t($, [2, 38]), t(W, [2, 48], { 44: ht }), t(W, [2, 49], { 18: 155, 10: D, 40: st }), t(ne, [2, 44]), { 44: g, 47: 157, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, { 102: [1, 158], 103: 159, 105: [1, 160] }, { 44: g, 47: 161, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, { 44: g, 47: 162, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, t(Ue, [2, 107], { 10: [1, 163], 96: [1, 164] }), { 80: [1, 165] }, t(Ue, [2, 115], { 120: 167, 10: [1, 166], 14: U, 44: Z, 60: K, 89: ce, 105: J, 106: ee, 109: j, 111: X, 114: re, 115: Q, 116: ue }), t(Ue, [2, 117], { 10: [1, 168] }), t(Et, [2, 183]), t(Et, [2, 170]), t(Et, [2, 171]), t(Et, [2, 172]), t(Et, [2, 173]), t(Et, [2, 174]), t(Et, [2, 175]), t(Et, [2, 176]), t(Et, [2, 177]), t(Et, [2, 178]), t(Et, [2, 179]), t(Et, [2, 180]), { 44: g, 47: 169, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, { 30: 170, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 178, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 180, 50: [1, 179], 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 181, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 182, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 183, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 109: [1, 184] }, { 30: 185, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 186, 65: [1, 187], 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 188, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 189, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 30: 190, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, t(Y, [2, 182]), t(i, [2, 20]), t(Ne, [2, 25]), t(W, [2, 46], { 39: 191, 18: 192, 10: D, 40: V }), t(fe, [2, 73], { 10: [1, 193] }), { 10: [1, 194] }, { 30: 195, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 77: [1, 196], 79: 197, 116: Ge, 119: Ee }, t(er, [2, 79]), t(er, [2, 81]), t(er, [2, 82]), t(er, [2, 168]), t(er, [2, 169]), { 76: 198, 79: 120, 80: qe, 81: ze, 116: Ge, 119: Ee }, t(Oe, [2, 84]), { 8: z, 9: B, 10: Ce, 11: G, 12: Ae, 14: $e, 21: 200, 27: me, 29: [1, 199], 32: Ie, 44: te, 60: he, 75: F, 83: 140, 84: oe, 85: se, 86: ge, 87: de, 88: we, 89: _e, 90: Se, 91: 201, 105: Me, 109: Xe, 111: We, 114: Ke, 115: Ze, 116: Pe }, t(Dt, [2, 101]), t(Dt, [2, 103]), t(Dt, [2, 104]), t(Dt, [2, 157]), t(Dt, [2, 158]), t(Dt, [2, 159]), t(Dt, [2, 160]), t(Dt, [2, 161]), t(Dt, [2, 162]), t(Dt, [2, 163]), t(Dt, [2, 164]), t(Dt, [2, 165]), t(Dt, [2, 166]), t(Dt, [2, 167]), t(Dt, [2, 90]), t(Dt, [2, 91]), t(Dt, [2, 92]), t(Dt, [2, 93]), t(Dt, [2, 94]), t(Dt, [2, 95]), t(Dt, [2, 96]), t(Dt, [2, 97]), t(Dt, [2, 98]), t(Dt, [2, 99]), t(Dt, [2, 100]), { 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 32: [1, 202], 33: 24, 34: f, 36: d, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: x, 88: T, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P, 121: C, 122: I, 123: N, 124: O }, { 10: D, 18: 203 }, { 44: [1, 204] }, t(ne, [2, 43]), { 10: [1, 205], 44: g, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 112, 114: L, 115: M, 116: P }, { 10: [1, 206] }, { 10: [1, 207], 106: [1, 208] }, t(ir, [2, 128]), { 10: [1, 209], 44: g, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 112, 114: L, 115: M, 116: P }, { 10: [1, 210], 44: g, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 112, 114: L, 115: M, 116: P }, { 80: [1, 211] }, t(Ue, [2, 109], { 10: [1, 212] }), t(Ue, [2, 111], { 10: [1, 213] }), { 80: [1, 214] }, t(Et, [2, 184]), { 80: [1, 215], 98: [1, 216] }, t(ne, [2, 55], { 113: 112, 44: g, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 114: L, 115: M, 116: P }), { 31: [1, 217], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, t(wr, [2, 86]), t(wr, [2, 88]), t(wr, [2, 89]), t(wr, [2, 153]), t(wr, [2, 154]), t(wr, [2, 155]), t(wr, [2, 156]), { 49: [1, 219], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 30: 220, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 51: [1, 221], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 53: [1, 222], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 55: [1, 223], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 57: [1, 224], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 60: [1, 225] }, { 64: [1, 226], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 66: [1, 227], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 30: 228, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, { 31: [1, 229], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 67: He, 69: [1, 230], 71: [1, 231], 82: 218, 116: ut, 117: nt, 118: bt }, { 67: He, 69: [1, 233], 71: [1, 232], 82: 218, 116: ut, 117: nt, 118: bt }, t(W, [2, 45], { 18: 155, 10: D, 40: st }), t(W, [2, 47], { 44: ht }), t(fe, [2, 75]), t(fe, [2, 74]), { 62: [1, 234], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, t(fe, [2, 77]), t(er, [2, 80]), { 77: [1, 235], 79: 197, 116: Ge, 119: Ee }, { 30: 236, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, t(Ve, a, { 5: 237 }), t(Dt, [2, 102]), t($, [2, 35]), { 43: 238, 44: g, 45: 39, 47: 40, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, { 10: D, 18: 239 }, { 10: ar, 60: Wt, 84: ur, 92: 240, 105: cn, 107: 241, 108: 242, 109: ft, 110: ke, 111: Je, 112: xt }, { 10: ar, 60: Wt, 84: ur, 92: 251, 104: [1, 252], 105: cn, 107: 241, 108: 242, 109: ft, 110: ke, 111: Je, 112: xt }, { 10: ar, 60: Wt, 84: ur, 92: 253, 104: [1, 254], 105: cn, 107: 241, 108: 242, 109: ft, 110: ke, 111: Je, 112: xt }, { 105: [1, 255] }, { 10: ar, 60: Wt, 84: ur, 92: 256, 105: cn, 107: 241, 108: 242, 109: ft, 110: ke, 111: Je, 112: xt }, { 44: g, 47: 257, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, t(Ue, [2, 108]), { 80: [1, 258] }, { 80: [1, 259], 98: [1, 260] }, t(Ue, [2, 116]), t(Ue, [2, 118], { 10: [1, 261] }), t(Ue, [2, 119]), t(xe, [2, 56]), t(wr, [2, 87]), t(xe, [2, 57]), { 51: [1, 262], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, t(xe, [2, 64]), t(xe, [2, 59]), t(xe, [2, 60]), t(xe, [2, 61]), { 109: [1, 263] }, t(xe, [2, 63]), t(xe, [2, 65]), { 66: [1, 264], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, t(xe, [2, 67]), t(xe, [2, 68]), t(xe, [2, 70]), t(xe, [2, 69]), t(xe, [2, 71]), t([10, 44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116], [2, 85]), t(fe, [2, 78]), { 31: [1, 265], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 32: [1, 266], 33: 24, 34: f, 36: d, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: x, 88: T, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P, 121: C, 122: I, 123: N, 124: O }, t(ne, [2, 53]), { 43: 267, 44: g, 45: 39, 47: 40, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P }, t(Ue, [2, 121], { 106: lr }), t(Vr, [2, 130], { 108: 269, 10: ar, 60: Wt, 84: ur, 105: cn, 109: ft, 110: ke, 111: Je, 112: xt }), t(hr, [2, 132]), t(hr, [2, 134]), t(hr, [2, 135]), t(hr, [2, 136]), t(hr, [2, 137]), t(hr, [2, 138]), t(hr, [2, 139]), t(hr, [2, 140]), t(hr, [2, 141]), t(Ue, [2, 122], { 106: lr }), { 10: [1, 270] }, t(Ue, [2, 123], { 106: lr }), { 10: [1, 271] }, t(ir, [2, 129]), t(Ue, [2, 105], { 106: lr }), t(Ue, [2, 106], { 113: 112, 44: g, 60: m, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 114: L, 115: M, 116: P }), t(Ue, [2, 110]), t(Ue, [2, 112], { 10: [1, 272] }), t(Ue, [2, 113]), { 98: [1, 273] }, { 51: [1, 274] }, { 62: [1, 275] }, { 66: [1, 276] }, { 8: z, 9: B, 11: G, 21: 277 }, t($, [2, 34]), t(ne, [2, 52]), { 10: ar, 60: Wt, 84: ur, 105: cn, 107: 278, 108: 242, 109: ft, 110: ke, 111: Je, 112: xt }, t(hr, [2, 133]), { 14: U, 44: Z, 60: K, 89: ce, 101: 279, 105: J, 106: ee, 109: j, 111: X, 114: re, 115: Q, 116: ue, 120: 87 }, { 14: U, 44: Z, 60: K, 89: ce, 101: 280, 105: J, 106: ee, 109: j, 111: X, 114: re, 115: Q, 116: ue, 120: 87 }, { 98: [1, 281] }, t(Ue, [2, 120]), t(xe, [2, 58]), { 30: 282, 67: He, 80: rt, 81: ct, 82: 171, 116: ut, 117: nt, 118: bt }, t(xe, [2, 66]), t(Ve, a, { 5: 283 }), t(Vr, [2, 131], { 108: 269, 10: ar, 60: Wt, 84: ur, 105: cn, 109: ft, 110: ke, 111: Je, 112: xt }), t(Ue, [2, 126], { 120: 167, 10: [1, 284], 14: U, 44: Z, 60: K, 89: ce, 105: J, 106: ee, 109: j, 111: X, 114: re, 115: Q, 116: ue }), t(Ue, [2, 127], { 120: 167, 10: [1, 285], 14: U, 44: Z, 60: K, 89: ce, 105: J, 106: ee, 109: j, 111: X, 114: re, 115: Q, 116: ue }), t(Ue, [2, 114]), { 31: [1, 286], 67: He, 82: 218, 116: ut, 117: nt, 118: bt }, { 6: 11, 7: 12, 8: s, 9: o, 10: l, 11: u, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: h, 32: [1, 287], 33: 24, 34: f, 36: d, 38: p, 42: 28, 43: 38, 44: g, 45: 39, 47: 40, 60: m, 84: v, 85: y, 86: b, 87: x, 88: T, 89: E, 102: A, 105: S, 106: k, 109: _, 111: R, 113: 41, 114: L, 115: M, 116: P, 121: C, 122: I, 123: N, 124: O }, { 10: ar, 60: Wt, 84: ur, 92: 288, 105: cn, 107: 241, 108: 242, 109: ft, 110: ke, 111: Je, 112: xt }, { 10: ar, 60: Wt, 84: ur, 92: 289, 105: cn, 107: 241, 108: 242, 109: ft, 110: ke, 111: Je, 112: xt }, t(xe, [2, 62]), t($, [2, 33]), t(Ue, [2, 124], { 106: lr }), t(Ue, [2, 125], { 106: lr })],
    defaultActions: {},
    parseError: /* @__PURE__ */ w(function(dt, wt) {
      if (wt.recoverable)
        this.trace(dt);
      else {
        var lt = new Error(dt);
        throw lt.hash = wt, lt;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(dt) {
      var wt = this, lt = [0], je = [], Qt = [null], pe = [], Fl = this.table, ve = "", Tr = 0, jm = 0, wM = 2, Km = 1, dhe = pe.slice.call(arguments, 1), Kn = Object.create(this.lexer), au = { yy: {} };
      for (var s5 in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, s5) && (au.yy[s5] = this.yy[s5]);
      Kn.setInput(dt, au.yy), au.yy.lexer = Kn, au.yy.parser = this, typeof Kn.yylloc > "u" && (Kn.yylloc = {});
      var o5 = Kn.yylloc;
      pe.push(o5);
      var phe = Kn.options && Kn.options.ranges;
      typeof au.yy.parseError == "function" ? this.parseError = au.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ghe(xa) {
        lt.length = lt.length - 2 * xa, Qt.length = Qt.length - xa, pe.length = pe.length - xa;
      }
      w(ghe, "popStack");
      function TM() {
        var xa;
        return xa = je.pop() || Kn.lex() || Km, typeof xa != "number" && (xa instanceof Array && (je = xa, xa = je.pop()), xa = wt.symbols_[xa] || xa), xa;
      }
      w(TM, "lex");
      for (var ta, su, Fa, l5, Kh = {}, Zm, Oo, EM, Qm; ; ) {
        if (su = lt[lt.length - 1], this.defaultActions[su] ? Fa = this.defaultActions[su] : ((ta === null || typeof ta > "u") && (ta = TM()), Fa = Fl[su] && Fl[su][ta]), typeof Fa > "u" || !Fa.length || !Fa[0]) {
          var c5 = "";
          Qm = [];
          for (Zm in Fl[su])
            this.terminals_[Zm] && Zm > wM && Qm.push("'" + this.terminals_[Zm] + "'");
          Kn.showPosition ? c5 = "Parse error on line " + (Tr + 1) + `:
` + Kn.showPosition() + `
Expecting ` + Qm.join(", ") + ", got '" + (this.terminals_[ta] || ta) + "'" : c5 = "Parse error on line " + (Tr + 1) + ": Unexpected " + (ta == Km ? "end of input" : "'" + (this.terminals_[ta] || ta) + "'"), this.parseError(c5, {
            text: Kn.match,
            token: this.terminals_[ta] || ta,
            line: Kn.yylineno,
            loc: o5,
            expected: Qm
          });
        }
        if (Fa[0] instanceof Array && Fa.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + su + ", token: " + ta);
        switch (Fa[0]) {
          case 1:
            lt.push(ta), Qt.push(Kn.yytext), pe.push(Kn.yylloc), lt.push(Fa[1]), ta = null, jm = Kn.yyleng, ve = Kn.yytext, Tr = Kn.yylineno, o5 = Kn.yylloc;
            break;
          case 2:
            if (Oo = this.productions_[Fa[1]][1], Kh.$ = Qt[Qt.length - Oo], Kh._$ = {
              first_line: pe[pe.length - (Oo || 1)].first_line,
              last_line: pe[pe.length - 1].last_line,
              first_column: pe[pe.length - (Oo || 1)].first_column,
              last_column: pe[pe.length - 1].last_column
            }, phe && (Kh._$.range = [
              pe[pe.length - (Oo || 1)].range[0],
              pe[pe.length - 1].range[1]
            ]), l5 = this.performAction.apply(Kh, [
              ve,
              jm,
              Tr,
              au.yy,
              Fa[1],
              Qt,
              pe
            ].concat(dhe)), typeof l5 < "u")
              return l5;
            Oo && (lt = lt.slice(0, -1 * Oo * 2), Qt = Qt.slice(0, -1 * Oo), pe = pe.slice(0, -1 * Oo)), lt.push(this.productions_[Fa[1]][0]), Qt.push(Kh.$), pe.push(Kh._$), EM = Fl[lt[lt.length - 2]][lt[lt.length - 1]], lt.push(EM);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, bi = /* @__PURE__ */ (function() {
    var Sn = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(wt, lt) {
        if (this.yy.parser)
          this.yy.parser.parseError(wt, lt);
        else
          throw new Error(wt);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(dt, wt) {
        return this.yy = wt || this.yy || {}, this._input = dt, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var dt = this._input[0];
        this.yytext += dt, this.yyleng++, this.offset++, this.match += dt, this.matched += dt;
        var wt = dt.match(/(?:\r\n?|\n).*/g);
        return wt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), dt;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(dt) {
        var wt = dt.length, lt = dt.split(/(?:\r\n?|\n)/g);
        this._input = dt + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - wt), this.offset -= wt;
        var je = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), lt.length - 1 && (this.yylineno -= lt.length - 1);
        var Qt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lt ? (lt.length === je.length ? this.yylloc.first_column : 0) + je[je.length - lt.length].length - lt[0].length : this.yylloc.first_column - wt
        }, this.options.ranges && (this.yylloc.range = [Qt[0], Qt[0] + this.yyleng - wt]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(dt) {
        this.unput(this.match.slice(dt));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var dt = this.matched.substr(0, this.matched.length - this.match.length);
        return (dt.length > 20 ? "..." : "") + dt.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var dt = this.match;
        return dt.length < 20 && (dt += this._input.substr(0, 20 - dt.length)), (dt.substr(0, 20) + (dt.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var dt = this.pastInput(), wt = new Array(dt.length + 1).join("-");
        return dt + this.upcomingInput() + `
` + wt + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(dt, wt) {
        var lt, je, Qt;
        if (this.options.backtrack_lexer && (Qt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Qt.yylloc.range = this.yylloc.range.slice(0))), je = dt[0].match(/(?:\r\n?|\n).*/g), je && (this.yylineno += je.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: je ? je[je.length - 1].length - je[je.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + dt[0].length
        }, this.yytext += dt[0], this.match += dt[0], this.matches = dt, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(dt[0].length), this.matched += dt[0], lt = this.performAction.call(this, this.yy, this, wt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), lt)
          return lt;
        if (this._backtrack) {
          for (var pe in Qt)
            this[pe] = Qt[pe];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var dt, wt, lt, je;
        this._more || (this.yytext = "", this.match = "");
        for (var Qt = this._currentRules(), pe = 0; pe < Qt.length; pe++)
          if (lt = this._input.match(this.rules[Qt[pe]]), lt && (!wt || lt[0].length > wt[0].length)) {
            if (wt = lt, je = pe, this.options.backtrack_lexer) {
              if (dt = this.test_match(lt, Qt[pe]), dt !== !1)
                return dt;
              if (this._backtrack) {
                wt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return wt ? (dt = this.test_match(wt, Qt[je]), dt !== !1 ? dt : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var wt = this.next();
        return wt || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(wt) {
        this.conditionStack.push(wt);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var wt = this.conditionStack.length - 1;
        return wt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(wt) {
        return wt = this.conditionStack.length - 1 - Math.abs(wt || 0), wt >= 0 ? this.conditionStack[wt] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(wt) {
        this.begin(wt);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ w(function(wt, lt, je, Qt) {
        switch (je) {
          case 0:
            return this.begin("acc_title"), 34;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 36;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return this.pushState("shapeData"), lt.yytext = "", 40;
          case 8:
            return this.pushState("shapeDataStr"), 40;
          case 9:
            return this.popState(), 40;
          case 10:
            const pe = /\n\s*/g;
            return lt.yytext = lt.yytext.replace(pe, "<br/>"), 40;
          case 11:
            return 40;
          case 12:
            this.popState();
            break;
          case 13:
            this.begin("callbackname");
            break;
          case 14:
            this.popState();
            break;
          case 15:
            this.popState(), this.begin("callbackargs");
            break;
          case 16:
            return 95;
          case 17:
            this.popState();
            break;
          case 18:
            return 96;
          case 19:
            return "MD_STR";
          case 20:
            this.popState();
            break;
          case 21:
            this.begin("md_string");
            break;
          case 22:
            return "STR";
          case 23:
            this.popState();
            break;
          case 24:
            this.pushState("string");
            break;
          case 25:
            return 84;
          case 26:
            return 102;
          case 27:
            return 85;
          case 28:
            return 104;
          case 29:
            return 86;
          case 30:
            return 87;
          case 31:
            return 97;
          case 32:
            this.begin("click");
            break;
          case 33:
            this.popState();
            break;
          case 34:
            return 88;
          case 35:
            return wt.lex.firstGraph() && this.begin("dir"), 12;
          case 36:
            return wt.lex.firstGraph() && this.begin("dir"), 12;
          case 37:
            return wt.lex.firstGraph() && this.begin("dir"), 12;
          case 38:
            return 27;
          case 39:
            return 32;
          case 40:
            return 98;
          case 41:
            return 98;
          case 42:
            return 98;
          case 43:
            return 98;
          case 44:
            return this.popState(), 13;
          case 45:
            return this.popState(), 14;
          case 46:
            return this.popState(), 14;
          case 47:
            return this.popState(), 14;
          case 48:
            return this.popState(), 14;
          case 49:
            return this.popState(), 14;
          case 50:
            return this.popState(), 14;
          case 51:
            return this.popState(), 14;
          case 52:
            return this.popState(), 14;
          case 53:
            return this.popState(), 14;
          case 54:
            return this.popState(), 14;
          case 55:
            return 121;
          case 56:
            return 122;
          case 57:
            return 123;
          case 58:
            return 124;
          case 59:
            return 78;
          case 60:
            return 105;
          case 61:
            return 111;
          case 62:
            return 46;
          case 63:
            return 60;
          case 64:
            return 44;
          case 65:
            return 8;
          case 66:
            return 106;
          case 67:
            return 115;
          case 68:
            return this.popState(), 77;
          case 69:
            return this.pushState("edgeText"), 75;
          case 70:
            return 119;
          case 71:
            return this.popState(), 77;
          case 72:
            return this.pushState("thickEdgeText"), 75;
          case 73:
            return 119;
          case 74:
            return this.popState(), 77;
          case 75:
            return this.pushState("dottedEdgeText"), 75;
          case 76:
            return 119;
          case 77:
            return 77;
          case 78:
            return this.popState(), 53;
          case 79:
            return "TEXT";
          case 80:
            return this.pushState("ellipseText"), 52;
          case 81:
            return this.popState(), 55;
          case 82:
            return this.pushState("text"), 54;
          case 83:
            return this.popState(), 57;
          case 84:
            return this.pushState("text"), 56;
          case 85:
            return 58;
          case 86:
            return this.pushState("text"), 67;
          case 87:
            return this.popState(), 64;
          case 88:
            return this.pushState("text"), 63;
          case 89:
            return this.popState(), 49;
          case 90:
            return this.pushState("text"), 48;
          case 91:
            return this.popState(), 69;
          case 92:
            return this.popState(), 71;
          case 93:
            return 117;
          case 94:
            return this.pushState("trapText"), 68;
          case 95:
            return this.pushState("trapText"), 70;
          case 96:
            return 118;
          case 97:
            return 67;
          case 98:
            return 90;
          case 99:
            return "SEP";
          case 100:
            return 89;
          case 101:
            return 115;
          case 102:
            return 111;
          case 103:
            return 44;
          case 104:
            return 109;
          case 105:
            return 114;
          case 106:
            return 116;
          case 107:
            return this.popState(), 62;
          case 108:
            return this.pushState("text"), 62;
          case 109:
            return this.popState(), 51;
          case 110:
            return this.pushState("text"), 50;
          case 111:
            return this.popState(), 31;
          case 112:
            return this.pushState("text"), 29;
          case 113:
            return this.popState(), 66;
          case 114:
            return this.pushState("text"), 65;
          case 115:
            return "TEXT";
          case 116:
            return "QUOTE";
          case 117:
            return 9;
          case 118:
            return 10;
          case 119:
            return 11;
        }
      }, "anonymous"),
      rules: [/^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:@\{)/, /^(?:["])/, /^(?:["])/, /^(?:[^\"]+)/, /^(?:[^}^"]+)/, /^(?:\})/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["][`])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:["])/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s])/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:flowchart-elk\b)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[^\s\"]+@(?=[^\{\"]))/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:[^-]|-(?!-)+)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:[^=]|=(?!))/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:[^\.]|\.(?!))/, /^(?:\s*~~[\~]+\s*)/, /^(?:[-/\)][\)])/, /^(?:[^\(\)\[\]\{\}]|!\)+)/, /^(?:\(-)/, /^(?:\]\))/, /^(?:\(\[)/, /^(?:\]\])/, /^(?:\[\[)/, /^(?:\[\|)/, /^(?:>)/, /^(?:\)\])/, /^(?:\[\()/, /^(?:\)\)\))/, /^(?:\(\(\()/, /^(?:[\\(?=\])][\]])/, /^(?:\/(?=\])\])/, /^(?:\/(?!\])|\\(?!\])|[^\\\[\]\(\)\{\}\/]+)/, /^(?:\[\/)/, /^(?:\[\\)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:\*)/, /^(?:#)/, /^(?:&)/, /^(?:([A-Za-z0-9!"\#$%&'*+\.`?\\_\/]|-(?=[^\>\-\.])|(?!))+)/, /^(?:-)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\|)/, /^(?:\))/, /^(?:\()/, /^(?:\])/, /^(?:\[)/, /^(?:(\}))/, /^(?:\{)/, /^(?:[^\[\]\(\)\{\}\|\"]+)/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
      conditions: { shapeDataEndBracket: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, shapeDataStr: { rules: [9, 10, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, shapeData: { rules: [8, 11, 12, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, callbackargs: { rules: [17, 18, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, callbackname: { rules: [14, 15, 16, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, href: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, click: { rules: [21, 24, 33, 34, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, dottedEdgeText: { rules: [21, 24, 74, 76, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, thickEdgeText: { rules: [21, 24, 71, 73, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, edgeText: { rules: [21, 24, 68, 70, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, trapText: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 91, 92, 93, 94, 95, 108, 110, 112, 114], inclusive: !1 }, ellipseText: { rules: [21, 24, 77, 78, 79, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, text: { rules: [21, 24, 77, 80, 81, 82, 83, 84, 87, 88, 89, 90, 94, 95, 107, 108, 109, 110, 111, 112, 113, 114, 115], inclusive: !1 }, vertex: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, dir: { rules: [21, 24, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_descr_multiline: { rules: [5, 6, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_descr: { rules: [3, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_title: { rules: [1, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, md_string: { rules: [19, 20, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, string: { rules: [21, 22, 23, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 13, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 74, 75, 77, 80, 82, 84, 85, 86, 88, 90, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 110, 112, 114, 116, 117, 118, 119], inclusive: !0 } }
    };
    return Sn;
  })();
  Kr.lexer = bi;
  function En() {
    this.yy = {};
  }
  return w(En, "Parser"), En.prototype = Kr, Kr.Parser = En, new En();
})();
DA.parser = DA;
var $ae = DA, Bae = Object.assign({}, $ae);
Bae.parse = (t) => {
  const e = t.replace(/}\s*\n/g, `}
`);
  return $ae.parse(e);
};
var FPe = Bae, zPe = /* @__PURE__ */ w((t, e) => {
  const r = l9, n = r(t, "r"), i = r(t, "g"), a = r(t, "b");
  return ac(n, i, a, e);
}, "fade"), qPe = /* @__PURE__ */ w((t) => `.label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }
  .cluster-label text {
    fill: ${t.titleColor};
  }
  .cluster-label span {
    color: ${t.titleColor};
  }
  .cluster-label span p {
    background-color: transparent;
  }

  .label text,span {
    fill: ${t.nodeTextColor || t.textColor};
    color: ${t.nodeTextColor || t.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }
  .rough-node .label text , .node .label text, .image-shape .label, .icon-shape .label {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .katex path {
    fill: #000;
    stroke: #000;
    stroke-width: 1px;
  }

  .rough-node .label,.node .label, .image-shape .label, .icon-shape .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }


  .root .anchor path {
    fill: ${t.lineColor} !important;
    stroke-width: 0;
    stroke: ${t.lineColor};
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    p {
      background-color: ${t.edgeLabelBackground};
    }
    rect {
      opacity: 0.5;
      background-color: ${t.edgeLabelBackground};
      fill: ${t.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${zPe(t.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .cluster rect {
    fill: ${t.clusterBkg};
    stroke: ${t.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  .cluster span {
    color: ${t.titleColor};
  }
  /* .cluster div {
    color: ${t.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${t.fontFamily};
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }

  rect.text {
    fill: none;
    stroke-width: 0;
  }

  .icon-shape, .image-shape {
    background-color: ${t.edgeLabelBackground};
    p {
      background-color: ${t.edgeLabelBackground};
      padding: 2px;
    }
    rect {
      opacity: 0.5;
      background-color: ${t.edgeLabelBackground};
      fill: ${t.edgeLabelBackground};
    }
    text-align: center;
  }
  ${Rm()}
`, "getStyles"), GPe = qPe, UPe = {
  parser: FPe,
  get db() {
    return new OPe();
  },
  renderer: BPe,
  styles: GPe,
  init: /* @__PURE__ */ w((t) => {
    t.flowchart || (t.flowchart = {}), t.layout && t_({ layout: t.layout }), t.flowchart.arrowMarkerAbsolute = t.arrowMarkerAbsolute, t_({ flowchart: { arrowMarkerAbsolute: t.arrowMarkerAbsolute } });
  }, "init")
};
const HR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: UPe
}, Symbol.toStringTag, { value: "Module" }));
var OA = (function() {
  var t = /* @__PURE__ */ w(function(X, re, Q, ue) {
    for (Q = Q || {}, ue = X.length; ue--; Q[X[ue]] = re) ;
    return Q;
  }, "o"), e = [6, 8, 10, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50], r = [1, 10], n = [1, 11], i = [1, 12], a = [1, 13], s = [1, 20], o = [1, 21], l = [1, 22], u = [1, 23], h = [1, 24], f = [1, 19], d = [1, 25], p = [1, 26], g = [1, 18], m = [1, 33], v = [1, 34], y = [1, 35], b = [1, 36], x = [1, 37], T = [6, 8, 10, 13, 15, 17, 20, 21, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50, 63, 64, 65, 66, 67], E = [1, 42], A = [1, 43], S = [1, 52], k = [40, 50, 68, 69], _ = [1, 63], R = [1, 61], L = [1, 58], M = [1, 62], P = [1, 64], C = [6, 8, 10, 13, 17, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 41, 42, 43, 44, 48, 49, 50, 63, 64, 65, 66, 67], I = [63, 64, 65, 66, 67], N = [1, 81], O = [1, 80], D = [1, 78], $ = [1, 79], z = [6, 10, 42, 47], B = [6, 10, 13, 41, 42, 47, 48, 49], G = [1, 89], W = [1, 88], V = [1, 87], U = [19, 56], Z = [1, 98], K = [1, 97], ce = [19, 56, 58, 60], J = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, ER_DIAGRAM: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, entityName: 11, relSpec: 12, COLON: 13, role: 14, STYLE_SEPARATOR: 15, idList: 16, BLOCK_START: 17, attributes: 18, BLOCK_STOP: 19, SQS: 20, SQE: 21, title: 22, title_value: 23, acc_title: 24, acc_title_value: 25, acc_descr: 26, acc_descr_value: 27, acc_descr_multiline_value: 28, direction: 29, classDefStatement: 30, classStatement: 31, styleStatement: 32, direction_tb: 33, direction_bt: 34, direction_rl: 35, direction_lr: 36, CLASSDEF: 37, stylesOpt: 38, separator: 39, UNICODE_TEXT: 40, STYLE_TEXT: 41, COMMA: 42, CLASS: 43, STYLE: 44, style: 45, styleComponent: 46, SEMI: 47, NUM: 48, BRKT: 49, ENTITY_NAME: 50, attribute: 51, attributeType: 52, attributeName: 53, attributeKeyTypeList: 54, attributeComment: 55, ATTRIBUTE_WORD: 56, attributeKeyType: 57, ",": 58, ATTRIBUTE_KEY: 59, COMMENT: 60, cardinality: 61, relType: 62, ZERO_OR_ONE: 63, ZERO_OR_MORE: 64, ONE_OR_MORE: 65, ONLY_ONE: 66, MD_PARENT: 67, NON_IDENTIFYING: 68, IDENTIFYING: 69, WORD: 70, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 13: "COLON", 15: "STYLE_SEPARATOR", 17: "BLOCK_START", 19: "BLOCK_STOP", 20: "SQS", 21: "SQE", 22: "title", 23: "title_value", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "direction_tb", 34: "direction_bt", 35: "direction_rl", 36: "direction_lr", 37: "CLASSDEF", 40: "UNICODE_TEXT", 41: "STYLE_TEXT", 42: "COMMA", 43: "CLASS", 44: "STYLE", 47: "SEMI", 48: "NUM", 49: "BRKT", 50: "ENTITY_NAME", 56: "ATTRIBUTE_WORD", 58: ",", 59: "ATTRIBUTE_KEY", 60: "COMMENT", 63: "ZERO_OR_ONE", 64: "ZERO_OR_MORE", 65: "ONE_OR_MORE", 66: "ONLY_ONE", 67: "MD_PARENT", 68: "NON_IDENTIFYING", 69: "IDENTIFYING", 70: "WORD" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 5], [9, 9], [9, 7], [9, 7], [9, 4], [9, 6], [9, 3], [9, 5], [9, 1], [9, 3], [9, 7], [9, 9], [9, 6], [9, 8], [9, 4], [9, 6], [9, 2], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [29, 1], [29, 1], [29, 1], [29, 1], [30, 4], [16, 1], [16, 1], [16, 3], [16, 3], [31, 3], [32, 4], [38, 1], [38, 3], [45, 1], [45, 2], [39, 1], [39, 1], [39, 1], [46, 1], [46, 1], [46, 1], [46, 1], [11, 1], [11, 1], [18, 1], [18, 2], [51, 2], [51, 3], [51, 3], [51, 4], [52, 1], [53, 1], [54, 1], [54, 3], [57, 1], [55, 1], [12, 3], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [62, 1], [62, 1], [14, 1], [14, 1], [14, 1]],
    performAction: /* @__PURE__ */ w(function(re, Q, ue, ne, xe, Y, Ne) {
      var fe = Y.length - 1;
      switch (xe) {
        case 1:
          break;
        case 2:
          this.$ = [];
          break;
        case 3:
          Y[fe - 1].push(Y[fe]), this.$ = Y[fe - 1];
          break;
        case 4:
        case 5:
          this.$ = Y[fe];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          ne.addEntity(Y[fe - 4]), ne.addEntity(Y[fe - 2]), ne.addRelationship(Y[fe - 4], Y[fe], Y[fe - 2], Y[fe - 3]);
          break;
        case 9:
          ne.addEntity(Y[fe - 8]), ne.addEntity(Y[fe - 4]), ne.addRelationship(Y[fe - 8], Y[fe], Y[fe - 4], Y[fe - 5]), ne.setClass([Y[fe - 8]], Y[fe - 6]), ne.setClass([Y[fe - 4]], Y[fe - 2]);
          break;
        case 10:
          ne.addEntity(Y[fe - 6]), ne.addEntity(Y[fe - 2]), ne.addRelationship(Y[fe - 6], Y[fe], Y[fe - 2], Y[fe - 3]), ne.setClass([Y[fe - 6]], Y[fe - 4]);
          break;
        case 11:
          ne.addEntity(Y[fe - 6]), ne.addEntity(Y[fe - 4]), ne.addRelationship(Y[fe - 6], Y[fe], Y[fe - 4], Y[fe - 5]), ne.setClass([Y[fe - 4]], Y[fe - 2]);
          break;
        case 12:
          ne.addEntity(Y[fe - 3]), ne.addAttributes(Y[fe - 3], Y[fe - 1]);
          break;
        case 13:
          ne.addEntity(Y[fe - 5]), ne.addAttributes(Y[fe - 5], Y[fe - 1]), ne.setClass([Y[fe - 5]], Y[fe - 3]);
          break;
        case 14:
          ne.addEntity(Y[fe - 2]);
          break;
        case 15:
          ne.addEntity(Y[fe - 4]), ne.setClass([Y[fe - 4]], Y[fe - 2]);
          break;
        case 16:
          ne.addEntity(Y[fe]);
          break;
        case 17:
          ne.addEntity(Y[fe - 2]), ne.setClass([Y[fe - 2]], Y[fe]);
          break;
        case 18:
          ne.addEntity(Y[fe - 6], Y[fe - 4]), ne.addAttributes(Y[fe - 6], Y[fe - 1]);
          break;
        case 19:
          ne.addEntity(Y[fe - 8], Y[fe - 6]), ne.addAttributes(Y[fe - 8], Y[fe - 1]), ne.setClass([Y[fe - 8]], Y[fe - 3]);
          break;
        case 20:
          ne.addEntity(Y[fe - 5], Y[fe - 3]);
          break;
        case 21:
          ne.addEntity(Y[fe - 7], Y[fe - 5]), ne.setClass([Y[fe - 7]], Y[fe - 2]);
          break;
        case 22:
          ne.addEntity(Y[fe - 3], Y[fe - 1]);
          break;
        case 23:
          ne.addEntity(Y[fe - 5], Y[fe - 3]), ne.setClass([Y[fe - 5]], Y[fe]);
          break;
        case 24:
        case 25:
          this.$ = Y[fe].trim(), ne.setAccTitle(this.$);
          break;
        case 26:
        case 27:
          this.$ = Y[fe].trim(), ne.setAccDescription(this.$);
          break;
        case 32:
          ne.setDirection("TB");
          break;
        case 33:
          ne.setDirection("BT");
          break;
        case 34:
          ne.setDirection("RL");
          break;
        case 35:
          ne.setDirection("LR");
          break;
        case 36:
          this.$ = Y[fe - 3], ne.addClass(Y[fe - 2], Y[fe - 1]);
          break;
        case 37:
        case 38:
        case 56:
        case 64:
          this.$ = [Y[fe]];
          break;
        case 39:
        case 40:
          this.$ = Y[fe - 2].concat([Y[fe]]);
          break;
        case 41:
          this.$ = Y[fe - 2], ne.setClass(Y[fe - 1], Y[fe]);
          break;
        case 42:
          this.$ = Y[fe - 3], ne.addCssStyles(Y[fe - 2], Y[fe - 1]);
          break;
        case 43:
          this.$ = [Y[fe]];
          break;
        case 44:
          Y[fe - 2].push(Y[fe]), this.$ = Y[fe - 2];
          break;
        case 46:
          this.$ = Y[fe - 1] + Y[fe];
          break;
        case 54:
        case 76:
        case 77:
          this.$ = Y[fe].replace(/"/g, "");
          break;
        case 55:
        case 78:
          this.$ = Y[fe];
          break;
        case 57:
          Y[fe].push(Y[fe - 1]), this.$ = Y[fe];
          break;
        case 58:
          this.$ = { type: Y[fe - 1], name: Y[fe] };
          break;
        case 59:
          this.$ = { type: Y[fe - 2], name: Y[fe - 1], keys: Y[fe] };
          break;
        case 60:
          this.$ = { type: Y[fe - 2], name: Y[fe - 1], comment: Y[fe] };
          break;
        case 61:
          this.$ = { type: Y[fe - 3], name: Y[fe - 2], keys: Y[fe - 1], comment: Y[fe] };
          break;
        case 62:
        case 63:
        case 66:
          this.$ = Y[fe];
          break;
        case 65:
          Y[fe - 2].push(Y[fe]), this.$ = Y[fe - 2];
          break;
        case 67:
          this.$ = Y[fe].replace(/"/g, "");
          break;
        case 68:
          this.$ = { cardA: Y[fe], relType: Y[fe - 1], cardB: Y[fe - 2] };
          break;
        case 69:
          this.$ = ne.Cardinality.ZERO_OR_ONE;
          break;
        case 70:
          this.$ = ne.Cardinality.ZERO_OR_MORE;
          break;
        case 71:
          this.$ = ne.Cardinality.ONE_OR_MORE;
          break;
        case 72:
          this.$ = ne.Cardinality.ONLY_ONE;
          break;
        case 73:
          this.$ = ne.Cardinality.MD_PARENT;
          break;
        case 74:
          this.$ = ne.Identification.NON_IDENTIFYING;
          break;
        case 75:
          this.$ = ne.Identification.IDENTIFYING;
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: 9, 22: r, 24: n, 26: i, 28: a, 29: 14, 30: 15, 31: 16, 32: 17, 33: s, 34: o, 35: l, 36: u, 37: h, 40: f, 43: d, 44: p, 50: g }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 27, 11: 9, 22: r, 24: n, 26: i, 28: a, 29: 14, 30: 15, 31: 16, 32: 17, 33: s, 34: o, 35: l, 36: u, 37: h, 40: f, 43: d, 44: p, 50: g }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 16], { 12: 28, 61: 32, 15: [1, 29], 17: [1, 30], 20: [1, 31], 63: m, 64: v, 65: y, 66: b, 67: x }), { 23: [1, 38] }, { 25: [1, 39] }, { 27: [1, 40] }, t(e, [2, 27]), t(e, [2, 28]), t(e, [2, 29]), t(e, [2, 30]), t(e, [2, 31]), t(T, [2, 54]), t(T, [2, 55]), t(e, [2, 32]), t(e, [2, 33]), t(e, [2, 34]), t(e, [2, 35]), { 16: 41, 40: E, 41: A }, { 16: 44, 40: E, 41: A }, { 16: 45, 40: E, 41: A }, t(e, [2, 4]), { 11: 46, 40: f, 50: g }, { 16: 47, 40: E, 41: A }, { 18: 48, 19: [1, 49], 51: 50, 52: 51, 56: S }, { 11: 53, 40: f, 50: g }, { 62: 54, 68: [1, 55], 69: [1, 56] }, t(k, [2, 69]), t(k, [2, 70]), t(k, [2, 71]), t(k, [2, 72]), t(k, [2, 73]), t(e, [2, 24]), t(e, [2, 25]), t(e, [2, 26]), { 13: _, 38: 57, 41: R, 42: L, 45: 59, 46: 60, 48: M, 49: P }, t(C, [2, 37]), t(C, [2, 38]), { 16: 65, 40: E, 41: A, 42: L }, { 13: _, 38: 66, 41: R, 42: L, 45: 59, 46: 60, 48: M, 49: P }, { 13: [1, 67], 15: [1, 68] }, t(e, [2, 17], { 61: 32, 12: 69, 17: [1, 70], 42: L, 63: m, 64: v, 65: y, 66: b, 67: x }), { 19: [1, 71] }, t(e, [2, 14]), { 18: 72, 19: [2, 56], 51: 50, 52: 51, 56: S }, { 53: 73, 56: [1, 74] }, { 56: [2, 62] }, { 21: [1, 75] }, { 61: 76, 63: m, 64: v, 65: y, 66: b, 67: x }, t(I, [2, 74]), t(I, [2, 75]), { 6: N, 10: O, 39: 77, 42: D, 47: $ }, { 40: [1, 82], 41: [1, 83] }, t(z, [2, 43], { 46: 84, 13: _, 41: R, 48: M, 49: P }), t(B, [2, 45]), t(B, [2, 50]), t(B, [2, 51]), t(B, [2, 52]), t(B, [2, 53]), t(e, [2, 41], { 42: L }), { 6: N, 10: O, 39: 85, 42: D, 47: $ }, { 14: 86, 40: G, 50: W, 70: V }, { 16: 90, 40: E, 41: A }, { 11: 91, 40: f, 50: g }, { 18: 92, 19: [1, 93], 51: 50, 52: 51, 56: S }, t(e, [2, 12]), { 19: [2, 57] }, t(U, [2, 58], { 54: 94, 55: 95, 57: 96, 59: Z, 60: K }), t([19, 56, 59, 60], [2, 63]), t(e, [2, 22], { 15: [1, 100], 17: [1, 99] }), t([40, 50], [2, 68]), t(e, [2, 36]), { 13: _, 41: R, 45: 101, 46: 60, 48: M, 49: P }, t(e, [2, 47]), t(e, [2, 48]), t(e, [2, 49]), t(C, [2, 39]), t(C, [2, 40]), t(B, [2, 46]), t(e, [2, 42]), t(e, [2, 8]), t(e, [2, 76]), t(e, [2, 77]), t(e, [2, 78]), { 13: [1, 102], 42: L }, { 13: [1, 104], 15: [1, 103] }, { 19: [1, 105] }, t(e, [2, 15]), t(U, [2, 59], { 55: 106, 58: [1, 107], 60: K }), t(U, [2, 60]), t(ce, [2, 64]), t(U, [2, 67]), t(ce, [2, 66]), { 18: 108, 19: [1, 109], 51: 50, 52: 51, 56: S }, { 16: 110, 40: E, 41: A }, t(z, [2, 44], { 46: 84, 13: _, 41: R, 48: M, 49: P }), { 14: 111, 40: G, 50: W, 70: V }, { 16: 112, 40: E, 41: A }, { 14: 113, 40: G, 50: W, 70: V }, t(e, [2, 13]), t(U, [2, 61]), { 57: 114, 59: Z }, { 19: [1, 115] }, t(e, [2, 20]), t(e, [2, 23], { 17: [1, 116], 42: L }), t(e, [2, 11]), { 13: [1, 117], 42: L }, t(e, [2, 10]), t(ce, [2, 65]), t(e, [2, 18]), { 18: 118, 19: [1, 119], 51: 50, 52: 51, 56: S }, { 14: 120, 40: G, 50: W, 70: V }, { 19: [1, 121] }, t(e, [2, 21]), t(e, [2, 9]), t(e, [2, 19])],
    defaultActions: { 52: [2, 62], 72: [2, 57] },
    parseError: /* @__PURE__ */ w(function(re, Q) {
      if (Q.recoverable)
        this.trace(re);
      else {
        var ue = new Error(re);
        throw ue.hash = Q, ue;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(re) {
      var Q = this, ue = [0], ne = [], xe = [null], Y = [], Ne = this.table, fe = "", qe = 0, ze = 0, Ge = 2, Ee = 1, Oe = Y.slice.call(arguments, 1), Ce = Object.create(this.lexer), Ae = { yy: {} };
      for (var $e in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, $e) && (Ae.yy[$e] = this.yy[$e]);
      Ce.setInput(re, Ae.yy), Ae.yy.lexer = Ce, Ae.yy.parser = this, typeof Ce.yylloc > "u" && (Ce.yylloc = {});
      var me = Ce.yylloc;
      Y.push(me);
      var Ie = Ce.options && Ce.options.ranges;
      typeof Ae.yy.parseError == "function" ? this.parseError = Ae.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function te(We) {
        ue.length = ue.length - 2 * We, xe.length = xe.length - We, Y.length = Y.length - We;
      }
      w(te, "popStack");
      function he() {
        var We;
        return We = ne.pop() || Ce.lex() || Ee, typeof We != "number" && (We instanceof Array && (ne = We, We = ne.pop()), We = Q.symbols_[We] || We), We;
      }
      w(he, "lex");
      for (var F, oe, se, ge, de = {}, we, _e, Se, Me; ; ) {
        if (oe = ue[ue.length - 1], this.defaultActions[oe] ? se = this.defaultActions[oe] : ((F === null || typeof F > "u") && (F = he()), se = Ne[oe] && Ne[oe][F]), typeof se > "u" || !se.length || !se[0]) {
          var Xe = "";
          Me = [];
          for (we in Ne[oe])
            this.terminals_[we] && we > Ge && Me.push("'" + this.terminals_[we] + "'");
          Ce.showPosition ? Xe = "Parse error on line " + (qe + 1) + `:
` + Ce.showPosition() + `
Expecting ` + Me.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : Xe = "Parse error on line " + (qe + 1) + ": Unexpected " + (F == Ee ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(Xe, {
            text: Ce.match,
            token: this.terminals_[F] || F,
            line: Ce.yylineno,
            loc: me,
            expected: Me
          });
        }
        if (se[0] instanceof Array && se.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + oe + ", token: " + F);
        switch (se[0]) {
          case 1:
            ue.push(F), xe.push(Ce.yytext), Y.push(Ce.yylloc), ue.push(se[1]), F = null, ze = Ce.yyleng, fe = Ce.yytext, qe = Ce.yylineno, me = Ce.yylloc;
            break;
          case 2:
            if (_e = this.productions_[se[1]][1], de.$ = xe[xe.length - _e], de._$ = {
              first_line: Y[Y.length - (_e || 1)].first_line,
              last_line: Y[Y.length - 1].last_line,
              first_column: Y[Y.length - (_e || 1)].first_column,
              last_column: Y[Y.length - 1].last_column
            }, Ie && (de._$.range = [
              Y[Y.length - (_e || 1)].range[0],
              Y[Y.length - 1].range[1]
            ]), ge = this.performAction.apply(de, [
              fe,
              ze,
              qe,
              Ae.yy,
              se[1],
              xe,
              Y
            ].concat(Oe)), typeof ge < "u")
              return ge;
            _e && (ue = ue.slice(0, -1 * _e * 2), xe = xe.slice(0, -1 * _e), Y = Y.slice(0, -1 * _e)), ue.push(this.productions_[se[1]][0]), xe.push(de.$), Y.push(de._$), Se = Ne[ue[ue.length - 2]][ue[ue.length - 1]], ue.push(Se);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, ee = /* @__PURE__ */ (function() {
    var X = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(Q, ue) {
        if (this.yy.parser)
          this.yy.parser.parseError(Q, ue);
        else
          throw new Error(Q);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(re, Q) {
        return this.yy = Q || this.yy || {}, this._input = re, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var re = this._input[0];
        this.yytext += re, this.yyleng++, this.offset++, this.match += re, this.matched += re;
        var Q = re.match(/(?:\r\n?|\n).*/g);
        return Q ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), re;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(re) {
        var Q = re.length, ue = re.split(/(?:\r\n?|\n)/g);
        this._input = re + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Q), this.offset -= Q;
        var ne = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), ue.length - 1 && (this.yylineno -= ue.length - 1);
        var xe = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: ue ? (ue.length === ne.length ? this.yylloc.first_column : 0) + ne[ne.length - ue.length].length - ue[0].length : this.yylloc.first_column - Q
        }, this.options.ranges && (this.yylloc.range = [xe[0], xe[0] + this.yyleng - Q]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(re) {
        this.unput(this.match.slice(re));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var re = this.matched.substr(0, this.matched.length - this.match.length);
        return (re.length > 20 ? "..." : "") + re.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var re = this.match;
        return re.length < 20 && (re += this._input.substr(0, 20 - re.length)), (re.substr(0, 20) + (re.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var re = this.pastInput(), Q = new Array(re.length + 1).join("-");
        return re + this.upcomingInput() + `
` + Q + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(re, Q) {
        var ue, ne, xe;
        if (this.options.backtrack_lexer && (xe = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (xe.yylloc.range = this.yylloc.range.slice(0))), ne = re[0].match(/(?:\r\n?|\n).*/g), ne && (this.yylineno += ne.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: ne ? ne[ne.length - 1].length - ne[ne.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + re[0].length
        }, this.yytext += re[0], this.match += re[0], this.matches = re, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(re[0].length), this.matched += re[0], ue = this.performAction.call(this, this.yy, this, Q, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), ue)
          return ue;
        if (this._backtrack) {
          for (var Y in xe)
            this[Y] = xe[Y];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var re, Q, ue, ne;
        this._more || (this.yytext = "", this.match = "");
        for (var xe = this._currentRules(), Y = 0; Y < xe.length; Y++)
          if (ue = this._input.match(this.rules[xe[Y]]), ue && (!Q || ue[0].length > Q[0].length)) {
            if (Q = ue, ne = Y, this.options.backtrack_lexer) {
              if (re = this.test_match(ue, xe[Y]), re !== !1)
                return re;
              if (this._backtrack) {
                Q = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Q ? (re = this.test_match(Q, xe[ne]), re !== !1 ? re : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var Q = this.next();
        return Q || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(Q) {
        this.conditionStack.push(Q);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var Q = this.conditionStack.length - 1;
        return Q > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(Q) {
        return Q = this.conditionStack.length - 1 - Math.abs(Q || 0), Q >= 0 ? this.conditionStack[Q] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(Q) {
        this.begin(Q);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(Q, ue, ne, xe) {
        switch (ne) {
          case 0:
            return this.begin("acc_title"), 24;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 26;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return 33;
          case 8:
            return 34;
          case 9:
            return 35;
          case 10:
            return 36;
          case 11:
            return 10;
          case 12:
            break;
          case 13:
            return 8;
          case 14:
            return 50;
          case 15:
            return 70;
          case 16:
            return 4;
          case 17:
            return this.begin("block"), 17;
          case 18:
            return 49;
          case 19:
            return 49;
          case 20:
            return 42;
          case 21:
            return 15;
          case 22:
            return 13;
          case 23:
            break;
          case 24:
            return 59;
          case 25:
            return 56;
          case 26:
            return 56;
          case 27:
            return 60;
          case 28:
            break;
          case 29:
            return this.popState(), 19;
          case 30:
            return ue.yytext[0];
          case 31:
            return 20;
          case 32:
            return 21;
          case 33:
            return this.begin("style"), 44;
          case 34:
            return this.popState(), 10;
          case 35:
            break;
          case 36:
            return 13;
          case 37:
            return 42;
          case 38:
            return 49;
          case 39:
            return this.begin("style"), 37;
          case 40:
            return 43;
          case 41:
            return 63;
          case 42:
            return 65;
          case 43:
            return 65;
          case 44:
            return 65;
          case 45:
            return 63;
          case 46:
            return 63;
          case 47:
            return 64;
          case 48:
            return 64;
          case 49:
            return 64;
          case 50:
            return 64;
          case 51:
            return 64;
          case 52:
            return 65;
          case 53:
            return 64;
          case 54:
            return 65;
          case 55:
            return 66;
          case 56:
            return 66;
          case 57:
            return 66;
          case 58:
            return 66;
          case 59:
            return 63;
          case 60:
            return 64;
          case 61:
            return 65;
          case 62:
            return 67;
          case 63:
            return 68;
          case 64:
            return 69;
          case 65:
            return 69;
          case 66:
            return 68;
          case 67:
            return 68;
          case 68:
            return 68;
          case 69:
            return 41;
          case 70:
            return 47;
          case 71:
            return 40;
          case 72:
            return 48;
          case 73:
            return ue.yytext[0];
          case 74:
            return 6;
        }
      }, "anonymous"),
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:#)/i, /^(?:#)/i, /^(?:,)/i, /^(?::::)/i, /^(?::)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i, /^(?:([^\s]*)[~].*[~]([^\s]*))/i, /^(?:([\*A-Za-z_\u00C0-\uFFFF][A-Za-z0-9\-\_\[\]\(\)\u00C0-\uFFFF\*]*))/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:style\b)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?::)/i, /^(?:,)/i, /^(?:#)/i, /^(?:classDef\b)/i, /^(?:class\b)/i, /^(?:one or zero\b)/i, /^(?:one or more\b)/i, /^(?:one or many\b)/i, /^(?:1\+)/i, /^(?:\|o\b)/i, /^(?:zero or one\b)/i, /^(?:zero or more\b)/i, /^(?:zero or many\b)/i, /^(?:0\+)/i, /^(?:\}o\b)/i, /^(?:many\(0\))/i, /^(?:many\(1\))/i, /^(?:many\b)/i, /^(?:\}\|)/i, /^(?:one\b)/i, /^(?:only one\b)/i, /^(?:1\b)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\s*u\b)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:to\b)/i, /^(?:optionally to\b)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:;)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:[0-9])/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { style: { rules: [34, 35, 36, 37, 38, 69, 70], inclusive: !1 }, acc_descr_multiline: { rules: [5, 6], inclusive: !1 }, acc_descr: { rules: [3], inclusive: !1 }, acc_title: { rules: [1], inclusive: !1 }, block: { rules: [23, 24, 25, 26, 27, 28, 29, 30], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 31, 32, 33, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 71, 72, 73, 74], inclusive: !0 } }
    };
    return X;
  })();
  J.lexer = ee;
  function j() {
    this.yy = {};
  }
  return w(j, "Parser"), j.prototype = J, J.Parser = j, new j();
})();
OA.parser = OA;
var VPe = OA, id, HPe = (id = class {
  constructor() {
    this.entities = /* @__PURE__ */ new Map(), this.relationships = [], this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.Cardinality = {
      ZERO_OR_ONE: "ZERO_OR_ONE",
      ZERO_OR_MORE: "ZERO_OR_MORE",
      ONE_OR_MORE: "ONE_OR_MORE",
      ONLY_ONE: "ONLY_ONE",
      MD_PARENT: "MD_PARENT"
    }, this.Identification = {
      NON_IDENTIFYING: "NON_IDENTIFYING",
      IDENTIFYING: "IDENTIFYING"
    }, this.setAccTitle = Ln, this.getAccTitle = Hn, this.setAccDescription = Wn, this.getAccDescription = Yn, this.setDiagramTitle = ti, this.getDiagramTitle = Mn, this.getConfig = /* @__PURE__ */ w(() => Te().er, "getConfig"), this.clear(), this.addEntity = this.addEntity.bind(this), this.addAttributes = this.addAttributes.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setDirection = this.setDirection.bind(this), this.addCssStyles = this.addCssStyles.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
  }
  /**
   * Add entity
   * @param name - The name of the entity
   * @param alias - The alias of the entity
   */
  addEntity(e, r = "") {
    return this.entities.has(e) ? !this.entities.get(e)?.alias && r && (this.entities.get(e).alias = r, ae.info(`Add alias '${r}' to entity '${e}'`)) : (this.entities.set(e, {
      id: `entity-${e}-${this.entities.size}`,
      label: e,
      attributes: [],
      alias: r,
      shape: "erBox",
      look: Te().look ?? "default",
      cssClasses: "default",
      cssStyles: []
    }), ae.info("Added new entity :", e)), this.entities.get(e);
  }
  getEntity(e) {
    return this.entities.get(e);
  }
  getEntities() {
    return this.entities;
  }
  getClasses() {
    return this.classes;
  }
  addAttributes(e, r) {
    const n = this.addEntity(e);
    let i;
    for (i = r.length - 1; i >= 0; i--)
      r[i].keys || (r[i].keys = []), r[i].comment || (r[i].comment = ""), n.attributes.push(r[i]), ae.debug("Added attribute ", r[i].name);
  }
  /**
   * Add a relationship
   *
   * @param entA - The first entity in the relationship
   * @param rolA - The role played by the first entity in relation to the second
   * @param entB - The second entity in the relationship
   * @param rSpec - The details of the relationship between the two entities
   */
  addRelationship(e, r, n, i) {
    const a = this.entities.get(e), s = this.entities.get(n);
    if (!a || !s)
      return;
    const o = {
      entityA: a.id,
      roleA: r,
      entityB: s.id,
      relSpec: i
    };
    this.relationships.push(o), ae.debug("Added new relationship :", o);
  }
  getRelationships() {
    return this.relationships;
  }
  getDirection() {
    return this.direction;
  }
  setDirection(e) {
    this.direction = e;
  }
  getCompiledStyles(e) {
    let r = [];
    for (const n of e) {
      const i = this.classes.get(n);
      i?.styles && (r = [...r, ...i.styles ?? []].map((a) => a.trim())), i?.textStyles && (r = [...r, ...i.textStyles ?? []].map((a) => a.trim()));
    }
    return r;
  }
  addCssStyles(e, r) {
    for (const n of e) {
      const i = this.entities.get(n);
      if (!r || !i)
        return;
      for (const a of r)
        i.cssStyles.push(a);
    }
  }
  addClass(e, r) {
    e.forEach((n) => {
      let i = this.classes.get(n);
      i === void 0 && (i = { id: n, styles: [], textStyles: [] }, this.classes.set(n, i)), r && r.forEach(function(a) {
        if (/color/.exec(a)) {
          const s = a.replace("fill", "bgFill");
          i.textStyles.push(s);
        }
        i.styles.push(a);
      });
    });
  }
  setClass(e, r) {
    for (const n of e) {
      const i = this.entities.get(n);
      if (i)
        for (const a of r)
          i.cssClasses += " " + a;
    }
  }
  clear() {
    this.entities = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.relationships = [], In();
  }
  getData() {
    const e = [], r = [], n = Te();
    for (const a of this.entities.keys()) {
      const s = this.entities.get(a);
      s && (s.cssCompiledStyles = this.getCompiledStyles(s.cssClasses.split(" ")), e.push(s));
    }
    let i = 0;
    for (const a of this.relationships) {
      const s = {
        id: Nf(a.entityA, a.entityB, {
          prefix: "id",
          counter: i++
        }),
        type: "normal",
        curve: "basis",
        start: a.entityA,
        end: a.entityB,
        label: a.roleA,
        labelpos: "c",
        thickness: "normal",
        classes: "relationshipLine",
        arrowTypeStart: a.relSpec.cardB.toLowerCase(),
        arrowTypeEnd: a.relSpec.cardA.toLowerCase(),
        pattern: a.relSpec.relType == "IDENTIFYING" ? "solid" : "dashed",
        look: n.look
      };
      r.push(s);
    }
    return { nodes: e, edges: r, other: {}, config: n, direction: "TB" };
  }
}, w(id, "ErDB"), id), Fae = {};
Mx(Fae, {
  draw: () => WPe
});
var WPe = /* @__PURE__ */ w(async function(t, e, r, n) {
  ae.info("REF0:"), ae.info("Drawing er diagram (unified)", e);
  const { securityLevel: i, er: a, layout: s } = Te(), o = n.db.getData(), l = Y0(e, i);
  o.type = n.type, o.layoutAlgorithm = om(s), o.config.flowchart.nodeSpacing = a?.nodeSpacing || 140, o.config.flowchart.rankSpacing = a?.rankSpacing || 80, o.direction = n.db.getDirection(), o.markers = ["only_one", "zero_or_one", "one_or_more", "zero_or_more"], o.diagramId = e, await I0(o, l), o.layoutAlgorithm === "elk" && l.select(".edges").lower();
  const u = l.selectAll('[id*="-background"]');
  Array.from(u).length > 0 && u.each(function() {
    const f = Qe(this), p = f.attr("id").replace("-background", ""), g = l.select(`#${CSS.escape(p)}`);
    if (!g.empty()) {
      const m = g.attr("transform");
      f.attr("transform", m);
    }
  });
  const h = 8;
  Jt.insertTitle(
    l,
    "erDiagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), Oh(l, h, "erDiagram", a?.useMaxWidth ?? !0);
}, "draw"), YPe = /* @__PURE__ */ w((t, e) => {
  const r = l9, n = r(t, "r"), i = r(t, "g"), a = r(t, "b");
  return ac(n, i, a, e);
}, "fade"), XPe = /* @__PURE__ */ w((t) => `
  .entityBox {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${t.tertiaryColor};
    opacity: 0.7;
    background-color: ${t.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

  .labelBkg {
    background-color: ${YPe(t.tertiaryColor, 0.5)};
  }

  .edgeLabel .label {
    fill: ${t.nodeBorder};
    font-size: 14px;
  }

  .label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }

  .edge-pattern-dashed {
    stroke-dasharray: 8,8;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon
  {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .relationshipLine {
    stroke: ${t.lineColor};
    stroke-width: 1;
    fill: none;
  }

  .marker {
    fill: none !important;
    stroke: ${t.lineColor} !important;
    stroke-width: 1;
  }
`, "getStyles"), jPe = XPe, KPe = {
  parser: VPe,
  get db() {
    return new HPe();
  },
  renderer: Fae,
  styles: jPe
};
const ZPe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: KPe
}, Symbol.toStringTag, { value: "Module" }));
function Ph(t, e) {
  t.accDescr && e.setAccDescription?.(t.accDescr), t.accTitle && e.setAccTitle?.(t.accTitle), t.title && e.setDiagramTitle?.(t.title);
}
w(Ph, "populateCommonDb");
var ad, zae = (ad = class {
  /**
   * @param init - Function that creates the default state.
   */
  constructor(e) {
    this.init = e, this.records = this.init();
  }
  reset() {
    this.records = this.init();
  }
}, w(ad, "ImperativeState"), ad);
function Ci(t) {
  return typeof t == "object" && t !== null && typeof t.$type == "string";
}
function oo(t) {
  return typeof t == "object" && t !== null && typeof t.$refText == "string";
}
function QPe(t) {
  return typeof t == "object" && t !== null && typeof t.name == "string" && typeof t.type == "string" && typeof t.path == "string";
}
function Ky(t) {
  return typeof t == "object" && t !== null && Ci(t.container) && oo(t.reference) && typeof t.message == "string";
}
class qae {
  constructor() {
    this.subtypes = {}, this.allSubtypes = {};
  }
  isInstance(e, r) {
    return Ci(e) && this.isSubtype(e.$type, r);
  }
  isSubtype(e, r) {
    if (e === r)
      return !0;
    let n = this.subtypes[e];
    n || (n = this.subtypes[e] = {});
    const i = n[r];
    if (i !== void 0)
      return i;
    {
      const a = this.computeIsSubtype(e, r);
      return n[r] = a, a;
    }
  }
  getAllSubTypes(e) {
    const r = this.allSubtypes[e];
    if (r)
      return r;
    {
      const n = this.getAllTypes(), i = [];
      for (const a of n)
        this.isSubtype(a, e) && i.push(a);
      return this.allSubtypes[e] = i, i;
    }
  }
}
function N1(t) {
  return typeof t == "object" && t !== null && Array.isArray(t.content);
}
function Gae(t) {
  return typeof t == "object" && t !== null && typeof t.tokenType == "object";
}
function Uae(t) {
  return N1(t) && typeof t.fullText == "string";
}
class ui {
  constructor(e, r) {
    this.startFn = e, this.nextFn = r;
  }
  iterator() {
    const e = {
      state: this.startFn(),
      next: () => this.nextFn(e.state),
      [Symbol.iterator]: () => e
    };
    return e;
  }
  [Symbol.iterator]() {
    return this.iterator();
  }
  isEmpty() {
    return !!this.iterator().next().done;
  }
  count() {
    const e = this.iterator();
    let r = 0, n = e.next();
    for (; !n.done; )
      r++, n = e.next();
    return r;
  }
  toArray() {
    const e = [], r = this.iterator();
    let n;
    do
      n = r.next(), n.value !== void 0 && e.push(n.value);
    while (!n.done);
    return e;
  }
  toSet() {
    return new Set(this);
  }
  toMap(e, r) {
    const n = this.map((i) => [
      e ? e(i) : i,
      r ? r(i) : i
    ]);
    return new Map(n);
  }
  toString() {
    return this.join();
  }
  concat(e) {
    return new ui(() => ({ first: this.startFn(), firstDone: !1, iterator: e[Symbol.iterator]() }), (r) => {
      let n;
      if (!r.firstDone) {
        do
          if (n = this.nextFn(r.first), !n.done)
            return n;
        while (!n.done);
        r.firstDone = !0;
      }
      do
        if (n = r.iterator.next(), !n.done)
          return n;
      while (!n.done);
      return Ea;
    });
  }
  join(e = ",") {
    const r = this.iterator();
    let n = "", i, a = !1;
    do
      i = r.next(), i.done || (a && (n += e), n += JPe(i.value)), a = !0;
    while (!i.done);
    return n;
  }
  indexOf(e, r = 0) {
    const n = this.iterator();
    let i = 0, a = n.next();
    for (; !a.done; ) {
      if (i >= r && a.value === e)
        return i;
      a = n.next(), i++;
    }
    return -1;
  }
  every(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (!e(n.value))
        return !1;
      n = r.next();
    }
    return !0;
  }
  some(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (e(n.value))
        return !0;
      n = r.next();
    }
    return !1;
  }
  forEach(e) {
    const r = this.iterator();
    let n = 0, i = r.next();
    for (; !i.done; )
      e(i.value, n), i = r.next(), n++;
  }
  map(e) {
    return new ui(this.startFn, (r) => {
      const { done: n, value: i } = this.nextFn(r);
      return n ? Ea : { done: !1, value: e(i) };
    });
  }
  filter(e) {
    return new ui(this.startFn, (r) => {
      let n;
      do
        if (n = this.nextFn(r), !n.done && e(n.value))
          return n;
      while (!n.done);
      return Ea;
    });
  }
  nonNullable() {
    return this.filter((e) => e != null);
  }
  reduce(e, r) {
    const n = this.iterator();
    let i = r, a = n.next();
    for (; !a.done; )
      i === void 0 ? i = a.value : i = e(i, a.value), a = n.next();
    return i;
  }
  reduceRight(e, r) {
    return this.recursiveReduce(this.iterator(), e, r);
  }
  recursiveReduce(e, r, n) {
    const i = e.next();
    if (i.done)
      return n;
    const a = this.recursiveReduce(e, r, n);
    return a === void 0 ? i.value : r(a, i.value);
  }
  find(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (e(n.value))
        return n.value;
      n = r.next();
    }
  }
  findIndex(e) {
    const r = this.iterator();
    let n = 0, i = r.next();
    for (; !i.done; ) {
      if (e(i.value))
        return n;
      i = r.next(), n++;
    }
    return -1;
  }
  includes(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (n.value === e)
        return !0;
      n = r.next();
    }
    return !1;
  }
  flatMap(e) {
    return new ui(() => ({ this: this.startFn() }), (r) => {
      do {
        if (r.iterator) {
          const a = r.iterator.next();
          if (a.done)
            r.iterator = void 0;
          else
            return a;
        }
        const { done: n, value: i } = this.nextFn(r.this);
        if (!n) {
          const a = e(i);
          if (Hb(a))
            r.iterator = a[Symbol.iterator]();
          else
            return { done: !1, value: a };
        }
      } while (r.iterator);
      return Ea;
    });
  }
  flat(e) {
    if (e === void 0 && (e = 1), e <= 0)
      return this;
    const r = e > 1 ? this.flat(e - 1) : this;
    return new ui(() => ({ this: r.startFn() }), (n) => {
      do {
        if (n.iterator) {
          const s = n.iterator.next();
          if (s.done)
            n.iterator = void 0;
          else
            return s;
        }
        const { done: i, value: a } = r.nextFn(n.this);
        if (!i)
          if (Hb(a))
            n.iterator = a[Symbol.iterator]();
          else
            return { done: !1, value: a };
      } while (n.iterator);
      return Ea;
    });
  }
  head() {
    const r = this.iterator().next();
    if (!r.done)
      return r.value;
  }
  tail(e = 1) {
    return new ui(() => {
      const r = this.startFn();
      for (let n = 0; n < e; n++)
        if (this.nextFn(r).done)
          return r;
      return r;
    }, this.nextFn);
  }
  limit(e) {
    return new ui(() => ({ size: 0, state: this.startFn() }), (r) => (r.size++, r.size > e ? Ea : this.nextFn(r.state)));
  }
  distinct(e) {
    return new ui(() => ({ set: /* @__PURE__ */ new Set(), internalState: this.startFn() }), (r) => {
      let n;
      do
        if (n = this.nextFn(r.internalState), !n.done) {
          const i = e ? e(n.value) : n.value;
          if (!r.set.has(i))
            return r.set.add(i), n;
        }
      while (!n.done);
      return Ea;
    });
  }
  exclude(e, r) {
    const n = /* @__PURE__ */ new Set();
    for (const i of e) {
      const a = r ? r(i) : i;
      n.add(a);
    }
    return this.filter((i) => {
      const a = r ? r(i) : i;
      return !n.has(a);
    });
  }
}
function JPe(t) {
  return typeof t == "string" ? t : typeof t > "u" ? "undefined" : typeof t.toString == "function" ? t.toString() : Object.prototype.toString.call(t);
}
function Hb(t) {
  return !!t && typeof t[Symbol.iterator] == "function";
}
const e$e = new ui(() => {
}, () => Ea), Ea = Object.freeze({ done: !0, value: void 0 });
function hi(...t) {
  if (t.length === 1) {
    const e = t[0];
    if (e instanceof ui)
      return e;
    if (Hb(e))
      return new ui(() => e[Symbol.iterator](), (r) => r.next());
    if (typeof e.length == "number")
      return new ui(() => ({ index: 0 }), (r) => r.index < e.length ? { done: !1, value: e[r.index++] } : Ea);
  }
  return t.length > 1 ? new ui(() => ({ collIndex: 0, arrIndex: 0 }), (e) => {
    do {
      if (e.iterator) {
        const r = e.iterator.next();
        if (!r.done)
          return r;
        e.iterator = void 0;
      }
      if (e.array) {
        if (e.arrIndex < e.array.length)
          return { done: !1, value: e.array[e.arrIndex++] };
        e.array = void 0, e.arrIndex = 0;
      }
      if (e.collIndex < t.length) {
        const r = t[e.collIndex++];
        Hb(r) ? e.iterator = r[Symbol.iterator]() : r && typeof r.length == "number" && (e.array = r);
      }
    } while (e.iterator || e.array || e.collIndex < t.length);
    return Ea;
  }) : e$e;
}
class WR extends ui {
  constructor(e, r, n) {
    super(() => ({
      iterators: n?.includeRoot ? [[e][Symbol.iterator]()] : [r(e)[Symbol.iterator]()],
      pruned: !1
    }), (i) => {
      for (i.pruned && (i.iterators.pop(), i.pruned = !1); i.iterators.length > 0; ) {
        const s = i.iterators[i.iterators.length - 1].next();
        if (s.done)
          i.iterators.pop();
        else
          return i.iterators.push(r(s.value)[Symbol.iterator]()), s;
      }
      return Ea;
    });
  }
  iterator() {
    const e = {
      state: this.startFn(),
      next: () => this.nextFn(e.state),
      prune: () => {
        e.state.pruned = !0;
      },
      [Symbol.iterator]: () => e
    };
    return e;
  }
}
var PA;
(function(t) {
  function e(a) {
    return a.reduce((s, o) => s + o, 0);
  }
  t.sum = e;
  function r(a) {
    return a.reduce((s, o) => s * o, 0);
  }
  t.product = r;
  function n(a) {
    return a.reduce((s, o) => Math.min(s, o));
  }
  t.min = n;
  function i(a) {
    return a.reduce((s, o) => Math.max(s, o));
  }
  t.max = i;
})(PA || (PA = {}));
function $A(t) {
  return new WR(t, (e) => N1(e) ? e.content : [], { includeRoot: !0 });
}
function t$e(t, e) {
  for (; t.container; )
    if (t = t.container, t === e)
      return !0;
  return !1;
}
function BA(t) {
  return {
    start: {
      character: t.startColumn - 1,
      line: t.startLine - 1
    },
    end: {
      character: t.endColumn,
      // endColumn uses the correct index
      line: t.endLine - 1
    }
  };
}
function Wb(t) {
  if (!t)
    return;
  const { offset: e, end: r, range: n } = t;
  return {
    range: n,
    offset: e,
    end: r,
    length: r - e
  };
}
var Xo;
(function(t) {
  t[t.Before = 0] = "Before", t[t.After = 1] = "After", t[t.OverlapFront = 2] = "OverlapFront", t[t.OverlapBack = 3] = "OverlapBack", t[t.Inside = 4] = "Inside", t[t.Outside = 5] = "Outside";
})(Xo || (Xo = {}));
function r$e(t, e) {
  if (t.end.line < e.start.line || t.end.line === e.start.line && t.end.character <= e.start.character)
    return Xo.Before;
  if (t.start.line > e.end.line || t.start.line === e.end.line && t.start.character >= e.end.character)
    return Xo.After;
  const r = t.start.line > e.start.line || t.start.line === e.start.line && t.start.character >= e.start.character, n = t.end.line < e.end.line || t.end.line === e.end.line && t.end.character <= e.end.character;
  return r && n ? Xo.Inside : r ? Xo.OverlapBack : n ? Xo.OverlapFront : Xo.Outside;
}
function n$e(t, e) {
  return r$e(t, e) > Xo.After;
}
const i$e = /^[\w\p{L}]$/u;
function a$e(t, e) {
  if (t) {
    const r = s$e(t, !0);
    if (r && DU(r, e))
      return r;
    if (Uae(t)) {
      const n = t.content.findIndex((i) => !i.hidden);
      for (let i = n - 1; i >= 0; i--) {
        const a = t.content[i];
        if (DU(a, e))
          return a;
      }
    }
  }
}
function DU(t, e) {
  return Gae(t) && e.includes(t.tokenType.name);
}
function s$e(t, e = !0) {
  for (; t.container; ) {
    const r = t.container;
    let n = r.content.indexOf(t);
    for (; n > 0; ) {
      n--;
      const i = r.content[n];
      if (e || !i.hidden)
        return i;
    }
    t = r;
  }
}
class Vae extends Error {
  constructor(e, r) {
    super(e ? `${r} at ${e.range.start.line}:${e.range.start.character}` : r);
  }
}
function Im(t) {
  throw new Error("Error! The input value was not handled.");
}
const Fv = "AbstractRule", zv = "AbstractType", a7 = "Condition", OU = "TypeDefinition", s7 = "ValueLiteral", Hp = "AbstractElement";
function o$e(t) {
  return Ir.isInstance(t, Hp);
}
const qv = "ArrayLiteral", Gv = "ArrayType", Wp = "BooleanLiteral";
function l$e(t) {
  return Ir.isInstance(t, Wp);
}
const Yp = "Conjunction";
function c$e(t) {
  return Ir.isInstance(t, Yp);
}
const Xp = "Disjunction";
function u$e(t) {
  return Ir.isInstance(t, Xp);
}
const Uv = "Grammar", o7 = "GrammarImport", jp = "InferredType";
function Hae(t) {
  return Ir.isInstance(t, jp);
}
const Kp = "Interface";
function Wae(t) {
  return Ir.isInstance(t, Kp);
}
const l7 = "NamedArgument", Zp = "Negation";
function h$e(t) {
  return Ir.isInstance(t, Zp);
}
const Vv = "NumberLiteral", Hv = "Parameter", Qp = "ParameterReference";
function f$e(t) {
  return Ir.isInstance(t, Qp);
}
const Jp = "ParserRule";
function os(t) {
  return Ir.isInstance(t, Jp);
}
const Wv = "ReferenceType", Zy = "ReturnType";
function d$e(t) {
  return Ir.isInstance(t, Zy);
}
const eg = "SimpleType";
function p$e(t) {
  return Ir.isInstance(t, eg);
}
const Yv = "StringLiteral", mf = "TerminalRule";
function $h(t) {
  return Ir.isInstance(t, mf);
}
const tg = "Type";
function Yae(t) {
  return Ir.isInstance(t, tg);
}
const c7 = "TypeAttribute", Xv = "UnionType", rg = "Action";
function f3(t) {
  return Ir.isInstance(t, rg);
}
const ng = "Alternatives";
function Xae(t) {
  return Ir.isInstance(t, ng);
}
const ig = "Assignment";
function sh(t) {
  return Ir.isInstance(t, ig);
}
const ag = "CharacterRange";
function g$e(t) {
  return Ir.isInstance(t, ag);
}
const sg = "CrossReference";
function YR(t) {
  return Ir.isInstance(t, sg);
}
const og = "EndOfFile";
function m$e(t) {
  return Ir.isInstance(t, og);
}
const lg = "Group";
function XR(t) {
  return Ir.isInstance(t, lg);
}
const cg = "Keyword";
function oh(t) {
  return Ir.isInstance(t, cg);
}
const ug = "NegatedToken";
function v$e(t) {
  return Ir.isInstance(t, ug);
}
const hg = "RegexToken";
function y$e(t) {
  return Ir.isInstance(t, hg);
}
const fg = "RuleCall";
function lh(t) {
  return Ir.isInstance(t, fg);
}
const dg = "TerminalAlternatives";
function b$e(t) {
  return Ir.isInstance(t, dg);
}
const pg = "TerminalGroup";
function x$e(t) {
  return Ir.isInstance(t, pg);
}
const gg = "TerminalRuleCall";
function w$e(t) {
  return Ir.isInstance(t, gg);
}
const mg = "UnorderedGroup";
function jae(t) {
  return Ir.isInstance(t, mg);
}
const vg = "UntilToken";
function T$e(t) {
  return Ir.isInstance(t, vg);
}
const yg = "Wildcard";
function E$e(t) {
  return Ir.isInstance(t, yg);
}
class Kae extends qae {
  getAllTypes() {
    return [Hp, Fv, zv, rg, ng, qv, Gv, ig, Wp, ag, a7, Yp, sg, Xp, og, Uv, o7, lg, jp, Kp, cg, l7, ug, Zp, Vv, Hv, Qp, Jp, Wv, hg, Zy, fg, eg, Yv, dg, pg, mf, gg, tg, c7, OU, Xv, mg, vg, s7, yg];
  }
  computeIsSubtype(e, r) {
    switch (e) {
      case rg:
      case ng:
      case ig:
      case ag:
      case sg:
      case og:
      case lg:
      case cg:
      case ug:
      case hg:
      case fg:
      case dg:
      case pg:
      case gg:
      case mg:
      case vg:
      case yg:
        return this.isSubtype(Hp, r);
      case qv:
      case Vv:
      case Yv:
        return this.isSubtype(s7, r);
      case Gv:
      case Wv:
      case eg:
      case Xv:
        return this.isSubtype(OU, r);
      case Wp:
        return this.isSubtype(a7, r) || this.isSubtype(s7, r);
      case Yp:
      case Xp:
      case Zp:
      case Qp:
        return this.isSubtype(a7, r);
      case jp:
      case Kp:
      case tg:
        return this.isSubtype(zv, r);
      case Jp:
        return this.isSubtype(Fv, r) || this.isSubtype(zv, r);
      case mf:
        return this.isSubtype(Fv, r);
      default:
        return !1;
    }
  }
  getReferenceType(e) {
    const r = `${e.container.$type}:${e.property}`;
    switch (r) {
      case "Action:type":
      case "CrossReference:type":
      case "Interface:superTypes":
      case "ParserRule:returnType":
      case "SimpleType:typeRef":
        return zv;
      case "Grammar:hiddenTokens":
      case "ParserRule:hiddenTokens":
      case "RuleCall:rule":
        return Fv;
      case "Grammar:usedGrammars":
        return Uv;
      case "NamedArgument:parameter":
      case "ParameterReference:parameter":
        return Hv;
      case "TerminalRuleCall:rule":
        return mf;
      default:
        throw new Error(`${r} is not a valid reference id.`);
    }
  }
  getTypeMetaData(e) {
    switch (e) {
      case Hp:
        return {
          name: Hp,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      case qv:
        return {
          name: qv,
          properties: [
            { name: "elements", defaultValue: [] }
          ]
        };
      case Gv:
        return {
          name: Gv,
          properties: [
            { name: "elementType" }
          ]
        };
      case Wp:
        return {
          name: Wp,
          properties: [
            { name: "true", defaultValue: !1 }
          ]
        };
      case Yp:
        return {
          name: Yp,
          properties: [
            { name: "left" },
            { name: "right" }
          ]
        };
      case Xp:
        return {
          name: Xp,
          properties: [
            { name: "left" },
            { name: "right" }
          ]
        };
      case Uv:
        return {
          name: Uv,
          properties: [
            { name: "definesHiddenTokens", defaultValue: !1 },
            { name: "hiddenTokens", defaultValue: [] },
            { name: "imports", defaultValue: [] },
            { name: "interfaces", defaultValue: [] },
            { name: "isDeclared", defaultValue: !1 },
            { name: "name" },
            { name: "rules", defaultValue: [] },
            { name: "types", defaultValue: [] },
            { name: "usedGrammars", defaultValue: [] }
          ]
        };
      case o7:
        return {
          name: o7,
          properties: [
            { name: "path" }
          ]
        };
      case jp:
        return {
          name: jp,
          properties: [
            { name: "name" }
          ]
        };
      case Kp:
        return {
          name: Kp,
          properties: [
            { name: "attributes", defaultValue: [] },
            { name: "name" },
            { name: "superTypes", defaultValue: [] }
          ]
        };
      case l7:
        return {
          name: l7,
          properties: [
            { name: "calledByName", defaultValue: !1 },
            { name: "parameter" },
            { name: "value" }
          ]
        };
      case Zp:
        return {
          name: Zp,
          properties: [
            { name: "value" }
          ]
        };
      case Vv:
        return {
          name: Vv,
          properties: [
            { name: "value" }
          ]
        };
      case Hv:
        return {
          name: Hv,
          properties: [
            { name: "name" }
          ]
        };
      case Qp:
        return {
          name: Qp,
          properties: [
            { name: "parameter" }
          ]
        };
      case Jp:
        return {
          name: Jp,
          properties: [
            { name: "dataType" },
            { name: "definesHiddenTokens", defaultValue: !1 },
            { name: "definition" },
            { name: "entry", defaultValue: !1 },
            { name: "fragment", defaultValue: !1 },
            { name: "hiddenTokens", defaultValue: [] },
            { name: "inferredType" },
            { name: "name" },
            { name: "parameters", defaultValue: [] },
            { name: "returnType" },
            { name: "wildcard", defaultValue: !1 }
          ]
        };
      case Wv:
        return {
          name: Wv,
          properties: [
            { name: "referenceType" }
          ]
        };
      case Zy:
        return {
          name: Zy,
          properties: [
            { name: "name" }
          ]
        };
      case eg:
        return {
          name: eg,
          properties: [
            { name: "primitiveType" },
            { name: "stringType" },
            { name: "typeRef" }
          ]
        };
      case Yv:
        return {
          name: Yv,
          properties: [
            { name: "value" }
          ]
        };
      case mf:
        return {
          name: mf,
          properties: [
            { name: "definition" },
            { name: "fragment", defaultValue: !1 },
            { name: "hidden", defaultValue: !1 },
            { name: "name" },
            { name: "type" }
          ]
        };
      case tg:
        return {
          name: tg,
          properties: [
            { name: "name" },
            { name: "type" }
          ]
        };
      case c7:
        return {
          name: c7,
          properties: [
            { name: "defaultValue" },
            { name: "isOptional", defaultValue: !1 },
            { name: "name" },
            { name: "type" }
          ]
        };
      case Xv:
        return {
          name: Xv,
          properties: [
            { name: "types", defaultValue: [] }
          ]
        };
      case rg:
        return {
          name: rg,
          properties: [
            { name: "cardinality" },
            { name: "feature" },
            { name: "inferredType" },
            { name: "lookahead" },
            { name: "operator" },
            { name: "type" }
          ]
        };
      case ng:
        return {
          name: ng,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case ig:
        return {
          name: ig,
          properties: [
            { name: "cardinality" },
            { name: "feature" },
            { name: "lookahead" },
            { name: "operator" },
            { name: "terminal" }
          ]
        };
      case ag:
        return {
          name: ag,
          properties: [
            { name: "cardinality" },
            { name: "left" },
            { name: "lookahead" },
            { name: "right" }
          ]
        };
      case sg:
        return {
          name: sg,
          properties: [
            { name: "cardinality" },
            { name: "deprecatedSyntax", defaultValue: !1 },
            { name: "lookahead" },
            { name: "terminal" },
            { name: "type" }
          ]
        };
      case og:
        return {
          name: og,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      case lg:
        return {
          name: lg,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "guardCondition" },
            { name: "lookahead" }
          ]
        };
      case cg:
        return {
          name: cg,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "value" }
          ]
        };
      case ug:
        return {
          name: ug,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "terminal" }
          ]
        };
      case hg:
        return {
          name: hg,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "regex" }
          ]
        };
      case fg:
        return {
          name: fg,
          properties: [
            { name: "arguments", defaultValue: [] },
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "rule" }
          ]
        };
      case dg:
        return {
          name: dg,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case pg:
        return {
          name: pg,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case gg:
        return {
          name: gg,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "rule" }
          ]
        };
      case mg:
        return {
          name: mg,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case vg:
        return {
          name: vg,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "terminal" }
          ]
        };
      case yg:
        return {
          name: yg,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      default:
        return {
          name: e,
          properties: []
        };
    }
  }
}
const Ir = new Kae();
function S$e(t) {
  for (const [e, r] of Object.entries(t))
    e.startsWith("$") || (Array.isArray(r) ? r.forEach((n, i) => {
      Ci(n) && (n.$container = t, n.$containerProperty = e, n.$containerIndex = i);
    }) : Ci(r) && (r.$container = t, r.$containerProperty = e));
}
function d3(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return r;
    r = r.$container;
  }
}
function Sc(t) {
  const r = FA(t).$document;
  if (!r)
    throw new Error("AST node has no document.");
  return r;
}
function FA(t) {
  for (; t.$container; )
    t = t.$container;
  return t;
}
function jR(t, e) {
  if (!t)
    throw new Error("Node must be an AstNode.");
  const r = e?.range;
  return new ui(() => ({
    keys: Object.keys(t),
    keyIndex: 0,
    arrayIndex: 0
  }), (n) => {
    for (; n.keyIndex < n.keys.length; ) {
      const i = n.keys[n.keyIndex];
      if (!i.startsWith("$")) {
        const a = t[i];
        if (Ci(a)) {
          if (n.keyIndex++, PU(a, r))
            return { done: !1, value: a };
        } else if (Array.isArray(a)) {
          for (; n.arrayIndex < a.length; ) {
            const s = n.arrayIndex++, o = a[s];
            if (Ci(o) && PU(o, r))
              return { done: !1, value: o };
          }
          n.arrayIndex = 0;
        }
      }
      n.keyIndex++;
    }
    return Ea;
  });
}
function Mm(t, e) {
  if (!t)
    throw new Error("Root node must be an AstNode.");
  return new WR(t, (r) => jR(r, e));
}
function Gf(t, e) {
  if (!t)
    throw new Error("Root node must be an AstNode.");
  return new WR(t, (r) => jR(r, e), { includeRoot: !0 });
}
function PU(t, e) {
  var r;
  if (!e)
    return !0;
  const n = (r = t.$cstNode) === null || r === void 0 ? void 0 : r.range;
  return n ? n$e(n, e) : !1;
}
function Zae(t) {
  return new ui(() => ({
    keys: Object.keys(t),
    keyIndex: 0,
    arrayIndex: 0
  }), (e) => {
    for (; e.keyIndex < e.keys.length; ) {
      const r = e.keys[e.keyIndex];
      if (!r.startsWith("$")) {
        const n = t[r];
        if (oo(n))
          return e.keyIndex++, { done: !1, value: { reference: n, container: t, property: r } };
        if (Array.isArray(n)) {
          for (; e.arrayIndex < n.length; ) {
            const i = e.arrayIndex++, a = n[i];
            if (oo(a))
              return { done: !1, value: { reference: a, container: t, property: r, index: i } };
          }
          e.arrayIndex = 0;
        }
      }
      e.keyIndex++;
    }
    return Ea;
  });
}
function k$e(t, e) {
  const r = t.getTypeMetaData(e.$type), n = e;
  for (const i of r.properties)
    i.defaultValue !== void 0 && n[i.name] === void 0 && (n[i.name] = Qae(i.defaultValue));
}
function Qae(t) {
  return Array.isArray(t) ? [...t.map(Qae)] : t;
}
function jt(t) {
  return t.charCodeAt(0);
}
function u7(t, e) {
  Array.isArray(t) ? t.forEach(function(r) {
    e.push(r);
  }) : e.push(t);
}
function Tp(t, e) {
  if (t[e] === !0)
    throw "duplicate flag " + e;
  t[e], t[e] = !0;
}
function cf(t) {
  if (t === void 0)
    throw Error("Internal Error - Should never get here!");
  return !0;
}
function C$e() {
  throw Error("Internal Error - Should never get here!");
}
function $U(t) {
  return t.type === "Character";
}
const Yb = [];
for (let t = jt("0"); t <= jt("9"); t++)
  Yb.push(t);
const Xb = [jt("_")].concat(Yb);
for (let t = jt("a"); t <= jt("z"); t++)
  Xb.push(t);
for (let t = jt("A"); t <= jt("Z"); t++)
  Xb.push(t);
const BU = [
  jt(" "),
  jt("\f"),
  jt(`
`),
  jt("\r"),
  jt("	"),
  jt("\v"),
  jt("	"),
  jt("\xA0"),
  jt("\u1680"),
  jt("\u2000"),
  jt("\u2001"),
  jt("\u2002"),
  jt("\u2003"),
  jt("\u2004"),
  jt("\u2005"),
  jt("\u2006"),
  jt("\u2007"),
  jt("\u2008"),
  jt("\u2009"),
  jt("\u200A"),
  jt("\u2028"),
  jt("\u2029"),
  jt("\u202F"),
  jt("\u205F"),
  jt("\u3000"),
  jt("\uFEFF")
], _$e = /[0-9a-fA-F]/, jv = /[0-9]/, A$e = /[1-9]/;
class Jae {
  constructor() {
    this.idx = 0, this.input = "", this.groupIdx = 0;
  }
  saveState() {
    return {
      idx: this.idx,
      input: this.input,
      groupIdx: this.groupIdx
    };
  }
  restoreState(e) {
    this.idx = e.idx, this.input = e.input, this.groupIdx = e.groupIdx;
  }
  pattern(e) {
    this.idx = 0, this.input = e, this.groupIdx = 0, this.consumeChar("/");
    const r = this.disjunction();
    this.consumeChar("/");
    const n = {
      type: "Flags",
      loc: { begin: this.idx, end: e.length },
      global: !1,
      ignoreCase: !1,
      multiLine: !1,
      unicode: !1,
      sticky: !1
    };
    for (; this.isRegExpFlag(); )
      switch (this.popChar()) {
        case "g":
          Tp(n, "global");
          break;
        case "i":
          Tp(n, "ignoreCase");
          break;
        case "m":
          Tp(n, "multiLine");
          break;
        case "u":
          Tp(n, "unicode");
          break;
        case "y":
          Tp(n, "sticky");
          break;
      }
    if (this.idx !== this.input.length)
      throw Error("Redundant input: " + this.input.substring(this.idx));
    return {
      type: "Pattern",
      flags: n,
      value: r,
      loc: this.loc(0)
    };
  }
  disjunction() {
    const e = [], r = this.idx;
    for (e.push(this.alternative()); this.peekChar() === "|"; )
      this.consumeChar("|"), e.push(this.alternative());
    return { type: "Disjunction", value: e, loc: this.loc(r) };
  }
  alternative() {
    const e = [], r = this.idx;
    for (; this.isTerm(); )
      e.push(this.term());
    return { type: "Alternative", value: e, loc: this.loc(r) };
  }
  term() {
    return this.isAssertion() ? this.assertion() : this.atom();
  }
  assertion() {
    const e = this.idx;
    switch (this.popChar()) {
      case "^":
        return {
          type: "StartAnchor",
          loc: this.loc(e)
        };
      case "$":
        return { type: "EndAnchor", loc: this.loc(e) };
      // '\b' or '\B'
      case "\\":
        switch (this.popChar()) {
          case "b":
            return {
              type: "WordBoundary",
              loc: this.loc(e)
            };
          case "B":
            return {
              type: "NonWordBoundary",
              loc: this.loc(e)
            };
        }
        throw Error("Invalid Assertion Escape");
      // '(?=' or '(?!'
      case "(":
        this.consumeChar("?");
        let r;
        switch (this.popChar()) {
          case "=":
            r = "Lookahead";
            break;
          case "!":
            r = "NegativeLookahead";
            break;
        }
        cf(r);
        const n = this.disjunction();
        return this.consumeChar(")"), {
          type: r,
          value: n,
          loc: this.loc(e)
        };
    }
    return C$e();
  }
  quantifier(e = !1) {
    let r;
    const n = this.idx;
    switch (this.popChar()) {
      case "*":
        r = {
          atLeast: 0,
          atMost: 1 / 0
        };
        break;
      case "+":
        r = {
          atLeast: 1,
          atMost: 1 / 0
        };
        break;
      case "?":
        r = {
          atLeast: 0,
          atMost: 1
        };
        break;
      case "{":
        const i = this.integerIncludingZero();
        switch (this.popChar()) {
          case "}":
            r = {
              atLeast: i,
              atMost: i
            };
            break;
          case ",":
            let a;
            this.isDigit() ? (a = this.integerIncludingZero(), r = {
              atLeast: i,
              atMost: a
            }) : r = {
              atLeast: i,
              atMost: 1 / 0
            }, this.consumeChar("}");
            break;
        }
        if (e === !0 && r === void 0)
          return;
        cf(r);
        break;
    }
    if (!(e === !0 && r === void 0) && cf(r))
      return this.peekChar(0) === "?" ? (this.consumeChar("?"), r.greedy = !1) : r.greedy = !0, r.type = "Quantifier", r.loc = this.loc(n), r;
  }
  atom() {
    let e;
    const r = this.idx;
    switch (this.peekChar()) {
      case ".":
        e = this.dotAll();
        break;
      case "\\":
        e = this.atomEscape();
        break;
      case "[":
        e = this.characterClass();
        break;
      case "(":
        e = this.group();
        break;
    }
    if (e === void 0 && this.isPatternCharacter() && (e = this.patternCharacter()), cf(e))
      return e.loc = this.loc(r), this.isQuantifier() && (e.quantifier = this.quantifier()), e;
  }
  dotAll() {
    return this.consumeChar("."), {
      type: "Set",
      complement: !0,
      value: [jt(`
`), jt("\r"), jt("\u2028"), jt("\u2029")]
    };
  }
  atomEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        return this.decimalEscapeAtom();
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  decimalEscapeAtom() {
    return { type: "GroupBackReference", value: this.positiveInteger() };
  }
  characterClassEscape() {
    let e, r = !1;
    switch (this.popChar()) {
      case "d":
        e = Yb;
        break;
      case "D":
        e = Yb, r = !0;
        break;
      case "s":
        e = BU;
        break;
      case "S":
        e = BU, r = !0;
        break;
      case "w":
        e = Xb;
        break;
      case "W":
        e = Xb, r = !0;
        break;
    }
    if (cf(e))
      return { type: "Set", value: e, complement: r };
  }
  controlEscapeAtom() {
    let e;
    switch (this.popChar()) {
      case "f":
        e = jt("\f");
        break;
      case "n":
        e = jt(`
`);
        break;
      case "r":
        e = jt("\r");
        break;
      case "t":
        e = jt("	");
        break;
      case "v":
        e = jt("\v");
        break;
    }
    if (cf(e))
      return { type: "Character", value: e };
  }
  controlLetterEscapeAtom() {
    this.consumeChar("c");
    const e = this.popChar();
    if (/[a-zA-Z]/.test(e) === !1)
      throw Error("Invalid ");
    return { type: "Character", value: e.toUpperCase().charCodeAt(0) - 64 };
  }
  nulCharacterAtom() {
    return this.consumeChar("0"), { type: "Character", value: jt("\0") };
  }
  hexEscapeSequenceAtom() {
    return this.consumeChar("x"), this.parseHexDigits(2);
  }
  regExpUnicodeEscapeSequenceAtom() {
    return this.consumeChar("u"), this.parseHexDigits(4);
  }
  identityEscapeAtom() {
    const e = this.popChar();
    return { type: "Character", value: jt(e) };
  }
  classPatternCharacterAtom() {
    switch (this.peekChar()) {
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
      // istanbul ignore next
      case "\\":
      // istanbul ignore next
      case "]":
        throw Error("TBD");
      default:
        const e = this.popChar();
        return { type: "Character", value: jt(e) };
    }
  }
  characterClass() {
    const e = [];
    let r = !1;
    for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), r = !0); this.isClassAtom(); ) {
      const n = this.classAtom();
      if (n.type, $U(n) && this.isRangeDash()) {
        this.consumeChar("-");
        const i = this.classAtom();
        if (i.type, $U(i)) {
          if (i.value < n.value)
            throw Error("Range out of order in character class");
          e.push({ from: n.value, to: i.value });
        } else
          u7(n.value, e), e.push(jt("-")), u7(i.value, e);
      } else
        u7(n.value, e);
    }
    return this.consumeChar("]"), { type: "Set", complement: r, value: e };
  }
  classAtom() {
    switch (this.peekChar()) {
      // istanbul ignore next
      case "]":
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
        throw Error("TBD");
      case "\\":
        return this.classEscape();
      default:
        return this.classPatternCharacterAtom();
    }
  }
  classEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      // Matches a backspace.
      // (Not to be confused with \b word boundary outside characterClass)
      case "b":
        return this.consumeChar("b"), { type: "Character", value: jt("\b") };
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  group() {
    let e = !0;
    switch (this.consumeChar("("), this.peekChar(0)) {
      case "?":
        this.consumeChar("?"), this.consumeChar(":"), e = !1;
        break;
      default:
        this.groupIdx++;
        break;
    }
    const r = this.disjunction();
    this.consumeChar(")");
    const n = {
      type: "Group",
      capturing: e,
      value: r
    };
    return e && (n.idx = this.groupIdx), n;
  }
  positiveInteger() {
    let e = this.popChar();
    if (A$e.test(e) === !1)
      throw Error("Expecting a positive integer");
    for (; jv.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  integerIncludingZero() {
    let e = this.popChar();
    if (jv.test(e) === !1)
      throw Error("Expecting an integer");
    for (; jv.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  patternCharacter() {
    const e = this.popChar();
    switch (e) {
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
      // istanbul ignore next
      case "^":
      // istanbul ignore next
      case "$":
      // istanbul ignore next
      case "\\":
      // istanbul ignore next
      case ".":
      // istanbul ignore next
      case "*":
      // istanbul ignore next
      case "+":
      // istanbul ignore next
      case "?":
      // istanbul ignore next
      case "(":
      // istanbul ignore next
      case ")":
      // istanbul ignore next
      case "[":
      // istanbul ignore next
      case "|":
        throw Error("TBD");
      default:
        return { type: "Character", value: jt(e) };
    }
  }
  isRegExpFlag() {
    switch (this.peekChar(0)) {
      case "g":
      case "i":
      case "m":
      case "u":
      case "y":
        return !0;
      default:
        return !1;
    }
  }
  isRangeDash() {
    return this.peekChar() === "-" && this.isClassAtom(1);
  }
  isDigit() {
    return jv.test(this.peekChar(0));
  }
  isClassAtom(e = 0) {
    switch (this.peekChar(e)) {
      case "]":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  isTerm() {
    return this.isAtom() || this.isAssertion();
  }
  isAtom() {
    if (this.isPatternCharacter())
      return !0;
    switch (this.peekChar(0)) {
      case ".":
      case "\\":
      // atomEscape
      case "[":
      // characterClass
      // TODO: isAtom must be called before isAssertion - disambiguate
      case "(":
        return !0;
      default:
        return !1;
    }
  }
  isAssertion() {
    switch (this.peekChar(0)) {
      case "^":
      case "$":
        return !0;
      // '\b' or '\B'
      case "\\":
        switch (this.peekChar(1)) {
          case "b":
          case "B":
            return !0;
          default:
            return !1;
        }
      // '(?=' or '(?!'
      case "(":
        return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
      default:
        return !1;
    }
  }
  isQuantifier() {
    const e = this.saveState();
    try {
      return this.quantifier(!0) !== void 0;
    } catch {
      return !1;
    } finally {
      this.restoreState(e);
    }
  }
  isPatternCharacter() {
    switch (this.peekChar()) {
      case "^":
      case "$":
      case "\\":
      case ".":
      case "*":
      case "+":
      case "?":
      case "(":
      case ")":
      case "[":
      case "|":
      case "/":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  parseHexDigits(e) {
    let r = "";
    for (let i = 0; i < e; i++) {
      const a = this.popChar();
      if (_$e.test(a) === !1)
        throw Error("Expecting a HexDecimal digits");
      r += a;
    }
    return { type: "Character", value: parseInt(r, 16) };
  }
  peekChar(e = 0) {
    return this.input[this.idx + e];
  }
  popChar() {
    const e = this.peekChar(0);
    return this.consumeChar(void 0), e;
  }
  consumeChar(e) {
    if (e !== void 0 && this.input[this.idx] !== e)
      throw Error("Expected: '" + e + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
    if (this.idx >= this.input.length)
      throw Error("Unexpected end of input");
    this.idx++;
  }
  loc(e) {
    return { begin: e, end: this.idx };
  }
}
class p3 {
  visitChildren(e) {
    for (const r in e) {
      const n = e[r];
      e.hasOwnProperty(r) && (n.type !== void 0 ? this.visit(n) : Array.isArray(n) && n.forEach((i) => {
        this.visit(i);
      }, this));
    }
  }
  visit(e) {
    switch (e.type) {
      case "Pattern":
        this.visitPattern(e);
        break;
      case "Flags":
        this.visitFlags(e);
        break;
      case "Disjunction":
        this.visitDisjunction(e);
        break;
      case "Alternative":
        this.visitAlternative(e);
        break;
      case "StartAnchor":
        this.visitStartAnchor(e);
        break;
      case "EndAnchor":
        this.visitEndAnchor(e);
        break;
      case "WordBoundary":
        this.visitWordBoundary(e);
        break;
      case "NonWordBoundary":
        this.visitNonWordBoundary(e);
        break;
      case "Lookahead":
        this.visitLookahead(e);
        break;
      case "NegativeLookahead":
        this.visitNegativeLookahead(e);
        break;
      case "Character":
        this.visitCharacter(e);
        break;
      case "Set":
        this.visitSet(e);
        break;
      case "Group":
        this.visitGroup(e);
        break;
      case "GroupBackReference":
        this.visitGroupBackReference(e);
        break;
      case "Quantifier":
        this.visitQuantifier(e);
        break;
    }
    this.visitChildren(e);
  }
  visitPattern(e) {
  }
  visitFlags(e) {
  }
  visitDisjunction(e) {
  }
  visitAlternative(e) {
  }
  // Assertion
  visitStartAnchor(e) {
  }
  visitEndAnchor(e) {
  }
  visitWordBoundary(e) {
  }
  visitNonWordBoundary(e) {
  }
  visitLookahead(e) {
  }
  visitNegativeLookahead(e) {
  }
  // atoms
  visitCharacter(e) {
  }
  visitSet(e) {
  }
  visitGroup(e) {
  }
  visitGroupBackReference(e) {
  }
  visitQuantifier(e) {
  }
}
const L$e = /\r?\n/gm, R$e = new Jae();
class I$e extends p3 {
  constructor() {
    super(...arguments), this.isStarting = !0, this.endRegexpStack = [], this.multiline = !1;
  }
  get endRegex() {
    return this.endRegexpStack.join("");
  }
  reset(e) {
    this.multiline = !1, this.regex = e, this.startRegexp = "", this.isStarting = !0, this.endRegexpStack = [];
  }
  visitGroup(e) {
    e.quantifier && (this.isStarting = !1, this.endRegexpStack = []);
  }
  visitCharacter(e) {
    const r = String.fromCharCode(e.value);
    if (!this.multiline && r === `
` && (this.multiline = !0), e.quantifier)
      this.isStarting = !1, this.endRegexpStack = [];
    else {
      const n = g3(r);
      this.endRegexpStack.push(n), this.isStarting && (this.startRegexp += n);
    }
  }
  visitSet(e) {
    if (!this.multiline) {
      const r = this.regex.substring(e.loc.begin, e.loc.end), n = new RegExp(r);
      this.multiline = !!`
`.match(n);
    }
    if (e.quantifier)
      this.isStarting = !1, this.endRegexpStack = [];
    else {
      const r = this.regex.substring(e.loc.begin, e.loc.end);
      this.endRegexpStack.push(r), this.isStarting && (this.startRegexp += r);
    }
  }
  visitChildren(e) {
    e.type === "Group" && e.quantifier || super.visitChildren(e);
  }
}
const h7 = new I$e();
function M$e(t) {
  try {
    return typeof t == "string" && (t = new RegExp(t)), t = t.toString(), h7.reset(t), h7.visit(R$e.pattern(t)), h7.multiline;
  } catch {
    return !1;
  }
}
const N$e = `\f
\r	\v \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF`.split("");
function zA(t) {
  const e = typeof t == "string" ? new RegExp(t) : t;
  return N$e.some((r) => e.test(r));
}
function g3(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function D$e(t) {
  return Array.prototype.map.call(t, (e) => /\w/.test(e) ? `[${e.toLowerCase()}${e.toUpperCase()}]` : g3(e)).join("");
}
function O$e(t, e) {
  const r = P$e(t), n = e.match(r);
  return !!n && n[0].length > 0;
}
function P$e(t) {
  typeof t == "string" && (t = new RegExp(t));
  const e = t, r = t.source;
  let n = 0;
  function i() {
    let a = "", s;
    function o(u) {
      a += r.substr(n, u), n += u;
    }
    function l(u) {
      a += "(?:" + r.substr(n, u) + "|$)", n += u;
    }
    for (; n < r.length; )
      switch (r[n]) {
        case "\\":
          switch (r[n + 1]) {
            case "c":
              l(3);
              break;
            case "x":
              l(4);
              break;
            case "u":
              e.unicode ? r[n + 2] === "{" ? l(r.indexOf("}", n) - n + 1) : l(6) : l(2);
              break;
            case "p":
            case "P":
              e.unicode ? l(r.indexOf("}", n) - n + 1) : l(2);
              break;
            case "k":
              l(r.indexOf(">", n) - n + 1);
              break;
            default:
              l(2);
              break;
          }
          break;
        case "[":
          s = /\[(?:\\.|.)*?\]/g, s.lastIndex = n, s = s.exec(r) || [], l(s[0].length);
          break;
        case "|":
        case "^":
        case "$":
        case "*":
        case "+":
        case "?":
          o(1);
          break;
        case "{":
          s = /\{\d+,?\d*\}/g, s.lastIndex = n, s = s.exec(r), s ? o(s[0].length) : l(1);
          break;
        case "(":
          if (r[n + 1] === "?")
            switch (r[n + 2]) {
              case ":":
                a += "(?:", n += 3, a += i() + "|$)";
                break;
              case "=":
                a += "(?=", n += 3, a += i() + ")";
                break;
              case "!":
                s = n, n += 3, i(), a += r.substr(s, n - s);
                break;
              case "<":
                switch (r[n + 3]) {
                  case "=":
                  case "!":
                    s = n, n += 4, i(), a += r.substr(s, n - s);
                    break;
                  default:
                    o(r.indexOf(">", n) - n + 1), a += i() + "|$)";
                    break;
                }
                break;
            }
          else
            o(1), a += i() + "|$)";
          break;
        case ")":
          return ++n, a;
        default:
          l(1);
          break;
      }
    return a;
  }
  return new RegExp(i(), t.flags);
}
function $$e(t) {
  return t.rules.find((e) => os(e) && e.entry);
}
function B$e(t) {
  return t.rules.filter((e) => $h(e) && e.hidden);
}
function ese(t, e) {
  const r = /* @__PURE__ */ new Set(), n = $$e(t);
  if (!n)
    return new Set(t.rules);
  const i = [n].concat(B$e(t));
  for (const s of i)
    tse(s, r, e);
  const a = /* @__PURE__ */ new Set();
  for (const s of t.rules)
    (r.has(s.name) || $h(s) && s.hidden) && a.add(s);
  return a;
}
function tse(t, e, r) {
  e.add(t.name), Mm(t).forEach((n) => {
    if (lh(n) || r) {
      const i = n.rule.ref;
      i && !e.has(i.name) && tse(i, e, r);
    }
  });
}
function F$e(t) {
  if (t.terminal)
    return t.terminal;
  if (t.type.ref) {
    const e = nse(t.type.ref);
    return e?.terminal;
  }
}
function z$e(t) {
  return t.hidden && !zA(JR(t));
}
function q$e(t, e) {
  return !t || !e ? [] : KR(t, e, t.astNode, !0);
}
function rse(t, e, r) {
  if (!t || !e)
    return;
  const n = KR(t, e, t.astNode, !0);
  if (n.length !== 0)
    return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
}
function KR(t, e, r, n) {
  if (!n) {
    const i = d3(t.grammarSource, sh);
    if (i && i.feature === e)
      return [t];
  }
  return N1(t) && t.astNode === r ? t.content.flatMap((i) => KR(i, e, r, !1)) : [];
}
function G$e(t, e, r) {
  if (!t)
    return;
  const n = U$e(t, e, t?.astNode);
  if (n.length !== 0)
    return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
}
function U$e(t, e, r) {
  if (t.astNode !== r)
    return [];
  if (oh(t.grammarSource) && t.grammarSource.value === e)
    return [t];
  const n = $A(t).iterator();
  let i;
  const a = [];
  do
    if (i = n.next(), !i.done) {
      const s = i.value;
      s.astNode === r ? oh(s.grammarSource) && s.grammarSource.value === e && a.push(s) : n.prune();
    }
  while (!i.done);
  return a;
}
function V$e(t) {
  var e;
  const r = t.astNode;
  for (; r === ((e = t.container) === null || e === void 0 ? void 0 : e.astNode); ) {
    const n = d3(t.grammarSource, sh);
    if (n)
      return n;
    t = t.container;
  }
}
function nse(t) {
  let e = t;
  return Hae(e) && (f3(e.$container) ? e = e.$container.$container : os(e.$container) ? e = e.$container : Im(e.$container)), ise(t, e, /* @__PURE__ */ new Map());
}
function ise(t, e, r) {
  var n;
  function i(a, s) {
    let o;
    return d3(a, sh) || (o = ise(s, s, r)), r.set(t, o), o;
  }
  if (r.has(t))
    return r.get(t);
  r.set(t, void 0);
  for (const a of Mm(e)) {
    if (sh(a) && a.feature.toLowerCase() === "name")
      return r.set(t, a), a;
    if (lh(a) && os(a.rule.ref))
      return i(a, a.rule.ref);
    if (p$e(a) && (!((n = a.typeRef) === null || n === void 0) && n.ref))
      return i(a, a.typeRef.ref);
  }
}
function ase(t) {
  return sse(t, /* @__PURE__ */ new Set());
}
function sse(t, e) {
  if (e.has(t))
    return !0;
  e.add(t);
  for (const r of Mm(t))
    if (lh(r)) {
      if (!r.rule.ref || os(r.rule.ref) && !sse(r.rule.ref, e))
        return !1;
    } else {
      if (sh(r))
        return !1;
      if (f3(r))
        return !1;
    }
  return !!t.definition;
}
function ZR(t) {
  if (t.inferredType)
    return t.inferredType.name;
  if (t.dataType)
    return t.dataType;
  if (t.returnType) {
    const e = t.returnType.ref;
    if (e) {
      if (os(e))
        return e.name;
      if (Wae(e) || Yae(e))
        return e.name;
    }
  }
}
function QR(t) {
  var e;
  if (os(t))
    return ase(t) ? t.name : (e = ZR(t)) !== null && e !== void 0 ? e : t.name;
  if (Wae(t) || Yae(t) || d$e(t))
    return t.name;
  if (f3(t)) {
    const r = H$e(t);
    if (r)
      return r;
  } else if (Hae(t))
    return t.name;
  throw new Error("Cannot get name of Unknown Type");
}
function H$e(t) {
  var e;
  if (t.inferredType)
    return t.inferredType.name;
  if (!((e = t.type) === null || e === void 0) && e.ref)
    return QR(t.type.ref);
}
function W$e(t) {
  var e, r, n;
  return $h(t) ? (r = (e = t.type) === null || e === void 0 ? void 0 : e.name) !== null && r !== void 0 ? r : "string" : (n = ZR(t)) !== null && n !== void 0 ? n : t.name;
}
function JR(t) {
  const e = {
    s: !1,
    i: !1,
    u: !1
  }, r = X0(t.definition, e), n = Object.entries(e).filter(([, i]) => i).map(([i]) => i).join("");
  return new RegExp(r, n);
}
const eI = /[\s\S]/.source;
function X0(t, e) {
  if (b$e(t))
    return Y$e(t);
  if (x$e(t))
    return X$e(t);
  if (g$e(t))
    return Z$e(t);
  if (w$e(t)) {
    const r = t.rule.ref;
    if (!r)
      throw new Error("Missing rule reference.");
    return cl(X0(r.definition), {
      cardinality: t.cardinality,
      lookahead: t.lookahead
    });
  } else {
    if (v$e(t))
      return K$e(t);
    if (T$e(t))
      return j$e(t);
    if (y$e(t)) {
      const r = t.regex.lastIndexOf("/"), n = t.regex.substring(1, r), i = t.regex.substring(r + 1);
      return e && (e.i = i.includes("i"), e.s = i.includes("s"), e.u = i.includes("u")), cl(n, {
        cardinality: t.cardinality,
        lookahead: t.lookahead,
        wrap: !1
      });
    } else {
      if (E$e(t))
        return cl(eI, {
          cardinality: t.cardinality,
          lookahead: t.lookahead
        });
      throw new Error(`Invalid terminal element: ${t?.$type}`);
    }
  }
}
function Y$e(t) {
  return cl(t.elements.map((e) => X0(e)).join("|"), {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function X$e(t) {
  return cl(t.elements.map((e) => X0(e)).join(""), {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function j$e(t) {
  return cl(`${eI}*?${X0(t.terminal)}`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function K$e(t) {
  return cl(`(?!${X0(t.terminal)})${eI}*?`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function Z$e(t) {
  return t.right ? cl(`[${f7(t.left)}-${f7(t.right)}]`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead,
    wrap: !1
  }) : cl(f7(t.left), {
    cardinality: t.cardinality,
    lookahead: t.lookahead,
    wrap: !1
  });
}
function f7(t) {
  return g3(t.value);
}
function cl(t, e) {
  var r;
  return (e.wrap !== !1 || e.lookahead) && (t = `(${(r = e.lookahead) !== null && r !== void 0 ? r : ""}${t})`), e.cardinality ? `${t}${e.cardinality}` : t;
}
function Q$e(t) {
  const e = [], r = t.Grammar;
  for (const n of r.rules)
    $h(n) && z$e(n) && M$e(JR(n)) && e.push(n.name);
  return {
    multilineCommentRules: e,
    nameRegexp: i$e
  };
}
var ose = typeof global == "object" && global && global.Object === Object && global, J$e = typeof self == "object" && self && self.Object === Object && self, Ao = ose || J$e || Function("return this")(), ls = Ao.Symbol, lse = Object.prototype, eBe = lse.hasOwnProperty, tBe = lse.toString, Ep = ls ? ls.toStringTag : void 0;
function rBe(t) {
  var e = eBe.call(t, Ep), r = t[Ep];
  try {
    t[Ep] = void 0;
    var n = !0;
  } catch {
  }
  var i = tBe.call(t);
  return n && (e ? t[Ep] = r : delete t[Ep]), i;
}
var nBe = Object.prototype, iBe = nBe.toString;
function aBe(t) {
  return iBe.call(t);
}
var sBe = "[object Null]", oBe = "[object Undefined]", FU = ls ? ls.toStringTag : void 0;
function Xc(t) {
  return t == null ? t === void 0 ? oBe : sBe : FU && FU in Object(t) ? rBe(t) : aBe(t);
}
function Os(t) {
  return t != null && typeof t == "object";
}
var lBe = "[object Symbol]";
function m3(t) {
  return typeof t == "symbol" || Os(t) && Xc(t) == lBe;
}
function v3(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
var xr = Array.isArray, zU = ls ? ls.prototype : void 0, qU = zU ? zU.toString : void 0;
function cse(t) {
  if (typeof t == "string")
    return t;
  if (xr(t))
    return v3(t, cse) + "";
  if (m3(t))
    return qU ? qU.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var cBe = /\s/;
function uBe(t) {
  for (var e = t.length; e-- && cBe.test(t.charAt(e)); )
    ;
  return e;
}
var hBe = /^\s+/;
function fBe(t) {
  return t && t.slice(0, uBe(t) + 1).replace(hBe, "");
}
function cs(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var GU = NaN, dBe = /^[-+]0x[0-9a-f]+$/i, pBe = /^0b[01]+$/i, gBe = /^0o[0-7]+$/i, mBe = parseInt;
function vBe(t) {
  if (typeof t == "number")
    return t;
  if (m3(t))
    return GU;
  if (cs(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = cs(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = fBe(t);
  var r = pBe.test(t);
  return r || gBe.test(t) ? mBe(t.slice(2), r ? 2 : 8) : dBe.test(t) ? GU : +t;
}
var UU = 1 / 0, yBe = 17976931348623157e292;
function bBe(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = vBe(t), t === UU || t === -UU) {
    var e = t < 0 ? -1 : 1;
    return e * yBe;
  }
  return t === t ? t : 0;
}
function y3(t) {
  var e = bBe(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function d0(t) {
  return t;
}
var xBe = "[object AsyncFunction]", wBe = "[object Function]", TBe = "[object GeneratorFunction]", EBe = "[object Proxy]";
function Ml(t) {
  if (!cs(t))
    return !1;
  var e = Xc(t);
  return e == wBe || e == TBe || e == xBe || e == EBe;
}
var d7 = Ao["__core-js_shared__"], VU = (function() {
  var t = /[^.]+$/.exec(d7 && d7.keys && d7.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
})();
function SBe(t) {
  return !!VU && VU in t;
}
var kBe = Function.prototype, CBe = kBe.toString;
function Bh(t) {
  if (t != null) {
    try {
      return CBe.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var _Be = /[\\^$.*+?()[\]{}|]/g, ABe = /^\[object .+?Constructor\]$/, LBe = Function.prototype, RBe = Object.prototype, IBe = LBe.toString, MBe = RBe.hasOwnProperty, NBe = RegExp(
  "^" + IBe.call(MBe).replace(_Be, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function DBe(t) {
  if (!cs(t) || SBe(t))
    return !1;
  var e = Ml(t) ? NBe : ABe;
  return e.test(Bh(t));
}
function OBe(t, e) {
  return t?.[e];
}
function Fh(t, e) {
  var r = OBe(t, e);
  return DBe(r) ? r : void 0;
}
var qA = Fh(Ao, "WeakMap"), HU = Object.create, PBe = /* @__PURE__ */ (function() {
  function t() {
  }
  return function(e) {
    if (!cs(e))
      return {};
    if (HU)
      return HU(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
})();
function $Be(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
function Pn() {
}
function BBe(t, e) {
  var r = -1, n = t.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t[r];
  return e;
}
var FBe = 800, zBe = 16, qBe = Date.now;
function GBe(t) {
  var e = 0, r = 0;
  return function() {
    var n = qBe(), i = zBe - (n - r);
    if (r = n, i > 0) {
      if (++e >= FBe)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function UBe(t) {
  return function() {
    return t;
  };
}
var jb = (function() {
  try {
    var t = Fh(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
})(), VBe = jb ? function(t, e) {
  return jb(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: UBe(e),
    writable: !0
  });
} : d0, HBe = GBe(VBe);
function use(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
function hse(t, e, r, n) {
  for (var i = t.length, a = r + -1; ++a < i; )
    if (e(t[a], a, t))
      return a;
  return -1;
}
function WBe(t) {
  return t !== t;
}
function YBe(t, e, r) {
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
function tI(t, e, r) {
  return e === e ? YBe(t, e, r) : hse(t, WBe, r);
}
function fse(t, e) {
  var r = t == null ? 0 : t.length;
  return !!r && tI(t, e, 0) > -1;
}
var XBe = 9007199254740991, jBe = /^(?:0|[1-9]\d*)$/;
function b3(t, e) {
  var r = typeof t;
  return e = e ?? XBe, !!e && (r == "number" || r != "symbol" && jBe.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function rI(t, e, r) {
  e == "__proto__" && jb ? jb(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
function Nm(t, e) {
  return t === e || t !== t && e !== e;
}
var KBe = Object.prototype, ZBe = KBe.hasOwnProperty;
function x3(t, e, r) {
  var n = t[e];
  (!(ZBe.call(t, e) && Nm(n, r)) || r === void 0 && !(e in t)) && rI(t, e, r);
}
function Dm(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, s = e.length; ++a < s; ) {
    var o = e[a], l = void 0;
    l === void 0 && (l = t[o]), i ? rI(r, o, l) : x3(r, o, l);
  }
  return r;
}
var WU = Math.max;
function QBe(t, e, r) {
  return e = WU(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, a = WU(n.length - e, 0), s = Array(a); ++i < a; )
      s[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(s), $Be(t, this, o);
  };
}
function nI(t, e) {
  return HBe(QBe(t, e, d0), t + "");
}
var JBe = 9007199254740991;
function iI(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= JBe;
}
function Lo(t) {
  return t != null && iI(t.length) && !Ml(t);
}
function dse(t, e, r) {
  if (!cs(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? Lo(r) && b3(e, r.length) : n == "string" && e in r) ? Nm(r[e], t) : !1;
}
function eFe(t) {
  return nI(function(e, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && dse(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t(e, o, n, a);
    }
    return e;
  });
}
var tFe = Object.prototype;
function Om(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || tFe;
  return t === r;
}
function rFe(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var nFe = "[object Arguments]";
function YU(t) {
  return Os(t) && Xc(t) == nFe;
}
var pse = Object.prototype, iFe = pse.hasOwnProperty, aFe = pse.propertyIsEnumerable, w3 = YU(/* @__PURE__ */ (function() {
  return arguments;
})()) ? YU : function(t) {
  return Os(t) && iFe.call(t, "callee") && !aFe.call(t, "callee");
};
function sFe() {
  return !1;
}
var gse = typeof exports == "object" && exports && !exports.nodeType && exports, XU = gse && typeof module == "object" && module && !module.nodeType && module, oFe = XU && XU.exports === gse, jU = oFe ? Ao.Buffer : void 0, lFe = jU ? jU.isBuffer : void 0, D1 = lFe || sFe, cFe = "[object Arguments]", uFe = "[object Array]", hFe = "[object Boolean]", fFe = "[object Date]", dFe = "[object Error]", pFe = "[object Function]", gFe = "[object Map]", mFe = "[object Number]", vFe = "[object Object]", yFe = "[object RegExp]", bFe = "[object Set]", xFe = "[object String]", wFe = "[object WeakMap]", TFe = "[object ArrayBuffer]", EFe = "[object DataView]", SFe = "[object Float32Array]", kFe = "[object Float64Array]", CFe = "[object Int8Array]", _Fe = "[object Int16Array]", AFe = "[object Int32Array]", LFe = "[object Uint8Array]", RFe = "[object Uint8ClampedArray]", IFe = "[object Uint16Array]", MFe = "[object Uint32Array]", Wr = {};
Wr[SFe] = Wr[kFe] = Wr[CFe] = Wr[_Fe] = Wr[AFe] = Wr[LFe] = Wr[RFe] = Wr[IFe] = Wr[MFe] = !0;
Wr[cFe] = Wr[uFe] = Wr[TFe] = Wr[hFe] = Wr[EFe] = Wr[fFe] = Wr[dFe] = Wr[pFe] = Wr[gFe] = Wr[mFe] = Wr[vFe] = Wr[yFe] = Wr[bFe] = Wr[xFe] = Wr[wFe] = !1;
function NFe(t) {
  return Os(t) && iI(t.length) && !!Wr[Xc(t)];
}
function T3(t) {
  return function(e) {
    return t(e);
  };
}
var mse = typeof exports == "object" && exports && !exports.nodeType && exports, Hg = mse && typeof module == "object" && module && !module.nodeType && module, DFe = Hg && Hg.exports === mse, p7 = DFe && ose.process, kc = (function() {
  try {
    var t = Hg && Hg.require && Hg.require("util").types;
    return t || p7 && p7.binding && p7.binding("util");
  } catch {
  }
})(), KU = kc && kc.isTypedArray, aI = KU ? T3(KU) : NFe, OFe = Object.prototype, PFe = OFe.hasOwnProperty;
function vse(t, e) {
  var r = xr(t), n = !r && w3(t), i = !r && !n && D1(t), a = !r && !n && !i && aI(t), s = r || n || i || a, o = s ? rFe(t.length, String) : [], l = o.length;
  for (var u in t)
    (e || PFe.call(t, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    b3(u, l))) && o.push(u);
  return o;
}
function yse(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var $Fe = yse(Object.keys, Object), BFe = Object.prototype, FFe = BFe.hasOwnProperty;
function bse(t) {
  if (!Om(t))
    return $Fe(t);
  var e = [];
  for (var r in Object(t))
    FFe.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
function us(t) {
  return Lo(t) ? vse(t) : bse(t);
}
var zFe = Object.prototype, qFe = zFe.hasOwnProperty, GA = eFe(function(t, e) {
  if (Om(e) || Lo(e)) {
    Dm(e, us(e), t);
    return;
  }
  for (var r in e)
    qFe.call(e, r) && x3(t, r, e[r]);
});
function GFe(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var UFe = Object.prototype, VFe = UFe.hasOwnProperty;
function HFe(t) {
  if (!cs(t))
    return GFe(t);
  var e = Om(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !VFe.call(t, n)) || r.push(n);
  return r;
}
function sI(t) {
  return Lo(t) ? vse(t, !0) : HFe(t);
}
var WFe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, YFe = /^\w*$/;
function oI(t, e) {
  if (xr(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || m3(t) ? !0 : YFe.test(t) || !WFe.test(t) || e != null && t in Object(e);
}
var O1 = Fh(Object, "create");
function XFe() {
  this.__data__ = O1 ? O1(null) : {}, this.size = 0;
}
function jFe(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var KFe = "__lodash_hash_undefined__", ZFe = Object.prototype, QFe = ZFe.hasOwnProperty;
function JFe(t) {
  var e = this.__data__;
  if (O1) {
    var r = e[t];
    return r === KFe ? void 0 : r;
  }
  return QFe.call(e, t) ? e[t] : void 0;
}
var eze = Object.prototype, tze = eze.hasOwnProperty;
function rze(t) {
  var e = this.__data__;
  return O1 ? e[t] !== void 0 : tze.call(e, t);
}
var nze = "__lodash_hash_undefined__";
function ize(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = O1 && e === void 0 ? nze : e, this;
}
function ch(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
ch.prototype.clear = XFe;
ch.prototype.delete = jFe;
ch.prototype.get = JFe;
ch.prototype.has = rze;
ch.prototype.set = ize;
function aze() {
  this.__data__ = [], this.size = 0;
}
function E3(t, e) {
  for (var r = t.length; r--; )
    if (Nm(t[r][0], e))
      return r;
  return -1;
}
var sze = Array.prototype, oze = sze.splice;
function lze(t) {
  var e = this.__data__, r = E3(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : oze.call(e, r, 1), --this.size, !0;
}
function cze(t) {
  var e = this.__data__, r = E3(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function uze(t) {
  return E3(this.__data__, t) > -1;
}
function hze(t, e) {
  var r = this.__data__, n = E3(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
function Nl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Nl.prototype.clear = aze;
Nl.prototype.delete = lze;
Nl.prototype.get = cze;
Nl.prototype.has = uze;
Nl.prototype.set = hze;
var P1 = Fh(Ao, "Map");
function fze() {
  this.size = 0, this.__data__ = {
    hash: new ch(),
    map: new (P1 || Nl)(),
    string: new ch()
  };
}
function dze(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function S3(t, e) {
  var r = t.__data__;
  return dze(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function pze(t) {
  var e = S3(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function gze(t) {
  return S3(this, t).get(t);
}
function mze(t) {
  return S3(this, t).has(t);
}
function vze(t, e) {
  var r = S3(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
function Dl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Dl.prototype.clear = fze;
Dl.prototype.delete = pze;
Dl.prototype.get = gze;
Dl.prototype.has = mze;
Dl.prototype.set = vze;
var yze = "Expected a function";
function lI(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(yze);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = t.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (lI.Cache || Dl)(), r;
}
lI.Cache = Dl;
var bze = 500;
function xze(t) {
  var e = lI(t, function(n) {
    return r.size === bze && r.clear(), n;
  }), r = e.cache;
  return e;
}
var wze = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Tze = /\\(\\)?/g, Eze = xze(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(wze, function(r, n, i, a) {
    e.push(i ? a.replace(Tze, "$1") : n || r);
  }), e;
});
function Sze(t) {
  return t == null ? "" : cse(t);
}
function k3(t, e) {
  return xr(t) ? t : oI(t, e) ? [t] : Eze(Sze(t));
}
function Pm(t) {
  if (typeof t == "string" || m3(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function cI(t, e) {
  e = k3(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[Pm(e[r++])];
  return r && r == n ? t : void 0;
}
function kze(t, e, r) {
  var n = t == null ? void 0 : cI(t, e);
  return n === void 0 ? r : n;
}
function uI(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n; )
    t[i + r] = e[r];
  return t;
}
var ZU = ls ? ls.isConcatSpreadable : void 0;
function Cze(t) {
  return xr(t) || w3(t) || !!(ZU && t && t[ZU]);
}
function hI(t, e, r, n, i) {
  var a = -1, s = t.length;
  for (r || (r = Cze), i || (i = []); ++a < s; ) {
    var o = t[a];
    r(o) ? uI(i, o) : n || (i[i.length] = o);
  }
  return i;
}
function Ls(t) {
  var e = t == null ? 0 : t.length;
  return e ? hI(t) : [];
}
var xse = yse(Object.getPrototypeOf, Object);
function wse(t, e, r) {
  var n = -1, i = t.length;
  e < 0 && (e = -e > i ? 0 : i + e), r = r > i ? i : r, r < 0 && (r += i), i = e > r ? 0 : r - e >>> 0, e >>>= 0;
  for (var a = Array(i); ++n < i; )
    a[n] = t[n + e];
  return a;
}
function _ze(t, e, r, n) {
  var i = -1, a = t == null ? 0 : t.length;
  for (n && a && (r = t[++i]); ++i < a; )
    r = e(r, t[i], i, t);
  return r;
}
function Aze() {
  this.__data__ = new Nl(), this.size = 0;
}
function Lze(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function Rze(t) {
  return this.__data__.get(t);
}
function Ize(t) {
  return this.__data__.has(t);
}
var Mze = 200;
function Nze(t, e) {
  var r = this.__data__;
  if (r instanceof Nl) {
    var n = r.__data__;
    if (!P1 || n.length < Mze - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new Dl(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
function ho(t) {
  var e = this.__data__ = new Nl(t);
  this.size = e.size;
}
ho.prototype.clear = Aze;
ho.prototype.delete = Lze;
ho.prototype.get = Rze;
ho.prototype.has = Ize;
ho.prototype.set = Nze;
function Dze(t, e) {
  return t && Dm(e, us(e), t);
}
function Oze(t, e) {
  return t && Dm(e, sI(e), t);
}
var Tse = typeof exports == "object" && exports && !exports.nodeType && exports, QU = Tse && typeof module == "object" && module && !module.nodeType && module, Pze = QU && QU.exports === Tse, JU = Pze ? Ao.Buffer : void 0, eV = JU ? JU.allocUnsafe : void 0;
function $ze(t, e) {
  var r = t.length, n = eV ? eV(r) : new t.constructor(r);
  return t.copy(n), n;
}
function fI(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n; ) {
    var s = t[r];
    e(s, r, t) && (a[i++] = s);
  }
  return a;
}
function Ese() {
  return [];
}
var Bze = Object.prototype, Fze = Bze.propertyIsEnumerable, tV = Object.getOwnPropertySymbols, dI = tV ? function(t) {
  return t == null ? [] : (t = Object(t), fI(tV(t), function(e) {
    return Fze.call(t, e);
  }));
} : Ese;
function zze(t, e) {
  return Dm(t, dI(t), e);
}
var qze = Object.getOwnPropertySymbols, Sse = qze ? function(t) {
  for (var e = []; t; )
    uI(e, dI(t)), t = xse(t);
  return e;
} : Ese;
function Gze(t, e) {
  return Dm(t, Sse(t), e);
}
function kse(t, e, r) {
  var n = e(t);
  return xr(t) ? n : uI(n, r(t));
}
function UA(t) {
  return kse(t, us, dI);
}
function Uze(t) {
  return kse(t, sI, Sse);
}
var VA = Fh(Ao, "DataView"), HA = Fh(Ao, "Promise"), Uf = Fh(Ao, "Set"), rV = "[object Map]", Vze = "[object Object]", nV = "[object Promise]", iV = "[object Set]", aV = "[object WeakMap]", sV = "[object DataView]", Hze = Bh(VA), Wze = Bh(P1), Yze = Bh(HA), Xze = Bh(Uf), jze = Bh(qA), Ya = Xc;
(VA && Ya(new VA(new ArrayBuffer(1))) != sV || P1 && Ya(new P1()) != rV || HA && Ya(HA.resolve()) != nV || Uf && Ya(new Uf()) != iV || qA && Ya(new qA()) != aV) && (Ya = function(t) {
  var e = Xc(t), r = e == Vze ? t.constructor : void 0, n = r ? Bh(r) : "";
  if (n)
    switch (n) {
      case Hze:
        return sV;
      case Wze:
        return rV;
      case Yze:
        return nV;
      case Xze:
        return iV;
      case jze:
        return aV;
    }
  return e;
});
var Kze = Object.prototype, Zze = Kze.hasOwnProperty;
function Qze(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && Zze.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
var Kb = Ao.Uint8Array;
function Jze(t) {
  var e = new t.constructor(t.byteLength);
  return new Kb(e).set(new Kb(t)), e;
}
function eqe(t, e) {
  var r = t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var tqe = /\w*$/;
function rqe(t) {
  var e = new t.constructor(t.source, tqe.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var oV = ls ? ls.prototype : void 0, lV = oV ? oV.valueOf : void 0;
function nqe(t) {
  return lV ? Object(lV.call(t)) : {};
}
function iqe(t, e) {
  var r = t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
var aqe = "[object Boolean]", sqe = "[object Date]", oqe = "[object Map]", lqe = "[object Number]", cqe = "[object RegExp]", uqe = "[object Set]", hqe = "[object String]", fqe = "[object Symbol]", dqe = "[object ArrayBuffer]", pqe = "[object DataView]", gqe = "[object Float32Array]", mqe = "[object Float64Array]", vqe = "[object Int8Array]", yqe = "[object Int16Array]", bqe = "[object Int32Array]", xqe = "[object Uint8Array]", wqe = "[object Uint8ClampedArray]", Tqe = "[object Uint16Array]", Eqe = "[object Uint32Array]";
function Sqe(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case dqe:
      return Jze(t);
    case aqe:
    case sqe:
      return new n(+t);
    case pqe:
      return eqe(t);
    case gqe:
    case mqe:
    case vqe:
    case yqe:
    case bqe:
    case xqe:
    case wqe:
    case Tqe:
    case Eqe:
      return iqe(t);
    case oqe:
      return new n();
    case lqe:
    case hqe:
      return new n(t);
    case cqe:
      return rqe(t);
    case uqe:
      return new n();
    case fqe:
      return nqe(t);
  }
}
function kqe(t) {
  return typeof t.constructor == "function" && !Om(t) ? PBe(xse(t)) : {};
}
var Cqe = "[object Map]";
function _qe(t) {
  return Os(t) && Ya(t) == Cqe;
}
var cV = kc && kc.isMap, Aqe = cV ? T3(cV) : _qe, Lqe = "[object Set]";
function Rqe(t) {
  return Os(t) && Ya(t) == Lqe;
}
var uV = kc && kc.isSet, Iqe = uV ? T3(uV) : Rqe, Mqe = 2, Cse = "[object Arguments]", Nqe = "[object Array]", Dqe = "[object Boolean]", Oqe = "[object Date]", Pqe = "[object Error]", _se = "[object Function]", $qe = "[object GeneratorFunction]", Bqe = "[object Map]", Fqe = "[object Number]", Ase = "[object Object]", zqe = "[object RegExp]", qqe = "[object Set]", Gqe = "[object String]", Uqe = "[object Symbol]", Vqe = "[object WeakMap]", Hqe = "[object ArrayBuffer]", Wqe = "[object DataView]", Yqe = "[object Float32Array]", Xqe = "[object Float64Array]", jqe = "[object Int8Array]", Kqe = "[object Int16Array]", Zqe = "[object Int32Array]", Qqe = "[object Uint8Array]", Jqe = "[object Uint8ClampedArray]", eGe = "[object Uint16Array]", tGe = "[object Uint32Array]", zr = {};
zr[Cse] = zr[Nqe] = zr[Hqe] = zr[Wqe] = zr[Dqe] = zr[Oqe] = zr[Yqe] = zr[Xqe] = zr[jqe] = zr[Kqe] = zr[Zqe] = zr[Bqe] = zr[Fqe] = zr[Ase] = zr[zqe] = zr[qqe] = zr[Gqe] = zr[Uqe] = zr[Qqe] = zr[Jqe] = zr[eGe] = zr[tGe] = !0;
zr[Pqe] = zr[_se] = zr[Vqe] = !1;
function Qy(t, e, r, n, i, a) {
  var s, o = e & Mqe;
  if (s !== void 0)
    return s;
  if (!cs(t))
    return t;
  var l = xr(t);
  if (l)
    return s = Qze(t), BBe(t, s);
  var u = Ya(t), h = u == _se || u == $qe;
  if (D1(t))
    return $ze(t);
  if (u == Ase || u == Cse || h && !i)
    return s = h ? {} : kqe(t), o ? Gze(t, Oze(s, t)) : zze(t, Dze(s, t));
  if (!zr[u])
    return i ? t : {};
  s = Sqe(t, u), a || (a = new ho());
  var f = a.get(t);
  if (f)
    return f;
  a.set(t, s), Iqe(t) ? t.forEach(function(g) {
    s.add(Qy(g, e, r, g, t, a));
  }) : Aqe(t) && t.forEach(function(g, m) {
    s.set(m, Qy(g, e, r, m, t, a));
  });
  var d = UA, p = l ? void 0 : d(t);
  return use(p || t, function(g, m) {
    p && (m = g, g = t[m]), x3(s, m, Qy(g, e, r, m, t, a));
  }), s;
}
var rGe = 4;
function mi(t) {
  return Qy(t, rGe);
}
function $m(t) {
  for (var e = -1, r = t == null ? 0 : t.length, n = 0, i = []; ++e < r; ) {
    var a = t[e];
    a && (i[n++] = a);
  }
  return i;
}
var nGe = "__lodash_hash_undefined__";
function iGe(t) {
  return this.__data__.set(t, nGe), this;
}
function aGe(t) {
  return this.__data__.has(t);
}
function p0(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new Dl(); ++e < r; )
    this.add(t[e]);
}
p0.prototype.add = p0.prototype.push = iGe;
p0.prototype.has = aGe;
function Lse(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (e(t[r], r, t))
      return !0;
  return !1;
}
function pI(t, e) {
  return t.has(e);
}
var sGe = 1, oGe = 2;
function Rse(t, e, r, n, i, a) {
  var s = r & sGe, o = t.length, l = e.length;
  if (o != l && !(s && l > o))
    return !1;
  var u = a.get(t), h = a.get(e);
  if (u && h)
    return u == e && h == t;
  var f = -1, d = !0, p = r & oGe ? new p0() : void 0;
  for (a.set(t, e), a.set(e, t); ++f < o; ) {
    var g = t[f], m = e[f];
    if (n)
      var v = s ? n(m, g, f, e, t, a) : n(g, m, f, t, e, a);
    if (v !== void 0) {
      if (v)
        continue;
      d = !1;
      break;
    }
    if (p) {
      if (!Lse(e, function(y, b) {
        if (!pI(p, b) && (g === y || i(g, y, r, n, a)))
          return p.push(b);
      })) {
        d = !1;
        break;
      }
    } else if (!(g === m || i(g, m, r, n, a))) {
      d = !1;
      break;
    }
  }
  return a.delete(t), a.delete(e), d;
}
function lGe(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, i) {
    r[++e] = [i, n];
  }), r;
}
function gI(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var cGe = 1, uGe = 2, hGe = "[object Boolean]", fGe = "[object Date]", dGe = "[object Error]", pGe = "[object Map]", gGe = "[object Number]", mGe = "[object RegExp]", vGe = "[object Set]", yGe = "[object String]", bGe = "[object Symbol]", xGe = "[object ArrayBuffer]", wGe = "[object DataView]", hV = ls ? ls.prototype : void 0, g7 = hV ? hV.valueOf : void 0;
function TGe(t, e, r, n, i, a, s) {
  switch (r) {
    case wGe:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case xGe:
      return !(t.byteLength != e.byteLength || !a(new Kb(t), new Kb(e)));
    case hGe:
    case fGe:
    case gGe:
      return Nm(+t, +e);
    case dGe:
      return t.name == e.name && t.message == e.message;
    case mGe:
    case yGe:
      return t == e + "";
    case pGe:
      var o = lGe;
    case vGe:
      var l = n & cGe;
      if (o || (o = gI), t.size != e.size && !l)
        return !1;
      var u = s.get(t);
      if (u)
        return u == e;
      n |= uGe, s.set(t, e);
      var h = Rse(o(t), o(e), n, i, a, s);
      return s.delete(t), h;
    case bGe:
      if (g7)
        return g7.call(t) == g7.call(e);
  }
  return !1;
}
var EGe = 1, SGe = Object.prototype, kGe = SGe.hasOwnProperty;
function CGe(t, e, r, n, i, a) {
  var s = r & EGe, o = UA(t), l = o.length, u = UA(e), h = u.length;
  if (l != h && !s)
    return !1;
  for (var f = l; f--; ) {
    var d = o[f];
    if (!(s ? d in e : kGe.call(e, d)))
      return !1;
  }
  var p = a.get(t), g = a.get(e);
  if (p && g)
    return p == e && g == t;
  var m = !0;
  a.set(t, e), a.set(e, t);
  for (var v = s; ++f < l; ) {
    d = o[f];
    var y = t[d], b = e[d];
    if (n)
      var x = s ? n(b, y, d, e, t, a) : n(y, b, d, t, e, a);
    if (!(x === void 0 ? y === b || i(y, b, r, n, a) : x)) {
      m = !1;
      break;
    }
    v || (v = d == "constructor");
  }
  if (m && !v) {
    var T = t.constructor, E = e.constructor;
    T != E && "constructor" in t && "constructor" in e && !(typeof T == "function" && T instanceof T && typeof E == "function" && E instanceof E) && (m = !1);
  }
  return a.delete(t), a.delete(e), m;
}
var _Ge = 1, fV = "[object Arguments]", dV = "[object Array]", Kv = "[object Object]", AGe = Object.prototype, pV = AGe.hasOwnProperty;
function LGe(t, e, r, n, i, a) {
  var s = xr(t), o = xr(e), l = s ? dV : Ya(t), u = o ? dV : Ya(e);
  l = l == fV ? Kv : l, u = u == fV ? Kv : u;
  var h = l == Kv, f = u == Kv, d = l == u;
  if (d && D1(t)) {
    if (!D1(e))
      return !1;
    s = !0, h = !1;
  }
  if (d && !h)
    return a || (a = new ho()), s || aI(t) ? Rse(t, e, r, n, i, a) : TGe(t, e, l, r, n, i, a);
  if (!(r & _Ge)) {
    var p = h && pV.call(t, "__wrapped__"), g = f && pV.call(e, "__wrapped__");
    if (p || g) {
      var m = p ? t.value() : t, v = g ? e.value() : e;
      return a || (a = new ho()), i(m, v, r, n, a);
    }
  }
  return d ? (a || (a = new ho()), CGe(t, e, r, n, i, a)) : !1;
}
function mI(t, e, r, n, i) {
  return t === e ? !0 : t == null || e == null || !Os(t) && !Os(e) ? t !== t && e !== e : LGe(t, e, r, n, mI, i);
}
var RGe = 1, IGe = 2;
function MGe(t, e, r, n) {
  var i = r.length, a = i;
  if (t == null)
    return !a;
  for (t = Object(t); i--; ) {
    var s = r[i];
    if (s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
      return !1;
  }
  for (; ++i < a; ) {
    s = r[i];
    var o = s[0], l = t[o], u = s[1];
    if (s[2]) {
      if (l === void 0 && !(o in t))
        return !1;
    } else {
      var h = new ho(), f;
      if (!(f === void 0 ? mI(u, l, RGe | IGe, n, h) : f))
        return !1;
    }
  }
  return !0;
}
function Ise(t) {
  return t === t && !cs(t);
}
function NGe(t) {
  for (var e = us(t), r = e.length; r--; ) {
    var n = e[r], i = t[n];
    e[r] = [n, i, Ise(i)];
  }
  return e;
}
function Mse(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function DGe(t) {
  var e = NGe(t);
  return e.length == 1 && e[0][2] ? Mse(e[0][0], e[0][1]) : function(r) {
    return r === t || MGe(r, t, e);
  };
}
function OGe(t, e) {
  return t != null && e in Object(t);
}
function Nse(t, e, r) {
  e = k3(e, t);
  for (var n = -1, i = e.length, a = !1; ++n < i; ) {
    var s = Pm(e[n]);
    if (!(a = t != null && r(t, s)))
      break;
    t = t[s];
  }
  return a || ++n != i ? a : (i = t == null ? 0 : t.length, !!i && iI(i) && b3(s, i) && (xr(t) || w3(t)));
}
function PGe(t, e) {
  return t != null && Nse(t, e, OGe);
}
var $Ge = 1, BGe = 2;
function FGe(t, e) {
  return oI(t) && Ise(e) ? Mse(Pm(t), e) : function(r) {
    var n = kze(r, t);
    return n === void 0 && n === e ? PGe(r, t) : mI(e, n, $Ge | BGe);
  };
}
function zGe(t) {
  return function(e) {
    return e?.[t];
  };
}
function qGe(t) {
  return function(e) {
    return cI(e, t);
  };
}
function GGe(t) {
  return oI(t) ? zGe(Pm(t)) : qGe(t);
}
function Ro(t) {
  return typeof t == "function" ? t : t == null ? d0 : typeof t == "object" ? xr(t) ? FGe(t[0], t[1]) : DGe(t) : GGe(t);
}
function UGe(t, e, r, n) {
  for (var i = -1, a = t == null ? 0 : t.length; ++i < a; ) {
    var s = t[i];
    e(n, s, r(s), t);
  }
  return n;
}
function VGe(t) {
  return function(e, r, n) {
    for (var i = -1, a = Object(e), s = n(e), o = s.length; o--; ) {
      var l = s[++i];
      if (r(a[l], l, a) === !1)
        break;
    }
    return e;
  };
}
var HGe = VGe();
function WGe(t, e) {
  return t && HGe(t, e, us);
}
function YGe(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!Lo(r))
      return t(r, n);
    for (var i = r.length, a = -1, s = Object(r); ++a < i && n(s[a], a, s) !== !1; )
      ;
    return r;
  };
}
var zh = YGe(WGe);
function XGe(t, e, r, n) {
  return zh(t, function(i, a, s) {
    e(n, i, r(i), s);
  }), n;
}
function jGe(t, e) {
  return function(r, n) {
    var i = xr(r) ? UGe : XGe, a = e ? e() : {};
    return i(r, t, Ro(n), a);
  };
}
var Dse = Object.prototype, KGe = Dse.hasOwnProperty, vI = nI(function(t, e) {
  t = Object(t);
  var r = -1, n = e.length, i = n > 2 ? e[2] : void 0;
  for (i && dse(e[0], e[1], i) && (n = 1); ++r < n; )
    for (var a = e[r], s = sI(a), o = -1, l = s.length; ++o < l; ) {
      var u = s[o], h = t[u];
      (h === void 0 || Nm(h, Dse[u]) && !KGe.call(t, u)) && (t[u] = a[u]);
    }
  return t;
});
function gV(t) {
  return Os(t) && Lo(t);
}
var ZGe = 200;
function QGe(t, e, r, n) {
  var i = -1, a = fse, s = !0, o = t.length, l = [], u = e.length;
  if (!o)
    return l;
  e.length >= ZGe && (a = pI, s = !1, e = new p0(e));
  e:
    for (; ++i < o; ) {
      var h = t[i], f = h;
      if (h = h !== 0 ? h : 0, s && f === f) {
        for (var d = u; d--; )
          if (e[d] === f)
            continue e;
        l.push(h);
      } else a(e, f, n) || l.push(h);
    }
  return l;
}
var C3 = nI(function(t, e) {
  return gV(t) ? QGe(t, hI(e, 1, gV, !0)) : [];
});
function g0(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
function li(t, e, r) {
  var n = t == null ? 0 : t.length;
  return n ? (e = e === void 0 ? 1 : y3(e), wse(t, e < 0 ? 0 : e, n)) : [];
}
function $1(t, e, r) {
  var n = t == null ? 0 : t.length;
  return n ? (e = e === void 0 ? 1 : y3(e), e = n - e, wse(t, 0, e < 0 ? 0 : e)) : [];
}
function JGe(t) {
  return typeof t == "function" ? t : d0;
}
function Zt(t, e) {
  var r = xr(t) ? use : zh;
  return r(t, JGe(e));
}
function eUe(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (!e(t[r], r, t))
      return !1;
  return !0;
}
function tUe(t, e) {
  var r = !0;
  return zh(t, function(n, i, a) {
    return r = !!e(n, i, a), r;
  }), r;
}
function fo(t, e, r) {
  var n = xr(t) ? eUe : tUe;
  return n(t, Ro(e));
}
function Ose(t, e) {
  var r = [];
  return zh(t, function(n, i, a) {
    e(n, i, a) && r.push(n);
  }), r;
}
function ds(t, e) {
  var r = xr(t) ? fI : Ose;
  return r(t, Ro(e));
}
function rUe(t) {
  return function(e, r, n) {
    var i = Object(e);
    if (!Lo(e)) {
      var a = Ro(r);
      e = us(e), r = function(o) {
        return a(i[o], o, i);
      };
    }
    var s = t(e, r, n);
    return s > -1 ? i[a ? e[s] : s] : void 0;
  };
}
var nUe = Math.max;
function iUe(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = r == null ? 0 : y3(r);
  return i < 0 && (i = nUe(n + i, 0)), hse(t, Ro(e), i);
}
var m0 = rUe(iUe);
function Ps(t) {
  return t && t.length ? t[0] : void 0;
}
function aUe(t, e) {
  var r = -1, n = Lo(t) ? Array(t.length) : [];
  return zh(t, function(i, a, s) {
    n[++r] = e(i, a, s);
  }), n;
}
function $t(t, e) {
  var r = xr(t) ? v3 : aUe;
  return r(t, Ro(e));
}
function ts(t, e) {
  return hI($t(t, e));
}
var sUe = Object.prototype, oUe = sUe.hasOwnProperty, lUe = jGe(function(t, e, r) {
  oUe.call(t, r) ? t[r].push(e) : rI(t, r, [e]);
}), cUe = Object.prototype, uUe = cUe.hasOwnProperty;
function hUe(t, e) {
  return t != null && uUe.call(t, e);
}
function Vt(t, e) {
  return t != null && Nse(t, e, hUe);
}
var fUe = "[object String]";
function $s(t) {
  return typeof t == "string" || !xr(t) && Os(t) && Xc(t) == fUe;
}
function dUe(t, e) {
  return v3(e, function(r) {
    return t[r];
  });
}
function Fn(t) {
  return t == null ? [] : dUe(t, us(t));
}
var pUe = Math.max;
function va(t, e, r, n) {
  t = Lo(t) ? t : Fn(t), r = r ? y3(r) : 0;
  var i = t.length;
  return r < 0 && (r = pUe(i + r, 0)), $s(t) ? r <= i && t.indexOf(e, r) > -1 : !!i && tI(t, e, r) > -1;
}
function mV(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = 0;
  return tI(t, e, i);
}
var gUe = "[object Map]", mUe = "[object Set]", vUe = Object.prototype, yUe = vUe.hasOwnProperty;
function qr(t) {
  if (t == null)
    return !0;
  if (Lo(t) && (xr(t) || typeof t == "string" || typeof t.splice == "function" || D1(t) || aI(t) || w3(t)))
    return !t.length;
  var e = Ya(t);
  if (e == gUe || e == mUe)
    return !t.size;
  if (Om(t))
    return !bse(t).length;
  for (var r in t)
    if (yUe.call(t, r))
      return !1;
  return !0;
}
var bUe = "[object RegExp]";
function xUe(t) {
  return Os(t) && Xc(t) == bUe;
}
var vV = kc && kc.isRegExp, Cc = vV ? T3(vV) : xUe;
function xl(t) {
  return t === void 0;
}
var wUe = "Expected a function";
function TUe(t) {
  if (typeof t != "function")
    throw new TypeError(wUe);
  return function() {
    var e = arguments;
    switch (e.length) {
      case 0:
        return !t.call(this);
      case 1:
        return !t.call(this, e[0]);
      case 2:
        return !t.call(this, e[0], e[1]);
      case 3:
        return !t.call(this, e[0], e[1], e[2]);
    }
    return !t.apply(this, e);
  };
}
function EUe(t, e, r, n) {
  if (!cs(t))
    return t;
  e = k3(e, t);
  for (var i = -1, a = e.length, s = a - 1, o = t; o != null && ++i < a; ) {
    var l = Pm(e[i]), u = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != s) {
      var h = o[l];
      u = void 0, u === void 0 && (u = cs(h) ? h : b3(e[i + 1]) ? [] : {});
    }
    x3(o, l, u), o = o[l];
  }
  return t;
}
function SUe(t, e, r) {
  for (var n = -1, i = e.length, a = {}; ++n < i; ) {
    var s = e[n], o = cI(t, s);
    r(o, s) && EUe(a, k3(s, t), o);
  }
  return a;
}
function kUe(t, e) {
  if (t == null)
    return {};
  var r = v3(Uze(t), function(n) {
    return [n];
  });
  return e = Ro(e), SUe(t, r, function(n, i) {
    return e(n, i[0]);
  });
}
function CUe(t, e, r, n, i) {
  return i(t, function(a, s, o) {
    r = n ? (n = !1, a) : e(r, a, s, o);
  }), r;
}
function Ma(t, e, r) {
  var n = xr(t) ? _ze : CUe, i = arguments.length < 3;
  return n(t, Ro(e), r, i, zh);
}
function _3(t, e) {
  var r = xr(t) ? fI : Ose;
  return r(t, TUe(Ro(e)));
}
function _Ue(t, e) {
  var r;
  return zh(t, function(n, i, a) {
    return r = e(n, i, a), !r;
  }), !!r;
}
function AUe(t, e, r) {
  var n = xr(t) ? Lse : _Ue;
  return n(t, Ro(e));
}
var LUe = 1 / 0, RUe = Uf && 1 / gI(new Uf([, -0]))[1] == LUe ? function(t) {
  return new Uf(t);
} : Pn, IUe = 200;
function MUe(t, e, r) {
  var n = -1, i = fse, a = t.length, s = !0, o = [], l = o;
  if (a >= IUe) {
    var u = RUe(t);
    if (u)
      return gI(u);
    s = !1, i = pI, l = new p0();
  } else
    l = o;
  e:
    for (; ++n < a; ) {
      var h = t[n], f = h;
      if (h = h !== 0 ? h : 0, s && f === f) {
        for (var d = l.length; d--; )
          if (l[d] === f)
            continue e;
        o.push(h);
      } else i(l, f, r) || (l !== o && l.push(f), o.push(h));
    }
  return o;
}
function yI(t) {
  return t && t.length ? MUe(t) : [];
}
function WA(t) {
  console && console.error && console.error(`Error: ${t}`);
}
function Pse(t) {
  console && console.warn && console.warn(`Warning: ${t}`);
}
function $se(t) {
  const e = (/* @__PURE__ */ new Date()).getTime(), r = t();
  return { time: (/* @__PURE__ */ new Date()).getTime() - e, value: r };
}
function Bse(t) {
  function e() {
  }
  e.prototype = t;
  const r = new e();
  function n() {
    return typeof r.bar;
  }
  return n(), n(), t;
}
var Fse = typeof global == "object" && global && global.Object === Object && global, NUe = typeof self == "object" && self && self.Object === Object && self, Ol = Fse || NUe || Function("return this")(), _c = Ol.Symbol, zse = Object.prototype, DUe = zse.hasOwnProperty, OUe = zse.toString, Sp = _c ? _c.toStringTag : void 0;
function PUe(t) {
  var e = DUe.call(t, Sp), r = t[Sp];
  try {
    t[Sp] = void 0;
    var n = !0;
  } catch {
  }
  var i = OUe.call(t);
  return n && (e ? t[Sp] = r : delete t[Sp]), i;
}
var $Ue = Object.prototype, BUe = $Ue.toString;
function FUe(t) {
  return BUe.call(t);
}
var zUe = "[object Null]", qUe = "[object Undefined]", yV = _c ? _c.toStringTag : void 0;
function jc(t) {
  return t == null ? t === void 0 ? qUe : zUe : yV && yV in Object(t) ? PUe(t) : FUe(t);
}
function Ac(t) {
  return t != null && typeof t == "object";
}
var GUe = "[object Symbol]";
function A3(t) {
  return typeof t == "symbol" || Ac(t) && jc(t) == GUe;
}
function L3(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
var da = Array.isArray, bV = _c ? _c.prototype : void 0, xV = bV ? bV.toString : void 0;
function qse(t) {
  if (typeof t == "string")
    return t;
  if (da(t))
    return L3(t, qse) + "";
  if (A3(t))
    return xV ? xV.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var UUe = /\s/;
function VUe(t) {
  for (var e = t.length; e-- && UUe.test(t.charAt(e)); )
    ;
  return e;
}
var HUe = /^\s+/;
function WUe(t) {
  return t && t.slice(0, VUe(t) + 1).replace(HUe, "");
}
function wl(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var wV = NaN, YUe = /^[-+]0x[0-9a-f]+$/i, XUe = /^0b[01]+$/i, jUe = /^0o[0-7]+$/i, KUe = parseInt;
function ZUe(t) {
  if (typeof t == "number")
    return t;
  if (A3(t))
    return wV;
  if (wl(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = wl(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = WUe(t);
  var r = XUe.test(t);
  return r || jUe.test(t) ? KUe(t.slice(2), r ? 2 : 8) : YUe.test(t) ? wV : +t;
}
var TV = 1 / 0, QUe = 17976931348623157e292;
function JUe(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = ZUe(t), t === TV || t === -TV) {
    var e = t < 0 ? -1 : 1;
    return e * QUe;
  }
  return t === t ? t : 0;
}
function eVe(t) {
  var e = JUe(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function R3(t) {
  return t;
}
var tVe = "[object AsyncFunction]", rVe = "[object Function]", nVe = "[object GeneratorFunction]", iVe = "[object Proxy]";
function Gse(t) {
  if (!wl(t))
    return !1;
  var e = jc(t);
  return e == rVe || e == nVe || e == tVe || e == iVe;
}
var m7 = Ol["__core-js_shared__"], EV = (function() {
  var t = /[^.]+$/.exec(m7 && m7.keys && m7.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
})();
function aVe(t) {
  return !!EV && EV in t;
}
var sVe = Function.prototype, oVe = sVe.toString;
function qh(t) {
  if (t != null) {
    try {
      return oVe.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var lVe = /[\\^$.*+?()[\]{}|]/g, cVe = /^\[object .+?Constructor\]$/, uVe = Function.prototype, hVe = Object.prototype, fVe = uVe.toString, dVe = hVe.hasOwnProperty, pVe = RegExp(
  "^" + fVe.call(dVe).replace(lVe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function gVe(t) {
  if (!wl(t) || aVe(t))
    return !1;
  var e = Gse(t) ? pVe : cVe;
  return e.test(qh(t));
}
function mVe(t, e) {
  return t?.[e];
}
function Gh(t, e) {
  var r = mVe(t, e);
  return gVe(r) ? r : void 0;
}
var YA = Gh(Ol, "WeakMap");
function vVe(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
var yVe = 800, bVe = 16, xVe = Date.now;
function wVe(t) {
  var e = 0, r = 0;
  return function() {
    var n = xVe(), i = bVe - (n - r);
    if (r = n, i > 0) {
      if (++e >= yVe)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function TVe(t) {
  return function() {
    return t;
  };
}
var Zb = (function() {
  try {
    var t = Gh(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
})(), EVe = Zb ? function(t, e) {
  return Zb(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: TVe(e),
    writable: !0
  });
} : R3, SVe = wVe(EVe);
function kVe(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
function CVe(t, e, r, n) {
  for (var i = t.length, a = r + -1; ++a < i; )
    if (e(t[a], a, t))
      return a;
  return -1;
}
function _Ve(t) {
  return t !== t;
}
function AVe(t, e, r) {
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
function LVe(t, e, r) {
  return e === e ? AVe(t, e, r) : CVe(t, _Ve, r);
}
var RVe = 9007199254740991, IVe = /^(?:0|[1-9]\d*)$/;
function I3(t, e) {
  var r = typeof t;
  return e = e ?? RVe, !!e && (r == "number" || r != "symbol" && IVe.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function Use(t, e, r) {
  e == "__proto__" && Zb ? Zb(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
function M3(t, e) {
  return t === e || t !== t && e !== e;
}
var MVe = Object.prototype, NVe = MVe.hasOwnProperty;
function bI(t, e, r) {
  var n = t[e];
  (!(NVe.call(t, e) && M3(n, r)) || r === void 0 && !(e in t)) && Use(t, e, r);
}
function DVe(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, s = e.length; ++a < s; ) {
    var o = e[a], l = void 0;
    l === void 0 && (l = t[o]), i ? Use(r, o, l) : bI(r, o, l);
  }
  return r;
}
var SV = Math.max;
function OVe(t, e, r) {
  return e = SV(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, a = SV(n.length - e, 0), s = Array(a); ++i < a; )
      s[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(s), vVe(t, this, o);
  };
}
function PVe(t, e) {
  return SVe(OVe(t, e, R3), t + "");
}
var $Ve = 9007199254740991;
function xI(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= $Ve;
}
function Uh(t) {
  return t != null && xI(t.length) && !Gse(t);
}
function BVe(t, e, r) {
  if (!wl(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? Uh(r) && I3(e, r.length) : n == "string" && e in r) ? M3(r[e], t) : !1;
}
function FVe(t) {
  return PVe(function(e, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && BVe(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t(e, o, n, a);
    }
    return e;
  });
}
var zVe = Object.prototype;
function wI(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || zVe;
  return t === r;
}
function qVe(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var GVe = "[object Arguments]";
function kV(t) {
  return Ac(t) && jc(t) == GVe;
}
var Vse = Object.prototype, UVe = Vse.hasOwnProperty, VVe = Vse.propertyIsEnumerable, Hse = kV(/* @__PURE__ */ (function() {
  return arguments;
})()) ? kV : function(t) {
  return Ac(t) && UVe.call(t, "callee") && !VVe.call(t, "callee");
};
function HVe() {
  return !1;
}
var Wse = typeof exports == "object" && exports && !exports.nodeType && exports, CV = Wse && typeof module == "object" && module && !module.nodeType && module, WVe = CV && CV.exports === Wse, _V = WVe ? Ol.Buffer : void 0, YVe = _V ? _V.isBuffer : void 0, XA = YVe || HVe, XVe = "[object Arguments]", jVe = "[object Array]", KVe = "[object Boolean]", ZVe = "[object Date]", QVe = "[object Error]", JVe = "[object Function]", eHe = "[object Map]", tHe = "[object Number]", rHe = "[object Object]", nHe = "[object RegExp]", iHe = "[object Set]", aHe = "[object String]", sHe = "[object WeakMap]", oHe = "[object ArrayBuffer]", lHe = "[object DataView]", cHe = "[object Float32Array]", uHe = "[object Float64Array]", hHe = "[object Int8Array]", fHe = "[object Int16Array]", dHe = "[object Int32Array]", pHe = "[object Uint8Array]", gHe = "[object Uint8ClampedArray]", mHe = "[object Uint16Array]", vHe = "[object Uint32Array]", Yr = {};
Yr[cHe] = Yr[uHe] = Yr[hHe] = Yr[fHe] = Yr[dHe] = Yr[pHe] = Yr[gHe] = Yr[mHe] = Yr[vHe] = !0;
Yr[XVe] = Yr[jVe] = Yr[oHe] = Yr[KVe] = Yr[lHe] = Yr[ZVe] = Yr[QVe] = Yr[JVe] = Yr[eHe] = Yr[tHe] = Yr[rHe] = Yr[nHe] = Yr[iHe] = Yr[aHe] = Yr[sHe] = !1;
function yHe(t) {
  return Ac(t) && xI(t.length) && !!Yr[jc(t)];
}
function Yse(t) {
  return function(e) {
    return t(e);
  };
}
var Xse = typeof exports == "object" && exports && !exports.nodeType && exports, Wg = Xse && typeof module == "object" && module && !module.nodeType && module, bHe = Wg && Wg.exports === Xse, v7 = bHe && Fse.process, Qb = (function() {
  try {
    var t = Wg && Wg.require && Wg.require("util").types;
    return t || v7 && v7.binding && v7.binding("util");
  } catch {
  }
})(), AV = Qb && Qb.isTypedArray, jse = AV ? Yse(AV) : yHe, xHe = Object.prototype, wHe = xHe.hasOwnProperty;
function Kse(t, e) {
  var r = da(t), n = !r && Hse(t), i = !r && !n && XA(t), a = !r && !n && !i && jse(t), s = r || n || i || a, o = s ? qVe(t.length, String) : [], l = o.length;
  for (var u in t)
    (e || wHe.call(t, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    I3(u, l))) && o.push(u);
  return o;
}
function Zse(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var THe = Zse(Object.keys, Object), EHe = Object.prototype, SHe = EHe.hasOwnProperty;
function kHe(t) {
  if (!wI(t))
    return THe(t);
  var e = [];
  for (var r in Object(t))
    SHe.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
function Bm(t) {
  return Uh(t) ? Kse(t) : kHe(t);
}
var CHe = Object.prototype, _He = CHe.hasOwnProperty, Io = FVe(function(t, e) {
  if (wI(e) || Uh(e)) {
    DVe(e, Bm(e), t);
    return;
  }
  for (var r in e)
    _He.call(e, r) && bI(t, r, e[r]);
});
function AHe(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var LHe = Object.prototype, RHe = LHe.hasOwnProperty;
function IHe(t) {
  if (!wl(t))
    return AHe(t);
  var e = wI(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !RHe.call(t, n)) || r.push(n);
  return r;
}
function MHe(t) {
  return Uh(t) ? Kse(t, !0) : IHe(t);
}
var NHe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, DHe = /^\w*$/;
function TI(t, e) {
  if (da(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || A3(t) ? !0 : DHe.test(t) || !NHe.test(t) || e != null && t in Object(e);
}
var B1 = Gh(Object, "create");
function OHe() {
  this.__data__ = B1 ? B1(null) : {}, this.size = 0;
}
function PHe(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var $He = "__lodash_hash_undefined__", BHe = Object.prototype, FHe = BHe.hasOwnProperty;
function zHe(t) {
  var e = this.__data__;
  if (B1) {
    var r = e[t];
    return r === $He ? void 0 : r;
  }
  return FHe.call(e, t) ? e[t] : void 0;
}
var qHe = Object.prototype, GHe = qHe.hasOwnProperty;
function UHe(t) {
  var e = this.__data__;
  return B1 ? e[t] !== void 0 : GHe.call(e, t);
}
var VHe = "__lodash_hash_undefined__";
function HHe(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = B1 && e === void 0 ? VHe : e, this;
}
function uh(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
uh.prototype.clear = OHe;
uh.prototype.delete = PHe;
uh.prototype.get = zHe;
uh.prototype.has = UHe;
uh.prototype.set = HHe;
function WHe() {
  this.__data__ = [], this.size = 0;
}
function N3(t, e) {
  for (var r = t.length; r--; )
    if (M3(t[r][0], e))
      return r;
  return -1;
}
var YHe = Array.prototype, XHe = YHe.splice;
function jHe(t) {
  var e = this.__data__, r = N3(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : XHe.call(e, r, 1), --this.size, !0;
}
function KHe(t) {
  var e = this.__data__, r = N3(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function ZHe(t) {
  return N3(this.__data__, t) > -1;
}
function QHe(t, e) {
  var r = this.__data__, n = N3(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
function Pl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Pl.prototype.clear = WHe;
Pl.prototype.delete = jHe;
Pl.prototype.get = KHe;
Pl.prototype.has = ZHe;
Pl.prototype.set = QHe;
var F1 = Gh(Ol, "Map");
function JHe() {
  this.size = 0, this.__data__ = {
    hash: new uh(),
    map: new (F1 || Pl)(),
    string: new uh()
  };
}
function eWe(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function D3(t, e) {
  var r = t.__data__;
  return eWe(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function tWe(t) {
  var e = D3(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function rWe(t) {
  return D3(this, t).get(t);
}
function nWe(t) {
  return D3(this, t).has(t);
}
function iWe(t, e) {
  var r = D3(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
function $l(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
$l.prototype.clear = JHe;
$l.prototype.delete = tWe;
$l.prototype.get = rWe;
$l.prototype.has = nWe;
$l.prototype.set = iWe;
var aWe = "Expected a function";
function EI(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(aWe);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = t.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (EI.Cache || $l)(), r;
}
EI.Cache = $l;
var sWe = 500;
function oWe(t) {
  var e = EI(t, function(n) {
    return r.size === sWe && r.clear(), n;
  }), r = e.cache;
  return e;
}
var lWe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, cWe = /\\(\\)?/g, uWe = oWe(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(lWe, function(r, n, i, a) {
    e.push(i ? a.replace(cWe, "$1") : n || r);
  }), e;
});
function hWe(t) {
  return t == null ? "" : qse(t);
}
function O3(t, e) {
  return da(t) ? t : TI(t, e) ? [t] : uWe(hWe(t));
}
function Fm(t) {
  if (typeof t == "string" || A3(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function SI(t, e) {
  e = O3(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[Fm(e[r++])];
  return r && r == n ? t : void 0;
}
function fWe(t, e, r) {
  var n = t == null ? void 0 : SI(t, e);
  return n === void 0 ? r : n;
}
function Qse(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n; )
    t[i + r] = e[r];
  return t;
}
var dWe = Zse(Object.getPrototypeOf, Object);
function pWe() {
  this.__data__ = new Pl(), this.size = 0;
}
function gWe(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function mWe(t) {
  return this.__data__.get(t);
}
function vWe(t) {
  return this.__data__.has(t);
}
var yWe = 200;
function bWe(t, e) {
  var r = this.__data__;
  if (r instanceof Pl) {
    var n = r.__data__;
    if (!F1 || n.length < yWe - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new $l(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
function ul(t) {
  var e = this.__data__ = new Pl(t);
  this.size = e.size;
}
ul.prototype.clear = pWe;
ul.prototype.delete = gWe;
ul.prototype.get = mWe;
ul.prototype.has = vWe;
ul.prototype.set = bWe;
function xWe(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n; ) {
    var s = t[r];
    e(s, r, t) && (a[i++] = s);
  }
  return a;
}
function Jse() {
  return [];
}
var wWe = Object.prototype, TWe = wWe.propertyIsEnumerable, LV = Object.getOwnPropertySymbols, eoe = LV ? function(t) {
  return t == null ? [] : (t = Object(t), xWe(LV(t), function(e) {
    return TWe.call(t, e);
  }));
} : Jse, EWe = Object.getOwnPropertySymbols, SWe = EWe ? function(t) {
  for (var e = []; t; )
    Qse(e, eoe(t)), t = dWe(t);
  return e;
} : Jse;
function toe(t, e, r) {
  var n = e(t);
  return da(t) ? n : Qse(n, r(t));
}
function RV(t) {
  return toe(t, Bm, eoe);
}
function kWe(t) {
  return toe(t, MHe, SWe);
}
var jA = Gh(Ol, "DataView"), KA = Gh(Ol, "Promise"), ZA = Gh(Ol, "Set"), IV = "[object Map]", CWe = "[object Object]", MV = "[object Promise]", NV = "[object Set]", DV = "[object WeakMap]", OV = "[object DataView]", _We = qh(jA), AWe = qh(F1), LWe = qh(KA), RWe = qh(ZA), IWe = qh(YA), Yl = jc;
(jA && Yl(new jA(new ArrayBuffer(1))) != OV || F1 && Yl(new F1()) != IV || KA && Yl(KA.resolve()) != MV || ZA && Yl(new ZA()) != NV || YA && Yl(new YA()) != DV) && (Yl = function(t) {
  var e = jc(t), r = e == CWe ? t.constructor : void 0, n = r ? qh(r) : "";
  if (n)
    switch (n) {
      case _We:
        return OV;
      case AWe:
        return IV;
      case LWe:
        return MV;
      case RWe:
        return NV;
      case IWe:
        return DV;
    }
  return e;
});
var PV = Ol.Uint8Array, MWe = "__lodash_hash_undefined__";
function NWe(t) {
  return this.__data__.set(t, MWe), this;
}
function DWe(t) {
  return this.__data__.has(t);
}
function Jb(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new $l(); ++e < r; )
    this.add(t[e]);
}
Jb.prototype.add = Jb.prototype.push = NWe;
Jb.prototype.has = DWe;
function roe(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (e(t[r], r, t))
      return !0;
  return !1;
}
function OWe(t, e) {
  return t.has(e);
}
var PWe = 1, $We = 2;
function noe(t, e, r, n, i, a) {
  var s = r & PWe, o = t.length, l = e.length;
  if (o != l && !(s && l > o))
    return !1;
  var u = a.get(t), h = a.get(e);
  if (u && h)
    return u == e && h == t;
  var f = -1, d = !0, p = r & $We ? new Jb() : void 0;
  for (a.set(t, e), a.set(e, t); ++f < o; ) {
    var g = t[f], m = e[f];
    if (n)
      var v = s ? n(m, g, f, e, t, a) : n(g, m, f, t, e, a);
    if (v !== void 0) {
      if (v)
        continue;
      d = !1;
      break;
    }
    if (p) {
      if (!roe(e, function(y, b) {
        if (!OWe(p, b) && (g === y || i(g, y, r, n, a)))
          return p.push(b);
      })) {
        d = !1;
        break;
      }
    } else if (!(g === m || i(g, m, r, n, a))) {
      d = !1;
      break;
    }
  }
  return a.delete(t), a.delete(e), d;
}
function BWe(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, i) {
    r[++e] = [i, n];
  }), r;
}
function FWe(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var zWe = 1, qWe = 2, GWe = "[object Boolean]", UWe = "[object Date]", VWe = "[object Error]", HWe = "[object Map]", WWe = "[object Number]", YWe = "[object RegExp]", XWe = "[object Set]", jWe = "[object String]", KWe = "[object Symbol]", ZWe = "[object ArrayBuffer]", QWe = "[object DataView]", $V = _c ? _c.prototype : void 0, y7 = $V ? $V.valueOf : void 0;
function JWe(t, e, r, n, i, a, s) {
  switch (r) {
    case QWe:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case ZWe:
      return !(t.byteLength != e.byteLength || !a(new PV(t), new PV(e)));
    case GWe:
    case UWe:
    case WWe:
      return M3(+t, +e);
    case VWe:
      return t.name == e.name && t.message == e.message;
    case YWe:
    case jWe:
      return t == e + "";
    case HWe:
      var o = BWe;
    case XWe:
      var l = n & zWe;
      if (o || (o = FWe), t.size != e.size && !l)
        return !1;
      var u = s.get(t);
      if (u)
        return u == e;
      n |= qWe, s.set(t, e);
      var h = noe(o(t), o(e), n, i, a, s);
      return s.delete(t), h;
    case KWe:
      if (y7)
        return y7.call(t) == y7.call(e);
  }
  return !1;
}
var eYe = 1, tYe = Object.prototype, rYe = tYe.hasOwnProperty;
function nYe(t, e, r, n, i, a) {
  var s = r & eYe, o = RV(t), l = o.length, u = RV(e), h = u.length;
  if (l != h && !s)
    return !1;
  for (var f = l; f--; ) {
    var d = o[f];
    if (!(s ? d in e : rYe.call(e, d)))
      return !1;
  }
  var p = a.get(t), g = a.get(e);
  if (p && g)
    return p == e && g == t;
  var m = !0;
  a.set(t, e), a.set(e, t);
  for (var v = s; ++f < l; ) {
    d = o[f];
    var y = t[d], b = e[d];
    if (n)
      var x = s ? n(b, y, d, e, t, a) : n(y, b, d, t, e, a);
    if (!(x === void 0 ? y === b || i(y, b, r, n, a) : x)) {
      m = !1;
      break;
    }
    v || (v = d == "constructor");
  }
  if (m && !v) {
    var T = t.constructor, E = e.constructor;
    T != E && "constructor" in t && "constructor" in e && !(typeof T == "function" && T instanceof T && typeof E == "function" && E instanceof E) && (m = !1);
  }
  return a.delete(t), a.delete(e), m;
}
var iYe = 1, BV = "[object Arguments]", FV = "[object Array]", Zv = "[object Object]", aYe = Object.prototype, zV = aYe.hasOwnProperty;
function sYe(t, e, r, n, i, a) {
  var s = da(t), o = da(e), l = s ? FV : Yl(t), u = o ? FV : Yl(e);
  l = l == BV ? Zv : l, u = u == BV ? Zv : u;
  var h = l == Zv, f = u == Zv, d = l == u;
  if (d && XA(t)) {
    if (!XA(e))
      return !1;
    s = !0, h = !1;
  }
  if (d && !h)
    return a || (a = new ul()), s || jse(t) ? noe(t, e, r, n, i, a) : JWe(t, e, l, r, n, i, a);
  if (!(r & iYe)) {
    var p = h && zV.call(t, "__wrapped__"), g = f && zV.call(e, "__wrapped__");
    if (p || g) {
      var m = p ? t.value() : t, v = g ? e.value() : e;
      return a || (a = new ul()), i(m, v, r, n, a);
    }
  }
  return d ? (a || (a = new ul()), nYe(t, e, r, n, i, a)) : !1;
}
function kI(t, e, r, n, i) {
  return t === e ? !0 : t == null || e == null || !Ac(t) && !Ac(e) ? t !== t && e !== e : sYe(t, e, r, n, kI, i);
}
var oYe = 1, lYe = 2;
function cYe(t, e, r, n) {
  var i = r.length, a = i;
  if (t == null)
    return !a;
  for (t = Object(t); i--; ) {
    var s = r[i];
    if (s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
      return !1;
  }
  for (; ++i < a; ) {
    s = r[i];
    var o = s[0], l = t[o], u = s[1];
    if (s[2]) {
      if (l === void 0 && !(o in t))
        return !1;
    } else {
      var h = new ul(), f;
      if (!(f === void 0 ? kI(u, l, oYe | lYe, n, h) : f))
        return !1;
    }
  }
  return !0;
}
function ioe(t) {
  return t === t && !wl(t);
}
function uYe(t) {
  for (var e = Bm(t), r = e.length; r--; ) {
    var n = e[r], i = t[n];
    e[r] = [n, i, ioe(i)];
  }
  return e;
}
function aoe(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function hYe(t) {
  var e = uYe(t);
  return e.length == 1 && e[0][2] ? aoe(e[0][0], e[0][1]) : function(r) {
    return r === t || cYe(r, t, e);
  };
}
function fYe(t, e) {
  return t != null && e in Object(t);
}
function dYe(t, e, r) {
  e = O3(e, t);
  for (var n = -1, i = e.length, a = !1; ++n < i; ) {
    var s = Fm(e[n]);
    if (!(a = t != null && r(t, s)))
      break;
    t = t[s];
  }
  return a || ++n != i ? a : (i = t == null ? 0 : t.length, !!i && xI(i) && I3(s, i) && (da(t) || Hse(t)));
}
function pYe(t, e) {
  return t != null && dYe(t, e, fYe);
}
var gYe = 1, mYe = 2;
function vYe(t, e) {
  return TI(t) && ioe(e) ? aoe(Fm(t), e) : function(r) {
    var n = fWe(r, t);
    return n === void 0 && n === e ? pYe(r, t) : kI(e, n, gYe | mYe);
  };
}
function yYe(t) {
  return function(e) {
    return e?.[t];
  };
}
function bYe(t) {
  return function(e) {
    return SI(e, t);
  };
}
function xYe(t) {
  return TI(t) ? yYe(Fm(t)) : bYe(t);
}
function P3(t) {
  return typeof t == "function" ? t : t == null ? R3 : typeof t == "object" ? da(t) ? vYe(t[0], t[1]) : hYe(t) : xYe(t);
}
function wYe(t) {
  return function(e, r, n) {
    for (var i = -1, a = Object(e), s = n(e), o = s.length; o--; ) {
      var l = s[++i];
      if (r(a[l], l, a) === !1)
        break;
    }
    return e;
  };
}
var TYe = wYe();
function EYe(t, e) {
  return t && TYe(t, e, Bm);
}
function SYe(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!Uh(r))
      return t(r, n);
    for (var i = r.length, a = -1, s = Object(r); ++a < i && n(s[a], a, s) !== !1; )
      ;
    return r;
  };
}
var $3 = SYe(EYe);
function kYe(t) {
  return typeof t == "function" ? t : R3;
}
function CYe(t, e) {
  var r = da(t) ? kVe : $3;
  return r(t, kYe(e));
}
function _Ye(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (!e(t[r], r, t))
      return !1;
  return !0;
}
function AYe(t, e) {
  var r = !0;
  return $3(t, function(n, i, a) {
    return r = !!e(n, i, a), r;
  }), r;
}
function LYe(t, e, r) {
  var n = da(t) ? _Ye : AYe;
  return n(t, P3(e));
}
function RYe(t, e) {
  var r = -1, n = Uh(t) ? Array(t.length) : [];
  return $3(t, function(i, a, s) {
    n[++r] = e(i, a, s);
  }), n;
}
function soe(t, e) {
  var r = da(t) ? L3 : RYe;
  return r(t, P3(e));
}
var IYe = "[object String]";
function ex(t) {
  return typeof t == "string" || !da(t) && Ac(t) && jc(t) == IYe;
}
function MYe(t, e) {
  return L3(e, function(r) {
    return t[r];
  });
}
function NYe(t) {
  return t == null ? [] : MYe(t, Bm(t));
}
var DYe = Math.max;
function OYe(t, e, r, n) {
  t = Uh(t) ? t : NYe(t), r = r ? eVe(r) : 0;
  var i = t.length;
  return r < 0 && (r = DYe(i + r, 0)), ex(t) ? r <= i && t.indexOf(e, r) > -1 : !!i && LVe(t, e, r) > -1;
}
var PYe = "[object RegExp]";
function $Ye(t) {
  return Ac(t) && jc(t) == PYe;
}
var qV = Qb && Qb.isRegExp, BYe = qV ? Yse(qV) : $Ye;
function FYe(t, e, r, n) {
  if (!wl(t))
    return t;
  e = O3(e, t);
  for (var i = -1, a = e.length, s = a - 1, o = t; o != null && ++i < a; ) {
    var l = Fm(e[i]), u = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != s) {
      var h = o[l];
      u = void 0, u === void 0 && (u = wl(h) ? h : I3(e[i + 1]) ? [] : {});
    }
    bI(o, l, u), o = o[l];
  }
  return t;
}
function zYe(t, e, r) {
  for (var n = -1, i = e.length, a = {}; ++n < i; ) {
    var s = e[n], o = SI(t, s);
    r(o, s) && FYe(a, O3(s, t), o);
  }
  return a;
}
function Mo(t, e) {
  if (t == null)
    return {};
  var r = L3(kWe(t), function(n) {
    return [n];
  });
  return e = P3(e), zYe(t, r, function(n, i) {
    return e(n, i[0]);
  });
}
function qYe(t, e) {
  var r;
  return $3(t, function(n, i, a) {
    return r = e(n, i, a), !r;
  }), !!r;
}
function GYe(t, e, r) {
  var n = da(t) ? roe : qYe;
  return n(t, P3(e));
}
function UYe(t) {
  return VYe(t) ? t.LABEL : t.name;
}
function VYe(t) {
  return ex(t.LABEL) && t.LABEL !== "";
}
class No {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    this._definition = e;
  }
  accept(e) {
    e.visit(this), CYe(this.definition, (r) => {
      r.accept(e);
    });
  }
}
class Ki extends No {
  constructor(e) {
    super([]), this.idx = 1, Io(this, Mo(e, (r) => r !== void 0));
  }
  set definition(e) {
  }
  get definition() {
    return this.referencedRule !== void 0 ? this.referencedRule.definition : [];
  }
  accept(e) {
    e.visit(this);
  }
}
class j0 extends No {
  constructor(e) {
    super(e.definition), this.orgText = "", Io(this, Mo(e, (r) => r !== void 0));
  }
}
class pa extends No {
  constructor(e) {
    super(e.definition), this.ignoreAmbiguities = !1, Io(this, Mo(e, (r) => r !== void 0));
  }
}
let gi = class extends No {
  constructor(e) {
    super(e.definition), this.idx = 1, Io(this, Mo(e, (r) => r !== void 0));
  }
};
class Pa extends No {
  constructor(e) {
    super(e.definition), this.idx = 1, Io(this, Mo(e, (r) => r !== void 0));
  }
}
class $a extends No {
  constructor(e) {
    super(e.definition), this.idx = 1, Io(this, Mo(e, (r) => r !== void 0));
  }
}
class hn extends No {
  constructor(e) {
    super(e.definition), this.idx = 1, Io(this, Mo(e, (r) => r !== void 0));
  }
}
class ya extends No {
  constructor(e) {
    super(e.definition), this.idx = 1, Io(this, Mo(e, (r) => r !== void 0));
  }
}
class ba extends No {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    super(e.definition), this.idx = 1, this.ignoreAmbiguities = !1, this.hasPredicates = !1, Io(this, Mo(e, (r) => r !== void 0));
  }
}
class jr {
  constructor(e) {
    this.idx = 1, Io(this, Mo(e, (r) => r !== void 0));
  }
  accept(e) {
    e.visit(this);
  }
}
function HYe(t) {
  return soe(t, Jy);
}
function Jy(t) {
  function e(r) {
    return soe(r, Jy);
  }
  if (t instanceof Ki) {
    const r = {
      type: "NonTerminal",
      name: t.nonTerminalName,
      idx: t.idx
    };
    return ex(t.label) && (r.label = t.label), r;
  } else {
    if (t instanceof pa)
      return {
        type: "Alternative",
        definition: e(t.definition)
      };
    if (t instanceof gi)
      return {
        type: "Option",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof Pa)
      return {
        type: "RepetitionMandatory",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof $a)
      return {
        type: "RepetitionMandatoryWithSeparator",
        idx: t.idx,
        separator: Jy(new jr({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof ya)
      return {
        type: "RepetitionWithSeparator",
        idx: t.idx,
        separator: Jy(new jr({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof hn)
      return {
        type: "Repetition",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof ba)
      return {
        type: "Alternation",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof jr) {
      const r = {
        type: "Terminal",
        name: t.terminalType.name,
        label: UYe(t.terminalType),
        idx: t.idx
      };
      ex(t.label) && (r.terminalLabel = t.label);
      const n = t.terminalType.PATTERN;
      return t.terminalType.PATTERN && (r.pattern = BYe(n) ? n.source : n), r;
    } else {
      if (t instanceof j0)
        return {
          type: "Rule",
          name: t.name,
          orgText: t.orgText,
          definition: e(t.definition)
        };
      throw Error("non exhaustive match");
    }
  }
}
class K0 {
  visit(e) {
    const r = e;
    switch (r.constructor) {
      case Ki:
        return this.visitNonTerminal(r);
      case pa:
        return this.visitAlternative(r);
      case gi:
        return this.visitOption(r);
      case Pa:
        return this.visitRepetitionMandatory(r);
      case $a:
        return this.visitRepetitionMandatoryWithSeparator(r);
      case ya:
        return this.visitRepetitionWithSeparator(r);
      case hn:
        return this.visitRepetition(r);
      case ba:
        return this.visitAlternation(r);
      case jr:
        return this.visitTerminal(r);
      case j0:
        return this.visitRule(r);
      /* c8 ignore next 2 */
      default:
        throw Error("non exhaustive match");
    }
  }
  /* c8 ignore next */
  visitNonTerminal(e) {
  }
  /* c8 ignore next */
  visitAlternative(e) {
  }
  /* c8 ignore next */
  visitOption(e) {
  }
  /* c8 ignore next */
  visitRepetition(e) {
  }
  /* c8 ignore next */
  visitRepetitionMandatory(e) {
  }
  /* c8 ignore next 3 */
  visitRepetitionMandatoryWithSeparator(e) {
  }
  /* c8 ignore next */
  visitRepetitionWithSeparator(e) {
  }
  /* c8 ignore next */
  visitAlternation(e) {
  }
  /* c8 ignore next */
  visitTerminal(e) {
  }
  /* c8 ignore next */
  visitRule(e) {
  }
}
function WYe(t) {
  return t instanceof pa || t instanceof gi || t instanceof hn || t instanceof Pa || t instanceof $a || t instanceof ya || t instanceof jr || t instanceof j0;
}
function tx(t, e = []) {
  return t instanceof gi || t instanceof hn || t instanceof ya ? !0 : t instanceof ba ? GYe(t.definition, (n) => tx(n, e)) : t instanceof Ki && OYe(e, t) ? !1 : t instanceof No ? (t instanceof Ki && e.push(t), LYe(t.definition, (n) => tx(n, e))) : !1;
}
function YYe(t) {
  return t instanceof ba;
}
function eo(t) {
  if (t instanceof Ki)
    return "SUBRULE";
  if (t instanceof gi)
    return "OPTION";
  if (t instanceof ba)
    return "OR";
  if (t instanceof Pa)
    return "AT_LEAST_ONE";
  if (t instanceof $a)
    return "AT_LEAST_ONE_SEP";
  if (t instanceof ya)
    return "MANY_SEP";
  if (t instanceof hn)
    return "MANY";
  if (t instanceof jr)
    return "CONSUME";
  throw Error("non exhaustive match");
}
class B3 {
  walk(e, r = []) {
    Zt(e.definition, (n, i) => {
      const a = li(e.definition, i + 1);
      if (n instanceof Ki)
        this.walkProdRef(n, a, r);
      else if (n instanceof jr)
        this.walkTerminal(n, a, r);
      else if (n instanceof pa)
        this.walkFlat(n, a, r);
      else if (n instanceof gi)
        this.walkOption(n, a, r);
      else if (n instanceof Pa)
        this.walkAtLeastOne(n, a, r);
      else if (n instanceof $a)
        this.walkAtLeastOneSep(n, a, r);
      else if (n instanceof ya)
        this.walkManySep(n, a, r);
      else if (n instanceof hn)
        this.walkMany(n, a, r);
      else if (n instanceof ba)
        this.walkOr(n, a, r);
      else
        throw Error("non exhaustive match");
    });
  }
  walkTerminal(e, r, n) {
  }
  walkProdRef(e, r, n) {
  }
  walkFlat(e, r, n) {
    const i = r.concat(n);
    this.walk(e, i);
  }
  walkOption(e, r, n) {
    const i = r.concat(n);
    this.walk(e, i);
  }
  walkAtLeastOne(e, r, n) {
    const i = [
      new gi({ definition: e.definition })
    ].concat(r, n);
    this.walk(e, i);
  }
  walkAtLeastOneSep(e, r, n) {
    const i = GV(e, r, n);
    this.walk(e, i);
  }
  walkMany(e, r, n) {
    const i = [
      new gi({ definition: e.definition })
    ].concat(r, n);
    this.walk(e, i);
  }
  walkManySep(e, r, n) {
    const i = GV(e, r, n);
    this.walk(e, i);
  }
  walkOr(e, r, n) {
    const i = r.concat(n);
    Zt(e.definition, (a) => {
      const s = new pa({ definition: [a] });
      this.walk(s, i);
    });
  }
}
function GV(t, e, r) {
  return [
    new gi({
      definition: [
        new jr({ terminalType: t.separator })
      ].concat(t.definition)
    })
  ].concat(e, r);
}
function zm(t) {
  if (t instanceof Ki)
    return zm(t.referencedRule);
  if (t instanceof jr)
    return KYe(t);
  if (WYe(t))
    return XYe(t);
  if (YYe(t))
    return jYe(t);
  throw Error("non exhaustive match");
}
function XYe(t) {
  let e = [];
  const r = t.definition;
  let n = 0, i = r.length > n, a, s = !0;
  for (; i && s; )
    a = r[n], s = tx(a), e = e.concat(zm(a)), n = n + 1, i = r.length > n;
  return yI(e);
}
function jYe(t) {
  const e = $t(t.definition, (r) => zm(r));
  return yI(Ls(e));
}
function KYe(t) {
  return [t.terminalType];
}
const ooe = "_~IN~_";
class ZYe extends B3 {
  constructor(e) {
    super(), this.topProd = e, this.follows = {};
  }
  startWalking() {
    return this.walk(this.topProd), this.follows;
  }
  walkTerminal(e, r, n) {
  }
  walkProdRef(e, r, n) {
    const i = JYe(e.referencedRule, e.idx) + this.topProd.name, a = r.concat(n), s = new pa({ definition: a }), o = zm(s);
    this.follows[i] = o;
  }
}
function QYe(t) {
  const e = {};
  return Zt(t, (r) => {
    const n = new ZYe(r).startWalking();
    GA(e, n);
  }), e;
}
function JYe(t, e) {
  return t.name + e + ooe;
}
let e2 = {};
const eXe = new Jae();
function F3(t) {
  const e = t.toString();
  if (e2.hasOwnProperty(e))
    return e2[e];
  {
    const r = eXe.pattern(e);
    return e2[e] = r, r;
  }
}
function tXe() {
  e2 = {};
}
const loe = "Complement Sets are not supported for first char optimization", rx = `Unable to use "first char" lexer optimizations:
`;
function rXe(t, e = !1) {
  try {
    const r = F3(t);
    return QA(r.value, {}, r.flags.ignoreCase);
  } catch (r) {
    if (r.message === loe)
      e && Pse(`${rx}	Unable to optimize: < ${t.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
    else {
      let n = "";
      e && (n = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), WA(`${rx}
	Failed parsing: < ${t.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + n);
    }
  }
  return [];
}
function QA(t, e, r) {
  switch (t.type) {
    case "Disjunction":
      for (let i = 0; i < t.value.length; i++)
        QA(t.value[i], e, r);
      break;
    case "Alternative":
      const n = t.value;
      for (let i = 0; i < n.length; i++) {
        const a = n[i];
        switch (a.type) {
          case "EndAnchor":
          // A group back reference cannot affect potential starting char.
          // because if a back reference is the first production than automatically
          // the group being referenced has had to come BEFORE so its codes have already been added
          case "GroupBackReference":
          // assertions do not affect potential starting codes
          case "Lookahead":
          case "NegativeLookahead":
          case "StartAnchor":
          case "WordBoundary":
          case "NonWordBoundary":
            continue;
        }
        const s = a;
        switch (s.type) {
          case "Character":
            Qv(s.value, e, r);
            break;
          case "Set":
            if (s.complement === !0)
              throw Error(loe);
            Zt(s.value, (l) => {
              if (typeof l == "number")
                Qv(l, e, r);
              else {
                const u = l;
                if (r === !0)
                  for (let h = u.from; h <= u.to; h++)
                    Qv(h, e, r);
                else {
                  for (let h = u.from; h <= u.to && h < xg; h++)
                    Qv(h, e, r);
                  if (u.to >= xg) {
                    const h = u.from >= xg ? u.from : xg, f = u.to, d = Lc(h), p = Lc(f);
                    for (let g = d; g <= p; g++)
                      e[g] = g;
                  }
                }
              }
            });
            break;
          case "Group":
            QA(s.value, e, r);
            break;
          /* istanbul ignore next */
          default:
            throw Error("Non Exhaustive Match");
        }
        const o = s.quantifier !== void 0 && s.quantifier.atLeast === 0;
        if (
          // A group may be optional due to empty contents /(?:)/
          // or if everything inside it is optional /((a)?)/
          s.type === "Group" && JA(s) === !1 || // If this term is not a group it may only be optional if it has an optional quantifier
          s.type !== "Group" && o === !1
        )
          break;
      }
      break;
    /* istanbul ignore next */
    default:
      throw Error("non exhaustive match!");
  }
  return Fn(e);
}
function Qv(t, e, r) {
  const n = Lc(t);
  e[n] = n, r === !0 && nXe(t, e);
}
function nXe(t, e) {
  const r = String.fromCharCode(t), n = r.toUpperCase();
  if (n !== r) {
    const i = Lc(n.charCodeAt(0));
    e[i] = i;
  } else {
    const i = r.toLowerCase();
    if (i !== r) {
      const a = Lc(i.charCodeAt(0));
      e[a] = a;
    }
  }
}
function UV(t, e) {
  return m0(t.value, (r) => {
    if (typeof r == "number")
      return va(e, r);
    {
      const n = r;
      return m0(e, (i) => n.from <= i && i <= n.to) !== void 0;
    }
  });
}
function JA(t) {
  const e = t.quantifier;
  return e && e.atLeast === 0 ? !0 : t.value ? xr(t.value) ? fo(t.value, JA) : JA(t.value) : !1;
}
class iXe extends p3 {
  constructor(e) {
    super(), this.targetCharCodes = e, this.found = !1;
  }
  visitChildren(e) {
    if (this.found !== !0) {
      switch (e.type) {
        case "Lookahead":
          this.visitLookahead(e);
          return;
        case "NegativeLookahead":
          this.visitNegativeLookahead(e);
          return;
      }
      super.visitChildren(e);
    }
  }
  visitCharacter(e) {
    va(this.targetCharCodes, e.value) && (this.found = !0);
  }
  visitSet(e) {
    e.complement ? UV(e, this.targetCharCodes) === void 0 && (this.found = !0) : UV(e, this.targetCharCodes) !== void 0 && (this.found = !0);
  }
}
function CI(t, e) {
  if (e instanceof RegExp) {
    const r = F3(e), n = new iXe(t);
    return n.visit(r), n.found;
  } else
    return m0(e, (r) => va(t, r.charCodeAt(0))) !== void 0;
}
const hh = "PATTERN", bg = "defaultMode", Jv = "modes";
let coe = typeof new RegExp("(?:)").sticky == "boolean";
function aXe(t, e) {
  e = vI(e, {
    useSticky: coe,
    debug: !1,
    safeMode: !1,
    positionTracking: "full",
    lineTerminatorCharacters: ["\r", `
`],
    tracer: (b, x) => x()
  });
  const r = e.tracer;
  r("initCharCodeToOptimizedIndexMap", () => {
    AXe();
  });
  let n;
  r("Reject Lexer.NA", () => {
    n = _3(t, (b) => b[hh] === ha.NA);
  });
  let i = !1, a;
  r("Transform Patterns", () => {
    i = !1, a = $t(n, (b) => {
      const x = b[hh];
      if (Cc(x)) {
        const T = x.source;
        return T.length === 1 && // only these regExp meta characters which can appear in a length one regExp
        T !== "^" && T !== "$" && T !== "." && !x.ignoreCase ? T : T.length === 2 && T[0] === "\\" && // not a meta character
        !va([
          "d",
          "D",
          "s",
          "S",
          "t",
          "r",
          "n",
          "t",
          "0",
          "c",
          "b",
          "B",
          "f",
          "v",
          "w",
          "W"
        ], T[1]) ? T[1] : e.useSticky ? HV(x) : VV(x);
      } else {
        if (Ml(x))
          return i = !0, { exec: x };
        if (typeof x == "object")
          return i = !0, x;
        if (typeof x == "string") {
          if (x.length === 1)
            return x;
          {
            const T = x.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), E = new RegExp(T);
            return e.useSticky ? HV(E) : VV(E);
          }
        } else
          throw Error("non exhaustive match");
      }
    });
  });
  let s, o, l, u, h;
  r("misc mapping", () => {
    s = $t(n, (b) => b.tokenTypeIdx), o = $t(n, (b) => {
      const x = b.GROUP;
      if (x !== ha.SKIPPED) {
        if ($s(x))
          return x;
        if (xl(x))
          return !1;
        throw Error("non exhaustive match");
      }
    }), l = $t(n, (b) => {
      const x = b.LONGER_ALT;
      if (x)
        return xr(x) ? $t(x, (E) => mV(n, E)) : [mV(n, x)];
    }), u = $t(n, (b) => b.PUSH_MODE), h = $t(n, (b) => Vt(b, "POP_MODE"));
  });
  let f;
  r("Line Terminator Handling", () => {
    const b = foe(e.lineTerminatorCharacters);
    f = $t(n, (x) => !1), e.positionTracking !== "onlyOffset" && (f = $t(n, (x) => Vt(x, "LINE_BREAKS") ? !!x.LINE_BREAKS : hoe(x, b) === !1 && CI(b, x.PATTERN)));
  });
  let d, p, g, m;
  r("Misc Mapping #2", () => {
    d = $t(n, uoe), p = $t(a, kXe), g = Ma(n, (b, x) => {
      const T = x.GROUP;
      return $s(T) && T !== ha.SKIPPED && (b[T] = []), b;
    }, {}), m = $t(a, (b, x) => ({
      pattern: a[x],
      longerAlt: l[x],
      canLineTerminator: f[x],
      isCustom: d[x],
      short: p[x],
      group: o[x],
      push: u[x],
      pop: h[x],
      tokenTypeIdx: s[x],
      tokenType: n[x]
    }));
  });
  let v = !0, y = [];
  return e.safeMode || r("First Char Optimization", () => {
    y = Ma(n, (b, x, T) => {
      if (typeof x.PATTERN == "string") {
        const E = x.PATTERN.charCodeAt(0), A = Lc(E);
        b7(b, A, m[T]);
      } else if (xr(x.START_CHARS_HINT)) {
        let E;
        Zt(x.START_CHARS_HINT, (A) => {
          const S = typeof A == "string" ? A.charCodeAt(0) : A, k = Lc(S);
          E !== k && (E = k, b7(b, k, m[T]));
        });
      } else if (Cc(x.PATTERN))
        if (x.PATTERN.unicode)
          v = !1, e.ensureOptimizations && WA(`${rx}	Unable to analyze < ${x.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
        else {
          const E = rXe(x.PATTERN, e.ensureOptimizations);
          qr(E) && (v = !1), Zt(E, (A) => {
            b7(b, A, m[T]);
          });
        }
      else
        e.ensureOptimizations && WA(`${rx}	TokenType: <${x.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), v = !1;
      return b;
    }, []);
  }), {
    emptyGroups: g,
    patternIdxToConfig: m,
    charCodeToPatternIdxToConfig: y,
    hasCustom: i,
    canBeOptimized: v
  };
}
function sXe(t, e) {
  let r = [];
  const n = lXe(t);
  r = r.concat(n.errors);
  const i = cXe(n.valid), a = i.valid;
  return r = r.concat(i.errors), r = r.concat(oXe(a)), r = r.concat(vXe(a)), r = r.concat(yXe(a, e)), r = r.concat(bXe(a)), r;
}
function oXe(t) {
  let e = [];
  const r = ds(t, (n) => Cc(n[hh]));
  return e = e.concat(hXe(r)), e = e.concat(pXe(r)), e = e.concat(gXe(r)), e = e.concat(mXe(r)), e = e.concat(fXe(r)), e;
}
function lXe(t) {
  const e = ds(t, (i) => !Vt(i, hh)), r = $t(e, (i) => ({
    message: "Token Type: ->" + i.name + "<- missing static 'PATTERN' property",
    type: fn.MISSING_PATTERN,
    tokenTypes: [i]
  })), n = C3(t, e);
  return { errors: r, valid: n };
}
function cXe(t) {
  const e = ds(t, (i) => {
    const a = i[hh];
    return !Cc(a) && !Ml(a) && !Vt(a, "exec") && !$s(a);
  }), r = $t(e, (i) => ({
    message: "Token Type: ->" + i.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
    type: fn.INVALID_PATTERN,
    tokenTypes: [i]
  })), n = C3(t, e);
  return { errors: r, valid: n };
}
const uXe = /[^\\][$]/;
function hXe(t) {
  class e extends p3 {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitEndAnchor(a) {
      this.found = !0;
    }
  }
  const r = ds(t, (i) => {
    const a = i.PATTERN;
    try {
      const s = F3(a), o = new e();
      return o.visit(s), o.found;
    } catch {
      return uXe.test(a.source);
    }
  });
  return $t(r, (i) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + i.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: fn.EOI_ANCHOR_FOUND,
    tokenTypes: [i]
  }));
}
function fXe(t) {
  const e = ds(t, (n) => n.PATTERN.test(""));
  return $t(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'PATTERN' must not match an empty string",
    type: fn.EMPTY_MATCH_PATTERN,
    tokenTypes: [n]
  }));
}
const dXe = /[^\\[][\^]|^\^/;
function pXe(t) {
  class e extends p3 {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitStartAnchor(a) {
      this.found = !0;
    }
  }
  const r = ds(t, (i) => {
    const a = i.PATTERN;
    try {
      const s = F3(a), o = new e();
      return o.visit(s), o.found;
    } catch {
      return dXe.test(a.source);
    }
  });
  return $t(r, (i) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + i.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: fn.SOI_ANCHOR_FOUND,
    tokenTypes: [i]
  }));
}
function gXe(t) {
  const e = ds(t, (n) => {
    const i = n[hh];
    return i instanceof RegExp && (i.multiline || i.global);
  });
  return $t(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
    type: fn.UNSUPPORTED_FLAGS_FOUND,
    tokenTypes: [n]
  }));
}
function mXe(t) {
  const e = [];
  let r = $t(t, (a) => Ma(t, (s, o) => (a.PATTERN.source === o.PATTERN.source && !va(e, o) && o.PATTERN !== ha.NA && (e.push(o), s.push(o)), s), []));
  r = $m(r);
  const n = ds(r, (a) => a.length > 1);
  return $t(n, (a) => {
    const s = $t(a, (l) => l.name);
    return {
      message: `The same RegExp pattern ->${Ps(a).PATTERN}<-has been used in all of the following Token Types: ${s.join(", ")} <-`,
      type: fn.DUPLICATE_PATTERNS_FOUND,
      tokenTypes: a
    };
  });
}
function vXe(t) {
  const e = ds(t, (n) => {
    if (!Vt(n, "GROUP"))
      return !1;
    const i = n.GROUP;
    return i !== ha.SKIPPED && i !== ha.NA && !$s(i);
  });
  return $t(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
    type: fn.INVALID_GROUP_TYPE_FOUND,
    tokenTypes: [n]
  }));
}
function yXe(t, e) {
  const r = ds(t, (i) => i.PUSH_MODE !== void 0 && !va(e, i.PUSH_MODE));
  return $t(r, (i) => ({
    message: `Token Type: ->${i.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${i.PUSH_MODE}<-which does not exist`,
    type: fn.PUSH_MODE_DOES_NOT_EXIST,
    tokenTypes: [i]
  }));
}
function bXe(t) {
  const e = [], r = Ma(t, (n, i, a) => {
    const s = i.PATTERN;
    return s === ha.NA || ($s(s) ? n.push({ str: s, idx: a, tokenType: i }) : Cc(s) && wXe(s) && n.push({ str: s.source, idx: a, tokenType: i })), n;
  }, []);
  return Zt(t, (n, i) => {
    Zt(r, ({ str: a, idx: s, tokenType: o }) => {
      if (i < s && xXe(a, n.PATTERN)) {
        const l = `Token: ->${o.name}<- can never be matched.
Because it appears AFTER the Token Type ->${n.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
        e.push({
          message: l,
          type: fn.UNREACHABLE_PATTERN,
          tokenTypes: [n, o]
        });
      }
    });
  }), e;
}
function xXe(t, e) {
  if (Cc(e)) {
    const r = e.exec(t);
    return r !== null && r.index === 0;
  } else {
    if (Ml(e))
      return e(t, 0, [], {});
    if (Vt(e, "exec"))
      return e.exec(t, 0, [], {});
    if (typeof e == "string")
      return e === t;
    throw Error("non exhaustive match");
  }
}
function wXe(t) {
  return m0([
    ".",
    "\\",
    "[",
    "]",
    "|",
    "^",
    "$",
    "(",
    ")",
    "?",
    "*",
    "+",
    "{"
  ], (r) => t.source.indexOf(r) !== -1) === void 0;
}
function VV(t) {
  const e = t.ignoreCase ? "i" : "";
  return new RegExp(`^(?:${t.source})`, e);
}
function HV(t) {
  const e = t.ignoreCase ? "iy" : "y";
  return new RegExp(`${t.source}`, e);
}
function TXe(t, e, r) {
  const n = [];
  return Vt(t, bg) || n.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + bg + `> property in its definition
`,
    type: fn.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
  }), Vt(t, Jv) || n.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + Jv + `> property in its definition
`,
    type: fn.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
  }), Vt(t, Jv) && Vt(t, bg) && !Vt(t.modes, t.defaultMode) && n.push({
    message: `A MultiMode Lexer cannot be initialized with a ${bg}: <${t.defaultMode}>which does not exist
`,
    type: fn.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
  }), Vt(t, Jv) && Zt(t.modes, (i, a) => {
    Zt(i, (s, o) => {
      if (xl(s))
        n.push({
          message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${a}> at index: <${o}>
`,
          type: fn.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
        });
      else if (Vt(s, "LONGER_ALT")) {
        const l = xr(s.LONGER_ALT) ? s.LONGER_ALT : [s.LONGER_ALT];
        Zt(l, (u) => {
          !xl(u) && !va(i, u) && n.push({
            message: `A MultiMode Lexer cannot be initialized with a longer_alt <${u.name}> on token <${s.name}> outside of mode <${a}>
`,
            type: fn.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
          });
        });
      }
    });
  }), n;
}
function EXe(t, e, r) {
  const n = [];
  let i = !1;
  const a = $m(Ls(Fn(t.modes))), s = _3(a, (l) => l[hh] === ha.NA), o = foe(r);
  return e && Zt(s, (l) => {
    const u = hoe(l, o);
    if (u !== !1) {
      const f = {
        message: _Xe(l, u),
        type: u.issue,
        tokenType: l
      };
      n.push(f);
    } else
      Vt(l, "LINE_BREAKS") ? l.LINE_BREAKS === !0 && (i = !0) : CI(o, l.PATTERN) && (i = !0);
  }), e && !i && n.push({
    message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`,
    type: fn.NO_LINE_BREAKS_FLAGS
  }), n;
}
function SXe(t) {
  const e = {}, r = us(t);
  return Zt(r, (n) => {
    const i = t[n];
    if (xr(i))
      e[n] = [];
    else
      throw Error("non exhaustive match");
  }), e;
}
function uoe(t) {
  const e = t.PATTERN;
  if (Cc(e))
    return !1;
  if (Ml(e))
    return !0;
  if (Vt(e, "exec"))
    return !0;
  if ($s(e))
    return !1;
  throw Error("non exhaustive match");
}
function kXe(t) {
  return $s(t) && t.length === 1 ? t.charCodeAt(0) : !1;
}
const CXe = {
  // implements /\n|\r\n?/g.test
  test: function(t) {
    const e = t.length;
    for (let r = this.lastIndex; r < e; r++) {
      const n = t.charCodeAt(r);
      if (n === 10)
        return this.lastIndex = r + 1, !0;
      if (n === 13)
        return t.charCodeAt(r + 1) === 10 ? this.lastIndex = r + 2 : this.lastIndex = r + 1, !0;
    }
    return !1;
  },
  lastIndex: 0
};
function hoe(t, e) {
  if (Vt(t, "LINE_BREAKS"))
    return !1;
  if (Cc(t.PATTERN)) {
    try {
      CI(e, t.PATTERN);
    } catch (r) {
      return {
        issue: fn.IDENTIFY_TERMINATOR,
        errMsg: r.message
      };
    }
    return !1;
  } else {
    if ($s(t.PATTERN))
      return !1;
    if (uoe(t))
      return { issue: fn.CUSTOM_LINE_BREAK };
    throw Error("non exhaustive match");
  }
}
function _Xe(t, e) {
  if (e.issue === fn.IDENTIFY_TERMINATOR)
    return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${t.name}> Token Type
	 Root cause: ${e.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
  if (e.issue === fn.CUSTOM_LINE_BREAK)
    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${t.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
  throw Error("non exhaustive match");
}
function foe(t) {
  return $t(t, (r) => $s(r) ? r.charCodeAt(0) : r);
}
function b7(t, e, r) {
  t[e] === void 0 ? t[e] = [r] : t[e].push(r);
}
const xg = 256;
let t2 = [];
function Lc(t) {
  return t < xg ? t : t2[t];
}
function AXe() {
  if (qr(t2)) {
    t2 = new Array(65536);
    for (let t = 0; t < 65536; t++)
      t2[t] = t > 255 ? 255 + ~~(t / 255) : t;
  }
}
function qm(t, e) {
  const r = t.tokenTypeIdx;
  return r === e.tokenTypeIdx ? !0 : e.isParent === !0 && e.categoryMatchesMap[r] === !0;
}
function nx(t, e) {
  return t.tokenTypeIdx === e.tokenTypeIdx;
}
let WV = 1;
const doe = {};
function Gm(t) {
  const e = LXe(t);
  RXe(e), MXe(e), IXe(e), Zt(e, (r) => {
    r.isParent = r.categoryMatches.length > 0;
  });
}
function LXe(t) {
  let e = mi(t), r = t, n = !0;
  for (; n; ) {
    r = $m(Ls($t(r, (a) => a.CATEGORIES)));
    const i = C3(r, e);
    e = e.concat(i), qr(i) ? n = !1 : r = i;
  }
  return e;
}
function RXe(t) {
  Zt(t, (e) => {
    goe(e) || (doe[WV] = e, e.tokenTypeIdx = WV++), YV(e) && !xr(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), YV(e) || (e.CATEGORIES = []), NXe(e) || (e.categoryMatches = []), DXe(e) || (e.categoryMatchesMap = {});
  });
}
function IXe(t) {
  Zt(t, (e) => {
    e.categoryMatches = [], Zt(e.categoryMatchesMap, (r, n) => {
      e.categoryMatches.push(doe[n].tokenTypeIdx);
    });
  });
}
function MXe(t) {
  Zt(t, (e) => {
    poe([], e);
  });
}
function poe(t, e) {
  Zt(t, (r) => {
    e.categoryMatchesMap[r.tokenTypeIdx] = !0;
  }), Zt(e.CATEGORIES, (r) => {
    const n = t.concat(e);
    va(n, r) || poe(n, r);
  });
}
function goe(t) {
  return Vt(t, "tokenTypeIdx");
}
function YV(t) {
  return Vt(t, "CATEGORIES");
}
function NXe(t) {
  return Vt(t, "categoryMatches");
}
function DXe(t) {
  return Vt(t, "categoryMatchesMap");
}
function OXe(t) {
  return Vt(t, "tokenTypeIdx");
}
const e8 = {
  buildUnableToPopLexerModeMessage(t) {
    return `Unable to pop Lexer Mode after encountering Token ->${t.image}<- The Mode Stack is empty`;
  },
  buildUnexpectedCharactersMessage(t, e, r, n, i) {
    return `unexpected character: ->${t.charAt(e)}<- at offset: ${e}, skipped ${r} characters.`;
  }
};
var fn;
(function(t) {
  t[t.MISSING_PATTERN = 0] = "MISSING_PATTERN", t[t.INVALID_PATTERN = 1] = "INVALID_PATTERN", t[t.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", t[t.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", t[t.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", t[t.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", t[t.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", t[t.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", t[t.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", t[t.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", t[t.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", t[t.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", t[t.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK", t[t.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
})(fn || (fn = {}));
const wg = {
  deferDefinitionErrorsHandling: !1,
  positionTracking: "full",
  lineTerminatorsPattern: /\n|\r\n?/g,
  lineTerminatorCharacters: [`
`, "\r"],
  ensureOptimizations: !1,
  safeMode: !1,
  errorMessageProvider: e8,
  traceInitPerf: !1,
  skipValidations: !1,
  recoveryEnabled: !0
};
Object.freeze(wg);
class ha {
  constructor(e, r = wg) {
    if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, this.TRACE_INIT = (i, a) => {
      if (this.traceInitPerf === !0) {
        this.traceInitIndent++;
        const s = new Array(this.traceInitIndent + 1).join("	");
        this.traceInitIndent < this.traceInitMaxIdent && console.log(`${s}--> <${i}>`);
        const { time: o, value: l } = $se(a), u = o > 10 ? console.warn : console.log;
        return this.traceInitIndent < this.traceInitMaxIdent && u(`${s}<-- <${i}> time: ${o}ms`), this.traceInitIndent--, l;
      } else
        return a();
    }, typeof r == "boolean")
      throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
    this.config = GA({}, wg, r);
    const n = this.config.traceInitPerf;
    n === !0 ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = !0) : typeof n == "number" && (this.traceInitMaxIdent = n, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", () => {
      let i, a = !0;
      this.TRACE_INIT("Lexer Config handling", () => {
        if (this.config.lineTerminatorsPattern === wg.lineTerminatorsPattern)
          this.config.lineTerminatorsPattern = CXe;
        else if (this.config.lineTerminatorCharacters === wg.lineTerminatorCharacters)
          throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
        if (r.safeMode && r.ensureOptimizations)
          throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking), xr(e) ? i = {
          modes: { defaultMode: mi(e) },
          defaultMode: bg
        } : (a = !1, i = mi(e));
      }), this.config.skipValidations === !1 && (this.TRACE_INIT("performRuntimeChecks", () => {
        this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(TXe(i, this.trackStartLines, this.config.lineTerminatorCharacters));
      }), this.TRACE_INIT("performWarningRuntimeChecks", () => {
        this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(EXe(i, this.trackStartLines, this.config.lineTerminatorCharacters));
      })), i.modes = i.modes ? i.modes : {}, Zt(i.modes, (o, l) => {
        i.modes[l] = _3(o, (u) => xl(u));
      });
      const s = us(i.modes);
      if (Zt(i.modes, (o, l) => {
        this.TRACE_INIT(`Mode: <${l}> processing`, () => {
          if (this.modes.push(l), this.config.skipValidations === !1 && this.TRACE_INIT("validatePatterns", () => {
            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(sXe(o, s));
          }), qr(this.lexerDefinitionErrors)) {
            Gm(o);
            let u;
            this.TRACE_INIT("analyzeTokenTypes", () => {
              u = aXe(o, {
                lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                positionTracking: r.positionTracking,
                ensureOptimizations: r.ensureOptimizations,
                safeMode: r.safeMode,
                tracer: this.TRACE_INIT
              });
            }), this.patternIdxToConfig[l] = u.patternIdxToConfig, this.charCodeToPatternIdxToConfig[l] = u.charCodeToPatternIdxToConfig, this.emptyGroups = GA({}, this.emptyGroups, u.emptyGroups), this.hasCustom = u.hasCustom || this.hasCustom, this.canModeBeOptimized[l] = u.canBeOptimized;
          }
        });
      }), this.defaultMode = i.defaultMode, !qr(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
        const l = $t(this.lexerDefinitionErrors, (u) => u.message).join(`-----------------------
`);
        throw new Error(`Errors detected in definition of Lexer:
` + l);
      }
      Zt(this.lexerDefinitionWarning, (o) => {
        Pse(o.message);
      }), this.TRACE_INIT("Choosing sub-methods implementations", () => {
        if (coe ? (this.chopInput = d0, this.match = this.matchWithTest) : (this.updateLastIndex = Pn, this.match = this.matchWithExec), a && (this.handleModes = Pn), this.trackStartLines === !1 && (this.computeNewColumn = d0), this.trackEndLines === !1 && (this.updateTokenEndLineColumnLocation = Pn), /full/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createFullToken;
        else if (/onlyStart/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createStartOnlyToken;
        else if (/onlyOffset/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createOffsetOnlyToken;
        else
          throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
        this.hasCustom ? (this.addToken = this.addTokenUsingPush, this.handlePayload = this.handlePayloadWithCustom) : (this.addToken = this.addTokenUsingMemberAccess, this.handlePayload = this.handlePayloadNoCustom);
      }), this.TRACE_INIT("Failed Optimization Warnings", () => {
        const o = Ma(this.canModeBeOptimized, (l, u, h) => (u === !1 && l.push(h), l), []);
        if (r.ensureOptimizations && !qr(o))
          throw Error(`Lexer Modes: < ${o.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
      }), this.TRACE_INIT("clearRegExpParserCache", () => {
        tXe();
      }), this.TRACE_INIT("toFastProperties", () => {
        Bse(this);
      });
    });
  }
  tokenize(e, r = this.defaultMode) {
    if (!qr(this.lexerDefinitionErrors)) {
      const i = $t(this.lexerDefinitionErrors, (a) => a.message).join(`-----------------------
`);
      throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + i);
    }
    return this.tokenizeInternal(e, r);
  }
  // There is quite a bit of duplication between this and "tokenizeInternalLazy"
  // This is intentional due to performance considerations.
  // this method also used quite a bit of `!` none null assertions because it is too optimized
  // for `tsc` to always understand it is "safe"
  tokenizeInternal(e, r) {
    let n, i, a, s, o, l, u, h, f, d, p, g, m, v, y;
    const b = e, x = b.length;
    let T = 0, E = 0;
    const A = this.hasCustom ? 0 : Math.floor(e.length / 10), S = new Array(A), k = [];
    let _ = this.trackStartLines ? 1 : void 0, R = this.trackStartLines ? 1 : void 0;
    const L = SXe(this.emptyGroups), M = this.trackStartLines, P = this.config.lineTerminatorsPattern;
    let C = 0, I = [], N = [];
    const O = [], D = [];
    Object.freeze(D);
    let $;
    function z() {
      return I;
    }
    function B(Z) {
      const K = Lc(Z), ce = N[K];
      return ce === void 0 ? D : ce;
    }
    const G = (Z) => {
      if (O.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
      // So no error should occur.
      Z.tokenType.PUSH_MODE === void 0) {
        const K = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(Z);
        k.push({
          offset: Z.startOffset,
          line: Z.startLine,
          column: Z.startColumn,
          length: Z.image.length,
          message: K
        });
      } else {
        O.pop();
        const K = g0(O);
        I = this.patternIdxToConfig[K], N = this.charCodeToPatternIdxToConfig[K], C = I.length;
        const ce = this.canModeBeOptimized[K] && this.config.safeMode === !1;
        N && ce ? $ = B : $ = z;
      }
    };
    function W(Z) {
      O.push(Z), N = this.charCodeToPatternIdxToConfig[Z], I = this.patternIdxToConfig[Z], C = I.length, C = I.length;
      const K = this.canModeBeOptimized[Z] && this.config.safeMode === !1;
      N && K ? $ = B : $ = z;
    }
    W.call(this, r);
    let V;
    const U = this.config.recoveryEnabled;
    for (; T < x; ) {
      l = null;
      const Z = b.charCodeAt(T), K = $(Z), ce = K.length;
      for (n = 0; n < ce; n++) {
        V = K[n];
        const J = V.pattern;
        u = null;
        const ee = V.short;
        if (ee !== !1 ? Z === ee && (l = J) : V.isCustom === !0 ? (y = J.exec(b, T, S, L), y !== null ? (l = y[0], y.payload !== void 0 && (u = y.payload)) : l = null) : (this.updateLastIndex(J, T), l = this.match(J, e, T)), l !== null) {
          if (o = V.longerAlt, o !== void 0) {
            const j = o.length;
            for (a = 0; a < j; a++) {
              const X = I[o[a]], re = X.pattern;
              if (h = null, X.isCustom === !0 ? (y = re.exec(b, T, S, L), y !== null ? (s = y[0], y.payload !== void 0 && (h = y.payload)) : s = null) : (this.updateLastIndex(re, T), s = this.match(re, e, T)), s && s.length > l.length) {
                l = s, u = h, V = X;
                break;
              }
            }
          }
          break;
        }
      }
      if (l !== null) {
        if (f = l.length, d = V.group, d !== void 0 && (p = V.tokenTypeIdx, g = this.createTokenInstance(l, T, p, V.tokenType, _, R, f), this.handlePayload(g, u), d === !1 ? E = this.addToken(S, E, g) : L[d].push(g)), e = this.chopInput(e, f), T = T + f, R = this.computeNewColumn(R, f), M === !0 && V.canLineTerminator === !0) {
          let J = 0, ee, j;
          P.lastIndex = 0;
          do
            ee = P.test(l), ee === !0 && (j = P.lastIndex - 1, J++);
          while (ee === !0);
          J !== 0 && (_ = _ + J, R = f - j, this.updateTokenEndLineColumnLocation(g, d, j, J, _, R, f));
        }
        this.handleModes(V, G, W, g);
      } else {
        const J = T, ee = _, j = R;
        let X = U === !1;
        for (; X === !1 && T < x; )
          for (e = this.chopInput(e, 1), T++, i = 0; i < C; i++) {
            const re = I[i], Q = re.pattern, ue = re.short;
            if (ue !== !1 ? b.charCodeAt(T) === ue && (X = !0) : re.isCustom === !0 ? X = Q.exec(b, T, S, L) !== null : (this.updateLastIndex(Q, T), X = Q.exec(e) !== null), X === !0)
              break;
          }
        if (m = T - J, R = this.computeNewColumn(R, m), v = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(b, J, m, ee, j), k.push({
          offset: J,
          line: ee,
          column: j,
          length: m,
          message: v
        }), U === !1)
          break;
      }
    }
    return this.hasCustom || (S.length = E), {
      tokens: S,
      groups: L,
      errors: k
    };
  }
  handleModes(e, r, n, i) {
    if (e.pop === !0) {
      const a = e.push;
      r(i), a !== void 0 && n.call(this, a);
    } else e.push !== void 0 && n.call(this, e.push);
  }
  chopInput(e, r) {
    return e.substring(r);
  }
  updateLastIndex(e, r) {
    e.lastIndex = r;
  }
  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
  updateTokenEndLineColumnLocation(e, r, n, i, a, s, o) {
    let l, u;
    r !== void 0 && (l = n === o - 1, u = l ? -1 : 0, i === 1 && l === !0 || (e.endLine = a + u, e.endColumn = s - 1 + -u));
  }
  computeNewColumn(e, r) {
    return e + r;
  }
  createOffsetOnlyToken(e, r, n, i) {
    return {
      image: e,
      startOffset: r,
      tokenTypeIdx: n,
      tokenType: i
    };
  }
  createStartOnlyToken(e, r, n, i, a, s) {
    return {
      image: e,
      startOffset: r,
      startLine: a,
      startColumn: s,
      tokenTypeIdx: n,
      tokenType: i
    };
  }
  createFullToken(e, r, n, i, a, s, o) {
    return {
      image: e,
      startOffset: r,
      endOffset: r + o - 1,
      startLine: a,
      endLine: a,
      startColumn: s,
      endColumn: s + o - 1,
      tokenTypeIdx: n,
      tokenType: i
    };
  }
  addTokenUsingPush(e, r, n) {
    return e.push(n), r;
  }
  addTokenUsingMemberAccess(e, r, n) {
    return e[r] = n, r++, r;
  }
  handlePayloadNoCustom(e, r) {
  }
  handlePayloadWithCustom(e, r) {
    r !== null && (e.payload = r);
  }
  matchWithTest(e, r, n) {
    return e.test(r) === !0 ? r.substring(n, e.lastIndex) : null;
  }
  matchWithExec(e, r) {
    const n = e.exec(r);
    return n !== null ? n[0] : null;
  }
}
ha.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
ha.NA = /NOT_APPLICABLE/;
function Vf(t) {
  return moe(t) ? t.LABEL : t.name;
}
function moe(t) {
  return $s(t.LABEL) && t.LABEL !== "";
}
const PXe = "parent", XV = "categories", jV = "label", KV = "group", ZV = "push_mode", QV = "pop_mode", JV = "longer_alt", eH = "line_breaks", tH = "start_chars_hint";
function voe(t) {
  return $Xe(t);
}
function $Xe(t) {
  const e = t.pattern, r = {};
  if (r.name = t.name, xl(e) || (r.PATTERN = e), Vt(t, PXe))
    throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
  return Vt(t, XV) && (r.CATEGORIES = t[XV]), Gm([r]), Vt(t, jV) && (r.LABEL = t[jV]), Vt(t, KV) && (r.GROUP = t[KV]), Vt(t, QV) && (r.POP_MODE = t[QV]), Vt(t, ZV) && (r.PUSH_MODE = t[ZV]), Vt(t, JV) && (r.LONGER_ALT = t[JV]), Vt(t, eH) && (r.LINE_BREAKS = t[eH]), Vt(t, tH) && (r.START_CHARS_HINT = t[tH]), r;
}
const Rc = voe({ name: "EOF", pattern: ha.NA });
Gm([Rc]);
function _I(t, e, r, n, i, a, s, o) {
  return {
    image: e,
    startOffset: r,
    endOffset: n,
    startLine: i,
    endLine: a,
    startColumn: s,
    endColumn: o,
    tokenTypeIdx: t.tokenTypeIdx,
    tokenType: t
  };
}
function yoe(t, e) {
  return qm(t, e);
}
const _f = {
  buildMismatchTokenMessage({ expected: t, actual: e, previous: r, ruleName: n }) {
    return `Expecting ${moe(t) ? `--> ${Vf(t)} <--` : `token of type --> ${t.name} <--`} but found --> '${e.image}' <--`;
  },
  buildNotAllInputParsedMessage({ firstRedundant: t, ruleName: e }) {
    return "Redundant input, expecting EOF but found: " + t.image;
  },
  buildNoViableAltMessage({ expectedPathsPerAlt: t, actual: e, previous: r, customUserDescription: n, ruleName: i }) {
    const a = "Expecting: ", o = `
but found: '` + Ps(e).image + "'";
    if (n)
      return a + n + o;
    {
      const l = Ma(t, (d, p) => d.concat(p), []), u = $t(l, (d) => `[${$t(d, (p) => Vf(p)).join(", ")}]`), f = `one of these possible Token sequences:
${$t(u, (d, p) => `  ${p + 1}. ${d}`).join(`
`)}`;
      return a + f + o;
    }
  },
  buildEarlyExitMessage({ expectedIterationPaths: t, actual: e, customUserDescription: r, ruleName: n }) {
    const i = "Expecting: ", s = `
but found: '` + Ps(e).image + "'";
    if (r)
      return i + r + s;
    {
      const l = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${$t(t, (u) => `[${$t(u, (h) => Vf(h)).join(",")}]`).join(" ,")}>`;
      return i + l + s;
    }
  }
};
Object.freeze(_f);
const BXe = {
  buildRuleNotFoundError(t, e) {
    return "Invalid grammar, reference to a rule which is not defined: ->" + e.nonTerminalName + `<-
inside top level rule: ->` + t.name + "<-";
  }
}, Ou = {
  buildDuplicateFoundError(t, e) {
    function r(h) {
      return h instanceof jr ? h.terminalType.name : h instanceof Ki ? h.nonTerminalName : "";
    }
    const n = t.name, i = Ps(e), a = i.idx, s = eo(i), o = r(i), l = a > 0;
    let u = `->${s}${l ? a : ""}<- ${o ? `with argument: ->${o}<-` : ""}
                  appears more than once (${e.length} times) in the top level rule: ->${n}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
    return u = u.replace(/[ \t]+/g, " "), u = u.replace(/\s\s+/g, `
`), u;
  },
  buildNamespaceConflictError(t) {
    return `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${t.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
  },
  buildAlternationPrefixAmbiguityError(t) {
    const e = $t(t.prefixPath, (i) => Vf(i)).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx;
    return `Ambiguous alternatives: <${t.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
  },
  buildAlternationAmbiguityError(t) {
    const e = $t(t.prefixPath, (i) => Vf(i)).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx;
    let n = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(" ,")}> in <OR${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
    return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
  },
  buildEmptyRepetitionError(t) {
    let e = eo(t.repetition);
    return t.repetition.idx !== 0 && (e += t.repetition.idx), `The repetition <${e}> within Rule <${t.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildTokenNameError(t) {
    return "deprecated";
  },
  buildEmptyAlternationError(t) {
    return `Ambiguous empty alternative: <${t.emptyChoiceIdx + 1}> in <OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;
  },
  buildTooManyAlternativesError(t) {
    return `An Alternation cannot have more than 256 alternatives:
<OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
 has ${t.alternation.definition.length + 1} alternatives.`;
  },
  buildLeftRecursionError(t) {
    const e = t.topLevelRule.name, r = $t(t.leftRecursionPath, (a) => a.name), n = `${e} --> ${r.concat([e]).join(" --> ")}`;
    return `Left Recursion found in grammar.
rule: <${e}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${n}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildInvalidRuleNameError(t) {
    return "deprecated";
  },
  buildDuplicateRuleNameError(t) {
    let e;
    return t.topLevelRule instanceof j0 ? e = t.topLevelRule.name : e = t.topLevelRule, `Duplicate definition, rule: ->${e}<- is already defined in the grammar: ->${t.grammarName}<-`;
  }
};
function FXe(t, e) {
  const r = new zXe(t, e);
  return r.resolveRefs(), r.errors;
}
class zXe extends K0 {
  constructor(e, r) {
    super(), this.nameToTopRule = e, this.errMsgProvider = r, this.errors = [];
  }
  resolveRefs() {
    Zt(Fn(this.nameToTopRule), (e) => {
      this.currTopLevel = e, e.accept(this);
    });
  }
  visitNonTerminal(e) {
    const r = this.nameToTopRule[e.nonTerminalName];
    if (r)
      e.referencedRule = r;
    else {
      const n = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, e);
      this.errors.push({
        message: n,
        type: Zi.UNRESOLVED_SUBRULE_REF,
        ruleName: this.currTopLevel.name,
        unresolvedRefName: e.nonTerminalName
      });
    }
  }
}
class qXe extends B3 {
  constructor(e, r) {
    super(), this.topProd = e, this.path = r, this.possibleTokTypes = [], this.nextProductionName = "", this.nextProductionOccurrence = 0, this.found = !1, this.isAtEndOfPath = !1;
  }
  startWalking() {
    if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name)
      throw Error("The path does not start with the walker's top Rule!");
    return this.ruleStack = mi(this.path.ruleStack).reverse(), this.occurrenceStack = mi(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
  }
  walk(e, r = []) {
    this.found || super.walk(e, r);
  }
  walkProdRef(e, r, n) {
    if (e.referencedRule.name === this.nextProductionName && e.idx === this.nextProductionOccurrence) {
      const i = r.concat(n);
      this.updateExpectedNext(), this.walk(e.referencedRule, i);
    }
  }
  updateExpectedNext() {
    qr(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
  }
}
class GXe extends qXe {
  constructor(e, r) {
    super(e, r), this.path = r, this.nextTerminalName = "", this.nextTerminalOccurrence = 0, this.nextTerminalName = this.path.lastTok.name, this.nextTerminalOccurrence = this.path.lastTokOccurrence;
  }
  walkTerminal(e, r, n) {
    if (this.isAtEndOfPath && e.terminalType.name === this.nextTerminalName && e.idx === this.nextTerminalOccurrence && !this.found) {
      const i = r.concat(n), a = new pa({ definition: i });
      this.possibleTokTypes = zm(a), this.found = !0;
    }
  }
}
class z3 extends B3 {
  constructor(e, r) {
    super(), this.topRule = e, this.occurrence = r, this.result = {
      token: void 0,
      occurrence: void 0,
      isEndOfRule: void 0
    };
  }
  startWalking() {
    return this.walk(this.topRule), this.result;
  }
}
class UXe extends z3 {
  walkMany(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ps(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof jr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkMany(e, r, n);
  }
}
class rH extends z3 {
  walkManySep(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ps(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof jr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkManySep(e, r, n);
  }
}
class VXe extends z3 {
  walkAtLeastOne(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ps(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof jr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkAtLeastOne(e, r, n);
  }
}
class nH extends z3 {
  walkAtLeastOneSep(e, r, n) {
    if (e.idx === this.occurrence) {
      const i = Ps(r.concat(n));
      this.result.isEndOfRule = i === void 0, i instanceof jr && (this.result.token = i.terminalType, this.result.occurrence = i.idx);
    } else
      super.walkAtLeastOneSep(e, r, n);
  }
}
function t8(t, e, r = []) {
  r = mi(r);
  let n = [], i = 0;
  function a(o) {
    return o.concat(li(t, i + 1));
  }
  function s(o) {
    const l = t8(a(o), e, r);
    return n.concat(l);
  }
  for (; r.length < e && i < t.length; ) {
    const o = t[i];
    if (o instanceof pa)
      return s(o.definition);
    if (o instanceof Ki)
      return s(o.definition);
    if (o instanceof gi)
      n = s(o.definition);
    else if (o instanceof Pa) {
      const l = o.definition.concat([
        new hn({
          definition: o.definition
        })
      ]);
      return s(l);
    } else if (o instanceof $a) {
      const l = [
        new pa({ definition: o.definition }),
        new hn({
          definition: [new jr({ terminalType: o.separator })].concat(o.definition)
        })
      ];
      return s(l);
    } else if (o instanceof ya) {
      const l = o.definition.concat([
        new hn({
          definition: [new jr({ terminalType: o.separator })].concat(o.definition)
        })
      ]);
      n = s(l);
    } else if (o instanceof hn) {
      const l = o.definition.concat([
        new hn({
          definition: o.definition
        })
      ]);
      n = s(l);
    } else {
      if (o instanceof ba)
        return Zt(o.definition, (l) => {
          qr(l.definition) === !1 && (n = s(l.definition));
        }), n;
      if (o instanceof jr)
        r.push(o.terminalType);
      else
        throw Error("non exhaustive match");
    }
    i++;
  }
  return n.push({
    partialPath: r,
    suffixDef: li(t, i)
  }), n;
}
function boe(t, e, r, n) {
  const i = "EXIT_NONE_TERMINAL", a = [i], s = "EXIT_ALTERNATIVE";
  let o = !1;
  const l = e.length, u = l - n - 1, h = [], f = [];
  for (f.push({
    idx: -1,
    def: t,
    ruleStack: [],
    occurrenceStack: []
  }); !qr(f); ) {
    const d = f.pop();
    if (d === s) {
      o && g0(f).idx <= u && f.pop();
      continue;
    }
    const p = d.def, g = d.idx, m = d.ruleStack, v = d.occurrenceStack;
    if (qr(p))
      continue;
    const y = p[0];
    if (y === i) {
      const b = {
        idx: g,
        def: li(p),
        ruleStack: $1(m),
        occurrenceStack: $1(v)
      };
      f.push(b);
    } else if (y instanceof jr)
      if (g < l - 1) {
        const b = g + 1, x = e[b];
        if (r(x, y.terminalType)) {
          const T = {
            idx: b,
            def: li(p),
            ruleStack: m,
            occurrenceStack: v
          };
          f.push(T);
        }
      } else if (g === l - 1)
        h.push({
          nextTokenType: y.terminalType,
          nextTokenOccurrence: y.idx,
          ruleStack: m,
          occurrenceStack: v
        }), o = !0;
      else
        throw Error("non exhaustive match");
    else if (y instanceof Ki) {
      const b = mi(m);
      b.push(y.nonTerminalName);
      const x = mi(v);
      x.push(y.idx);
      const T = {
        idx: g,
        def: y.definition.concat(a, li(p)),
        ruleStack: b,
        occurrenceStack: x
      };
      f.push(T);
    } else if (y instanceof gi) {
      const b = {
        idx: g,
        def: li(p),
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(b), f.push(s);
      const x = {
        idx: g,
        def: y.definition.concat(li(p)),
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(x);
    } else if (y instanceof Pa) {
      const b = new hn({
        definition: y.definition,
        idx: y.idx
      }), x = y.definition.concat([b], li(p)), T = {
        idx: g,
        def: x,
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(T);
    } else if (y instanceof $a) {
      const b = new jr({
        terminalType: y.separator
      }), x = new hn({
        definition: [b].concat(y.definition),
        idx: y.idx
      }), T = y.definition.concat([x], li(p)), E = {
        idx: g,
        def: T,
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(E);
    } else if (y instanceof ya) {
      const b = {
        idx: g,
        def: li(p),
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(b), f.push(s);
      const x = new jr({
        terminalType: y.separator
      }), T = new hn({
        definition: [x].concat(y.definition),
        idx: y.idx
      }), E = y.definition.concat([T], li(p)), A = {
        idx: g,
        def: E,
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(A);
    } else if (y instanceof hn) {
      const b = {
        idx: g,
        def: li(p),
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(b), f.push(s);
      const x = new hn({
        definition: y.definition,
        idx: y.idx
      }), T = y.definition.concat([x], li(p)), E = {
        idx: g,
        def: T,
        ruleStack: m,
        occurrenceStack: v
      };
      f.push(E);
    } else if (y instanceof ba)
      for (let b = y.definition.length - 1; b >= 0; b--) {
        const x = y.definition[b], T = {
          idx: g,
          def: x.definition.concat(li(p)),
          ruleStack: m,
          occurrenceStack: v
        };
        f.push(T), f.push(s);
      }
    else if (y instanceof pa)
      f.push({
        idx: g,
        def: y.definition.concat(li(p)),
        ruleStack: m,
        occurrenceStack: v
      });
    else if (y instanceof j0)
      f.push(HXe(y, g, m, v));
    else
      throw Error("non exhaustive match");
  }
  return h;
}
function HXe(t, e, r, n) {
  const i = mi(r);
  i.push(t.name);
  const a = mi(n);
  return a.push(1), {
    idx: e,
    def: t.definition,
    ruleStack: i,
    occurrenceStack: a
  };
}
var sn;
(function(t) {
  t[t.OPTION = 0] = "OPTION", t[t.REPETITION = 1] = "REPETITION", t[t.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", t[t.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", t[t.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", t[t.ALTERNATION = 5] = "ALTERNATION";
})(sn || (sn = {}));
function AI(t) {
  if (t instanceof gi || t === "Option")
    return sn.OPTION;
  if (t instanceof hn || t === "Repetition")
    return sn.REPETITION;
  if (t instanceof Pa || t === "RepetitionMandatory")
    return sn.REPETITION_MANDATORY;
  if (t instanceof $a || t === "RepetitionMandatoryWithSeparator")
    return sn.REPETITION_MANDATORY_WITH_SEPARATOR;
  if (t instanceof ya || t === "RepetitionWithSeparator")
    return sn.REPETITION_WITH_SEPARATOR;
  if (t instanceof ba || t === "Alternation")
    return sn.ALTERNATION;
  throw Error("non exhaustive match");
}
function iH(t) {
  const { occurrence: e, rule: r, prodType: n, maxLookahead: i } = t, a = AI(n);
  return a === sn.ALTERNATION ? q3(e, r, i) : G3(e, r, a, i);
}
function WXe(t, e, r, n, i, a) {
  const s = q3(t, e, r), o = Toe(s) ? nx : qm;
  return a(s, n, o, i);
}
function YXe(t, e, r, n, i, a) {
  const s = G3(t, e, i, r), o = Toe(s) ? nx : qm;
  return a(s[0], o, n);
}
function XXe(t, e, r, n) {
  const i = t.length, a = fo(t, (s) => fo(s, (o) => o.length === 1));
  if (e)
    return function(s) {
      const o = $t(s, (l) => l.GATE);
      for (let l = 0; l < i; l++) {
        const u = t[l], h = u.length, f = o[l];
        if (!(f !== void 0 && f.call(this) === !1))
          e: for (let d = 0; d < h; d++) {
            const p = u[d], g = p.length;
            for (let m = 0; m < g; m++) {
              const v = this.LA(m + 1);
              if (r(v, p[m]) === !1)
                continue e;
            }
            return l;
          }
      }
    };
  if (a && !n) {
    const s = $t(t, (l) => Ls(l)), o = Ma(s, (l, u, h) => (Zt(u, (f) => {
      Vt(l, f.tokenTypeIdx) || (l[f.tokenTypeIdx] = h), Zt(f.categoryMatches, (d) => {
        Vt(l, d) || (l[d] = h);
      });
    }), l), {});
    return function() {
      const l = this.LA(1);
      return o[l.tokenTypeIdx];
    };
  } else
    return function() {
      for (let s = 0; s < i; s++) {
        const o = t[s], l = o.length;
        e: for (let u = 0; u < l; u++) {
          const h = o[u], f = h.length;
          for (let d = 0; d < f; d++) {
            const p = this.LA(d + 1);
            if (r(p, h[d]) === !1)
              continue e;
          }
          return s;
        }
      }
    };
}
function jXe(t, e, r) {
  const n = fo(t, (a) => a.length === 1), i = t.length;
  if (n && !r) {
    const a = Ls(t);
    if (a.length === 1 && qr(a[0].categoryMatches)) {
      const o = a[0].tokenTypeIdx;
      return function() {
        return this.LA(1).tokenTypeIdx === o;
      };
    } else {
      const s = Ma(a, (o, l, u) => (o[l.tokenTypeIdx] = !0, Zt(l.categoryMatches, (h) => {
        o[h] = !0;
      }), o), []);
      return function() {
        const o = this.LA(1);
        return s[o.tokenTypeIdx] === !0;
      };
    }
  } else
    return function() {
      e: for (let a = 0; a < i; a++) {
        const s = t[a], o = s.length;
        for (let l = 0; l < o; l++) {
          const u = this.LA(l + 1);
          if (e(u, s[l]) === !1)
            continue e;
        }
        return !0;
      }
      return !1;
    };
}
class KXe extends B3 {
  constructor(e, r, n) {
    super(), this.topProd = e, this.targetOccurrence = r, this.targetProdType = n;
  }
  startWalking() {
    return this.walk(this.topProd), this.restDef;
  }
  checkIsTarget(e, r, n, i) {
    return e.idx === this.targetOccurrence && this.targetProdType === r ? (this.restDef = n.concat(i), !0) : !1;
  }
  walkOption(e, r, n) {
    this.checkIsTarget(e, sn.OPTION, r, n) || super.walkOption(e, r, n);
  }
  walkAtLeastOne(e, r, n) {
    this.checkIsTarget(e, sn.REPETITION_MANDATORY, r, n) || super.walkOption(e, r, n);
  }
  walkAtLeastOneSep(e, r, n) {
    this.checkIsTarget(e, sn.REPETITION_MANDATORY_WITH_SEPARATOR, r, n) || super.walkOption(e, r, n);
  }
  walkMany(e, r, n) {
    this.checkIsTarget(e, sn.REPETITION, r, n) || super.walkOption(e, r, n);
  }
  walkManySep(e, r, n) {
    this.checkIsTarget(e, sn.REPETITION_WITH_SEPARATOR, r, n) || super.walkOption(e, r, n);
  }
}
class xoe extends K0 {
  constructor(e, r, n) {
    super(), this.targetOccurrence = e, this.targetProdType = r, this.targetRef = n, this.result = [];
  }
  checkIsTarget(e, r) {
    e.idx === this.targetOccurrence && this.targetProdType === r && (this.targetRef === void 0 || e === this.targetRef) && (this.result = e.definition);
  }
  visitOption(e) {
    this.checkIsTarget(e, sn.OPTION);
  }
  visitRepetition(e) {
    this.checkIsTarget(e, sn.REPETITION);
  }
  visitRepetitionMandatory(e) {
    this.checkIsTarget(e, sn.REPETITION_MANDATORY);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.checkIsTarget(e, sn.REPETITION_MANDATORY_WITH_SEPARATOR);
  }
  visitRepetitionWithSeparator(e) {
    this.checkIsTarget(e, sn.REPETITION_WITH_SEPARATOR);
  }
  visitAlternation(e) {
    this.checkIsTarget(e, sn.ALTERNATION);
  }
}
function aH(t) {
  const e = new Array(t);
  for (let r = 0; r < t; r++)
    e[r] = [];
  return e;
}
function x7(t) {
  let e = [""];
  for (let r = 0; r < t.length; r++) {
    const n = t[r], i = [];
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      i.push(s + "_" + n.tokenTypeIdx);
      for (let o = 0; o < n.categoryMatches.length; o++) {
        const l = "_" + n.categoryMatches[o];
        i.push(s + l);
      }
    }
    e = i;
  }
  return e;
}
function ZXe(t, e, r) {
  for (let n = 0; n < t.length; n++) {
    if (n === r)
      continue;
    const i = t[n];
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      if (i[s] === !0)
        return !1;
    }
  }
  return !0;
}
function woe(t, e) {
  const r = $t(t, (s) => t8([s], 1)), n = aH(r.length), i = $t(r, (s) => {
    const o = {};
    return Zt(s, (l) => {
      const u = x7(l.partialPath);
      Zt(u, (h) => {
        o[h] = !0;
      });
    }), o;
  });
  let a = r;
  for (let s = 1; s <= e; s++) {
    const o = a;
    a = aH(o.length);
    for (let l = 0; l < o.length; l++) {
      const u = o[l];
      for (let h = 0; h < u.length; h++) {
        const f = u[h].partialPath, d = u[h].suffixDef, p = x7(f);
        if (ZXe(i, p, l) || qr(d) || f.length === e) {
          const m = n[l];
          if (r8(m, f) === !1) {
            m.push(f);
            for (let v = 0; v < p.length; v++) {
              const y = p[v];
              i[l][y] = !0;
            }
          }
        } else {
          const m = t8(d, s + 1, f);
          a[l] = a[l].concat(m), Zt(m, (v) => {
            const y = x7(v.partialPath);
            Zt(y, (b) => {
              i[l][b] = !0;
            });
          });
        }
      }
    }
  }
  return n;
}
function q3(t, e, r, n) {
  const i = new xoe(t, sn.ALTERNATION, n);
  return e.accept(i), woe(i.result, r);
}
function G3(t, e, r, n) {
  const i = new xoe(t, r);
  e.accept(i);
  const a = i.result, o = new KXe(e, t, r).startWalking(), l = new pa({ definition: a }), u = new pa({ definition: o });
  return woe([l, u], n);
}
function r8(t, e) {
  e: for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n.length === e.length) {
      for (let i = 0; i < n.length; i++) {
        const a = e[i], s = n[i];
        if ((a === s || s.categoryMatchesMap[a.tokenTypeIdx] !== void 0) === !1)
          continue e;
      }
      return !0;
    }
  }
  return !1;
}
function QXe(t, e) {
  return t.length < e.length && fo(t, (r, n) => {
    const i = e[n];
    return r === i || i.categoryMatchesMap[r.tokenTypeIdx];
  });
}
function Toe(t) {
  return fo(t, (e) => fo(e, (r) => fo(r, (n) => qr(n.categoryMatches))));
}
function JXe(t) {
  const e = t.lookaheadStrategy.validate({
    rules: t.rules,
    tokenTypes: t.tokenTypes,
    grammarName: t.grammarName
  });
  return $t(e, (r) => Object.assign({ type: Zi.CUSTOM_LOOKAHEAD_VALIDATION }, r));
}
function eje(t, e, r, n) {
  const i = ts(t, (l) => tje(l, r)), a = dje(t, e, r), s = ts(t, (l) => cje(l, r)), o = ts(t, (l) => ije(l, t, n, r));
  return i.concat(a, s, o);
}
function tje(t, e) {
  const r = new nje();
  t.accept(r);
  const n = r.allProductions, i = lUe(n, rje), a = kUe(i, (o) => o.length > 1);
  return $t(Fn(a), (o) => {
    const l = Ps(o), u = e.buildDuplicateFoundError(t, o), h = eo(l), f = {
      message: u,
      type: Zi.DUPLICATE_PRODUCTIONS,
      ruleName: t.name,
      dslName: h,
      occurrence: l.idx
    }, d = Eoe(l);
    return d && (f.parameter = d), f;
  });
}
function rje(t) {
  return `${eo(t)}_#_${t.idx}_#_${Eoe(t)}`;
}
function Eoe(t) {
  return t instanceof jr ? t.terminalType.name : t instanceof Ki ? t.nonTerminalName : "";
}
class nje extends K0 {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitNonTerminal(e) {
    this.allProductions.push(e);
  }
  visitOption(e) {
    this.allProductions.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
  visitAlternation(e) {
    this.allProductions.push(e);
  }
  visitTerminal(e) {
    this.allProductions.push(e);
  }
}
function ije(t, e, r, n) {
  const i = [];
  if (Ma(e, (s, o) => o.name === t.name ? s + 1 : s, 0) > 1) {
    const s = n.buildDuplicateRuleNameError({
      topLevelRule: t,
      grammarName: r
    });
    i.push({
      message: s,
      type: Zi.DUPLICATE_RULE_NAME,
      ruleName: t.name
    });
  }
  return i;
}
function aje(t, e, r) {
  const n = [];
  let i;
  return va(e, t) || (i = `Invalid rule override, rule: ->${t}<- cannot be overridden in the grammar: ->${r}<-as it is not defined in any of the super grammars `, n.push({
    message: i,
    type: Zi.INVALID_RULE_OVERRIDE,
    ruleName: t
  })), n;
}
function Soe(t, e, r, n = []) {
  const i = [], a = r2(e.definition);
  if (qr(a))
    return [];
  {
    const s = t.name;
    va(a, t) && i.push({
      message: r.buildLeftRecursionError({
        topLevelRule: t,
        leftRecursionPath: n
      }),
      type: Zi.LEFT_RECURSION,
      ruleName: s
    });
    const l = C3(a, n.concat([t])), u = ts(l, (h) => {
      const f = mi(n);
      return f.push(h), Soe(t, h, r, f);
    });
    return i.concat(u);
  }
}
function r2(t) {
  let e = [];
  if (qr(t))
    return e;
  const r = Ps(t);
  if (r instanceof Ki)
    e.push(r.referencedRule);
  else if (r instanceof pa || r instanceof gi || r instanceof Pa || r instanceof $a || r instanceof ya || r instanceof hn)
    e = e.concat(r2(r.definition));
  else if (r instanceof ba)
    e = Ls($t(r.definition, (a) => r2(a.definition)));
  else if (!(r instanceof jr)) throw Error("non exhaustive match");
  const n = tx(r), i = t.length > 1;
  if (n && i) {
    const a = li(t);
    return e.concat(r2(a));
  } else
    return e;
}
class LI extends K0 {
  constructor() {
    super(...arguments), this.alternations = [];
  }
  visitAlternation(e) {
    this.alternations.push(e);
  }
}
function sje(t, e) {
  const r = new LI();
  t.accept(r);
  const n = r.alternations;
  return ts(n, (a) => {
    const s = $1(a.definition);
    return ts(s, (o, l) => {
      const u = boe([o], [], qm, 1);
      return qr(u) ? [
        {
          message: e.buildEmptyAlternationError({
            topLevelRule: t,
            alternation: a,
            emptyChoiceIdx: l
          }),
          type: Zi.NONE_LAST_EMPTY_ALT,
          ruleName: t.name,
          occurrence: a.idx,
          alternative: l + 1
        }
      ] : [];
    });
  });
}
function oje(t, e, r) {
  const n = new LI();
  t.accept(n);
  let i = n.alternations;
  return i = _3(i, (s) => s.ignoreAmbiguities === !0), ts(i, (s) => {
    const o = s.idx, l = s.maxLookahead || e, u = q3(o, t, l, s), h = hje(u, s, t, r), f = fje(u, s, t, r);
    return h.concat(f);
  });
}
class lje extends K0 {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
}
function cje(t, e) {
  const r = new LI();
  t.accept(r);
  const n = r.alternations;
  return ts(n, (a) => a.definition.length > 255 ? [
    {
      message: e.buildTooManyAlternativesError({
        topLevelRule: t,
        alternation: a
      }),
      type: Zi.TOO_MANY_ALTS,
      ruleName: t.name,
      occurrence: a.idx
    }
  ] : []);
}
function uje(t, e, r) {
  const n = [];
  return Zt(t, (i) => {
    const a = new lje();
    i.accept(a);
    const s = a.allProductions;
    Zt(s, (o) => {
      const l = AI(o), u = o.maxLookahead || e, h = o.idx, d = G3(h, i, l, u)[0];
      if (qr(Ls(d))) {
        const p = r.buildEmptyRepetitionError({
          topLevelRule: i,
          repetition: o
        });
        n.push({
          message: p,
          type: Zi.NO_NON_EMPTY_LOOKAHEAD,
          ruleName: i.name
        });
      }
    });
  }), n;
}
function hje(t, e, r, n) {
  const i = [], a = Ma(t, (o, l, u) => (e.definition[u].ignoreAmbiguities === !0 || Zt(l, (h) => {
    const f = [u];
    Zt(t, (d, p) => {
      u !== p && r8(d, h) && // ignore (skip) ambiguities with this "other" alternative
      e.definition[p].ignoreAmbiguities !== !0 && f.push(p);
    }), f.length > 1 && !r8(i, h) && (i.push(h), o.push({
      alts: f,
      path: h
    }));
  }), o), []);
  return $t(a, (o) => {
    const l = $t(o.alts, (h) => h + 1);
    return {
      message: n.buildAlternationAmbiguityError({
        topLevelRule: r,
        alternation: e,
        ambiguityIndices: l,
        prefixPath: o.path
      }),
      type: Zi.AMBIGUOUS_ALTS,
      ruleName: r.name,
      occurrence: e.idx,
      alternatives: o.alts
    };
  });
}
function fje(t, e, r, n) {
  const i = Ma(t, (s, o, l) => {
    const u = $t(o, (h) => ({ idx: l, path: h }));
    return s.concat(u);
  }, []);
  return $m(ts(i, (s) => {
    if (e.definition[s.idx].ignoreAmbiguities === !0)
      return [];
    const l = s.idx, u = s.path, h = ds(i, (d) => (
      // ignore (skip) ambiguities with this "other" alternative
      e.definition[d.idx].ignoreAmbiguities !== !0 && d.idx < l && // checking for strict prefix because identical lookaheads
      // will be be detected using a different validation.
      QXe(d.path, u)
    ));
    return $t(h, (d) => {
      const p = [d.idx + 1, l + 1], g = e.idx === 0 ? "" : e.idx;
      return {
        message: n.buildAlternationPrefixAmbiguityError({
          topLevelRule: r,
          alternation: e,
          ambiguityIndices: p,
          prefixPath: d.path
        }),
        type: Zi.AMBIGUOUS_PREFIX_ALTS,
        ruleName: r.name,
        occurrence: g,
        alternatives: p
      };
    });
  }));
}
function dje(t, e, r) {
  const n = [], i = $t(e, (a) => a.name);
  return Zt(t, (a) => {
    const s = a.name;
    if (va(i, s)) {
      const o = r.buildNamespaceConflictError(a);
      n.push({
        message: o,
        type: Zi.CONFLICT_TOKENS_RULES_NAMESPACE,
        ruleName: s
      });
    }
  }), n;
}
function pje(t) {
  const e = vI(t, {
    errMsgProvider: BXe
  }), r = {};
  return Zt(t.rules, (n) => {
    r[n.name] = n;
  }), FXe(r, e.errMsgProvider);
}
function gje(t) {
  return t = vI(t, {
    errMsgProvider: Ou
  }), eje(t.rules, t.tokenTypes, t.errMsgProvider, t.grammarName);
}
const koe = "MismatchedTokenException", Coe = "NoViableAltException", _oe = "EarlyExitException", Aoe = "NotAllInputParsedException", Loe = [
  koe,
  Coe,
  _oe,
  Aoe
];
Object.freeze(Loe);
function ix(t) {
  return va(Loe, t.name);
}
class U3 extends Error {
  constructor(e, r) {
    super(e), this.token = r, this.resyncedTokens = [], Object.setPrototypeOf(this, new.target.prototype), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}
class Roe extends U3 {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = koe;
  }
}
class mje extends U3 {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = Coe;
  }
}
class vje extends U3 {
  constructor(e, r) {
    super(e, r), this.name = Aoe;
  }
}
class yje extends U3 {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = _oe;
  }
}
const w7 = {}, Ioe = "InRuleRecoveryException";
class bje extends Error {
  constructor(e) {
    super(e), this.name = Ioe;
  }
}
class xje {
  initRecoverable(e) {
    this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = Vt(e, "recoveryEnabled") ? e.recoveryEnabled : Tl.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = wje);
  }
  getTokenToInsert(e) {
    const r = _I(e, "", NaN, NaN, NaN, NaN, NaN, NaN);
    return r.isInsertedInRecovery = !0, r;
  }
  canTokenTypeBeInsertedInRecovery(e) {
    return !0;
  }
  canTokenTypeBeDeletedInRecovery(e) {
    return !0;
  }
  tryInRepetitionRecovery(e, r, n, i) {
    const a = this.findReSyncTokenType(), s = this.exportLexerState(), o = [];
    let l = !1;
    const u = this.LA(1);
    let h = this.LA(1);
    const f = () => {
      const d = this.LA(0), p = this.errorMessageProvider.buildMismatchTokenMessage({
        expected: i,
        actual: u,
        previous: d,
        ruleName: this.getCurrRuleFullName()
      }), g = new Roe(p, u, this.LA(0));
      g.resyncedTokens = $1(o), this.SAVE_ERROR(g);
    };
    for (; !l; )
      if (this.tokenMatcher(h, i)) {
        f();
        return;
      } else if (n.call(this)) {
        f(), e.apply(this, r);
        return;
      } else this.tokenMatcher(h, a) ? l = !0 : (h = this.SKIP_TOKEN(), this.addToResyncTokens(h, o));
    this.importLexerState(s);
  }
  shouldInRepetitionRecoveryBeTried(e, r, n) {
    return !(n === !1 || this.tokenMatcher(this.LA(1), e) || this.isBackTracking() || this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, r)));
  }
  // Error Recovery functionality
  getFollowsForInRuleRecovery(e, r) {
    const n = this.getCurrentGrammarPath(e, r);
    return this.getNextPossibleTokenTypes(n);
  }
  tryInRuleRecovery(e, r) {
    if (this.canRecoverWithSingleTokenInsertion(e, r))
      return this.getTokenToInsert(e);
    if (this.canRecoverWithSingleTokenDeletion(e)) {
      const n = this.SKIP_TOKEN();
      return this.consumeToken(), n;
    }
    throw new bje("sad sad panda");
  }
  canPerformInRuleRecovery(e, r) {
    return this.canRecoverWithSingleTokenInsertion(e, r) || this.canRecoverWithSingleTokenDeletion(e);
  }
  canRecoverWithSingleTokenInsertion(e, r) {
    if (!this.canTokenTypeBeInsertedInRecovery(e) || qr(r))
      return !1;
    const n = this.LA(1);
    return m0(r, (a) => this.tokenMatcher(n, a)) !== void 0;
  }
  canRecoverWithSingleTokenDeletion(e) {
    return this.canTokenTypeBeDeletedInRecovery(e) ? this.tokenMatcher(this.LA(2), e) : !1;
  }
  isInCurrentRuleReSyncSet(e) {
    const r = this.getCurrFollowKey(), n = this.getFollowSetFromFollowKey(r);
    return va(n, e);
  }
  findReSyncTokenType() {
    const e = this.flattenFollowSet();
    let r = this.LA(1), n = 2;
    for (; ; ) {
      const i = m0(e, (a) => yoe(r, a));
      if (i !== void 0)
        return i;
      r = this.LA(n), n++;
    }
  }
  getCurrFollowKey() {
    if (this.RULE_STACK.length === 1)
      return w7;
    const e = this.getLastExplicitRuleShortName(), r = this.getLastExplicitRuleOccurrenceIndex(), n = this.getPreviousExplicitRuleShortName();
    return {
      ruleName: this.shortRuleNameToFullName(e),
      idxInCallingRule: r,
      inRule: this.shortRuleNameToFullName(n)
    };
  }
  buildFullFollowKeyStack() {
    const e = this.RULE_STACK, r = this.RULE_OCCURRENCE_STACK;
    return $t(e, (n, i) => i === 0 ? w7 : {
      ruleName: this.shortRuleNameToFullName(n),
      idxInCallingRule: r[i],
      inRule: this.shortRuleNameToFullName(e[i - 1])
    });
  }
  flattenFollowSet() {
    const e = $t(this.buildFullFollowKeyStack(), (r) => this.getFollowSetFromFollowKey(r));
    return Ls(e);
  }
  getFollowSetFromFollowKey(e) {
    if (e === w7)
      return [Rc];
    const r = e.ruleName + e.idxInCallingRule + ooe + e.inRule;
    return this.resyncFollows[r];
  }
  // It does not make any sense to include a virtual EOF token in the list of resynced tokens
  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
  addToResyncTokens(e, r) {
    return this.tokenMatcher(e, Rc) || r.push(e), r;
  }
  reSyncTo(e) {
    const r = [];
    let n = this.LA(1);
    for (; this.tokenMatcher(n, e) === !1; )
      n = this.SKIP_TOKEN(), this.addToResyncTokens(n, r);
    return $1(r);
  }
  attemptInRepetitionRecovery(e, r, n, i, a, s, o) {
  }
  getCurrentGrammarPath(e, r) {
    const n = this.getHumanReadableRuleStack(), i = mi(this.RULE_OCCURRENCE_STACK);
    return {
      ruleStack: n,
      occurrenceStack: i,
      lastTok: e,
      lastTokOccurrence: r
    };
  }
  getHumanReadableRuleStack() {
    return $t(this.RULE_STACK, (e) => this.shortRuleNameToFullName(e));
  }
}
function wje(t, e, r, n, i, a, s) {
  const o = this.getKeyForAutomaticLookahead(n, i);
  let l = this.firstAfterRepMap[o];
  if (l === void 0) {
    const d = this.getCurrRuleFullName(), p = this.getGAstProductions()[d];
    l = new a(p, i).startWalking(), this.firstAfterRepMap[o] = l;
  }
  let u = l.token, h = l.occurrence;
  const f = l.isEndOfRule;
  this.RULE_STACK.length === 1 && f && u === void 0 && (u = Rc, h = 1), !(u === void 0 || h === void 0) && this.shouldInRepetitionRecoveryBeTried(u, h, s) && this.tryInRepetitionRecovery(t, e, r, u);
}
const Tje = 4, Kc = 8, Moe = 1 << Kc, Noe = 2 << Kc, n8 = 3 << Kc, i8 = 4 << Kc, a8 = 5 << Kc, n2 = 6 << Kc;
function T7(t, e, r) {
  return r | e | t;
}
class RI {
  constructor(e) {
    var r;
    this.maxLookahead = (r = e?.maxLookahead) !== null && r !== void 0 ? r : Tl.maxLookahead;
  }
  validate(e) {
    const r = this.validateNoLeftRecursion(e.rules);
    if (qr(r)) {
      const n = this.validateEmptyOrAlternatives(e.rules), i = this.validateAmbiguousAlternationAlternatives(e.rules, this.maxLookahead), a = this.validateSomeNonEmptyLookaheadPath(e.rules, this.maxLookahead);
      return [
        ...r,
        ...n,
        ...i,
        ...a
      ];
    }
    return r;
  }
  validateNoLeftRecursion(e) {
    return ts(e, (r) => Soe(r, r, Ou));
  }
  validateEmptyOrAlternatives(e) {
    return ts(e, (r) => sje(r, Ou));
  }
  validateAmbiguousAlternationAlternatives(e, r) {
    return ts(e, (n) => oje(n, r, Ou));
  }
  validateSomeNonEmptyLookaheadPath(e, r) {
    return uje(e, r, Ou);
  }
  buildLookaheadForAlternation(e) {
    return WXe(e.prodOccurrence, e.rule, e.maxLookahead, e.hasPredicates, e.dynamicTokensEnabled, XXe);
  }
  buildLookaheadForOptional(e) {
    return YXe(e.prodOccurrence, e.rule, e.maxLookahead, e.dynamicTokensEnabled, AI(e.prodType), jXe);
  }
}
class Eje {
  initLooksAhead(e) {
    this.dynamicTokensEnabled = Vt(e, "dynamicTokensEnabled") ? e.dynamicTokensEnabled : Tl.dynamicTokensEnabled, this.maxLookahead = Vt(e, "maxLookahead") ? e.maxLookahead : Tl.maxLookahead, this.lookaheadStrategy = Vt(e, "lookaheadStrategy") ? e.lookaheadStrategy : new RI({ maxLookahead: this.maxLookahead }), this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
  }
  preComputeLookaheadFunctions(e) {
    Zt(e, (r) => {
      this.TRACE_INIT(`${r.name} Rule Lookahead`, () => {
        const { alternation: n, repetition: i, option: a, repetitionMandatory: s, repetitionMandatoryWithSeparator: o, repetitionWithSeparator: l } = kje(r);
        Zt(n, (u) => {
          const h = u.idx === 0 ? "" : u.idx;
          this.TRACE_INIT(`${eo(u)}${h}`, () => {
            const f = this.lookaheadStrategy.buildLookaheadForAlternation({
              prodOccurrence: u.idx,
              rule: r,
              maxLookahead: u.maxLookahead || this.maxLookahead,
              hasPredicates: u.hasPredicates,
              dynamicTokensEnabled: this.dynamicTokensEnabled
            }), d = T7(this.fullRuleNameToShort[r.name], Moe, u.idx);
            this.setLaFuncCache(d, f);
          });
        }), Zt(i, (u) => {
          this.computeLookaheadFunc(r, u.idx, n8, "Repetition", u.maxLookahead, eo(u));
        }), Zt(a, (u) => {
          this.computeLookaheadFunc(r, u.idx, Noe, "Option", u.maxLookahead, eo(u));
        }), Zt(s, (u) => {
          this.computeLookaheadFunc(r, u.idx, i8, "RepetitionMandatory", u.maxLookahead, eo(u));
        }), Zt(o, (u) => {
          this.computeLookaheadFunc(r, u.idx, n2, "RepetitionMandatoryWithSeparator", u.maxLookahead, eo(u));
        }), Zt(l, (u) => {
          this.computeLookaheadFunc(r, u.idx, a8, "RepetitionWithSeparator", u.maxLookahead, eo(u));
        });
      });
    });
  }
  computeLookaheadFunc(e, r, n, i, a, s) {
    this.TRACE_INIT(`${s}${r === 0 ? "" : r}`, () => {
      const o = this.lookaheadStrategy.buildLookaheadForOptional({
        prodOccurrence: r,
        rule: e,
        maxLookahead: a || this.maxLookahead,
        dynamicTokensEnabled: this.dynamicTokensEnabled,
        prodType: i
      }), l = T7(this.fullRuleNameToShort[e.name], n, r);
      this.setLaFuncCache(l, o);
    });
  }
  // this actually returns a number, but it is always used as a string (object prop key)
  getKeyForAutomaticLookahead(e, r) {
    const n = this.getLastExplicitRuleShortName();
    return T7(n, e, r);
  }
  getLaFuncFromCache(e) {
    return this.lookAheadFuncsCache.get(e);
  }
  /* istanbul ignore next */
  setLaFuncCache(e, r) {
    this.lookAheadFuncsCache.set(e, r);
  }
}
class Sje extends K0 {
  constructor() {
    super(...arguments), this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  reset() {
    this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  visitOption(e) {
    this.dslMethods.option.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.dslMethods.repetitionWithSeparator.push(e);
  }
  visitRepetitionMandatory(e) {
    this.dslMethods.repetitionMandatory.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.dslMethods.repetitionMandatoryWithSeparator.push(e);
  }
  visitRepetition(e) {
    this.dslMethods.repetition.push(e);
  }
  visitAlternation(e) {
    this.dslMethods.alternation.push(e);
  }
}
const ey = new Sje();
function kje(t) {
  ey.reset(), t.accept(ey);
  const e = ey.dslMethods;
  return ey.reset(), e;
}
function sH(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.endOffset = e.endOffset) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset);
}
function oH(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.startColumn = e.startColumn, t.startLine = e.startLine, t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine);
}
function Cje(t, e, r) {
  t.children[r] === void 0 ? t.children[r] = [e] : t.children[r].push(e);
}
function _je(t, e, r) {
  t.children[e] === void 0 ? t.children[e] = [r] : t.children[e].push(r);
}
const Aje = "name";
function Doe(t, e) {
  Object.defineProperty(t, Aje, {
    enumerable: !1,
    configurable: !0,
    writable: !1,
    value: e
  });
}
function Lje(t, e) {
  const r = us(t), n = r.length;
  for (let i = 0; i < n; i++) {
    const a = r[i], s = t[a], o = s.length;
    for (let l = 0; l < o; l++) {
      const u = s[l];
      u.tokenTypeIdx === void 0 && this[u.name](u.children, e);
    }
  }
}
function Rje(t, e) {
  const r = function() {
  };
  Doe(r, t + "BaseSemantics");
  const n = {
    visit: function(i, a) {
      if (xr(i) && (i = i[0]), !xl(i))
        return this[i.name](i.children, a);
    },
    validateVisitor: function() {
      const i = Mje(this, e);
      if (!qr(i)) {
        const a = $t(i, (s) => s.msg);
        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${a.join(`

`).replace(/\n/g, `
	`)}`);
      }
    }
  };
  return r.prototype = n, r.prototype.constructor = r, r._RULE_NAMES = e, r;
}
function Ije(t, e, r) {
  const n = function() {
  };
  Doe(n, t + "BaseSemanticsWithDefaults");
  const i = Object.create(r.prototype);
  return Zt(e, (a) => {
    i[a] = Lje;
  }), n.prototype = i, n.prototype.constructor = n, n;
}
var s8;
(function(t) {
  t[t.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", t[t.MISSING_METHOD = 1] = "MISSING_METHOD";
})(s8 || (s8 = {}));
function Mje(t, e) {
  return Nje(t, e);
}
function Nje(t, e) {
  const r = ds(e, (i) => Ml(t[i]) === !1), n = $t(r, (i) => ({
    msg: `Missing visitor method: <${i}> on ${t.constructor.name} CST Visitor.`,
    type: s8.MISSING_METHOD,
    methodName: i
  }));
  return $m(n);
}
class Dje {
  initTreeBuilder(e) {
    if (this.CST_STACK = [], this.outputCst = e.outputCst, this.nodeLocationTracking = Vt(e, "nodeLocationTracking") ? e.nodeLocationTracking : Tl.nodeLocationTracking, !this.outputCst)
      this.cstInvocationStateUpdate = Pn, this.cstFinallyStateUpdate = Pn, this.cstPostTerminal = Pn, this.cstPostNonTerminal = Pn, this.cstPostRule = Pn;
    else if (/full/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = oH, this.setNodeLocationFromNode = oH, this.cstPostRule = Pn, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = Pn, this.setNodeLocationFromNode = Pn, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
    else if (/onlyOffset/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = sH, this.setNodeLocationFromNode = sH, this.cstPostRule = Pn, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = Pn, this.setNodeLocationFromNode = Pn, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
    else if (/none/i.test(this.nodeLocationTracking))
      this.setNodeLocationFromToken = Pn, this.setNodeLocationFromNode = Pn, this.cstPostRule = Pn, this.setInitialNodeLocation = Pn;
    else
      throw Error(`Invalid <nodeLocationTracking> config option: "${e.nodeLocationTracking}"`);
  }
  setInitialNodeLocationOnlyOffsetRecovery(e) {
    e.location = {
      startOffset: NaN,
      endOffset: NaN
    };
  }
  setInitialNodeLocationOnlyOffsetRegular(e) {
    e.location = {
      // without error recovery the starting Location of a new CstNode is guaranteed
      // To be the next Token's startOffset (for valid inputs).
      // For invalid inputs there won't be any CSTOutput so this potential
      // inaccuracy does not matter
      startOffset: this.LA(1).startOffset,
      endOffset: NaN
    };
  }
  setInitialNodeLocationFullRecovery(e) {
    e.location = {
      startOffset: NaN,
      startLine: NaN,
      startColumn: NaN,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  /**
       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
  
       * @param cstNode
       */
  setInitialNodeLocationFullRegular(e) {
    const r = this.LA(1);
    e.location = {
      startOffset: r.startOffset,
      startLine: r.startLine,
      startColumn: r.startColumn,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  cstInvocationStateUpdate(e) {
    const r = {
      name: e,
      children: /* @__PURE__ */ Object.create(null)
    };
    this.setInitialNodeLocation(r), this.CST_STACK.push(r);
  }
  cstFinallyStateUpdate() {
    this.CST_STACK.pop();
  }
  cstPostRuleFull(e) {
    const r = this.LA(0), n = e.location;
    n.startOffset <= r.startOffset ? (n.endOffset = r.endOffset, n.endLine = r.endLine, n.endColumn = r.endColumn) : (n.startOffset = NaN, n.startLine = NaN, n.startColumn = NaN);
  }
  cstPostRuleOnlyOffset(e) {
    const r = this.LA(0), n = e.location;
    n.startOffset <= r.startOffset ? n.endOffset = r.endOffset : n.startOffset = NaN;
  }
  cstPostTerminal(e, r) {
    const n = this.CST_STACK[this.CST_STACK.length - 1];
    Cje(n, r, e), this.setNodeLocationFromToken(n.location, r);
  }
  cstPostNonTerminal(e, r) {
    const n = this.CST_STACK[this.CST_STACK.length - 1];
    _je(n, r, e), this.setNodeLocationFromNode(n.location, e.location);
  }
  getBaseCstVisitorConstructor() {
    if (xl(this.baseCstVisitorConstructor)) {
      const e = Rje(this.className, us(this.gastProductionsCache));
      return this.baseCstVisitorConstructor = e, e;
    }
    return this.baseCstVisitorConstructor;
  }
  getBaseCstVisitorConstructorWithDefaults() {
    if (xl(this.baseCstVisitorWithDefaultsConstructor)) {
      const e = Ije(this.className, us(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
      return this.baseCstVisitorWithDefaultsConstructor = e, e;
    }
    return this.baseCstVisitorWithDefaultsConstructor;
  }
  getLastExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 1];
  }
  getPreviousExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 2];
  }
  getLastExplicitRuleOccurrenceIndex() {
    const e = this.RULE_OCCURRENCE_STACK;
    return e[e.length - 1];
  }
}
class Oje {
  initLexerAdapter() {
    this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1;
  }
  set input(e) {
    if (this.selfAnalysisDone !== !0)
      throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
    this.reset(), this.tokVector = e, this.tokVectorLength = e.length;
  }
  get input() {
    return this.tokVector;
  }
  // skips a token and returns the next token
  SKIP_TOKEN() {
    return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : sx;
  }
  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
  // or lexers dependent on parser context.
  LA(e) {
    const r = this.currIdx + e;
    return r < 0 || this.tokVectorLength <= r ? sx : this.tokVector[r];
  }
  consumeToken() {
    this.currIdx++;
  }
  exportLexerState() {
    return this.currIdx;
  }
  importLexerState(e) {
    this.currIdx = e;
  }
  resetLexerState() {
    this.currIdx = -1;
  }
  moveToTerminatedState() {
    this.currIdx = this.tokVector.length - 1;
  }
  getLexerPosition() {
    return this.exportLexerState();
  }
}
class Pje {
  ACTION(e) {
    return e.call(this);
  }
  consume(e, r, n) {
    return this.consumeInternal(r, e, n);
  }
  subrule(e, r, n) {
    return this.subruleInternal(r, e, n);
  }
  option(e, r) {
    return this.optionInternal(r, e);
  }
  or(e, r) {
    return this.orInternal(r, e);
  }
  many(e, r) {
    return this.manyInternal(e, r);
  }
  atLeastOne(e, r) {
    return this.atLeastOneInternal(e, r);
  }
  CONSUME(e, r) {
    return this.consumeInternal(e, 0, r);
  }
  CONSUME1(e, r) {
    return this.consumeInternal(e, 1, r);
  }
  CONSUME2(e, r) {
    return this.consumeInternal(e, 2, r);
  }
  CONSUME3(e, r) {
    return this.consumeInternal(e, 3, r);
  }
  CONSUME4(e, r) {
    return this.consumeInternal(e, 4, r);
  }
  CONSUME5(e, r) {
    return this.consumeInternal(e, 5, r);
  }
  CONSUME6(e, r) {
    return this.consumeInternal(e, 6, r);
  }
  CONSUME7(e, r) {
    return this.consumeInternal(e, 7, r);
  }
  CONSUME8(e, r) {
    return this.consumeInternal(e, 8, r);
  }
  CONSUME9(e, r) {
    return this.consumeInternal(e, 9, r);
  }
  SUBRULE(e, r) {
    return this.subruleInternal(e, 0, r);
  }
  SUBRULE1(e, r) {
    return this.subruleInternal(e, 1, r);
  }
  SUBRULE2(e, r) {
    return this.subruleInternal(e, 2, r);
  }
  SUBRULE3(e, r) {
    return this.subruleInternal(e, 3, r);
  }
  SUBRULE4(e, r) {
    return this.subruleInternal(e, 4, r);
  }
  SUBRULE5(e, r) {
    return this.subruleInternal(e, 5, r);
  }
  SUBRULE6(e, r) {
    return this.subruleInternal(e, 6, r);
  }
  SUBRULE7(e, r) {
    return this.subruleInternal(e, 7, r);
  }
  SUBRULE8(e, r) {
    return this.subruleInternal(e, 8, r);
  }
  SUBRULE9(e, r) {
    return this.subruleInternal(e, 9, r);
  }
  OPTION(e) {
    return this.optionInternal(e, 0);
  }
  OPTION1(e) {
    return this.optionInternal(e, 1);
  }
  OPTION2(e) {
    return this.optionInternal(e, 2);
  }
  OPTION3(e) {
    return this.optionInternal(e, 3);
  }
  OPTION4(e) {
    return this.optionInternal(e, 4);
  }
  OPTION5(e) {
    return this.optionInternal(e, 5);
  }
  OPTION6(e) {
    return this.optionInternal(e, 6);
  }
  OPTION7(e) {
    return this.optionInternal(e, 7);
  }
  OPTION8(e) {
    return this.optionInternal(e, 8);
  }
  OPTION9(e) {
    return this.optionInternal(e, 9);
  }
  OR(e) {
    return this.orInternal(e, 0);
  }
  OR1(e) {
    return this.orInternal(e, 1);
  }
  OR2(e) {
    return this.orInternal(e, 2);
  }
  OR3(e) {
    return this.orInternal(e, 3);
  }
  OR4(e) {
    return this.orInternal(e, 4);
  }
  OR5(e) {
    return this.orInternal(e, 5);
  }
  OR6(e) {
    return this.orInternal(e, 6);
  }
  OR7(e) {
    return this.orInternal(e, 7);
  }
  OR8(e) {
    return this.orInternal(e, 8);
  }
  OR9(e) {
    return this.orInternal(e, 9);
  }
  MANY(e) {
    this.manyInternal(0, e);
  }
  MANY1(e) {
    this.manyInternal(1, e);
  }
  MANY2(e) {
    this.manyInternal(2, e);
  }
  MANY3(e) {
    this.manyInternal(3, e);
  }
  MANY4(e) {
    this.manyInternal(4, e);
  }
  MANY5(e) {
    this.manyInternal(5, e);
  }
  MANY6(e) {
    this.manyInternal(6, e);
  }
  MANY7(e) {
    this.manyInternal(7, e);
  }
  MANY8(e) {
    this.manyInternal(8, e);
  }
  MANY9(e) {
    this.manyInternal(9, e);
  }
  MANY_SEP(e) {
    this.manySepFirstInternal(0, e);
  }
  MANY_SEP1(e) {
    this.manySepFirstInternal(1, e);
  }
  MANY_SEP2(e) {
    this.manySepFirstInternal(2, e);
  }
  MANY_SEP3(e) {
    this.manySepFirstInternal(3, e);
  }
  MANY_SEP4(e) {
    this.manySepFirstInternal(4, e);
  }
  MANY_SEP5(e) {
    this.manySepFirstInternal(5, e);
  }
  MANY_SEP6(e) {
    this.manySepFirstInternal(6, e);
  }
  MANY_SEP7(e) {
    this.manySepFirstInternal(7, e);
  }
  MANY_SEP8(e) {
    this.manySepFirstInternal(8, e);
  }
  MANY_SEP9(e) {
    this.manySepFirstInternal(9, e);
  }
  AT_LEAST_ONE(e) {
    this.atLeastOneInternal(0, e);
  }
  AT_LEAST_ONE1(e) {
    return this.atLeastOneInternal(1, e);
  }
  AT_LEAST_ONE2(e) {
    this.atLeastOneInternal(2, e);
  }
  AT_LEAST_ONE3(e) {
    this.atLeastOneInternal(3, e);
  }
  AT_LEAST_ONE4(e) {
    this.atLeastOneInternal(4, e);
  }
  AT_LEAST_ONE5(e) {
    this.atLeastOneInternal(5, e);
  }
  AT_LEAST_ONE6(e) {
    this.atLeastOneInternal(6, e);
  }
  AT_LEAST_ONE7(e) {
    this.atLeastOneInternal(7, e);
  }
  AT_LEAST_ONE8(e) {
    this.atLeastOneInternal(8, e);
  }
  AT_LEAST_ONE9(e) {
    this.atLeastOneInternal(9, e);
  }
  AT_LEAST_ONE_SEP(e) {
    this.atLeastOneSepFirstInternal(0, e);
  }
  AT_LEAST_ONE_SEP1(e) {
    this.atLeastOneSepFirstInternal(1, e);
  }
  AT_LEAST_ONE_SEP2(e) {
    this.atLeastOneSepFirstInternal(2, e);
  }
  AT_LEAST_ONE_SEP3(e) {
    this.atLeastOneSepFirstInternal(3, e);
  }
  AT_LEAST_ONE_SEP4(e) {
    this.atLeastOneSepFirstInternal(4, e);
  }
  AT_LEAST_ONE_SEP5(e) {
    this.atLeastOneSepFirstInternal(5, e);
  }
  AT_LEAST_ONE_SEP6(e) {
    this.atLeastOneSepFirstInternal(6, e);
  }
  AT_LEAST_ONE_SEP7(e) {
    this.atLeastOneSepFirstInternal(7, e);
  }
  AT_LEAST_ONE_SEP8(e) {
    this.atLeastOneSepFirstInternal(8, e);
  }
  AT_LEAST_ONE_SEP9(e) {
    this.atLeastOneSepFirstInternal(9, e);
  }
  RULE(e, r, n = ox) {
    if (va(this.definedRulesNames, e)) {
      const s = {
        message: Ou.buildDuplicateRuleNameError({
          topLevelRule: e,
          grammarName: this.className
        }),
        type: Zi.DUPLICATE_RULE_NAME,
        ruleName: e
      };
      this.definitionErrors.push(s);
    }
    this.definedRulesNames.push(e);
    const i = this.defineRule(e, r, n);
    return this[e] = i, i;
  }
  OVERRIDE_RULE(e, r, n = ox) {
    const i = aje(e, this.definedRulesNames, this.className);
    this.definitionErrors = this.definitionErrors.concat(i);
    const a = this.defineRule(e, r, n);
    return this[e] = a, a;
  }
  BACKTRACK(e, r) {
    return function() {
      this.isBackTrackingStack.push(1);
      const n = this.saveRecogState();
      try {
        return e.apply(this, r), !0;
      } catch (i) {
        if (ix(i))
          return !1;
        throw i;
      } finally {
        this.reloadRecogState(n), this.isBackTrackingStack.pop();
      }
    };
  }
  // GAST export APIs
  getGAstProductions() {
    return this.gastProductionsCache;
  }
  getSerializedGastProductions() {
    return HYe(Fn(this.gastProductionsCache));
  }
}
class $je {
  initRecognizerEngine(e, r) {
    if (this.className = this.constructor.name, this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = nx, this.subruleIdx = 0, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, Vt(r, "serializedGrammar"))
      throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
    if (xr(e)) {
      if (qr(e))
        throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
      if (typeof e[0].startOffset == "number")
        throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`);
    }
    if (xr(e))
      this.tokensMap = Ma(e, (a, s) => (a[s.name] = s, a), {});
    else if (Vt(e, "modes") && fo(Ls(Fn(e.modes)), OXe)) {
      const a = Ls(Fn(e.modes)), s = yI(a);
      this.tokensMap = Ma(s, (o, l) => (o[l.name] = l, o), {});
    } else if (cs(e))
      this.tokensMap = mi(e);
    else
      throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
    this.tokensMap.EOF = Rc;
    const n = Vt(e, "modes") ? Ls(Fn(e.modes)) : Fn(e), i = fo(n, (a) => qr(a.categoryMatches));
    this.tokenMatcher = i ? nx : qm, Gm(Fn(this.tokensMap));
  }
  defineRule(e, r, n) {
    if (this.selfAnalysisDone)
      throw Error(`Grammar rule <${e}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
    const i = Vt(n, "resyncEnabled") ? n.resyncEnabled : ox.resyncEnabled, a = Vt(n, "recoveryValueFunc") ? n.recoveryValueFunc : ox.recoveryValueFunc, s = this.ruleShortNameIdx << Tje + Kc;
    this.ruleShortNameIdx++, this.shortRuleNameToFull[s] = e, this.fullRuleNameToShort[e] = s;
    let o;
    return this.outputCst === !0 ? o = function(...h) {
      try {
        this.ruleInvocationStateUpdate(s, e, this.subruleIdx), r.apply(this, h);
        const f = this.CST_STACK[this.CST_STACK.length - 1];
        return this.cstPostRule(f), f;
      } catch (f) {
        return this.invokeRuleCatch(f, i, a);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    } : o = function(...h) {
      try {
        return this.ruleInvocationStateUpdate(s, e, this.subruleIdx), r.apply(this, h);
      } catch (f) {
        return this.invokeRuleCatch(f, i, a);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    }, Object.assign(o, { ruleName: e, originalGrammarAction: r });
  }
  invokeRuleCatch(e, r, n) {
    const i = this.RULE_STACK.length === 1, a = r && !this.isBackTracking() && this.recoveryEnabled;
    if (ix(e)) {
      const s = e;
      if (a) {
        const o = this.findReSyncTokenType();
        if (this.isInCurrentRuleReSyncSet(o))
          if (s.resyncedTokens = this.reSyncTo(o), this.outputCst) {
            const l = this.CST_STACK[this.CST_STACK.length - 1];
            return l.recoveredNode = !0, l;
          } else
            return n(e);
        else {
          if (this.outputCst) {
            const l = this.CST_STACK[this.CST_STACK.length - 1];
            l.recoveredNode = !0, s.partialCstResult = l;
          }
          throw s;
        }
      } else {
        if (i)
          return this.moveToTerminatedState(), n(e);
        throw s;
      }
    } else
      throw e;
  }
  // Implementation of parsing DSL
  optionInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(Noe, r);
    return this.optionInternalLogic(e, r, n);
  }
  optionInternalLogic(e, r, n) {
    let i = this.getLaFuncFromCache(n), a;
    if (typeof e != "function") {
      a = e.DEF;
      const s = e.GATE;
      if (s !== void 0) {
        const o = i;
        i = () => s.call(this) && o.call(this);
      }
    } else
      a = e;
    if (i.call(this) === !0)
      return a.call(this);
  }
  atLeastOneInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(i8, e);
    return this.atLeastOneInternalLogic(e, r, n);
  }
  atLeastOneInternalLogic(e, r, n) {
    let i = this.getLaFuncFromCache(n), a;
    if (typeof r != "function") {
      a = r.DEF;
      const s = r.GATE;
      if (s !== void 0) {
        const o = i;
        i = () => s.call(this) && o.call(this);
      }
    } else
      a = r;
    if (i.call(this) === !0) {
      let s = this.doSingleRepetition(a);
      for (; i.call(this) === !0 && s === !0; )
        s = this.doSingleRepetition(a);
    } else
      throw this.raiseEarlyExitException(e, sn.REPETITION_MANDATORY, r.ERR_MSG);
    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, r], i, i8, e, VXe);
  }
  atLeastOneSepFirstInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(n2, e);
    this.atLeastOneSepFirstInternalLogic(e, r, n);
  }
  atLeastOneSepFirstInternalLogic(e, r, n) {
    const i = r.DEF, a = r.SEP;
    if (this.getLaFuncFromCache(n).call(this) === !0) {
      i.call(this);
      const o = () => this.tokenMatcher(this.LA(1), a);
      for (; this.tokenMatcher(this.LA(1), a) === !0; )
        this.CONSUME(a), i.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        a,
        o,
        i,
        nH
      ], o, n2, e, nH);
    } else
      throw this.raiseEarlyExitException(e, sn.REPETITION_MANDATORY_WITH_SEPARATOR, r.ERR_MSG);
  }
  manyInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(n8, e);
    return this.manyInternalLogic(e, r, n);
  }
  manyInternalLogic(e, r, n) {
    let i = this.getLaFuncFromCache(n), a;
    if (typeof r != "function") {
      a = r.DEF;
      const o = r.GATE;
      if (o !== void 0) {
        const l = i;
        i = () => o.call(this) && l.call(this);
      }
    } else
      a = r;
    let s = !0;
    for (; i.call(this) === !0 && s === !0; )
      s = this.doSingleRepetition(a);
    this.attemptInRepetitionRecovery(
      this.manyInternal,
      [e, r],
      i,
      n8,
      e,
      UXe,
      // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
      // An infinite loop cannot occur as:
      // - Either the lookahead is guaranteed to consume something (Single Token Separator)
      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
      s
    );
  }
  manySepFirstInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(a8, e);
    this.manySepFirstInternalLogic(e, r, n);
  }
  manySepFirstInternalLogic(e, r, n) {
    const i = r.DEF, a = r.SEP;
    if (this.getLaFuncFromCache(n).call(this) === !0) {
      i.call(this);
      const o = () => this.tokenMatcher(this.LA(1), a);
      for (; this.tokenMatcher(this.LA(1), a) === !0; )
        this.CONSUME(a), i.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        a,
        o,
        i,
        rH
      ], o, a8, e, rH);
    }
  }
  repetitionSepSecondInternal(e, r, n, i, a) {
    for (; n(); )
      this.CONSUME(r), i.call(this);
    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
      e,
      r,
      n,
      i,
      a
    ], n, n2, e, a);
  }
  doSingleRepetition(e) {
    const r = this.getLexerPosition();
    return e.call(this), this.getLexerPosition() > r;
  }
  orInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(Moe, r), i = xr(e) ? e : e.DEF, s = this.getLaFuncFromCache(n).call(this, i);
    if (s !== void 0)
      return i[s].ALT.call(this);
    this.raiseNoAltException(r, e.ERR_MSG);
  }
  ruleFinallyStateUpdate() {
    if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) {
      const e = this.LA(1), r = this.errorMessageProvider.buildNotAllInputParsedMessage({
        firstRedundant: e,
        ruleName: this.getCurrRuleFullName()
      });
      this.SAVE_ERROR(new vje(r, e));
    }
  }
  subruleInternal(e, r, n) {
    let i;
    try {
      const a = n !== void 0 ? n.ARGS : void 0;
      return this.subruleIdx = r, i = e.apply(this, a), this.cstPostNonTerminal(i, n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.ruleName), i;
    } catch (a) {
      throw this.subruleInternalError(a, n, e.ruleName);
    }
  }
  subruleInternalError(e, r, n) {
    throw ix(e) && e.partialCstResult !== void 0 && (this.cstPostNonTerminal(e.partialCstResult, r !== void 0 && r.LABEL !== void 0 ? r.LABEL : n), delete e.partialCstResult), e;
  }
  consumeInternal(e, r, n) {
    let i;
    try {
      const a = this.LA(1);
      this.tokenMatcher(a, e) === !0 ? (this.consumeToken(), i = a) : this.consumeInternalError(e, a, n);
    } catch (a) {
      i = this.consumeInternalRecovery(e, r, a);
    }
    return this.cstPostTerminal(n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.name, i), i;
  }
  consumeInternalError(e, r, n) {
    let i;
    const a = this.LA(0);
    throw n !== void 0 && n.ERR_MSG ? i = n.ERR_MSG : i = this.errorMessageProvider.buildMismatchTokenMessage({
      expected: e,
      actual: r,
      previous: a,
      ruleName: this.getCurrRuleFullName()
    }), this.SAVE_ERROR(new Roe(i, r, a));
  }
  consumeInternalRecovery(e, r, n) {
    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
    n.name === "MismatchedTokenException" && !this.isBackTracking()) {
      const i = this.getFollowsForInRuleRecovery(e, r);
      try {
        return this.tryInRuleRecovery(e, i);
      } catch (a) {
        throw a.name === Ioe ? n : a;
      }
    } else
      throw n;
  }
  saveRecogState() {
    const e = this.errors, r = mi(this.RULE_STACK);
    return {
      errors: e,
      lexerState: this.exportLexerState(),
      RULE_STACK: r,
      CST_STACK: this.CST_STACK
    };
  }
  reloadRecogState(e) {
    this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK;
  }
  ruleInvocationStateUpdate(e, r, n) {
    this.RULE_OCCURRENCE_STACK.push(n), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(r);
  }
  isBackTracking() {
    return this.isBackTrackingStack.length !== 0;
  }
  getCurrRuleFullName() {
    const e = this.getLastExplicitRuleShortName();
    return this.shortRuleNameToFull[e];
  }
  shortRuleNameToFullName(e) {
    return this.shortRuleNameToFull[e];
  }
  isAtEndOfInput() {
    return this.tokenMatcher(this.LA(1), Rc);
  }
  reset() {
    this.resetLexerState(), this.subruleIdx = 0, this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [];
  }
}
class Bje {
  initErrorHandler(e) {
    this._errors = [], this.errorMessageProvider = Vt(e, "errorMessageProvider") ? e.errorMessageProvider : Tl.errorMessageProvider;
  }
  SAVE_ERROR(e) {
    if (ix(e))
      return e.context = {
        ruleStack: this.getHumanReadableRuleStack(),
        ruleOccurrenceStack: mi(this.RULE_OCCURRENCE_STACK)
      }, this._errors.push(e), e;
    throw Error("Trying to save an Error which is not a RecognitionException");
  }
  get errors() {
    return mi(this._errors);
  }
  set errors(e) {
    this._errors = e;
  }
  // TODO: consider caching the error message computed information
  raiseEarlyExitException(e, r, n) {
    const i = this.getCurrRuleFullName(), a = this.getGAstProductions()[i], o = G3(e, a, r, this.maxLookahead)[0], l = [];
    for (let h = 1; h <= this.maxLookahead; h++)
      l.push(this.LA(h));
    const u = this.errorMessageProvider.buildEarlyExitMessage({
      expectedIterationPaths: o,
      actual: l,
      previous: this.LA(0),
      customUserDescription: n,
      ruleName: i
    });
    throw this.SAVE_ERROR(new yje(u, this.LA(1), this.LA(0)));
  }
  // TODO: consider caching the error message computed information
  raiseNoAltException(e, r) {
    const n = this.getCurrRuleFullName(), i = this.getGAstProductions()[n], a = q3(e, i, this.maxLookahead), s = [];
    for (let u = 1; u <= this.maxLookahead; u++)
      s.push(this.LA(u));
    const o = this.LA(0), l = this.errorMessageProvider.buildNoViableAltMessage({
      expectedPathsPerAlt: a,
      actual: s,
      previous: o,
      customUserDescription: r,
      ruleName: this.getCurrRuleFullName()
    });
    throw this.SAVE_ERROR(new mje(l, this.LA(1), o));
  }
}
class Fje {
  initContentAssist() {
  }
  computeContentAssist(e, r) {
    const n = this.gastProductionsCache[e];
    if (xl(n))
      throw Error(`Rule ->${e}<- does not exist in this grammar.`);
    return boe([n], r, this.tokenMatcher, this.maxLookahead);
  }
  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
  // TODO: should this be more explicitly part of the public API?
  getNextPossibleTokenTypes(e) {
    const r = Ps(e.ruleStack), i = this.getGAstProductions()[r];
    return new GXe(i, e).startWalking();
  }
}
const V3 = {
  description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(V3);
const lH = !0, cH = Math.pow(2, Kc) - 1, Ooe = voe({ name: "RECORDING_PHASE_TOKEN", pattern: ha.NA });
Gm([Ooe]);
const Poe = _I(
  Ooe,
  `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
);
Object.freeze(Poe);
const zje = {
  name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  children: {}
};
class qje {
  initGastRecorder(e) {
    this.recordingProdStack = [], this.RECORDING_PHASE = !1;
  }
  enableRecording() {
    this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", () => {
      for (let e = 0; e < 10; e++) {
        const r = e > 0 ? e : "";
        this[`CONSUME${r}`] = function(n, i) {
          return this.consumeInternalRecord(n, e, i);
        }, this[`SUBRULE${r}`] = function(n, i) {
          return this.subruleInternalRecord(n, e, i);
        }, this[`OPTION${r}`] = function(n) {
          return this.optionInternalRecord(n, e);
        }, this[`OR${r}`] = function(n) {
          return this.orInternalRecord(n, e);
        }, this[`MANY${r}`] = function(n) {
          this.manyInternalRecord(e, n);
        }, this[`MANY_SEP${r}`] = function(n) {
          this.manySepFirstInternalRecord(e, n);
        }, this[`AT_LEAST_ONE${r}`] = function(n) {
          this.atLeastOneInternalRecord(e, n);
        }, this[`AT_LEAST_ONE_SEP${r}`] = function(n) {
          this.atLeastOneSepFirstInternalRecord(e, n);
        };
      }
      this.consume = function(e, r, n) {
        return this.consumeInternalRecord(r, e, n);
      }, this.subrule = function(e, r, n) {
        return this.subruleInternalRecord(r, e, n);
      }, this.option = function(e, r) {
        return this.optionInternalRecord(r, e);
      }, this.or = function(e, r) {
        return this.orInternalRecord(r, e);
      }, this.many = function(e, r) {
        this.manyInternalRecord(e, r);
      }, this.atLeastOne = function(e, r) {
        this.atLeastOneInternalRecord(e, r);
      }, this.ACTION = this.ACTION_RECORD, this.BACKTRACK = this.BACKTRACK_RECORD, this.LA = this.LA_RECORD;
    });
  }
  disableRecording() {
    this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", () => {
      const e = this;
      for (let r = 0; r < 10; r++) {
        const n = r > 0 ? r : "";
        delete e[`CONSUME${n}`], delete e[`SUBRULE${n}`], delete e[`OPTION${n}`], delete e[`OR${n}`], delete e[`MANY${n}`], delete e[`MANY_SEP${n}`], delete e[`AT_LEAST_ONE${n}`], delete e[`AT_LEAST_ONE_SEP${n}`];
      }
      delete e.consume, delete e.subrule, delete e.option, delete e.or, delete e.many, delete e.atLeastOne, delete e.ACTION, delete e.BACKTRACK, delete e.LA;
    });
  }
  //   Parser methods are called inside an ACTION?
  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
  // @ts-expect-error -- noop place holder
  ACTION_RECORD(e) {
  }
  // Executing backtracking logic will break our recording logic assumptions
  BACKTRACK_RECORD(e, r) {
    return () => !0;
  }
  // LA is part of the official API and may be used for custom lookahead logic
  // by end users who may forget to wrap it in ACTION or inside a GATE
  LA_RECORD(e) {
    return sx;
  }
  topLevelRuleRecord(e, r) {
    try {
      const n = new j0({ definition: [], name: e });
      return n.name = e, this.recordingProdStack.push(n), r.call(this), this.recordingProdStack.pop(), n;
    } catch (n) {
      if (n.KNOWN_RECORDER_ERROR !== !0)
        try {
          n.message = n.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`;
        } catch {
          throw n;
        }
      throw n;
    }
  }
  // Implementation of parsing DSL
  optionInternalRecord(e, r) {
    return kp.call(this, gi, e, r);
  }
  atLeastOneInternalRecord(e, r) {
    kp.call(this, Pa, r, e);
  }
  atLeastOneSepFirstInternalRecord(e, r) {
    kp.call(this, $a, r, e, lH);
  }
  manyInternalRecord(e, r) {
    kp.call(this, hn, r, e);
  }
  manySepFirstInternalRecord(e, r) {
    kp.call(this, ya, r, e, lH);
  }
  orInternalRecord(e, r) {
    return Gje.call(this, e, r);
  }
  subruleInternalRecord(e, r, n) {
    if (ax(r), !e || Vt(e, "ruleName") === !1) {
      const o = new Error(`<SUBRULE${uH(r)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw o.KNOWN_RECORDER_ERROR = !0, o;
    }
    const i = g0(this.recordingProdStack), a = e.ruleName, s = new Ki({
      idx: r,
      nonTerminalName: a,
      label: n?.LABEL,
      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
      referencedRule: void 0
    });
    return i.definition.push(s), this.outputCst ? zje : V3;
  }
  consumeInternalRecord(e, r, n) {
    if (ax(r), !goe(e)) {
      const s = new Error(`<CONSUME${uH(r)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw s.KNOWN_RECORDER_ERROR = !0, s;
    }
    const i = g0(this.recordingProdStack), a = new jr({
      idx: r,
      terminalType: e,
      label: n?.LABEL
    });
    return i.definition.push(a), Poe;
  }
}
function kp(t, e, r, n = !1) {
  ax(r);
  const i = g0(this.recordingProdStack), a = Ml(e) ? e : e.DEF, s = new t({ definition: [], idx: r });
  return n && (s.separator = e.SEP), Vt(e, "MAX_LOOKAHEAD") && (s.maxLookahead = e.MAX_LOOKAHEAD), this.recordingProdStack.push(s), a.call(this), i.definition.push(s), this.recordingProdStack.pop(), V3;
}
function Gje(t, e) {
  ax(e);
  const r = g0(this.recordingProdStack), n = xr(t) === !1, i = n === !1 ? t : t.DEF, a = new ba({
    definition: [],
    idx: e,
    ignoreAmbiguities: n && t.IGNORE_AMBIGUITIES === !0
  });
  Vt(t, "MAX_LOOKAHEAD") && (a.maxLookahead = t.MAX_LOOKAHEAD);
  const s = AUe(i, (o) => Ml(o.GATE));
  return a.hasPredicates = s, r.definition.push(a), Zt(i, (o) => {
    const l = new pa({ definition: [] });
    a.definition.push(l), Vt(o, "IGNORE_AMBIGUITIES") ? l.ignoreAmbiguities = o.IGNORE_AMBIGUITIES : Vt(o, "GATE") && (l.ignoreAmbiguities = !0), this.recordingProdStack.push(l), o.ALT.call(this), this.recordingProdStack.pop();
  }), V3;
}
function uH(t) {
  return t === 0 ? "" : `${t}`;
}
function ax(t) {
  if (t < 0 || t > cH) {
    const e = new Error(
      // The stack trace will contain all the needed details
      `Invalid DSL Method idx value: <${t}>
	Idx value must be a none negative value smaller than ${cH + 1}`
    );
    throw e.KNOWN_RECORDER_ERROR = !0, e;
  }
}
class Uje {
  initPerformanceTracer(e) {
    if (Vt(e, "traceInitPerf")) {
      const r = e.traceInitPerf, n = typeof r == "number";
      this.traceInitMaxIdent = n ? r : 1 / 0, this.traceInitPerf = n ? r > 0 : r;
    } else
      this.traceInitMaxIdent = 0, this.traceInitPerf = Tl.traceInitPerf;
    this.traceInitIndent = -1;
  }
  TRACE_INIT(e, r) {
    if (this.traceInitPerf === !0) {
      this.traceInitIndent++;
      const n = new Array(this.traceInitIndent + 1).join("	");
      this.traceInitIndent < this.traceInitMaxIdent && console.log(`${n}--> <${e}>`);
      const { time: i, value: a } = $se(r), s = i > 10 ? console.warn : console.log;
      return this.traceInitIndent < this.traceInitMaxIdent && s(`${n}<-- <${e}> time: ${i}ms`), this.traceInitIndent--, a;
    } else
      return r();
  }
}
function Vje(t, e) {
  e.forEach((r) => {
    const n = r.prototype;
    Object.getOwnPropertyNames(n).forEach((i) => {
      if (i === "constructor")
        return;
      const a = Object.getOwnPropertyDescriptor(n, i);
      a && (a.get || a.set) ? Object.defineProperty(t.prototype, i, a) : t.prototype[i] = r.prototype[i];
    });
  });
}
const sx = _I(Rc, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(sx);
const Tl = Object.freeze({
  recoveryEnabled: !1,
  maxLookahead: 3,
  dynamicTokensEnabled: !1,
  outputCst: !0,
  errorMessageProvider: _f,
  nodeLocationTracking: "none",
  traceInitPerf: !1,
  skipValidations: !1
}), ox = Object.freeze({
  recoveryValueFunc: () => {
  },
  resyncEnabled: !0
});
var Zi;
(function(t) {
  t[t.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", t[t.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", t[t.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", t[t.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", t[t.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", t[t.LEFT_RECURSION = 5] = "LEFT_RECURSION", t[t.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", t[t.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", t[t.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", t[t.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", t[t.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", t[t.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", t[t.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS", t[t.CUSTOM_LOOKAHEAD_VALIDATION = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
})(Zi || (Zi = {}));
function hH(t = void 0) {
  return function() {
    return t;
  };
}
class Um {
  /**
   *  @deprecated use the **instance** method with the same name instead
   */
  static performSelfAnalysis(e) {
    throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
  }
  performSelfAnalysis() {
    this.TRACE_INIT("performSelfAnalysis", () => {
      let e;
      this.selfAnalysisDone = !0;
      const r = this.className;
      this.TRACE_INIT("toFastProps", () => {
        Bse(this);
      }), this.TRACE_INIT("Grammar Recording", () => {
        try {
          this.enableRecording(), Zt(this.definedRulesNames, (i) => {
            const s = this[i].originalGrammarAction;
            let o;
            this.TRACE_INIT(`${i} Rule`, () => {
              o = this.topLevelRuleRecord(i, s);
            }), this.gastProductionsCache[i] = o;
          });
        } finally {
          this.disableRecording();
        }
      });
      let n = [];
      if (this.TRACE_INIT("Grammar Resolving", () => {
        n = pje({
          rules: Fn(this.gastProductionsCache)
        }), this.definitionErrors = this.definitionErrors.concat(n);
      }), this.TRACE_INIT("Grammar Validations", () => {
        if (qr(n) && this.skipValidations === !1) {
          const i = gje({
            rules: Fn(this.gastProductionsCache),
            tokenTypes: Fn(this.tokensMap),
            errMsgProvider: Ou,
            grammarName: r
          }), a = JXe({
            lookaheadStrategy: this.lookaheadStrategy,
            rules: Fn(this.gastProductionsCache),
            tokenTypes: Fn(this.tokensMap),
            grammarName: r
          });
          this.definitionErrors = this.definitionErrors.concat(i, a);
        }
      }), qr(this.definitionErrors) && (this.recoveryEnabled && this.TRACE_INIT("computeAllProdsFollows", () => {
        const i = QYe(Fn(this.gastProductionsCache));
        this.resyncFollows = i;
      }), this.TRACE_INIT("ComputeLookaheadFunctions", () => {
        var i, a;
        (a = (i = this.lookaheadStrategy).initialize) === null || a === void 0 || a.call(i, {
          rules: Fn(this.gastProductionsCache)
        }), this.preComputeLookaheadFunctions(Fn(this.gastProductionsCache));
      })), !Um.DEFER_DEFINITION_ERRORS_HANDLING && !qr(this.definitionErrors))
        throw e = $t(this.definitionErrors, (i) => i.message), new Error(`Parser Definition Errors detected:
 ${e.join(`
-------------------------------
`)}`);
    });
  }
  constructor(e, r) {
    this.definitionErrors = [], this.selfAnalysisDone = !1;
    const n = this;
    if (n.initErrorHandler(r), n.initLexerAdapter(), n.initLooksAhead(r), n.initRecognizerEngine(e, r), n.initRecoverable(r), n.initTreeBuilder(r), n.initContentAssist(), n.initGastRecorder(r), n.initPerformanceTracer(r), Vt(r, "ignoredIssues"))
      throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
    this.skipValidations = Vt(r, "skipValidations") ? r.skipValidations : Tl.skipValidations;
  }
}
Um.DEFER_DEFINITION_ERRORS_HANDLING = !1;
Vje(Um, [
  xje,
  Eje,
  Dje,
  Oje,
  $je,
  Pje,
  Bje,
  Fje,
  qje,
  Uje
]);
class Hje extends Um {
  constructor(e, r = Tl) {
    const n = mi(r);
    n.outputCst = !1, super(e, n);
  }
}
function v0(t, e, r) {
  return `${t.name}_${e}_${r}`;
}
const Ic = 1, Wje = 2, $oe = 4, Boe = 5, Vm = 7, Yje = 8, Xje = 9, jje = 10, Kje = 11, Foe = 12;
class II {
  constructor(e) {
    this.target = e;
  }
  isEpsilon() {
    return !1;
  }
}
class MI extends II {
  constructor(e, r) {
    super(e), this.tokenType = r;
  }
}
class zoe extends II {
  constructor(e) {
    super(e);
  }
  isEpsilon() {
    return !0;
  }
}
class NI extends II {
  constructor(e, r, n) {
    super(e), this.rule = r, this.followState = n;
  }
  isEpsilon() {
    return !0;
  }
}
function Zje(t) {
  const e = {
    decisionMap: {},
    decisionStates: [],
    ruleToStartState: /* @__PURE__ */ new Map(),
    ruleToStopState: /* @__PURE__ */ new Map(),
    states: []
  };
  Qje(e, t);
  const r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n], a = Vh(e, i, i);
    a !== void 0 && cKe(e, i, a);
  }
  return e;
}
function Qje(t, e) {
  const r = e.length;
  for (let n = 0; n < r; n++) {
    const i = e[n], a = ei(t, i, void 0, {
      type: Wje
    }), s = ei(t, i, void 0, {
      type: Vm
    });
    a.stop = s, t.ruleToStartState.set(i, a), t.ruleToStopState.set(i, s);
  }
}
function qoe(t, e, r) {
  return r instanceof jr ? DI(t, e, r.terminalType, r) : r instanceof Ki ? lKe(t, e, r) : r instanceof ba ? nKe(t, e, r) : r instanceof gi ? iKe(t, e, r) : r instanceof hn ? Jje(t, e, r) : r instanceof ya ? eKe(t, e, r) : r instanceof Pa ? tKe(t, e, r) : r instanceof $a ? rKe(t, e, r) : Vh(t, e, r);
}
function Jje(t, e, r) {
  const n = ei(t, e, r, {
    type: Boe
  });
  Zc(t, n);
  const i = Z0(t, e, n, r, Vh(t, e, r));
  return Uoe(t, e, r, i);
}
function eKe(t, e, r) {
  const n = ei(t, e, r, {
    type: Boe
  });
  Zc(t, n);
  const i = Z0(t, e, n, r, Vh(t, e, r)), a = DI(t, e, r.separator, r);
  return Uoe(t, e, r, i, a);
}
function tKe(t, e, r) {
  const n = ei(t, e, r, {
    type: $oe
  });
  Zc(t, n);
  const i = Z0(t, e, n, r, Vh(t, e, r));
  return Goe(t, e, r, i);
}
function rKe(t, e, r) {
  const n = ei(t, e, r, {
    type: $oe
  });
  Zc(t, n);
  const i = Z0(t, e, n, r, Vh(t, e, r)), a = DI(t, e, r.separator, r);
  return Goe(t, e, r, i, a);
}
function nKe(t, e, r) {
  const n = ei(t, e, r, {
    type: Ic
  });
  Zc(t, n);
  const i = Dr(r.definition, (s) => qoe(t, e, s));
  return Z0(t, e, n, r, ...i);
}
function iKe(t, e, r) {
  const n = ei(t, e, r, {
    type: Ic
  });
  Zc(t, n);
  const i = Z0(t, e, n, r, Vh(t, e, r));
  return aKe(t, e, r, i);
}
function Vh(t, e, r) {
  const n = io(Dr(r.definition, (i) => qoe(t, e, i)), (i) => i !== void 0);
  return n.length === 1 ? n[0] : n.length === 0 ? void 0 : oKe(t, n);
}
function Goe(t, e, r, n, i) {
  const a = n.left, s = n.right, o = ei(t, e, r, {
    type: Kje
  });
  Zc(t, o);
  const l = ei(t, e, r, {
    type: Foe
  });
  return a.loopback = o, l.loopback = o, t.decisionMap[v0(e, i ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", r.idx)] = o, _n(s, o), i === void 0 ? (_n(o, a), _n(o, l)) : (_n(o, l), _n(o, i.left), _n(i.right, a)), {
    left: a,
    right: l
  };
}
function Uoe(t, e, r, n, i) {
  const a = n.left, s = n.right, o = ei(t, e, r, {
    type: jje
  });
  Zc(t, o);
  const l = ei(t, e, r, {
    type: Foe
  }), u = ei(t, e, r, {
    type: Xje
  });
  return o.loopback = u, l.loopback = u, _n(o, a), _n(o, l), _n(s, u), i !== void 0 ? (_n(u, l), _n(u, i.left), _n(i.right, a)) : _n(u, o), t.decisionMap[v0(e, i ? "RepetitionWithSeparator" : "Repetition", r.idx)] = o, {
    left: o,
    right: l
  };
}
function aKe(t, e, r, n) {
  const i = n.left, a = n.right;
  return _n(i, a), t.decisionMap[v0(e, "Option", r.idx)] = i, n;
}
function Zc(t, e) {
  return t.decisionStates.push(e), e.decision = t.decisionStates.length - 1, e.decision;
}
function Z0(t, e, r, n, ...i) {
  const a = ei(t, e, n, {
    type: Yje,
    start: r
  });
  r.end = a;
  for (const o of i)
    o !== void 0 ? (_n(r, o.left), _n(o.right, a)) : _n(r, a);
  const s = {
    left: r,
    right: a
  };
  return t.decisionMap[v0(e, sKe(n), n.idx)] = r, s;
}
function sKe(t) {
  if (t instanceof ba)
    return "Alternation";
  if (t instanceof gi)
    return "Option";
  if (t instanceof hn)
    return "Repetition";
  if (t instanceof ya)
    return "RepetitionWithSeparator";
  if (t instanceof Pa)
    return "RepetitionMandatory";
  if (t instanceof $a)
    return "RepetitionMandatoryWithSeparator";
  throw new Error("Invalid production type encountered");
}
function oKe(t, e) {
  const r = e.length;
  for (let a = 0; a < r - 1; a++) {
    const s = e[a];
    let o;
    s.left.transitions.length === 1 && (o = s.left.transitions[0]);
    const l = o instanceof NI, u = o, h = e[a + 1].left;
    s.left.type === Ic && s.right.type === Ic && o !== void 0 && (l && u.followState === s.right || o.target === s.right) ? (l ? u.followState = h : o.target = h, uKe(t, s.right)) : _n(s.right, h);
  }
  const n = e[0], i = e[r - 1];
  return {
    left: n.left,
    right: i.right
  };
}
function DI(t, e, r, n) {
  const i = ei(t, e, n, {
    type: Ic
  }), a = ei(t, e, n, {
    type: Ic
  });
  return OI(i, new MI(a, r)), {
    left: i,
    right: a
  };
}
function lKe(t, e, r) {
  const n = r.referencedRule, i = t.ruleToStartState.get(n), a = ei(t, e, r, {
    type: Ic
  }), s = ei(t, e, r, {
    type: Ic
  }), o = new NI(i, n, s);
  return OI(a, o), {
    left: a,
    right: s
  };
}
function cKe(t, e, r) {
  const n = t.ruleToStartState.get(e);
  _n(n, r.left);
  const i = t.ruleToStopState.get(e);
  return _n(r.right, i), {
    left: n,
    right: i
  };
}
function _n(t, e) {
  const r = new zoe(e);
  OI(t, r);
}
function ei(t, e, r, n) {
  const i = Object.assign({
    atn: t,
    production: r,
    epsilonOnlyTransitions: !1,
    rule: e,
    transitions: [],
    nextTokenWithinRule: [],
    stateNumber: t.states.length
  }, n);
  return t.states.push(i), i;
}
function OI(t, e) {
  t.transitions.length === 0 && (t.epsilonOnlyTransitions = e.isEpsilon()), t.transitions.push(e);
}
function uKe(t, e) {
  t.states.splice(t.states.indexOf(e), 1);
}
const lx = {};
class o8 {
  constructor() {
    this.map = {}, this.configs = [];
  }
  get size() {
    return this.configs.length;
  }
  finalize() {
    this.map = {};
  }
  add(e) {
    const r = Voe(e);
    r in this.map || (this.map[r] = this.configs.length, this.configs.push(e));
  }
  get elements() {
    return this.configs;
  }
  get alts() {
    return Dr(this.configs, (e) => e.alt);
  }
  get key() {
    let e = "";
    for (const r in this.map)
      e += r + ":";
    return e;
  }
}
function Voe(t, e = !0) {
  return `${e ? `a${t.alt}` : ""}s${t.state.stateNumber}:${t.stack.map((r) => r.stateNumber.toString()).join("_")}`;
}
function hKe(t, e) {
  const r = {};
  return (n) => {
    const i = n.toString();
    let a = r[i];
    return a !== void 0 || (a = {
      atnStartState: t,
      decision: e,
      states: {}
    }, r[i] = a), a;
  };
}
class Hoe {
  constructor() {
    this.predicates = [];
  }
  is(e) {
    return e >= this.predicates.length || this.predicates[e];
  }
  set(e, r) {
    this.predicates[e] = r;
  }
  toString() {
    let e = "";
    const r = this.predicates.length;
    for (let n = 0; n < r; n++)
      e += this.predicates[n] === !0 ? "1" : "0";
    return e;
  }
}
const fH = new Hoe();
class fKe extends RI {
  constructor(e) {
    var r;
    super(), this.logging = (r = e?.logging) !== null && r !== void 0 ? r : ((n) => console.log(n));
  }
  initialize(e) {
    this.atn = Zje(e.rules), this.dfas = dKe(this.atn);
  }
  validateAmbiguousAlternationAlternatives() {
    return [];
  }
  validateEmptyOrAlternatives() {
    return [];
  }
  buildLookaheadForAlternation(e) {
    const { prodOccurrence: r, rule: n, hasPredicates: i, dynamicTokensEnabled: a } = e, s = this.dfas, o = this.logging, l = v0(n, "Alternation", r), h = this.atn.decisionMap[l].decision, f = Dr(iH({
      maxLookahead: 1,
      occurrence: r,
      prodType: "Alternation",
      rule: n
    }), (d) => Dr(d, (p) => p[0]));
    if (dH(f, !1) && !a) {
      const d = eh(f, (p, g, m) => (Ye(g, (v) => {
        v && (p[v.tokenTypeIdx] = m, Ye(v.categoryMatches, (y) => {
          p[y] = m;
        }));
      }), p), {});
      return i ? function(p) {
        var g;
        const m = this.LA(1), v = d[m.tokenTypeIdx];
        if (p !== void 0 && v !== void 0) {
          const y = (g = p[v]) === null || g === void 0 ? void 0 : g.GATE;
          if (y !== void 0 && y.call(this) === !1)
            return;
        }
        return v;
      } : function() {
        const p = this.LA(1);
        return d[p.tokenTypeIdx];
      };
    } else return i ? function(d) {
      const p = new Hoe(), g = d === void 0 ? 0 : d.length;
      for (let v = 0; v < g; v++) {
        const y = d?.[v].GATE;
        p.set(v, y === void 0 || y.call(this));
      }
      const m = E7.call(this, s, h, p, o);
      return typeof m == "number" ? m : void 0;
    } : function() {
      const d = E7.call(this, s, h, fH, o);
      return typeof d == "number" ? d : void 0;
    };
  }
  buildLookaheadForOptional(e) {
    const { prodOccurrence: r, rule: n, prodType: i, dynamicTokensEnabled: a } = e, s = this.dfas, o = this.logging, l = v0(n, i, r), h = this.atn.decisionMap[l].decision, f = Dr(iH({
      maxLookahead: 1,
      occurrence: r,
      prodType: i,
      rule: n
    }), (d) => Dr(d, (p) => p[0]));
    if (dH(f) && f[0][0] && !a) {
      const d = f[0], p = Ih(d);
      if (p.length === 1 && m1(p[0].categoryMatches)) {
        const m = p[0].tokenTypeIdx;
        return function() {
          return this.LA(1).tokenTypeIdx === m;
        };
      } else {
        const g = eh(p, (m, v) => (v !== void 0 && (m[v.tokenTypeIdx] = !0, Ye(v.categoryMatches, (y) => {
          m[y] = !0;
        })), m), {});
        return function() {
          const m = this.LA(1);
          return g[m.tokenTypeIdx] === !0;
        };
      }
    }
    return function() {
      const d = E7.call(this, s, h, fH, o);
      return typeof d == "object" ? !1 : d === 0;
    };
  }
}
function dH(t, e = !0) {
  const r = /* @__PURE__ */ new Set();
  for (const n of t) {
    const i = /* @__PURE__ */ new Set();
    for (const a of n) {
      if (a === void 0) {
        if (e)
          break;
        return !1;
      }
      const s = [a.tokenTypeIdx].concat(a.categoryMatches);
      for (const o of s)
        if (r.has(o)) {
          if (!i.has(o))
            return !1;
        } else
          r.add(o), i.add(o);
    }
  }
  return !0;
}
function dKe(t) {
  const e = t.decisionStates.length, r = Array(e);
  for (let n = 0; n < e; n++)
    r[n] = hKe(t.decisionStates[n], n);
  return r;
}
function E7(t, e, r, n) {
  const i = t[e](r);
  let a = i.start;
  if (a === void 0) {
    const o = SKe(i.atnStartState);
    a = Yoe(i, Woe(o)), i.start = a;
  }
  return pKe.apply(this, [i, a, r, n]);
}
function pKe(t, e, r, n) {
  let i = e, a = 1;
  const s = [];
  let o = this.LA(a++);
  for (; ; ) {
    let l = xKe(i, o);
    if (l === void 0 && (l = gKe.apply(this, [t, i, o, a, r, n])), l === lx)
      return bKe(s, i, o);
    if (l.isAcceptState === !0)
      return l.prediction;
    i = l, s.push(o), o = this.LA(a++);
  }
}
function gKe(t, e, r, n, i, a) {
  const s = wKe(e.configs, r, i);
  if (s.size === 0)
    return pH(t, e, r, lx), lx;
  let o = Woe(s);
  const l = EKe(s, i);
  if (l !== void 0)
    o.isAcceptState = !0, o.prediction = l, o.configs.uniqueAlt = l;
  else if (AKe(s)) {
    const u = l0(s.alts);
    o.isAcceptState = !0, o.prediction = u, o.configs.uniqueAlt = u, mKe.apply(this, [t, n, s.alts, a]);
  }
  return o = pH(t, e, r, o), o;
}
function mKe(t, e, r, n) {
  const i = [];
  for (let u = 1; u <= e; u++)
    i.push(this.LA(u).tokenType);
  const a = t.atnStartState, s = a.rule, o = a.production, l = vKe({
    topLevelRule: s,
    ambiguityIndices: r,
    production: o,
    prefixPath: i
  });
  n(l);
}
function vKe(t) {
  const e = Dr(t.prefixPath, (i) => Vf(i)).join(", "), r = t.production.idx === 0 ? "" : t.production.idx;
  let n = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(", ")}> in <${yKe(t.production)}${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
  return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
}
function yKe(t) {
  if (t instanceof Ki)
    return "SUBRULE";
  if (t instanceof gi)
    return "OPTION";
  if (t instanceof ba)
    return "OR";
  if (t instanceof Pa)
    return "AT_LEAST_ONE";
  if (t instanceof $a)
    return "AT_LEAST_ONE_SEP";
  if (t instanceof ya)
    return "MANY_SEP";
  if (t instanceof hn)
    return "MANY";
  if (t instanceof jr)
    return "CONSUME";
  throw Error("non exhaustive match");
}
function bKe(t, e, r) {
  const n = EAe(e.configs.elements, (a) => a.state.transitions), i = YAe(n.filter((a) => a instanceof MI).map((a) => a.tokenType), (a) => a.tokenTypeIdx);
  return {
    actualToken: r,
    possibleTokenTypes: i,
    tokenPath: t
  };
}
function xKe(t, e) {
  return t.edges[e.tokenTypeIdx];
}
function wKe(t, e, r) {
  const n = new o8(), i = [];
  for (const s of t.elements) {
    if (r.is(s.alt) === !1)
      continue;
    if (s.state.type === Vm) {
      i.push(s);
      continue;
    }
    const o = s.state.transitions.length;
    for (let l = 0; l < o; l++) {
      const u = s.state.transitions[l], h = TKe(u, e);
      h !== void 0 && n.add({
        state: h,
        alt: s.alt,
        stack: s.stack
      });
    }
  }
  let a;
  if (i.length === 0 && n.size === 1 && (a = n), a === void 0) {
    a = new o8();
    for (const s of n.elements)
      cx(s, a);
  }
  if (i.length > 0 && !CKe(a))
    for (const s of i)
      a.add(s);
  return a;
}
function TKe(t, e) {
  if (t instanceof MI && yoe(e, t.tokenType))
    return t.target;
}
function EKe(t, e) {
  let r;
  for (const n of t.elements)
    if (e.is(n.alt) === !0) {
      if (r === void 0)
        r = n.alt;
      else if (r !== n.alt)
        return;
    }
  return r;
}
function Woe(t) {
  return {
    configs: t,
    edges: {},
    isAcceptState: !1,
    prediction: -1
  };
}
function pH(t, e, r, n) {
  return n = Yoe(t, n), e.edges[r.tokenTypeIdx] = n, n;
}
function Yoe(t, e) {
  if (e === lx)
    return e;
  const r = e.configs.key, n = t.states[r];
  return n !== void 0 ? n : (e.configs.finalize(), t.states[r] = e, e);
}
function SKe(t) {
  const e = new o8(), r = t.transitions.length;
  for (let n = 0; n < r; n++) {
    const a = {
      state: t.transitions[n].target,
      alt: n,
      stack: []
    };
    cx(a, e);
  }
  return e;
}
function cx(t, e) {
  const r = t.state;
  if (r.type === Vm) {
    if (t.stack.length > 0) {
      const i = [...t.stack], s = {
        state: i.pop(),
        alt: t.alt,
        stack: i
      };
      cx(s, e);
    } else
      e.add(t);
    return;
  }
  r.epsilonOnlyTransitions || e.add(t);
  const n = r.transitions.length;
  for (let i = 0; i < n; i++) {
    const a = r.transitions[i], s = kKe(t, a);
    s !== void 0 && cx(s, e);
  }
}
function kKe(t, e) {
  if (e instanceof zoe)
    return {
      state: e.target,
      alt: t.alt,
      stack: t.stack
    };
  if (e instanceof NI) {
    const r = [...t.stack, e.followState];
    return {
      state: e.target,
      alt: t.alt,
      stack: r
    };
  }
}
function CKe(t) {
  for (const e of t.elements)
    if (e.state.type === Vm)
      return !0;
  return !1;
}
function _Ke(t) {
  for (const e of t.elements)
    if (e.state.type !== Vm)
      return !1;
  return !0;
}
function AKe(t) {
  if (_Ke(t))
    return !0;
  const e = LKe(t.elements);
  return RKe(e) && !IKe(e);
}
function LKe(t) {
  const e = /* @__PURE__ */ new Map();
  for (const r of t) {
    const n = Voe(r, !1);
    let i = e.get(n);
    i === void 0 && (i = {}, e.set(n, i)), i[r.alt] = !0;
  }
  return e;
}
function RKe(t) {
  for (const e of Array.from(t.values()))
    if (Object.keys(e).length > 1)
      return !0;
  return !1;
}
function IKe(t) {
  for (const e of Array.from(t.values()))
    if (Object.keys(e).length === 1)
      return !0;
  return !1;
}
var gH;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(gH || (gH = {}));
var l8;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(l8 || (l8 = {}));
var mH;
(function(t) {
  t.MIN_VALUE = -2147483648, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(mH || (mH = {}));
var ux;
(function(t) {
  t.MIN_VALUE = 0, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(ux || (ux = {}));
var Cr;
(function(t) {
  function e(n, i) {
    return n === Number.MAX_VALUE && (n = ux.MAX_VALUE), i === Number.MAX_VALUE && (i = ux.MAX_VALUE), { line: n, character: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && Fe.uinteger(i.line) && Fe.uinteger(i.character);
  }
  t.is = r;
})(Cr || (Cr = {}));
var gr;
(function(t) {
  function e(n, i, a, s) {
    if (Fe.uinteger(n) && Fe.uinteger(i) && Fe.uinteger(a) && Fe.uinteger(s))
      return { start: Cr.create(n, i), end: Cr.create(a, s) };
    if (Cr.is(n) && Cr.is(i))
      return { start: n, end: i };
    throw new Error(`Range#create called with invalid arguments[${n}, ${i}, ${a}, ${s}]`);
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && Cr.is(i.start) && Cr.is(i.end);
  }
  t.is = r;
})(gr || (gr = {}));
var hx;
(function(t) {
  function e(n, i) {
    return { uri: n, range: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && gr.is(i.range) && (Fe.string(i.uri) || Fe.undefined(i.uri));
  }
  t.is = r;
})(hx || (hx = {}));
var vH;
(function(t) {
  function e(n, i, a, s) {
    return { targetUri: n, targetRange: i, targetSelectionRange: a, originSelectionRange: s };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && gr.is(i.targetRange) && Fe.string(i.targetUri) && gr.is(i.targetSelectionRange) && (gr.is(i.originSelectionRange) || Fe.undefined(i.originSelectionRange));
  }
  t.is = r;
})(vH || (vH = {}));
var c8;
(function(t) {
  function e(n, i, a, s) {
    return {
      red: n,
      green: i,
      blue: a,
      alpha: s
    };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.numberRange(i.red, 0, 1) && Fe.numberRange(i.green, 0, 1) && Fe.numberRange(i.blue, 0, 1) && Fe.numberRange(i.alpha, 0, 1);
  }
  t.is = r;
})(c8 || (c8 = {}));
var yH;
(function(t) {
  function e(n, i) {
    return {
      range: n,
      color: i
    };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && gr.is(i.range) && c8.is(i.color);
  }
  t.is = r;
})(yH || (yH = {}));
var bH;
(function(t) {
  function e(n, i, a) {
    return {
      label: n,
      textEdit: i,
      additionalTextEdits: a
    };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.string(i.label) && (Fe.undefined(i.textEdit) || b0.is(i)) && (Fe.undefined(i.additionalTextEdits) || Fe.typedArray(i.additionalTextEdits, b0.is));
  }
  t.is = r;
})(bH || (bH = {}));
var xH;
(function(t) {
  t.Comment = "comment", t.Imports = "imports", t.Region = "region";
})(xH || (xH = {}));
var wH;
(function(t) {
  function e(n, i, a, s, o, l) {
    const u = {
      startLine: n,
      endLine: i
    };
    return Fe.defined(a) && (u.startCharacter = a), Fe.defined(s) && (u.endCharacter = s), Fe.defined(o) && (u.kind = o), Fe.defined(l) && (u.collapsedText = l), u;
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.uinteger(i.startLine) && Fe.uinteger(i.startLine) && (Fe.undefined(i.startCharacter) || Fe.uinteger(i.startCharacter)) && (Fe.undefined(i.endCharacter) || Fe.uinteger(i.endCharacter)) && (Fe.undefined(i.kind) || Fe.string(i.kind));
  }
  t.is = r;
})(wH || (wH = {}));
var u8;
(function(t) {
  function e(n, i) {
    return {
      location: n,
      message: i
    };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && hx.is(i.location) && Fe.string(i.message);
  }
  t.is = r;
})(u8 || (u8 = {}));
var TH;
(function(t) {
  t.Error = 1, t.Warning = 2, t.Information = 3, t.Hint = 4;
})(TH || (TH = {}));
var EH;
(function(t) {
  t.Unnecessary = 1, t.Deprecated = 2;
})(EH || (EH = {}));
var SH;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(n) && Fe.string(n.href);
  }
  t.is = e;
})(SH || (SH = {}));
var fx;
(function(t) {
  function e(n, i, a, s, o, l) {
    let u = { range: n, message: i };
    return Fe.defined(a) && (u.severity = a), Fe.defined(s) && (u.code = s), Fe.defined(o) && (u.source = o), Fe.defined(l) && (u.relatedInformation = l), u;
  }
  t.create = e;
  function r(n) {
    var i;
    let a = n;
    return Fe.defined(a) && gr.is(a.range) && Fe.string(a.message) && (Fe.number(a.severity) || Fe.undefined(a.severity)) && (Fe.integer(a.code) || Fe.string(a.code) || Fe.undefined(a.code)) && (Fe.undefined(a.codeDescription) || Fe.string((i = a.codeDescription) === null || i === void 0 ? void 0 : i.href)) && (Fe.string(a.source) || Fe.undefined(a.source)) && (Fe.undefined(a.relatedInformation) || Fe.typedArray(a.relatedInformation, u8.is));
  }
  t.is = r;
})(fx || (fx = {}));
var y0;
(function(t) {
  function e(n, i, ...a) {
    let s = { title: n, command: i };
    return Fe.defined(a) && a.length > 0 && (s.arguments = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.title) && Fe.string(i.command);
  }
  t.is = r;
})(y0 || (y0 = {}));
var b0;
(function(t) {
  function e(a, s) {
    return { range: a, newText: s };
  }
  t.replace = e;
  function r(a, s) {
    return { range: { start: a, end: a }, newText: s };
  }
  t.insert = r;
  function n(a) {
    return { range: a, newText: "" };
  }
  t.del = n;
  function i(a) {
    const s = a;
    return Fe.objectLiteral(s) && Fe.string(s.newText) && gr.is(s.range);
  }
  t.is = i;
})(b0 || (b0 = {}));
var h8;
(function(t) {
  function e(n, i, a) {
    const s = { label: n };
    return i !== void 0 && (s.needsConfirmation = i), a !== void 0 && (s.description = a), s;
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Fe.string(i.label) && (Fe.boolean(i.needsConfirmation) || i.needsConfirmation === void 0) && (Fe.string(i.description) || i.description === void 0);
  }
  t.is = r;
})(h8 || (h8 = {}));
var x0;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.string(n);
  }
  t.is = e;
})(x0 || (x0 = {}));
var kH;
(function(t) {
  function e(a, s, o) {
    return { range: a, newText: s, annotationId: o };
  }
  t.replace = e;
  function r(a, s, o) {
    return { range: { start: a, end: a }, newText: s, annotationId: o };
  }
  t.insert = r;
  function n(a, s) {
    return { range: a, newText: "", annotationId: s };
  }
  t.del = n;
  function i(a) {
    const s = a;
    return b0.is(s) && (h8.is(s.annotationId) || x0.is(s.annotationId));
  }
  t.is = i;
})(kH || (kH = {}));
var f8;
(function(t) {
  function e(n, i) {
    return { textDocument: n, edits: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && v8.is(i.textDocument) && Array.isArray(i.edits);
  }
  t.is = r;
})(f8 || (f8 = {}));
var d8;
(function(t) {
  function e(n, i, a) {
    let s = {
      kind: "create",
      uri: n
    };
    return i !== void 0 && (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) && (s.options = i), a !== void 0 && (s.annotationId = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && i.kind === "create" && Fe.string(i.uri) && (i.options === void 0 || (i.options.overwrite === void 0 || Fe.boolean(i.options.overwrite)) && (i.options.ignoreIfExists === void 0 || Fe.boolean(i.options.ignoreIfExists))) && (i.annotationId === void 0 || x0.is(i.annotationId));
  }
  t.is = r;
})(d8 || (d8 = {}));
var p8;
(function(t) {
  function e(n, i, a, s) {
    let o = {
      kind: "rename",
      oldUri: n,
      newUri: i
    };
    return a !== void 0 && (a.overwrite !== void 0 || a.ignoreIfExists !== void 0) && (o.options = a), s !== void 0 && (o.annotationId = s), o;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && i.kind === "rename" && Fe.string(i.oldUri) && Fe.string(i.newUri) && (i.options === void 0 || (i.options.overwrite === void 0 || Fe.boolean(i.options.overwrite)) && (i.options.ignoreIfExists === void 0 || Fe.boolean(i.options.ignoreIfExists))) && (i.annotationId === void 0 || x0.is(i.annotationId));
  }
  t.is = r;
})(p8 || (p8 = {}));
var g8;
(function(t) {
  function e(n, i, a) {
    let s = {
      kind: "delete",
      uri: n
    };
    return i !== void 0 && (i.recursive !== void 0 || i.ignoreIfNotExists !== void 0) && (s.options = i), a !== void 0 && (s.annotationId = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && i.kind === "delete" && Fe.string(i.uri) && (i.options === void 0 || (i.options.recursive === void 0 || Fe.boolean(i.options.recursive)) && (i.options.ignoreIfNotExists === void 0 || Fe.boolean(i.options.ignoreIfNotExists))) && (i.annotationId === void 0 || x0.is(i.annotationId));
  }
  t.is = r;
})(g8 || (g8 = {}));
var m8;
(function(t) {
  function e(r) {
    let n = r;
    return n && (n.changes !== void 0 || n.documentChanges !== void 0) && (n.documentChanges === void 0 || n.documentChanges.every((i) => Fe.string(i.kind) ? d8.is(i) || p8.is(i) || g8.is(i) : f8.is(i)));
  }
  t.is = e;
})(m8 || (m8 = {}));
var CH;
(function(t) {
  function e(n) {
    return { uri: n };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri);
  }
  t.is = r;
})(CH || (CH = {}));
var _H;
(function(t) {
  function e(n, i) {
    return { uri: n, version: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri) && Fe.integer(i.version);
  }
  t.is = r;
})(_H || (_H = {}));
var v8;
(function(t) {
  function e(n, i) {
    return { uri: n, version: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri) && (i.version === null || Fe.integer(i.version));
  }
  t.is = r;
})(v8 || (v8 = {}));
var AH;
(function(t) {
  function e(n, i, a, s) {
    return { uri: n, languageId: i, version: a, text: s };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.string(i.uri) && Fe.string(i.languageId) && Fe.integer(i.version) && Fe.string(i.text);
  }
  t.is = r;
})(AH || (AH = {}));
var y8;
(function(t) {
  t.PlainText = "plaintext", t.Markdown = "markdown";
  function e(r) {
    const n = r;
    return n === t.PlainText || n === t.Markdown;
  }
  t.is = e;
})(y8 || (y8 = {}));
var z1;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(r) && y8.is(n.kind) && Fe.string(n.value);
  }
  t.is = e;
})(z1 || (z1 = {}));
var LH;
(function(t) {
  t.Text = 1, t.Method = 2, t.Function = 3, t.Constructor = 4, t.Field = 5, t.Variable = 6, t.Class = 7, t.Interface = 8, t.Module = 9, t.Property = 10, t.Unit = 11, t.Value = 12, t.Enum = 13, t.Keyword = 14, t.Snippet = 15, t.Color = 16, t.File = 17, t.Reference = 18, t.Folder = 19, t.EnumMember = 20, t.Constant = 21, t.Struct = 22, t.Event = 23, t.Operator = 24, t.TypeParameter = 25;
})(LH || (LH = {}));
var RH;
(function(t) {
  t.PlainText = 1, t.Snippet = 2;
})(RH || (RH = {}));
var IH;
(function(t) {
  t.Deprecated = 1;
})(IH || (IH = {}));
var MH;
(function(t) {
  function e(n, i, a) {
    return { newText: n, insert: i, replace: a };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i && Fe.string(i.newText) && gr.is(i.insert) && gr.is(i.replace);
  }
  t.is = r;
})(MH || (MH = {}));
var NH;
(function(t) {
  t.asIs = 1, t.adjustIndentation = 2;
})(NH || (NH = {}));
var DH;
(function(t) {
  function e(r) {
    const n = r;
    return n && (Fe.string(n.detail) || n.detail === void 0) && (Fe.string(n.description) || n.description === void 0);
  }
  t.is = e;
})(DH || (DH = {}));
var OH;
(function(t) {
  function e(r) {
    return { label: r };
  }
  t.create = e;
})(OH || (OH = {}));
var PH;
(function(t) {
  function e(r, n) {
    return { items: r || [], isIncomplete: !!n };
  }
  t.create = e;
})(PH || (PH = {}));
var dx;
(function(t) {
  function e(n) {
    return n.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  t.fromPlainText = e;
  function r(n) {
    const i = n;
    return Fe.string(i) || Fe.objectLiteral(i) && Fe.string(i.language) && Fe.string(i.value);
  }
  t.is = r;
})(dx || (dx = {}));
var $H;
(function(t) {
  function e(r) {
    let n = r;
    return !!n && Fe.objectLiteral(n) && (z1.is(n.contents) || dx.is(n.contents) || Fe.typedArray(n.contents, dx.is)) && (r.range === void 0 || gr.is(r.range));
  }
  t.is = e;
})($H || ($H = {}));
var BH;
(function(t) {
  function e(r, n) {
    return n ? { label: r, documentation: n } : { label: r };
  }
  t.create = e;
})(BH || (BH = {}));
var FH;
(function(t) {
  function e(r, n, ...i) {
    let a = { label: r };
    return Fe.defined(n) && (a.documentation = n), Fe.defined(i) ? a.parameters = i : a.parameters = [], a;
  }
  t.create = e;
})(FH || (FH = {}));
var zH;
(function(t) {
  t.Text = 1, t.Read = 2, t.Write = 3;
})(zH || (zH = {}));
var qH;
(function(t) {
  function e(r, n) {
    let i = { range: r };
    return Fe.number(n) && (i.kind = n), i;
  }
  t.create = e;
})(qH || (qH = {}));
var GH;
(function(t) {
  t.File = 1, t.Module = 2, t.Namespace = 3, t.Package = 4, t.Class = 5, t.Method = 6, t.Property = 7, t.Field = 8, t.Constructor = 9, t.Enum = 10, t.Interface = 11, t.Function = 12, t.Variable = 13, t.Constant = 14, t.String = 15, t.Number = 16, t.Boolean = 17, t.Array = 18, t.Object = 19, t.Key = 20, t.Null = 21, t.EnumMember = 22, t.Struct = 23, t.Event = 24, t.Operator = 25, t.TypeParameter = 26;
})(GH || (GH = {}));
var UH;
(function(t) {
  t.Deprecated = 1;
})(UH || (UH = {}));
var VH;
(function(t) {
  function e(r, n, i, a, s) {
    let o = {
      name: r,
      kind: n,
      location: { uri: a, range: i }
    };
    return s && (o.containerName = s), o;
  }
  t.create = e;
})(VH || (VH = {}));
var HH;
(function(t) {
  function e(r, n, i, a) {
    return a !== void 0 ? { name: r, kind: n, location: { uri: i, range: a } } : { name: r, kind: n, location: { uri: i } };
  }
  t.create = e;
})(HH || (HH = {}));
var WH;
(function(t) {
  function e(n, i, a, s, o, l) {
    let u = {
      name: n,
      detail: i,
      kind: a,
      range: s,
      selectionRange: o
    };
    return l !== void 0 && (u.children = l), u;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && Fe.string(i.name) && Fe.number(i.kind) && gr.is(i.range) && gr.is(i.selectionRange) && (i.detail === void 0 || Fe.string(i.detail)) && (i.deprecated === void 0 || Fe.boolean(i.deprecated)) && (i.children === void 0 || Array.isArray(i.children)) && (i.tags === void 0 || Array.isArray(i.tags));
  }
  t.is = r;
})(WH || (WH = {}));
var YH;
(function(t) {
  t.Empty = "", t.QuickFix = "quickfix", t.Refactor = "refactor", t.RefactorExtract = "refactor.extract", t.RefactorInline = "refactor.inline", t.RefactorRewrite = "refactor.rewrite", t.Source = "source", t.SourceOrganizeImports = "source.organizeImports", t.SourceFixAll = "source.fixAll";
})(YH || (YH = {}));
var px;
(function(t) {
  t.Invoked = 1, t.Automatic = 2;
})(px || (px = {}));
var XH;
(function(t) {
  function e(n, i, a) {
    let s = { diagnostics: n };
    return i != null && (s.only = i), a != null && (s.triggerKind = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.typedArray(i.diagnostics, fx.is) && (i.only === void 0 || Fe.typedArray(i.only, Fe.string)) && (i.triggerKind === void 0 || i.triggerKind === px.Invoked || i.triggerKind === px.Automatic);
  }
  t.is = r;
})(XH || (XH = {}));
var jH;
(function(t) {
  function e(n, i, a) {
    let s = { title: n }, o = !0;
    return typeof i == "string" ? (o = !1, s.kind = i) : y0.is(i) ? s.command = i : s.edit = i, o && a !== void 0 && (s.kind = a), s;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return i && Fe.string(i.title) && (i.diagnostics === void 0 || Fe.typedArray(i.diagnostics, fx.is)) && (i.kind === void 0 || Fe.string(i.kind)) && (i.edit !== void 0 || i.command !== void 0) && (i.command === void 0 || y0.is(i.command)) && (i.isPreferred === void 0 || Fe.boolean(i.isPreferred)) && (i.edit === void 0 || m8.is(i.edit));
  }
  t.is = r;
})(jH || (jH = {}));
var KH;
(function(t) {
  function e(n, i) {
    let a = { range: n };
    return Fe.defined(i) && (a.data = i), a;
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && gr.is(i.range) && (Fe.undefined(i.command) || y0.is(i.command));
  }
  t.is = r;
})(KH || (KH = {}));
var ZH;
(function(t) {
  function e(n, i) {
    return { tabSize: n, insertSpaces: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && Fe.uinteger(i.tabSize) && Fe.boolean(i.insertSpaces);
  }
  t.is = r;
})(ZH || (ZH = {}));
var QH;
(function(t) {
  function e(n, i, a) {
    return { range: n, target: i, data: a };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.defined(i) && gr.is(i.range) && (Fe.undefined(i.target) || Fe.string(i.target));
  }
  t.is = r;
})(QH || (QH = {}));
var JH;
(function(t) {
  function e(n, i) {
    return { range: n, parent: i };
  }
  t.create = e;
  function r(n) {
    let i = n;
    return Fe.objectLiteral(i) && gr.is(i.range) && (i.parent === void 0 || t.is(i.parent));
  }
  t.is = r;
})(JH || (JH = {}));
var eW;
(function(t) {
  t.namespace = "namespace", t.type = "type", t.class = "class", t.enum = "enum", t.interface = "interface", t.struct = "struct", t.typeParameter = "typeParameter", t.parameter = "parameter", t.variable = "variable", t.property = "property", t.enumMember = "enumMember", t.event = "event", t.function = "function", t.method = "method", t.macro = "macro", t.keyword = "keyword", t.modifier = "modifier", t.comment = "comment", t.string = "string", t.number = "number", t.regexp = "regexp", t.operator = "operator", t.decorator = "decorator";
})(eW || (eW = {}));
var tW;
(function(t) {
  t.declaration = "declaration", t.definition = "definition", t.readonly = "readonly", t.static = "static", t.deprecated = "deprecated", t.abstract = "abstract", t.async = "async", t.modification = "modification", t.documentation = "documentation", t.defaultLibrary = "defaultLibrary";
})(tW || (tW = {}));
var rW;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(n) && (n.resultId === void 0 || typeof n.resultId == "string") && Array.isArray(n.data) && (n.data.length === 0 || typeof n.data[0] == "number");
  }
  t.is = e;
})(rW || (rW = {}));
var nW;
(function(t) {
  function e(n, i) {
    return { range: n, text: i };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i != null && gr.is(i.range) && Fe.string(i.text);
  }
  t.is = r;
})(nW || (nW = {}));
var iW;
(function(t) {
  function e(n, i, a) {
    return { range: n, variableName: i, caseSensitiveLookup: a };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i != null && gr.is(i.range) && Fe.boolean(i.caseSensitiveLookup) && (Fe.string(i.variableName) || i.variableName === void 0);
  }
  t.is = r;
})(iW || (iW = {}));
var aW;
(function(t) {
  function e(n, i) {
    return { range: n, expression: i };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return i != null && gr.is(i.range) && (Fe.string(i.expression) || i.expression === void 0);
  }
  t.is = r;
})(aW || (aW = {}));
var sW;
(function(t) {
  function e(n, i) {
    return { frameId: n, stoppedLocation: i };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.defined(i) && gr.is(n.stoppedLocation);
  }
  t.is = r;
})(sW || (sW = {}));
var b8;
(function(t) {
  t.Type = 1, t.Parameter = 2;
  function e(r) {
    return r === 1 || r === 2;
  }
  t.is = e;
})(b8 || (b8 = {}));
var x8;
(function(t) {
  function e(n) {
    return { value: n };
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && (i.tooltip === void 0 || Fe.string(i.tooltip) || z1.is(i.tooltip)) && (i.location === void 0 || hx.is(i.location)) && (i.command === void 0 || y0.is(i.command));
  }
  t.is = r;
})(x8 || (x8 = {}));
var oW;
(function(t) {
  function e(n, i, a) {
    const s = { position: n, label: i };
    return a !== void 0 && (s.kind = a), s;
  }
  t.create = e;
  function r(n) {
    const i = n;
    return Fe.objectLiteral(i) && Cr.is(i.position) && (Fe.string(i.label) || Fe.typedArray(i.label, x8.is)) && (i.kind === void 0 || b8.is(i.kind)) && i.textEdits === void 0 || Fe.typedArray(i.textEdits, b0.is) && (i.tooltip === void 0 || Fe.string(i.tooltip) || z1.is(i.tooltip)) && (i.paddingLeft === void 0 || Fe.boolean(i.paddingLeft)) && (i.paddingRight === void 0 || Fe.boolean(i.paddingRight));
  }
  t.is = r;
})(oW || (oW = {}));
var lW;
(function(t) {
  function e(r) {
    return { kind: "snippet", value: r };
  }
  t.createSnippet = e;
})(lW || (lW = {}));
var cW;
(function(t) {
  function e(r, n, i, a) {
    return { insertText: r, filterText: n, range: i, command: a };
  }
  t.create = e;
})(cW || (cW = {}));
var uW;
(function(t) {
  function e(r) {
    return { items: r };
  }
  t.create = e;
})(uW || (uW = {}));
var hW;
(function(t) {
  t.Invoked = 0, t.Automatic = 1;
})(hW || (hW = {}));
var fW;
(function(t) {
  function e(r, n) {
    return { range: r, text: n };
  }
  t.create = e;
})(fW || (fW = {}));
var dW;
(function(t) {
  function e(r, n) {
    return { triggerKind: r, selectedCompletionInfo: n };
  }
  t.create = e;
})(dW || (dW = {}));
var pW;
(function(t) {
  function e(r) {
    const n = r;
    return Fe.objectLiteral(n) && l8.is(n.uri) && Fe.string(n.name);
  }
  t.is = e;
})(pW || (pW = {}));
var gW;
(function(t) {
  function e(a, s, o, l) {
    return new MKe(a, s, o, l);
  }
  t.create = e;
  function r(a) {
    let s = a;
    return !!(Fe.defined(s) && Fe.string(s.uri) && (Fe.undefined(s.languageId) || Fe.string(s.languageId)) && Fe.uinteger(s.lineCount) && Fe.func(s.getText) && Fe.func(s.positionAt) && Fe.func(s.offsetAt));
  }
  t.is = r;
  function n(a, s) {
    let o = a.getText(), l = i(s, (h, f) => {
      let d = h.range.start.line - f.range.start.line;
      return d === 0 ? h.range.start.character - f.range.start.character : d;
    }), u = o.length;
    for (let h = l.length - 1; h >= 0; h--) {
      let f = l[h], d = a.offsetAt(f.range.start), p = a.offsetAt(f.range.end);
      if (p <= u)
        o = o.substring(0, d) + f.newText + o.substring(p, o.length);
      else
        throw new Error("Overlapping edit");
      u = d;
    }
    return o;
  }
  t.applyEdits = n;
  function i(a, s) {
    if (a.length <= 1)
      return a;
    const o = a.length / 2 | 0, l = a.slice(0, o), u = a.slice(o);
    i(l, s), i(u, s);
    let h = 0, f = 0, d = 0;
    for (; h < l.length && f < u.length; )
      s(l[h], u[f]) <= 0 ? a[d++] = l[h++] : a[d++] = u[f++];
    for (; h < l.length; )
      a[d++] = l[h++];
    for (; f < u.length; )
      a[d++] = u[f++];
    return a;
  }
})(gW || (gW = {}));
let MKe = class {
  constructor(e, r, n, i) {
    this._uri = e, this._languageId = r, this._version = n, this._content = i, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      let r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    this._content = e.text, this._version = r, this._lineOffsets = void 0;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      let e = [], r = this._content, n = !0;
      for (let i = 0; i < r.length; i++) {
        n && (e.push(i), n = !1);
        let a = r.charAt(i);
        n = a === "\r" || a === `
`, a === "\r" && i + 1 < r.length && r.charAt(i + 1) === `
` && i++;
      }
      n && r.length > 0 && e.push(r.length), this._lineOffsets = e;
    }
    return this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    let r = this.getLineOffsets(), n = 0, i = r.length;
    if (i === 0)
      return Cr.create(0, e);
    for (; n < i; ) {
      let s = Math.floor((n + i) / 2);
      r[s] > e ? i = s : n = s + 1;
    }
    let a = n - 1;
    return Cr.create(a, e - r[a]);
  }
  offsetAt(e) {
    let r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    let n = r[e.line], i = e.line + 1 < r.length ? r[e.line + 1] : this._content.length;
    return Math.max(Math.min(n + e.character, i), n);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
};
var Fe;
(function(t) {
  const e = Object.prototype.toString;
  function r(p) {
    return typeof p < "u";
  }
  t.defined = r;
  function n(p) {
    return typeof p > "u";
  }
  t.undefined = n;
  function i(p) {
    return p === !0 || p === !1;
  }
  t.boolean = i;
  function a(p) {
    return e.call(p) === "[object String]";
  }
  t.string = a;
  function s(p) {
    return e.call(p) === "[object Number]";
  }
  t.number = s;
  function o(p, g, m) {
    return e.call(p) === "[object Number]" && g <= p && p <= m;
  }
  t.numberRange = o;
  function l(p) {
    return e.call(p) === "[object Number]" && -2147483648 <= p && p <= 2147483647;
  }
  t.integer = l;
  function u(p) {
    return e.call(p) === "[object Number]" && 0 <= p && p <= 2147483647;
  }
  t.uinteger = u;
  function h(p) {
    return e.call(p) === "[object Function]";
  }
  t.func = h;
  function f(p) {
    return p !== null && typeof p == "object";
  }
  t.objectLiteral = f;
  function d(p, g) {
    return Array.isArray(p) && p.every(g);
  }
  t.typedArray = d;
})(Fe || (Fe = {}));
class NKe {
  constructor() {
    this.nodeStack = [];
  }
  get current() {
    var e;
    return (e = this.nodeStack[this.nodeStack.length - 1]) !== null && e !== void 0 ? e : this.rootNode;
  }
  buildRootNode(e) {
    return this.rootNode = new joe(e), this.rootNode.root = this.rootNode, this.nodeStack = [this.rootNode], this.rootNode;
  }
  buildCompositeNode(e) {
    const r = new PI();
    return r.grammarSource = e, r.root = this.rootNode, this.current.content.push(r), this.nodeStack.push(r), r;
  }
  buildLeafNode(e, r) {
    const n = new w8(e.startOffset, e.image.length, BA(e), e.tokenType, !r);
    return n.grammarSource = r, n.root = this.rootNode, this.current.content.push(n), n;
  }
  removeNode(e) {
    const r = e.container;
    if (r) {
      const n = r.content.indexOf(e);
      n >= 0 && r.content.splice(n, 1);
    }
  }
  addHiddenNodes(e) {
    const r = [];
    for (const a of e) {
      const s = new w8(a.startOffset, a.image.length, BA(a), a.tokenType, !0);
      s.root = this.rootNode, r.push(s);
    }
    let n = this.current, i = !1;
    if (n.content.length > 0) {
      n.content.push(...r);
      return;
    }
    for (; n.container; ) {
      const a = n.container.content.indexOf(n);
      if (a > 0) {
        n.container.content.splice(a, 0, ...r), i = !0;
        break;
      }
      n = n.container;
    }
    i || this.rootNode.content.unshift(...r);
  }
  construct(e) {
    const r = this.current;
    typeof e.$type == "string" && (this.current.astNode = e), e.$cstNode = r;
    const n = this.nodeStack.pop();
    n?.content.length === 0 && this.removeNode(n);
  }
}
class Xoe {
  /** @deprecated use `container` instead. */
  get parent() {
    return this.container;
  }
  /** @deprecated use `grammarSource` instead. */
  get feature() {
    return this.grammarSource;
  }
  get hidden() {
    return !1;
  }
  get astNode() {
    var e, r;
    const n = typeof ((e = this._astNode) === null || e === void 0 ? void 0 : e.$type) == "string" ? this._astNode : (r = this.container) === null || r === void 0 ? void 0 : r.astNode;
    if (!n)
      throw new Error("This node has no associated AST element");
    return n;
  }
  set astNode(e) {
    this._astNode = e;
  }
  /** @deprecated use `astNode` instead. */
  get element() {
    return this.astNode;
  }
  get text() {
    return this.root.fullText.substring(this.offset, this.end);
  }
}
class w8 extends Xoe {
  get offset() {
    return this._offset;
  }
  get length() {
    return this._length;
  }
  get end() {
    return this._offset + this._length;
  }
  get hidden() {
    return this._hidden;
  }
  get tokenType() {
    return this._tokenType;
  }
  get range() {
    return this._range;
  }
  constructor(e, r, n, i, a = !1) {
    super(), this._hidden = a, this._offset = e, this._tokenType = i, this._length = r, this._range = n;
  }
}
class PI extends Xoe {
  constructor() {
    super(...arguments), this.content = new $I(this);
  }
  /** @deprecated use `content` instead. */
  get children() {
    return this.content;
  }
  get offset() {
    var e, r;
    return (r = (e = this.firstNonHiddenNode) === null || e === void 0 ? void 0 : e.offset) !== null && r !== void 0 ? r : 0;
  }
  get length() {
    return this.end - this.offset;
  }
  get end() {
    var e, r;
    return (r = (e = this.lastNonHiddenNode) === null || e === void 0 ? void 0 : e.end) !== null && r !== void 0 ? r : 0;
  }
  get range() {
    const e = this.firstNonHiddenNode, r = this.lastNonHiddenNode;
    if (e && r) {
      if (this._rangeCache === void 0) {
        const { range: n } = e, { range: i } = r;
        this._rangeCache = { start: n.start, end: i.end.line < n.start.line ? n.start : i.end };
      }
      return this._rangeCache;
    } else
      return { start: Cr.create(0, 0), end: Cr.create(0, 0) };
  }
  get firstNonHiddenNode() {
    for (const e of this.content)
      if (!e.hidden)
        return e;
    return this.content[0];
  }
  get lastNonHiddenNode() {
    for (let e = this.content.length - 1; e >= 0; e--) {
      const r = this.content[e];
      if (!r.hidden)
        return r;
    }
    return this.content[this.content.length - 1];
  }
}
class $I extends Array {
  constructor(e) {
    super(), this.parent = e, Object.setPrototypeOf(this, $I.prototype);
  }
  push(...e) {
    return this.addParents(e), super.push(...e);
  }
  unshift(...e) {
    return this.addParents(e), super.unshift(...e);
  }
  splice(e, r, ...n) {
    return this.addParents(n), super.splice(e, r, ...n);
  }
  addParents(e) {
    for (const r of e)
      r.container = this.parent;
  }
}
class joe extends PI {
  get text() {
    return this._text.substring(this.offset, this.end);
  }
  get fullText() {
    return this._text;
  }
  constructor(e) {
    super(), this._text = "", this._text = e ?? "";
  }
}
const T8 = Symbol("Datatype");
function S7(t) {
  return t.$type === T8;
}
const mW = "\u200B", Koe = (t) => t.endsWith(mW) ? t : t + mW;
class Zoe {
  constructor(e) {
    this._unorderedGroups = /* @__PURE__ */ new Map(), this.allRules = /* @__PURE__ */ new Map(), this.lexer = e.parser.Lexer;
    const r = this.lexer.definition, n = e.LanguageMetaData.mode === "production";
    this.wrapper = new BKe(r, Object.assign(Object.assign({}, e.parser.ParserConfig), { skipValidations: n, errorMessageProvider: e.parser.ParserErrorMessageProvider }));
  }
  alternatives(e, r) {
    this.wrapper.wrapOr(e, r);
  }
  optional(e, r) {
    this.wrapper.wrapOption(e, r);
  }
  many(e, r) {
    this.wrapper.wrapMany(e, r);
  }
  atLeastOne(e, r) {
    this.wrapper.wrapAtLeastOne(e, r);
  }
  getRule(e) {
    return this.allRules.get(e);
  }
  isRecording() {
    return this.wrapper.IS_RECORDING;
  }
  get unorderedGroups() {
    return this._unorderedGroups;
  }
  getRuleStack() {
    return this.wrapper.RULE_STACK;
  }
  finalize() {
    this.wrapper.wrapSelfAnalysis();
  }
}
class DKe extends Zoe {
  get current() {
    return this.stack[this.stack.length - 1];
  }
  constructor(e) {
    super(e), this.nodeBuilder = new NKe(), this.stack = [], this.assignmentMap = /* @__PURE__ */ new Map(), this.linker = e.references.Linker, this.converter = e.parser.ValueConverter, this.astReflection = e.shared.AstReflection;
  }
  rule(e, r) {
    const n = this.computeRuleType(e), i = this.wrapper.DEFINE_RULE(Koe(e.name), this.startImplementation(n, r).bind(this));
    return this.allRules.set(e.name, i), e.entry && (this.mainRule = i), i;
  }
  computeRuleType(e) {
    if (!e.fragment) {
      if (ase(e))
        return T8;
      {
        const r = ZR(e);
        return r ?? e.name;
      }
    }
  }
  parse(e, r = {}) {
    this.nodeBuilder.buildRootNode(e);
    const n = this.lexerResult = this.lexer.tokenize(e);
    this.wrapper.input = n.tokens;
    const i = r.rule ? this.allRules.get(r.rule) : this.mainRule;
    if (!i)
      throw new Error(r.rule ? `No rule found with name '${r.rule}'` : "No main rule available.");
    const a = i.call(this.wrapper, {});
    return this.nodeBuilder.addHiddenNodes(n.hidden), this.unorderedGroups.clear(), this.lexerResult = void 0, {
      value: a,
      lexerErrors: n.errors,
      lexerReport: n.report,
      parserErrors: this.wrapper.errors
    };
  }
  startImplementation(e, r) {
    return (n) => {
      const i = !this.isRecording() && e !== void 0;
      if (i) {
        const s = { $type: e };
        this.stack.push(s), e === T8 && (s.value = "");
      }
      let a;
      try {
        a = r(n);
      } catch {
        a = void 0;
      }
      return a === void 0 && i && (a = this.construct()), a;
    };
  }
  extractHiddenTokens(e) {
    const r = this.lexerResult.hidden;
    if (!r.length)
      return [];
    const n = e.startOffset;
    for (let i = 0; i < r.length; i++)
      if (r[i].startOffset > n)
        return r.splice(0, i);
    return r.splice(0, r.length);
  }
  consume(e, r, n) {
    const i = this.wrapper.wrapConsume(e, r);
    if (!this.isRecording() && this.isValidToken(i)) {
      const a = this.extractHiddenTokens(i);
      this.nodeBuilder.addHiddenNodes(a);
      const s = this.nodeBuilder.buildLeafNode(i, n), { assignment: o, isCrossRef: l } = this.getAssignment(n), u = this.current;
      if (o) {
        const h = oh(n) ? i.image : this.converter.convert(i.image, s);
        this.assign(o.operator, o.feature, h, s, l);
      } else if (S7(u)) {
        let h = i.image;
        oh(n) || (h = this.converter.convert(h, s).toString()), u.value += h;
      }
    }
  }
  /**
   * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
   *
   * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
   * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
   */
  isValidToken(e) {
    return !e.isInsertedInRecovery && !isNaN(e.startOffset) && typeof e.endOffset == "number" && !isNaN(e.endOffset);
  }
  subrule(e, r, n, i, a) {
    let s;
    !this.isRecording() && !n && (s = this.nodeBuilder.buildCompositeNode(i));
    const o = this.wrapper.wrapSubrule(e, r, a);
    !this.isRecording() && s && s.length > 0 && this.performSubruleAssignment(o, i, s);
  }
  performSubruleAssignment(e, r, n) {
    const { assignment: i, isCrossRef: a } = this.getAssignment(r);
    if (i)
      this.assign(i.operator, i.feature, e, n, a);
    else if (!i) {
      const s = this.current;
      if (S7(s))
        s.value += e.toString();
      else if (typeof e == "object" && e) {
        const l = this.assignWithoutOverride(e, s);
        this.stack.pop(), this.stack.push(l);
      }
    }
  }
  action(e, r) {
    if (!this.isRecording()) {
      let n = this.current;
      if (r.feature && r.operator) {
        n = this.construct(), this.nodeBuilder.removeNode(n.$cstNode), this.nodeBuilder.buildCompositeNode(r).content.push(n.$cstNode);
        const a = { $type: e };
        this.stack.push(a), this.assign(r.operator, r.feature, n, n.$cstNode, !1);
      } else
        n.$type = e;
    }
  }
  construct() {
    if (this.isRecording())
      return;
    const e = this.current;
    return S$e(e), this.nodeBuilder.construct(e), this.stack.pop(), S7(e) ? this.converter.convert(e.value, e.$cstNode) : (k$e(this.astReflection, e), e);
  }
  getAssignment(e) {
    if (!this.assignmentMap.has(e)) {
      const r = d3(e, sh);
      this.assignmentMap.set(e, {
        assignment: r,
        isCrossRef: r ? YR(r.terminal) : !1
      });
    }
    return this.assignmentMap.get(e);
  }
  assign(e, r, n, i, a) {
    const s = this.current;
    let o;
    switch (a && typeof n == "string" ? o = this.linker.buildReference(s, r, i, n) : o = n, e) {
      case "=": {
        s[r] = o;
        break;
      }
      case "?=": {
        s[r] = !0;
        break;
      }
      case "+=":
        Array.isArray(s[r]) || (s[r] = []), s[r].push(o);
    }
  }
  assignWithoutOverride(e, r) {
    for (const [i, a] of Object.entries(r)) {
      const s = e[i];
      s === void 0 ? e[i] = a : Array.isArray(s) && Array.isArray(a) && (a.push(...s), e[i] = a);
    }
    const n = e.$cstNode;
    return n && (n.astNode = void 0, e.$cstNode = void 0), e;
  }
  get definitionErrors() {
    return this.wrapper.definitionErrors;
  }
}
class OKe {
  buildMismatchTokenMessage(e) {
    return _f.buildMismatchTokenMessage(e);
  }
  buildNotAllInputParsedMessage(e) {
    return _f.buildNotAllInputParsedMessage(e);
  }
  buildNoViableAltMessage(e) {
    return _f.buildNoViableAltMessage(e);
  }
  buildEarlyExitMessage(e) {
    return _f.buildEarlyExitMessage(e);
  }
}
class Qoe extends OKe {
  buildMismatchTokenMessage({ expected: e, actual: r }) {
    return `Expecting ${e.LABEL ? "`" + e.LABEL + "`" : e.name.endsWith(":KW") ? `keyword '${e.name.substring(0, e.name.length - 3)}'` : `token of type '${e.name}'`} but found \`${r.image}\`.`;
  }
  buildNotAllInputParsedMessage({ firstRedundant: e }) {
    return `Expecting end of file but found \`${e.image}\`.`;
  }
}
class PKe extends Zoe {
  constructor() {
    super(...arguments), this.tokens = [], this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
  }
  action() {
  }
  construct() {
  }
  parse(e) {
    this.resetState();
    const r = this.lexer.tokenize(e, { mode: "partial" });
    return this.tokens = r.tokens, this.wrapper.input = [...this.tokens], this.mainRule.call(this.wrapper, {}), this.unorderedGroups.clear(), {
      tokens: this.tokens,
      elementStack: [...this.lastElementStack],
      tokenIndex: this.nextTokenIndex
    };
  }
  rule(e, r) {
    const n = this.wrapper.DEFINE_RULE(Koe(e.name), this.startImplementation(r).bind(this));
    return this.allRules.set(e.name, n), e.entry && (this.mainRule = n), n;
  }
  resetState() {
    this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
  }
  startImplementation(e) {
    return (r) => {
      const n = this.keepStackSize();
      try {
        e(r);
      } finally {
        this.resetStackSize(n);
      }
    };
  }
  removeUnexpectedElements() {
    this.elementStack.splice(this.stackSize);
  }
  keepStackSize() {
    const e = this.elementStack.length;
    return this.stackSize = e, e;
  }
  resetStackSize(e) {
    this.removeUnexpectedElements(), this.stackSize = e;
  }
  consume(e, r, n) {
    this.wrapper.wrapConsume(e, r), this.isRecording() || (this.lastElementStack = [...this.elementStack, n], this.nextTokenIndex = this.currIdx + 1);
  }
  subrule(e, r, n, i, a) {
    this.before(i), this.wrapper.wrapSubrule(e, r, a), this.after(i);
  }
  before(e) {
    this.isRecording() || this.elementStack.push(e);
  }
  after(e) {
    if (!this.isRecording()) {
      const r = this.elementStack.lastIndexOf(e);
      r >= 0 && this.elementStack.splice(r);
    }
  }
  get currIdx() {
    return this.wrapper.currIdx;
  }
}
const $Ke = {
  recoveryEnabled: !0,
  nodeLocationTracking: "full",
  skipValidations: !0,
  errorMessageProvider: new Qoe()
};
class BKe extends Hje {
  constructor(e, r) {
    const n = r && "maxLookahead" in r;
    super(e, Object.assign(Object.assign(Object.assign({}, $Ke), { lookaheadStrategy: n ? new RI({ maxLookahead: r.maxLookahead }) : new fKe({
      // If validations are skipped, don't log the lookahead warnings
      logging: r.skipValidations ? () => {
      } : void 0
    }) }), r));
  }
  get IS_RECORDING() {
    return this.RECORDING_PHASE;
  }
  DEFINE_RULE(e, r) {
    return this.RULE(e, r);
  }
  wrapSelfAnalysis() {
    this.performSelfAnalysis();
  }
  wrapConsume(e, r) {
    return this.consume(e, r);
  }
  wrapSubrule(e, r, n) {
    return this.subrule(e, r, {
      ARGS: [n]
    });
  }
  wrapOr(e, r) {
    this.or(e, r);
  }
  wrapOption(e, r) {
    this.option(e, r);
  }
  wrapMany(e, r) {
    this.many(e, r);
  }
  wrapAtLeastOne(e, r) {
    this.atLeastOne(e, r);
  }
}
function Joe(t, e, r) {
  return FKe({
    parser: e,
    tokens: r,
    ruleNames: /* @__PURE__ */ new Map()
  }, t), e;
}
function FKe(t, e) {
  const r = ese(e, !1), n = hi(e.rules).filter(os).filter((i) => r.has(i));
  for (const i of n) {
    const a = Object.assign(Object.assign({}, t), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
    t.parser.rule(i, fh(a, i.definition));
  }
}
function fh(t, e, r = !1) {
  let n;
  if (oh(e))
    n = WKe(t, e);
  else if (f3(e))
    n = zKe(t, e);
  else if (sh(e))
    n = fh(t, e.terminal);
  else if (YR(e))
    n = ele(t, e);
  else if (lh(e))
    n = qKe(t, e);
  else if (Xae(e))
    n = UKe(t, e);
  else if (jae(e))
    n = VKe(t, e);
  else if (XR(e))
    n = HKe(t, e);
  else if (m$e(e)) {
    const i = t.consume++;
    n = () => t.parser.consume(i, Rc, e);
  } else
    throw new Vae(e.$cstNode, `Unexpected element type: ${e.$type}`);
  return tle(t, r ? void 0 : gx(e), n, e.cardinality);
}
function zKe(t, e) {
  const r = QR(e);
  return () => t.parser.action(r, e);
}
function qKe(t, e) {
  const r = e.rule.ref;
  if (os(r)) {
    const n = t.subrule++, i = r.fragment, a = e.arguments.length > 0 ? GKe(r, e.arguments) : () => ({});
    return (s) => t.parser.subrule(n, rle(t, r), i, e, a(s));
  } else if ($h(r)) {
    const n = t.consume++, i = E8(t, r.name);
    return () => t.parser.consume(n, i, e);
  } else if (r)
    Im();
  else
    throw new Vae(e.$cstNode, `Undefined rule: ${e.rule.$refText}`);
}
function GKe(t, e) {
  const r = e.map((n) => Ko(n.value));
  return (n) => {
    const i = {};
    for (let a = 0; a < r.length; a++) {
      const s = t.parameters[a], o = r[a];
      i[s.name] = o(n);
    }
    return i;
  };
}
function Ko(t) {
  if (u$e(t)) {
    const e = Ko(t.left), r = Ko(t.right);
    return (n) => e(n) || r(n);
  } else if (c$e(t)) {
    const e = Ko(t.left), r = Ko(t.right);
    return (n) => e(n) && r(n);
  } else if (h$e(t)) {
    const e = Ko(t.value);
    return (r) => !e(r);
  } else if (f$e(t)) {
    const e = t.parameter.ref.name;
    return (r) => r !== void 0 && r[e] === !0;
  } else if (l$e(t)) {
    const e = !!t.true;
    return () => e;
  }
  Im();
}
function UKe(t, e) {
  if (e.elements.length === 1)
    return fh(t, e.elements[0]);
  {
    const r = [];
    for (const i of e.elements) {
      const a = {
        // Since we handle the guard condition in the alternative already
        // We can ignore the group guard condition inside
        ALT: fh(t, i, !0)
      }, s = gx(i);
      s && (a.GATE = Ko(s)), r.push(a);
    }
    const n = t.or++;
    return (i) => t.parser.alternatives(n, r.map((a) => {
      const s = {
        ALT: () => a.ALT(i)
      }, o = a.GATE;
      return o && (s.GATE = () => o(i)), s;
    }));
  }
}
function VKe(t, e) {
  if (e.elements.length === 1)
    return fh(t, e.elements[0]);
  const r = [];
  for (const o of e.elements) {
    const l = {
      // Since we handle the guard condition in the alternative already
      // We can ignore the group guard condition inside
      ALT: fh(t, o, !0)
    }, u = gx(o);
    u && (l.GATE = Ko(u)), r.push(l);
  }
  const n = t.or++, i = (o, l) => {
    const u = l.getRuleStack().join("-");
    return `uGroup_${o}_${u}`;
  }, a = (o) => t.parser.alternatives(n, r.map((l, u) => {
    const h = { ALT: () => !0 }, f = t.parser;
    h.ALT = () => {
      if (l.ALT(o), !f.isRecording()) {
        const p = i(n, f);
        f.unorderedGroups.get(p) || f.unorderedGroups.set(p, []);
        const g = f.unorderedGroups.get(p);
        typeof g?.[u] > "u" && (g[u] = !0);
      }
    };
    const d = l.GATE;
    return d ? h.GATE = () => d(o) : h.GATE = () => {
      const p = f.unorderedGroups.get(i(n, f));
      return !p?.[u];
    }, h;
  })), s = tle(t, gx(e), a, "*");
  return (o) => {
    s(o), t.parser.isRecording() || t.parser.unorderedGroups.delete(i(n, t.parser));
  };
}
function HKe(t, e) {
  const r = e.elements.map((n) => fh(t, n));
  return (n) => r.forEach((i) => i(n));
}
function gx(t) {
  if (XR(t))
    return t.guardCondition;
}
function ele(t, e, r = e.terminal) {
  if (r)
    if (lh(r) && os(r.rule.ref)) {
      const n = r.rule.ref, i = t.subrule++;
      return (a) => t.parser.subrule(i, rle(t, n), !1, e, a);
    } else if (lh(r) && $h(r.rule.ref)) {
      const n = t.consume++, i = E8(t, r.rule.ref.name);
      return () => t.parser.consume(n, i, e);
    } else if (oh(r)) {
      const n = t.consume++, i = E8(t, r.value);
      return () => t.parser.consume(n, i, e);
    } else
      throw new Error("Could not build cross reference parser");
  else {
    if (!e.type.ref)
      throw new Error("Could not resolve reference to type: " + e.type.$refText);
    const n = nse(e.type.ref), i = n?.terminal;
    if (!i)
      throw new Error("Could not find name assignment for type: " + QR(e.type.ref));
    return ele(t, e, i);
  }
}
function WKe(t, e) {
  const r = t.consume++, n = t.tokens[e.value];
  if (!n)
    throw new Error("Could not find token for keyword: " + e.value);
  return () => t.parser.consume(r, n, e);
}
function tle(t, e, r, n) {
  const i = e && Ko(e);
  if (!n)
    if (i) {
      const a = t.or++;
      return (s) => t.parser.alternatives(a, [
        {
          ALT: () => r(s),
          GATE: () => i(s)
        },
        {
          ALT: hH(),
          GATE: () => !i(s)
        }
      ]);
    } else
      return r;
  if (n === "*") {
    const a = t.many++;
    return (s) => t.parser.many(a, {
      DEF: () => r(s),
      GATE: i ? () => i(s) : void 0
    });
  } else if (n === "+") {
    const a = t.many++;
    if (i) {
      const s = t.or++;
      return (o) => t.parser.alternatives(s, [
        {
          ALT: () => t.parser.atLeastOne(a, {
            DEF: () => r(o)
          }),
          GATE: () => i(o)
        },
        {
          ALT: hH(),
          GATE: () => !i(o)
        }
      ]);
    } else
      return (s) => t.parser.atLeastOne(a, {
        DEF: () => r(s)
      });
  } else if (n === "?") {
    const a = t.optional++;
    return (s) => t.parser.optional(a, {
      DEF: () => r(s),
      GATE: i ? () => i(s) : void 0
    });
  } else
    Im();
}
function rle(t, e) {
  const r = YKe(t, e), n = t.parser.getRule(r);
  if (!n)
    throw new Error(`Rule "${r}" not found."`);
  return n;
}
function YKe(t, e) {
  if (os(e))
    return e.name;
  if (t.ruleNames.has(e))
    return t.ruleNames.get(e);
  {
    let r = e, n = r.$container, i = e.$type;
    for (; !os(n); )
      (XR(n) || Xae(n) || jae(n)) && (i = n.elements.indexOf(r).toString() + ":" + i), r = n, n = n.$container;
    return i = n.name + ":" + i, t.ruleNames.set(e, i), i;
  }
}
function E8(t, e) {
  const r = t.tokens[e];
  if (!r)
    throw new Error(`Token "${e}" not found."`);
  return r;
}
function XKe(t) {
  const e = t.Grammar, r = t.parser.Lexer, n = new PKe(t);
  return Joe(e, n, r.definition), n.finalize(), n;
}
function jKe(t) {
  const e = KKe(t);
  return e.finalize(), e;
}
function KKe(t) {
  const e = t.Grammar, r = t.parser.Lexer, n = new DKe(t);
  return Joe(e, n, r.definition);
}
class nle {
  constructor() {
    this.diagnostics = [];
  }
  buildTokens(e, r) {
    const n = hi(ese(e, !1)), i = this.buildTerminalTokens(n), a = this.buildKeywordTokens(n, i, r);
    return i.forEach((s) => {
      const o = s.PATTERN;
      typeof o == "object" && o && "test" in o && zA(o) ? a.unshift(s) : a.push(s);
    }), a;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  flushLexingReport(e) {
    return { diagnostics: this.popDiagnostics() };
  }
  popDiagnostics() {
    const e = [...this.diagnostics];
    return this.diagnostics = [], e;
  }
  buildTerminalTokens(e) {
    return e.filter($h).filter((r) => !r.fragment).map((r) => this.buildTerminalToken(r)).toArray();
  }
  buildTerminalToken(e) {
    const r = JR(e), n = this.requiresCustomPattern(r) ? this.regexPatternFunction(r) : r, i = {
      name: e.name,
      PATTERN: n
    };
    return typeof n == "function" && (i.LINE_BREAKS = !0), e.hidden && (i.GROUP = zA(r) ? ha.SKIPPED : "hidden"), i;
  }
  requiresCustomPattern(e) {
    return e.flags.includes("u") || e.flags.includes("s") ? !0 : !!(e.source.includes("?<=") || e.source.includes("?<!"));
  }
  regexPatternFunction(e) {
    const r = new RegExp(e, e.flags + "y");
    return (n, i) => (r.lastIndex = i, r.exec(n));
  }
  buildKeywordTokens(e, r, n) {
    return e.filter(os).flatMap((i) => Mm(i).filter(oh)).distinct((i) => i.value).toArray().sort((i, a) => a.value.length - i.value.length).map((i) => this.buildKeywordToken(i, r, !!n?.caseInsensitive));
  }
  buildKeywordToken(e, r, n) {
    const i = this.buildKeywordPattern(e, n), a = {
      name: e.value,
      PATTERN: i,
      LONGER_ALT: this.findLongerAlt(e, r)
    };
    return typeof i == "function" && (a.LINE_BREAKS = !0), a;
  }
  buildKeywordPattern(e, r) {
    return r ? new RegExp(D$e(e.value)) : e.value;
  }
  findLongerAlt(e, r) {
    return r.reduce((n, i) => {
      const a = i?.PATTERN;
      return a?.source && O$e("^" + a.source + "$", e.value) && n.push(i), n;
    }, []);
  }
}
class ile {
  convert(e, r) {
    let n = r.grammarSource;
    if (YR(n) && (n = F$e(n)), lh(n)) {
      const i = n.rule.ref;
      if (!i)
        throw new Error("This cst node was not parsed by a rule.");
      return this.runConverter(i, e, r);
    }
    return e;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  runConverter(e, r, n) {
    var i;
    switch (e.name.toUpperCase()) {
      case "INT":
        return Vo.convertInt(r);
      case "STRING":
        return Vo.convertString(r);
      case "ID":
        return Vo.convertID(r);
    }
    switch ((i = W$e(e)) === null || i === void 0 ? void 0 : i.toLowerCase()) {
      case "number":
        return Vo.convertNumber(r);
      case "boolean":
        return Vo.convertBoolean(r);
      case "bigint":
        return Vo.convertBigint(r);
      case "date":
        return Vo.convertDate(r);
      default:
        return r;
    }
  }
}
var Vo;
(function(t) {
  function e(u) {
    let h = "";
    for (let f = 1; f < u.length - 1; f++) {
      const d = u.charAt(f);
      if (d === "\\") {
        const p = u.charAt(++f);
        h += r(p);
      } else
        h += d;
    }
    return h;
  }
  t.convertString = e;
  function r(u) {
    switch (u) {
      case "b":
        return "\b";
      case "f":
        return "\f";
      case "n":
        return `
`;
      case "r":
        return "\r";
      case "t":
        return "	";
      case "v":
        return "\v";
      case "0":
        return "\0";
      default:
        return u;
    }
  }
  function n(u) {
    return u.charAt(0) === "^" ? u.substring(1) : u;
  }
  t.convertID = n;
  function i(u) {
    return parseInt(u);
  }
  t.convertInt = i;
  function a(u) {
    return BigInt(u);
  }
  t.convertBigint = a;
  function s(u) {
    return new Date(u);
  }
  t.convertDate = s;
  function o(u) {
    return Number(u);
  }
  t.convertNumber = o;
  function l(u) {
    return u.toLowerCase() === "true";
  }
  t.convertBoolean = l;
})(Vo || (Vo = {}));
var pu = {}, ty = {}, vW;
function ale() {
  if (vW) return ty;
  vW = 1, Object.defineProperty(ty, "__esModule", { value: !0 });
  let t;
  function e() {
    if (t === void 0)
      throw new Error("No runtime abstraction layer installed");
    return t;
  }
  return (function(r) {
    function n(i) {
      if (i === void 0)
        throw new Error("No runtime abstraction layer provided");
      t = i;
    }
    r.install = n;
  })(e || (e = {})), ty.default = e, ty;
}
var ai = {}, yW;
function ZKe() {
  if (yW) return ai;
  yW = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.stringArray = ai.array = ai.func = ai.error = ai.number = ai.string = ai.boolean = void 0;
  function t(o) {
    return o === !0 || o === !1;
  }
  ai.boolean = t;
  function e(o) {
    return typeof o == "string" || o instanceof String;
  }
  ai.string = e;
  function r(o) {
    return typeof o == "number" || o instanceof Number;
  }
  ai.number = r;
  function n(o) {
    return o instanceof Error;
  }
  ai.error = n;
  function i(o) {
    return typeof o == "function";
  }
  ai.func = i;
  function a(o) {
    return Array.isArray(o);
  }
  ai.array = a;
  function s(o) {
    return a(o) && o.every((l) => e(l));
  }
  return ai.stringArray = s, ai;
}
var gu = {}, bW;
function sle() {
  if (bW) return gu;
  bW = 1, Object.defineProperty(gu, "__esModule", { value: !0 }), gu.Emitter = gu.Event = void 0;
  const t = ale();
  var e;
  (function(i) {
    const a = { dispose() {
    } };
    i.None = function() {
      return a;
    };
  })(e || (gu.Event = e = {}));
  class r {
    add(a, s = null, o) {
      this._callbacks || (this._callbacks = [], this._contexts = []), this._callbacks.push(a), this._contexts.push(s), Array.isArray(o) && o.push({ dispose: () => this.remove(a, s) });
    }
    remove(a, s = null) {
      if (!this._callbacks)
        return;
      let o = !1;
      for (let l = 0, u = this._callbacks.length; l < u; l++)
        if (this._callbacks[l] === a)
          if (this._contexts[l] === s) {
            this._callbacks.splice(l, 1), this._contexts.splice(l, 1);
            return;
          } else
            o = !0;
      if (o)
        throw new Error("When adding a listener with a context, you should remove it with the same context");
    }
    invoke(...a) {
      if (!this._callbacks)
        return [];
      const s = [], o = this._callbacks.slice(0), l = this._contexts.slice(0);
      for (let u = 0, h = o.length; u < h; u++)
        try {
          s.push(o[u].apply(l[u], a));
        } catch (f) {
          (0, t.default)().console.error(f);
        }
      return s;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0, this._contexts = void 0;
    }
  }
  class n {
    constructor(a) {
      this._options = a;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
      return this._event || (this._event = (a, s, o) => {
        this._callbacks || (this._callbacks = new r()), this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty() && this._options.onFirstListenerAdd(this), this._callbacks.add(a, s);
        const l = {
          dispose: () => {
            this._callbacks && (this._callbacks.remove(a, s), l.dispose = n._noop, this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty() && this._options.onLastListenerRemove(this));
          }
        };
        return Array.isArray(o) && o.push(l), l;
      }), this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(a) {
      this._callbacks && this._callbacks.invoke.call(this._callbacks, a);
    }
    dispose() {
      this._callbacks && (this._callbacks.dispose(), this._callbacks = void 0);
    }
  }
  return gu.Emitter = n, n._noop = function() {
  }, gu;
}
var xW;
function QKe() {
  if (xW) return pu;
  xW = 1, Object.defineProperty(pu, "__esModule", { value: !0 }), pu.CancellationTokenSource = pu.CancellationToken = void 0;
  const t = ale(), e = ZKe(), r = sle();
  var n;
  (function(o) {
    o.None = Object.freeze({
      isCancellationRequested: !1,
      onCancellationRequested: r.Event.None
    }), o.Cancelled = Object.freeze({
      isCancellationRequested: !0,
      onCancellationRequested: r.Event.None
    });
    function l(u) {
      const h = u;
      return h && (h === o.None || h === o.Cancelled || e.boolean(h.isCancellationRequested) && !!h.onCancellationRequested);
    }
    o.is = l;
  })(n || (pu.CancellationToken = n = {}));
  const i = Object.freeze(function(o, l) {
    const u = (0, t.default)().timer.setTimeout(o.bind(l), 0);
    return { dispose() {
      u.dispose();
    } };
  });
  class a {
    constructor() {
      this._isCancelled = !1;
    }
    cancel() {
      this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      return this._isCancelled ? i : (this._emitter || (this._emitter = new r.Emitter()), this._emitter.event);
    }
    dispose() {
      this._emitter && (this._emitter.dispose(), this._emitter = void 0);
    }
  }
  class s {
    get token() {
      return this._token || (this._token = new a()), this._token;
    }
    cancel() {
      this._token ? this._token.cancel() : this._token = n.Cancelled;
    }
    dispose() {
      this._token ? this._token instanceof a && this._token.dispose() : this._token = n.None;
    }
  }
  return pu.CancellationTokenSource = s, pu;
}
var on = QKe();
function JKe() {
  return new Promise((t) => {
    typeof setImmediate > "u" ? setTimeout(t, 0) : setImmediate(t);
  });
}
let i2 = 0, eZe = 10;
function tZe() {
  return i2 = performance.now(), new on.CancellationTokenSource();
}
const mx = Symbol("OperationCancelled");
function H3(t) {
  return t === mx;
}
async function _a(t) {
  if (t === on.CancellationToken.None)
    return;
  const e = performance.now();
  if (e - i2 >= eZe && (i2 = e, await JKe(), i2 = performance.now()), t.isCancellationRequested)
    throw mx;
}
class BI {
  constructor() {
    this.promise = new Promise((e, r) => {
      this.resolve = (n) => (e(n), this), this.reject = (n) => (r(n), this);
    });
  }
}
class q1 {
  constructor(e, r, n, i) {
    this._uri = e, this._languageId = r, this._version = n, this._content = i, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      const r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    for (const n of e)
      if (q1.isIncremental(n)) {
        const i = lle(n.range), a = this.offsetAt(i.start), s = this.offsetAt(i.end);
        this._content = this._content.substring(0, a) + n.text + this._content.substring(s, this._content.length);
        const o = Math.max(i.start.line, 0), l = Math.max(i.end.line, 0);
        let u = this._lineOffsets;
        const h = wW(n.text, !1, a);
        if (l - o === h.length)
          for (let d = 0, p = h.length; d < p; d++)
            u[d + o + 1] = h[d];
        else
          h.length < 1e4 ? u.splice(o + 1, l - o, ...h) : this._lineOffsets = u = u.slice(0, o + 1).concat(h, u.slice(l + 1));
        const f = n.text.length - (s - a);
        if (f !== 0)
          for (let d = o + 1 + h.length, p = u.length; d < p; d++)
            u[d] = u[d] + f;
      } else if (q1.isFull(n))
        this._content = n.text, this._lineOffsets = void 0;
      else
        throw new Error("Unknown change event received");
    this._version = r;
  }
  getLineOffsets() {
    return this._lineOffsets === void 0 && (this._lineOffsets = wW(this._content, !0)), this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    const r = this.getLineOffsets();
    let n = 0, i = r.length;
    if (i === 0)
      return { line: 0, character: e };
    for (; n < i; ) {
      const s = Math.floor((n + i) / 2);
      r[s] > e ? i = s : n = s + 1;
    }
    const a = n - 1;
    return e = this.ensureBeforeEOL(e, r[a]), { line: a, character: e - r[a] };
  }
  offsetAt(e) {
    const r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    const n = r[e.line];
    if (e.character <= 0)
      return n;
    const i = e.line + 1 < r.length ? r[e.line + 1] : this._content.length, a = Math.min(n + e.character, i);
    return this.ensureBeforeEOL(a, n);
  }
  ensureBeforeEOL(e, r) {
    for (; e > r && ole(this._content.charCodeAt(e - 1)); )
      e--;
    return e;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range !== void 0 && (r.rangeLength === void 0 || typeof r.rangeLength == "number");
  }
  static isFull(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range === void 0 && r.rangeLength === void 0;
  }
}
var S8;
(function(t) {
  function e(i, a, s, o) {
    return new q1(i, a, s, o);
  }
  t.create = e;
  function r(i, a, s) {
    if (i instanceof q1)
      return i.update(a, s), i;
    throw new Error("TextDocument.update: document must be created by TextDocument.create");
  }
  t.update = r;
  function n(i, a) {
    const s = i.getText(), o = k8(a.map(rZe), (h, f) => {
      const d = h.range.start.line - f.range.start.line;
      return d === 0 ? h.range.start.character - f.range.start.character : d;
    });
    let l = 0;
    const u = [];
    for (const h of o) {
      const f = i.offsetAt(h.range.start);
      if (f < l)
        throw new Error("Overlapping edit");
      f > l && u.push(s.substring(l, f)), h.newText.length && u.push(h.newText), l = i.offsetAt(h.range.end);
    }
    return u.push(s.substr(l)), u.join("");
  }
  t.applyEdits = n;
})(S8 || (S8 = {}));
function k8(t, e) {
  if (t.length <= 1)
    return t;
  const r = t.length / 2 | 0, n = t.slice(0, r), i = t.slice(r);
  k8(n, e), k8(i, e);
  let a = 0, s = 0, o = 0;
  for (; a < n.length && s < i.length; )
    e(n[a], i[s]) <= 0 ? t[o++] = n[a++] : t[o++] = i[s++];
  for (; a < n.length; )
    t[o++] = n[a++];
  for (; s < i.length; )
    t[o++] = i[s++];
  return t;
}
function wW(t, e, r = 0) {
  const n = e ? [r] : [];
  for (let i = 0; i < t.length; i++) {
    const a = t.charCodeAt(i);
    ole(a) && (a === 13 && i + 1 < t.length && t.charCodeAt(i + 1) === 10 && i++, n.push(r + i + 1));
  }
  return n;
}
function ole(t) {
  return t === 13 || t === 10;
}
function lle(t) {
  const e = t.start, r = t.end;
  return e.line > r.line || e.line === r.line && e.character > r.character ? { start: r, end: e } : t;
}
function rZe(t) {
  const e = lle(t.range);
  return e !== t.range ? { newText: t.newText, range: e } : t;
}
var cle;
(() => {
  var t = { 470: (i) => {
    function a(l) {
      if (typeof l != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(l));
    }
    function s(l, u) {
      for (var h, f = "", d = 0, p = -1, g = 0, m = 0; m <= l.length; ++m) {
        if (m < l.length) h = l.charCodeAt(m);
        else {
          if (h === 47) break;
          h = 47;
        }
        if (h === 47) {
          if (!(p === m - 1 || g === 1)) if (p !== m - 1 && g === 2) {
            if (f.length < 2 || d !== 2 || f.charCodeAt(f.length - 1) !== 46 || f.charCodeAt(f.length - 2) !== 46) {
              if (f.length > 2) {
                var v = f.lastIndexOf("/");
                if (v !== f.length - 1) {
                  v === -1 ? (f = "", d = 0) : d = (f = f.slice(0, v)).length - 1 - f.lastIndexOf("/"), p = m, g = 0;
                  continue;
                }
              } else if (f.length === 2 || f.length === 1) {
                f = "", d = 0, p = m, g = 0;
                continue;
              }
            }
            u && (f.length > 0 ? f += "/.." : f = "..", d = 2);
          } else f.length > 0 ? f += "/" + l.slice(p + 1, m) : f = l.slice(p + 1, m), d = m - p - 1;
          p = m, g = 0;
        } else h === 46 && g !== -1 ? ++g : g = -1;
      }
      return f;
    }
    var o = { resolve: function() {
      for (var l, u = "", h = !1, f = arguments.length - 1; f >= -1 && !h; f--) {
        var d;
        f >= 0 ? d = arguments[f] : (l === void 0 && (l = process.cwd()), d = l), a(d), d.length !== 0 && (u = d + "/" + u, h = d.charCodeAt(0) === 47);
      }
      return u = s(u, !h), h ? u.length > 0 ? "/" + u : "/" : u.length > 0 ? u : ".";
    }, normalize: function(l) {
      if (a(l), l.length === 0) return ".";
      var u = l.charCodeAt(0) === 47, h = l.charCodeAt(l.length - 1) === 47;
      return (l = s(l, !u)).length !== 0 || u || (l = "."), l.length > 0 && h && (l += "/"), u ? "/" + l : l;
    }, isAbsolute: function(l) {
      return a(l), l.length > 0 && l.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0) return ".";
      for (var l, u = 0; u < arguments.length; ++u) {
        var h = arguments[u];
        a(h), h.length > 0 && (l === void 0 ? l = h : l += "/" + h);
      }
      return l === void 0 ? "." : o.normalize(l);
    }, relative: function(l, u) {
      if (a(l), a(u), l === u || (l = o.resolve(l)) === (u = o.resolve(u))) return "";
      for (var h = 1; h < l.length && l.charCodeAt(h) === 47; ++h) ;
      for (var f = l.length, d = f - h, p = 1; p < u.length && u.charCodeAt(p) === 47; ++p) ;
      for (var g = u.length - p, m = d < g ? d : g, v = -1, y = 0; y <= m; ++y) {
        if (y === m) {
          if (g > m) {
            if (u.charCodeAt(p + y) === 47) return u.slice(p + y + 1);
            if (y === 0) return u.slice(p + y);
          } else d > m && (l.charCodeAt(h + y) === 47 ? v = y : y === 0 && (v = 0));
          break;
        }
        var b = l.charCodeAt(h + y);
        if (b !== u.charCodeAt(p + y)) break;
        b === 47 && (v = y);
      }
      var x = "";
      for (y = h + v + 1; y <= f; ++y) y !== f && l.charCodeAt(y) !== 47 || (x.length === 0 ? x += ".." : x += "/..");
      return x.length > 0 ? x + u.slice(p + v) : (p += v, u.charCodeAt(p) === 47 && ++p, u.slice(p));
    }, _makeLong: function(l) {
      return l;
    }, dirname: function(l) {
      if (a(l), l.length === 0) return ".";
      for (var u = l.charCodeAt(0), h = u === 47, f = -1, d = !0, p = l.length - 1; p >= 1; --p) if ((u = l.charCodeAt(p)) === 47) {
        if (!d) {
          f = p;
          break;
        }
      } else d = !1;
      return f === -1 ? h ? "/" : "." : h && f === 1 ? "//" : l.slice(0, f);
    }, basename: function(l, u) {
      if (u !== void 0 && typeof u != "string") throw new TypeError('"ext" argument must be a string');
      a(l);
      var h, f = 0, d = -1, p = !0;
      if (u !== void 0 && u.length > 0 && u.length <= l.length) {
        if (u.length === l.length && u === l) return "";
        var g = u.length - 1, m = -1;
        for (h = l.length - 1; h >= 0; --h) {
          var v = l.charCodeAt(h);
          if (v === 47) {
            if (!p) {
              f = h + 1;
              break;
            }
          } else m === -1 && (p = !1, m = h + 1), g >= 0 && (v === u.charCodeAt(g) ? --g == -1 && (d = h) : (g = -1, d = m));
        }
        return f === d ? d = m : d === -1 && (d = l.length), l.slice(f, d);
      }
      for (h = l.length - 1; h >= 0; --h) if (l.charCodeAt(h) === 47) {
        if (!p) {
          f = h + 1;
          break;
        }
      } else d === -1 && (p = !1, d = h + 1);
      return d === -1 ? "" : l.slice(f, d);
    }, extname: function(l) {
      a(l);
      for (var u = -1, h = 0, f = -1, d = !0, p = 0, g = l.length - 1; g >= 0; --g) {
        var m = l.charCodeAt(g);
        if (m !== 47) f === -1 && (d = !1, f = g + 1), m === 46 ? u === -1 ? u = g : p !== 1 && (p = 1) : u !== -1 && (p = -1);
        else if (!d) {
          h = g + 1;
          break;
        }
      }
      return u === -1 || f === -1 || p === 0 || p === 1 && u === f - 1 && u === h + 1 ? "" : l.slice(u, f);
    }, format: function(l) {
      if (l === null || typeof l != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof l);
      return (function(u, h) {
        var f = h.dir || h.root, d = h.base || (h.name || "") + (h.ext || "");
        return f ? f === h.root ? f + d : f + "/" + d : d;
      })(0, l);
    }, parse: function(l) {
      a(l);
      var u = { root: "", dir: "", base: "", ext: "", name: "" };
      if (l.length === 0) return u;
      var h, f = l.charCodeAt(0), d = f === 47;
      d ? (u.root = "/", h = 1) : h = 0;
      for (var p = -1, g = 0, m = -1, v = !0, y = l.length - 1, b = 0; y >= h; --y) if ((f = l.charCodeAt(y)) !== 47) m === -1 && (v = !1, m = y + 1), f === 46 ? p === -1 ? p = y : b !== 1 && (b = 1) : p !== -1 && (b = -1);
      else if (!v) {
        g = y + 1;
        break;
      }
      return p === -1 || m === -1 || b === 0 || b === 1 && p === m - 1 && p === g + 1 ? m !== -1 && (u.base = u.name = g === 0 && d ? l.slice(1, m) : l.slice(g, m)) : (g === 0 && d ? (u.name = l.slice(1, p), u.base = l.slice(1, m)) : (u.name = l.slice(g, p), u.base = l.slice(g, m)), u.ext = l.slice(p, m)), g > 0 ? u.dir = l.slice(0, g - 1) : d && (u.dir = "/"), u;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    o.posix = o, i.exports = o;
  } }, e = {};
  function r(i) {
    var a = e[i];
    if (a !== void 0) return a.exports;
    var s = e[i] = { exports: {} };
    return t[i](s, s.exports, r), s.exports;
  }
  r.d = (i, a) => {
    for (var s in a) r.o(a, s) && !r.o(i, s) && Object.defineProperty(i, s, { enumerable: !0, get: a[s] });
  }, r.o = (i, a) => Object.prototype.hasOwnProperty.call(i, a), r.r = (i) => {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
  };
  var n = {};
  (() => {
    let i;
    r.r(n), r.d(n, { URI: () => d, Utils: () => R }), typeof process == "object" ? i = process.platform === "win32" : typeof navigator == "object" && (i = navigator.userAgent.indexOf("Windows") >= 0);
    const a = /^\w[\w\d+.-]*$/, s = /^\//, o = /^\/\//;
    function l(L, M) {
      if (!L.scheme && M) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${L.authority}", path: "${L.path}", query: "${L.query}", fragment: "${L.fragment}"}`);
      if (L.scheme && !a.test(L.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
      if (L.path) {
        if (L.authority) {
          if (!s.test(L.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (o.test(L.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const u = "", h = "/", f = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    class d {
      static isUri(M) {
        return M instanceof d || !!M && typeof M.authority == "string" && typeof M.fragment == "string" && typeof M.path == "string" && typeof M.query == "string" && typeof M.scheme == "string" && typeof M.fsPath == "string" && typeof M.with == "function" && typeof M.toString == "function";
      }
      scheme;
      authority;
      path;
      query;
      fragment;
      constructor(M, P, C, I, N, O = !1) {
        typeof M == "object" ? (this.scheme = M.scheme || u, this.authority = M.authority || u, this.path = M.path || u, this.query = M.query || u, this.fragment = M.fragment || u) : (this.scheme = /* @__PURE__ */ (function(D, $) {
          return D || $ ? D : "file";
        })(M, O), this.authority = P || u, this.path = (function(D, $) {
          switch (D) {
            case "https":
            case "http":
            case "file":
              $ ? $[0] !== h && ($ = h + $) : $ = h;
          }
          return $;
        })(this.scheme, C || u), this.query = I || u, this.fragment = N || u, l(this, O));
      }
      get fsPath() {
        return b(this);
      }
      with(M) {
        if (!M) return this;
        let { scheme: P, authority: C, path: I, query: N, fragment: O } = M;
        return P === void 0 ? P = this.scheme : P === null && (P = u), C === void 0 ? C = this.authority : C === null && (C = u), I === void 0 ? I = this.path : I === null && (I = u), N === void 0 ? N = this.query : N === null && (N = u), O === void 0 ? O = this.fragment : O === null && (O = u), P === this.scheme && C === this.authority && I === this.path && N === this.query && O === this.fragment ? this : new g(P, C, I, N, O);
      }
      static parse(M, P = !1) {
        const C = f.exec(M);
        return C ? new g(C[2] || u, A(C[4] || u), A(C[5] || u), A(C[7] || u), A(C[9] || u), P) : new g(u, u, u, u, u);
      }
      static file(M) {
        let P = u;
        if (i && (M = M.replace(/\\/g, h)), M[0] === h && M[1] === h) {
          const C = M.indexOf(h, 2);
          C === -1 ? (P = M.substring(2), M = h) : (P = M.substring(2, C), M = M.substring(C) || h);
        }
        return new g("file", P, M, u, u);
      }
      static from(M) {
        const P = new g(M.scheme, M.authority, M.path, M.query, M.fragment);
        return l(P, !0), P;
      }
      toString(M = !1) {
        return x(this, M);
      }
      toJSON() {
        return this;
      }
      static revive(M) {
        if (M) {
          if (M instanceof d) return M;
          {
            const P = new g(M);
            return P._formatted = M.external, P._fsPath = M._sep === p ? M.fsPath : null, P;
          }
        }
        return M;
      }
    }
    const p = i ? 1 : void 0;
    class g extends d {
      _formatted = null;
      _fsPath = null;
      get fsPath() {
        return this._fsPath || (this._fsPath = b(this)), this._fsPath;
      }
      toString(M = !1) {
        return M ? x(this, !0) : (this._formatted || (this._formatted = x(this, !1)), this._formatted);
      }
      toJSON() {
        const M = { $mid: 1 };
        return this._fsPath && (M.fsPath = this._fsPath, M._sep = p), this._formatted && (M.external = this._formatted), this.path && (M.path = this.path), this.scheme && (M.scheme = this.scheme), this.authority && (M.authority = this.authority), this.query && (M.query = this.query), this.fragment && (M.fragment = this.fragment), M;
      }
    }
    const m = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function v(L, M, P) {
      let C, I = -1;
      for (let N = 0; N < L.length; N++) {
        const O = L.charCodeAt(N);
        if (O >= 97 && O <= 122 || O >= 65 && O <= 90 || O >= 48 && O <= 57 || O === 45 || O === 46 || O === 95 || O === 126 || M && O === 47 || P && O === 91 || P && O === 93 || P && O === 58) I !== -1 && (C += encodeURIComponent(L.substring(I, N)), I = -1), C !== void 0 && (C += L.charAt(N));
        else {
          C === void 0 && (C = L.substr(0, N));
          const D = m[O];
          D !== void 0 ? (I !== -1 && (C += encodeURIComponent(L.substring(I, N)), I = -1), C += D) : I === -1 && (I = N);
        }
      }
      return I !== -1 && (C += encodeURIComponent(L.substring(I))), C !== void 0 ? C : L;
    }
    function y(L) {
      let M;
      for (let P = 0; P < L.length; P++) {
        const C = L.charCodeAt(P);
        C === 35 || C === 63 ? (M === void 0 && (M = L.substr(0, P)), M += m[C]) : M !== void 0 && (M += L[P]);
      }
      return M !== void 0 ? M : L;
    }
    function b(L, M) {
      let P;
      return P = L.authority && L.path.length > 1 && L.scheme === "file" ? `//${L.authority}${L.path}` : L.path.charCodeAt(0) === 47 && (L.path.charCodeAt(1) >= 65 && L.path.charCodeAt(1) <= 90 || L.path.charCodeAt(1) >= 97 && L.path.charCodeAt(1) <= 122) && L.path.charCodeAt(2) === 58 ? L.path[1].toLowerCase() + L.path.substr(2) : L.path, i && (P = P.replace(/\//g, "\\")), P;
    }
    function x(L, M) {
      const P = M ? y : v;
      let C = "", { scheme: I, authority: N, path: O, query: D, fragment: $ } = L;
      if (I && (C += I, C += ":"), (N || I === "file") && (C += h, C += h), N) {
        let z = N.indexOf("@");
        if (z !== -1) {
          const B = N.substr(0, z);
          N = N.substr(z + 1), z = B.lastIndexOf(":"), z === -1 ? C += P(B, !1, !1) : (C += P(B.substr(0, z), !1, !1), C += ":", C += P(B.substr(z + 1), !1, !0)), C += "@";
        }
        N = N.toLowerCase(), z = N.lastIndexOf(":"), z === -1 ? C += P(N, !1, !0) : (C += P(N.substr(0, z), !1, !0), C += N.substr(z));
      }
      if (O) {
        if (O.length >= 3 && O.charCodeAt(0) === 47 && O.charCodeAt(2) === 58) {
          const z = O.charCodeAt(1);
          z >= 65 && z <= 90 && (O = `/${String.fromCharCode(z + 32)}:${O.substr(3)}`);
        } else if (O.length >= 2 && O.charCodeAt(1) === 58) {
          const z = O.charCodeAt(0);
          z >= 65 && z <= 90 && (O = `${String.fromCharCode(z + 32)}:${O.substr(2)}`);
        }
        C += P(O, !0, !1);
      }
      return D && (C += "?", C += P(D, !1, !1)), $ && (C += "#", C += M ? $ : v($, !1, !1)), C;
    }
    function T(L) {
      try {
        return decodeURIComponent(L);
      } catch {
        return L.length > 3 ? L.substr(0, 3) + T(L.substr(3)) : L;
      }
    }
    const E = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function A(L) {
      return L.match(E) ? L.replace(E, ((M) => T(M))) : L;
    }
    var S = r(470);
    const k = S.posix || S, _ = "/";
    var R;
    (function(L) {
      L.joinPath = function(M, ...P) {
        return M.with({ path: k.join(M.path, ...P) });
      }, L.resolvePath = function(M, ...P) {
        let C = M.path, I = !1;
        C[0] !== _ && (C = _ + C, I = !0);
        let N = k.resolve(C, ...P);
        return I && N[0] === _ && !M.authority && (N = N.substring(1)), M.with({ path: N });
      }, L.dirname = function(M) {
        if (M.path.length === 0 || M.path === _) return M;
        let P = k.dirname(M.path);
        return P.length === 1 && P.charCodeAt(0) === 46 && (P = ""), M.with({ path: P });
      }, L.basename = function(M) {
        return k.basename(M.path);
      }, L.extname = function(M) {
        return k.extname(M.path);
      };
    })(R || (R = {}));
  })(), cle = n;
})();
const { URI: dh, Utils: Cp } = cle;
var Mc;
(function(t) {
  t.basename = Cp.basename, t.dirname = Cp.dirname, t.extname = Cp.extname, t.joinPath = Cp.joinPath, t.resolvePath = Cp.resolvePath;
  function e(i, a) {
    return i?.toString() === a?.toString();
  }
  t.equals = e;
  function r(i, a) {
    const s = typeof i == "string" ? i : i.path, o = typeof a == "string" ? a : a.path, l = s.split("/").filter((p) => p.length > 0), u = o.split("/").filter((p) => p.length > 0);
    let h = 0;
    for (; h < l.length && l[h] === u[h]; h++)
      ;
    const f = "../".repeat(l.length - h), d = u.slice(h).join("/");
    return f + d;
  }
  t.relative = r;
  function n(i) {
    return dh.parse(i.toString()).toString();
  }
  t.normalize = n;
})(Mc || (Mc = {}));
var Qr;
(function(t) {
  t[t.Changed = 0] = "Changed", t[t.Parsed = 1] = "Parsed", t[t.IndexedContent = 2] = "IndexedContent", t[t.ComputedScopes = 3] = "ComputedScopes", t[t.Linked = 4] = "Linked", t[t.IndexedReferences = 5] = "IndexedReferences", t[t.Validated = 6] = "Validated";
})(Qr || (Qr = {}));
class nZe {
  constructor(e) {
    this.serviceRegistry = e.ServiceRegistry, this.textDocuments = e.workspace.TextDocuments, this.fileSystemProvider = e.workspace.FileSystemProvider;
  }
  async fromUri(e, r = on.CancellationToken.None) {
    const n = await this.fileSystemProvider.readFile(e);
    return this.createAsync(e, n, r);
  }
  fromTextDocument(e, r, n) {
    return r = r ?? dh.parse(e.uri), on.CancellationToken.is(n) ? this.createAsync(r, e, n) : this.create(r, e, n);
  }
  fromString(e, r, n) {
    return on.CancellationToken.is(n) ? this.createAsync(r, e, n) : this.create(r, e, n);
  }
  fromModel(e, r) {
    return this.create(r, { $model: e });
  }
  create(e, r, n) {
    if (typeof r == "string") {
      const i = this.parse(e, r, n);
      return this.createLangiumDocument(i, e, void 0, r);
    } else if ("$model" in r) {
      const i = { value: r.$model, parserErrors: [], lexerErrors: [] };
      return this.createLangiumDocument(i, e);
    } else {
      const i = this.parse(e, r.getText(), n);
      return this.createLangiumDocument(i, e, r);
    }
  }
  async createAsync(e, r, n) {
    if (typeof r == "string") {
      const i = await this.parseAsync(e, r, n);
      return this.createLangiumDocument(i, e, void 0, r);
    } else {
      const i = await this.parseAsync(e, r.getText(), n);
      return this.createLangiumDocument(i, e, r);
    }
  }
  /**
   * Create a LangiumDocument from a given parse result.
   *
   * A TextDocument is created on demand if it is not provided as argument here. Usually this
   * should not be necessary because the main purpose of the TextDocument is to convert between
   * text ranges and offsets, which is done solely in LSP request handling.
   *
   * With the introduction of {@link update} below this method is supposed to be mainly called
   * during workspace initialization and on addition/recognition of new files, while changes in
   * existing documents are processed via {@link update}.
   */
  createLangiumDocument(e, r, n, i) {
    let a;
    if (n)
      a = {
        parseResult: e,
        uri: r,
        state: Qr.Parsed,
        references: [],
        textDocument: n
      };
    else {
      const s = this.createTextDocumentGetter(r, i);
      a = {
        parseResult: e,
        uri: r,
        state: Qr.Parsed,
        references: [],
        get textDocument() {
          return s();
        }
      };
    }
    return e.value.$document = a, a;
  }
  async update(e, r) {
    var n, i;
    const a = (n = e.parseResult.value.$cstNode) === null || n === void 0 ? void 0 : n.root.fullText, s = (i = this.textDocuments) === null || i === void 0 ? void 0 : i.get(e.uri.toString()), o = s ? s.getText() : await this.fileSystemProvider.readFile(e.uri);
    if (s)
      Object.defineProperty(e, "textDocument", {
        value: s
      });
    else {
      const l = this.createTextDocumentGetter(e.uri, o);
      Object.defineProperty(e, "textDocument", {
        get: l
      });
    }
    return a !== o && (e.parseResult = await this.parseAsync(e.uri, o, r), e.parseResult.value.$document = e), e.state = Qr.Parsed, e;
  }
  parse(e, r, n) {
    return this.serviceRegistry.getServices(e).parser.LangiumParser.parse(r, n);
  }
  parseAsync(e, r, n) {
    return this.serviceRegistry.getServices(e).parser.AsyncParser.parse(r, n);
  }
  createTextDocumentGetter(e, r) {
    const n = this.serviceRegistry;
    let i;
    return () => i ?? (i = S8.create(e.toString(), n.getServices(e).LanguageMetaData.languageId, 0, r ?? ""));
  }
}
class iZe {
  constructor(e) {
    this.documentMap = /* @__PURE__ */ new Map(), this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.serviceRegistry = e.ServiceRegistry;
  }
  get all() {
    return hi(this.documentMap.values());
  }
  addDocument(e) {
    const r = e.uri.toString();
    if (this.documentMap.has(r))
      throw new Error(`A document with the URI '${r}' is already present.`);
    this.documentMap.set(r, e);
  }
  getDocument(e) {
    const r = e.toString();
    return this.documentMap.get(r);
  }
  async getOrCreateDocument(e, r) {
    let n = this.getDocument(e);
    return n || (n = await this.langiumDocumentFactory.fromUri(e, r), this.addDocument(n), n);
  }
  createDocument(e, r, n) {
    if (n)
      return this.langiumDocumentFactory.fromString(r, e, n).then((i) => (this.addDocument(i), i));
    {
      const i = this.langiumDocumentFactory.fromString(r, e);
      return this.addDocument(i), i;
    }
  }
  hasDocument(e) {
    return this.documentMap.has(e.toString());
  }
  invalidateDocument(e) {
    const r = e.toString(), n = this.documentMap.get(r);
    return n && (this.serviceRegistry.getServices(e).references.Linker.unlink(n), n.state = Qr.Changed, n.precomputedScopes = void 0, n.diagnostics = void 0), n;
  }
  deleteDocument(e) {
    const r = e.toString(), n = this.documentMap.get(r);
    return n && (n.state = Qr.Changed, this.documentMap.delete(r)), n;
  }
}
const k7 = Symbol("ref_resolving");
class aZe {
  constructor(e) {
    this.reflection = e.shared.AstReflection, this.langiumDocuments = () => e.shared.workspace.LangiumDocuments, this.scopeProvider = e.references.ScopeProvider, this.astNodeLocator = e.workspace.AstNodeLocator;
  }
  async link(e, r = on.CancellationToken.None) {
    for (const n of Gf(e.parseResult.value))
      await _a(r), Zae(n).forEach((i) => this.doLink(i, e));
  }
  doLink(e, r) {
    var n;
    const i = e.reference;
    if (i._ref === void 0) {
      i._ref = k7;
      try {
        const a = this.getCandidate(e);
        if (Ky(a))
          i._ref = a;
        else if (i._nodeDescription = a, this.langiumDocuments().hasDocument(a.documentUri)) {
          const s = this.loadAstNode(a);
          i._ref = s ?? this.createLinkingError(e, a);
        } else
          i._ref = void 0;
      } catch (a) {
        console.error(`An error occurred while resolving reference to '${i.$refText}':`, a);
        const s = (n = a.message) !== null && n !== void 0 ? n : String(a);
        i._ref = Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${i.$refText}': ${s}` });
      }
      r.references.push(i);
    }
  }
  unlink(e) {
    for (const r of e.references)
      delete r._ref, delete r._nodeDescription;
    e.references = [];
  }
  getCandidate(e) {
    const n = this.scopeProvider.getScope(e).getElement(e.reference.$refText);
    return n ?? this.createLinkingError(e);
  }
  buildReference(e, r, n, i) {
    const a = this, s = {
      $refNode: n,
      $refText: i,
      get ref() {
        var o;
        if (Ci(this._ref))
          return this._ref;
        if (QPe(this._nodeDescription)) {
          const l = a.loadAstNode(this._nodeDescription);
          this._ref = l ?? a.createLinkingError({ reference: s, container: e, property: r }, this._nodeDescription);
        } else if (this._ref === void 0) {
          this._ref = k7;
          const l = FA(e).$document, u = a.getLinkedNode({ reference: s, container: e, property: r });
          if (u.error && l && l.state < Qr.ComputedScopes)
            return this._ref = void 0;
          this._ref = (o = u.node) !== null && o !== void 0 ? o : u.error, this._nodeDescription = u.descr, l?.references.push(this);
        } else if (this._ref === k7)
          throw new Error(`Cyclic reference resolution detected: ${a.astNodeLocator.getAstNodePath(e)}/${r} (symbol '${i}')`);
        return Ci(this._ref) ? this._ref : void 0;
      },
      get $nodeDescription() {
        return this._nodeDescription;
      },
      get error() {
        return Ky(this._ref) ? this._ref : void 0;
      }
    };
    return s;
  }
  getLinkedNode(e) {
    var r;
    try {
      const n = this.getCandidate(e);
      if (Ky(n))
        return { error: n };
      const i = this.loadAstNode(n);
      return i ? { node: i, descr: n } : {
        descr: n,
        error: this.createLinkingError(e, n)
      };
    } catch (n) {
      console.error(`An error occurred while resolving reference to '${e.reference.$refText}':`, n);
      const i = (r = n.message) !== null && r !== void 0 ? r : String(n);
      return {
        error: Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${e.reference.$refText}': ${i}` })
      };
    }
  }
  loadAstNode(e) {
    if (e.node)
      return e.node;
    const r = this.langiumDocuments().getDocument(e.documentUri);
    if (r)
      return this.astNodeLocator.getAstNode(r.parseResult.value, e.path);
  }
  createLinkingError(e, r) {
    const n = FA(e.container).$document;
    n && n.state < Qr.ComputedScopes && console.warn(`Attempted reference resolution before document reached ComputedScopes state (${n.uri}).`);
    const i = this.reflection.getReferenceType(e);
    return Object.assign(Object.assign({}, e), { message: `Could not resolve reference to ${i} named '${e.reference.$refText}'.`, targetDescription: r });
  }
}
function sZe(t) {
  return typeof t.name == "string";
}
class oZe {
  getName(e) {
    if (sZe(e))
      return e.name;
  }
  getNameNode(e) {
    return rse(e.$cstNode, "name");
  }
}
class lZe {
  constructor(e) {
    this.nameProvider = e.references.NameProvider, this.index = e.shared.workspace.IndexManager, this.nodeLocator = e.workspace.AstNodeLocator;
  }
  findDeclaration(e) {
    if (e) {
      const r = V$e(e), n = e.astNode;
      if (r && n) {
        const i = n[r.feature];
        if (oo(i))
          return i.ref;
        if (Array.isArray(i)) {
          for (const a of i)
            if (oo(a) && a.$refNode && a.$refNode.offset <= e.offset && a.$refNode.end >= e.end)
              return a.ref;
        }
      }
      if (n) {
        const i = this.nameProvider.getNameNode(n);
        if (i && (i === e || t$e(e, i)))
          return n;
      }
    }
  }
  findDeclarationNode(e) {
    const r = this.findDeclaration(e);
    if (r?.$cstNode) {
      const n = this.nameProvider.getNameNode(r);
      return n ?? r.$cstNode;
    }
  }
  findReferences(e, r) {
    const n = [];
    if (r.includeDeclaration) {
      const a = this.getReferenceToSelf(e);
      a && n.push(a);
    }
    let i = this.index.findAllReferences(e, this.nodeLocator.getAstNodePath(e));
    return r.documentUri && (i = i.filter((a) => Mc.equals(a.sourceUri, r.documentUri))), n.push(...i), hi(n);
  }
  getReferenceToSelf(e) {
    const r = this.nameProvider.getNameNode(e);
    if (r) {
      const n = Sc(e), i = this.nodeLocator.getAstNodePath(e);
      return {
        sourceUri: n.uri,
        sourcePath: i,
        targetUri: n.uri,
        targetPath: i,
        segment: Wb(r),
        local: !0
      };
    }
  }
}
class vx {
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), e)
      for (const [r, n] of e)
        this.add(r, n);
  }
  /**
   * The total number of values in the multimap.
   */
  get size() {
    return PA.sum(hi(this.map.values()).map((e) => e.length));
  }
  /**
   * Clear all entries in the multimap.
   */
  clear() {
    this.map.clear();
  }
  /**
   * Operates differently depending on whether a `value` is given:
   *  * With a value, this method deletes the specific key / value pair from the multimap.
   *  * Without a value, all values associated with the given key are deleted.
   *
   * @returns `true` if a value existed and has been removed, or `false` if the specified
   *     key / value does not exist.
   */
  delete(e, r) {
    if (r === void 0)
      return this.map.delete(e);
    {
      const n = this.map.get(e);
      if (n) {
        const i = n.indexOf(r);
        if (i >= 0)
          return n.length === 1 ? this.map.delete(e) : n.splice(i, 1), !0;
      }
      return !1;
    }
  }
  /**
   * Returns an array of all values associated with the given key. If no value exists,
   * an empty array is returned.
   *
   * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
   * value and `delete` to remove a value from the multimap.
   */
  get(e) {
    var r;
    return (r = this.map.get(e)) !== null && r !== void 0 ? r : [];
  }
  /**
   * Operates differently depending on whether a `value` is given:
   *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
   *  * Without a value, this method returns `true` if the given key is present in the multimap.
   */
  has(e, r) {
    if (r === void 0)
      return this.map.has(e);
    {
      const n = this.map.get(e);
      return n ? n.indexOf(r) >= 0 : !1;
    }
  }
  /**
   * Add the given key / value pair to the multimap.
   */
  add(e, r) {
    return this.map.has(e) ? this.map.get(e).push(r) : this.map.set(e, [r]), this;
  }
  /**
   * Add the given set of key / value pairs to the multimap.
   */
  addAll(e, r) {
    return this.map.has(e) ? this.map.get(e).push(...r) : this.map.set(e, Array.from(r)), this;
  }
  /**
   * Invokes the given callback function for every key / value pair in the multimap.
   */
  forEach(e) {
    this.map.forEach((r, n) => r.forEach((i) => e(i, n, this)));
  }
  /**
   * Returns an iterator of key, value pairs for every entry in the map.
   */
  [Symbol.iterator]() {
    return this.entries().iterator();
  }
  /**
   * Returns a stream of key, value pairs for every entry in the map.
   */
  entries() {
    return hi(this.map.entries()).flatMap(([e, r]) => r.map((n) => [e, n]));
  }
  /**
   * Returns a stream of keys in the map.
   */
  keys() {
    return hi(this.map.keys());
  }
  /**
   * Returns a stream of values in the map.
   */
  values() {
    return hi(this.map.values()).flat();
  }
  /**
   * Returns a stream of key, value set pairs for every key in the map.
   */
  entriesGroupedByKey() {
    return hi(this.map.entries());
  }
}
class TW {
  get size() {
    return this.map.size;
  }
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), this.inverse = /* @__PURE__ */ new Map(), e)
      for (const [r, n] of e)
        this.set(r, n);
  }
  clear() {
    this.map.clear(), this.inverse.clear();
  }
  set(e, r) {
    return this.map.set(e, r), this.inverse.set(r, e), this;
  }
  get(e) {
    return this.map.get(e);
  }
  getKey(e) {
    return this.inverse.get(e);
  }
  delete(e) {
    const r = this.map.get(e);
    return r !== void 0 ? (this.map.delete(e), this.inverse.delete(r), !0) : !1;
  }
}
class cZe {
  constructor(e) {
    this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider;
  }
  async computeExports(e, r = on.CancellationToken.None) {
    return this.computeExportsForNode(e.parseResult.value, e, void 0, r);
  }
  /**
   * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
   * The list of children to be considered is determined by the function parameter {@link children}.
   * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
   *
   * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
   * @param document The document containing the AST node to be exported.
   * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
   * @param cancelToken Indicates when to cancel the current operation.
   * @throws `OperationCancelled` if a user action occurs during execution.
   * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
   */
  async computeExportsForNode(e, r, n = jR, i = on.CancellationToken.None) {
    const a = [];
    this.exportNode(e, a, r);
    for (const s of n(e))
      await _a(i), this.exportNode(s, a, r);
    return a;
  }
  /**
   * Add a single node to the list of exports if it has a name. Override this method to change how
   * symbols are exported, e.g. by modifying their exported name.
   */
  exportNode(e, r, n) {
    const i = this.nameProvider.getName(e);
    i && r.push(this.descriptions.createDescription(e, i, n));
  }
  async computeLocalScopes(e, r = on.CancellationToken.None) {
    const n = e.parseResult.value, i = new vx();
    for (const a of Mm(n))
      await _a(r), this.processNode(a, e, i);
    return i;
  }
  /**
   * Process a single node during scopes computation. The default implementation makes the node visible
   * in the subtree of its container (if the node has a name). Override this method to change this,
   * e.g. by increasing the visibility to a higher level in the AST.
   */
  processNode(e, r, n) {
    const i = e.$container;
    if (i) {
      const a = this.nameProvider.getName(e);
      a && n.add(i, this.descriptions.createDescription(e, a, r));
    }
  }
}
class EW {
  constructor(e, r, n) {
    var i;
    this.elements = e, this.outerScope = r, this.caseInsensitive = (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1;
  }
  getAllElements() {
    return this.outerScope ? this.elements.concat(this.outerScope.getAllElements()) : this.elements;
  }
  getElement(e) {
    const r = this.caseInsensitive ? this.elements.find((n) => n.name.toLowerCase() === e.toLowerCase()) : this.elements.find((n) => n.name === e);
    if (r)
      return r;
    if (this.outerScope)
      return this.outerScope.getElement(e);
  }
}
class uZe {
  constructor(e, r, n) {
    var i;
    this.elements = /* @__PURE__ */ new Map(), this.caseInsensitive = (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1;
    for (const a of e) {
      const s = this.caseInsensitive ? a.name.toLowerCase() : a.name;
      this.elements.set(s, a);
    }
    this.outerScope = r;
  }
  getElement(e) {
    const r = this.caseInsensitive ? e.toLowerCase() : e, n = this.elements.get(r);
    if (n)
      return n;
    if (this.outerScope)
      return this.outerScope.getElement(e);
  }
  getAllElements() {
    let e = hi(this.elements.values());
    return this.outerScope && (e = e.concat(this.outerScope.getAllElements())), e;
  }
}
class ule {
  constructor() {
    this.toDispose = [], this.isDisposed = !1;
  }
  onDispose(e) {
    this.toDispose.push(e);
  }
  dispose() {
    this.throwIfDisposed(), this.clear(), this.isDisposed = !0, this.toDispose.forEach((e) => e.dispose());
  }
  throwIfDisposed() {
    if (this.isDisposed)
      throw new Error("This cache has already been disposed");
  }
}
class hZe extends ule {
  constructor() {
    super(...arguments), this.cache = /* @__PURE__ */ new Map();
  }
  has(e) {
    return this.throwIfDisposed(), this.cache.has(e);
  }
  set(e, r) {
    this.throwIfDisposed(), this.cache.set(e, r);
  }
  get(e, r) {
    if (this.throwIfDisposed(), this.cache.has(e))
      return this.cache.get(e);
    if (r) {
      const n = r();
      return this.cache.set(e, n), n;
    } else
      return;
  }
  delete(e) {
    return this.throwIfDisposed(), this.cache.delete(e);
  }
  clear() {
    this.throwIfDisposed(), this.cache.clear();
  }
}
class fZe extends ule {
  constructor(e) {
    super(), this.cache = /* @__PURE__ */ new Map(), this.converter = e ?? ((r) => r);
  }
  has(e, r) {
    return this.throwIfDisposed(), this.cacheForContext(e).has(r);
  }
  set(e, r, n) {
    this.throwIfDisposed(), this.cacheForContext(e).set(r, n);
  }
  get(e, r, n) {
    this.throwIfDisposed();
    const i = this.cacheForContext(e);
    if (i.has(r))
      return i.get(r);
    if (n) {
      const a = n();
      return i.set(r, a), a;
    } else
      return;
  }
  delete(e, r) {
    return this.throwIfDisposed(), this.cacheForContext(e).delete(r);
  }
  clear(e) {
    if (this.throwIfDisposed(), e) {
      const r = this.converter(e);
      this.cache.delete(r);
    } else
      this.cache.clear();
  }
  cacheForContext(e) {
    const r = this.converter(e);
    let n = this.cache.get(r);
    return n || (n = /* @__PURE__ */ new Map(), this.cache.set(r, n)), n;
  }
}
class dZe extends hZe {
  /**
   * Creates a new workspace cache.
   *
   * @param sharedServices Service container instance to hook into document lifecycle events.
   * @param state Optional document state on which the cache should evict.
   * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
   * *Deleted* documents are considered in both cases.
   */
  constructor(e, r) {
    super(), r ? (this.toDispose.push(e.workspace.DocumentBuilder.onBuildPhase(r, () => {
      this.clear();
    })), this.toDispose.push(e.workspace.DocumentBuilder.onUpdate((n, i) => {
      i.length > 0 && this.clear();
    }))) : this.toDispose.push(e.workspace.DocumentBuilder.onUpdate(() => {
      this.clear();
    }));
  }
}
class pZe {
  constructor(e) {
    this.reflection = e.shared.AstReflection, this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider, this.indexManager = e.shared.workspace.IndexManager, this.globalScopeCache = new dZe(e.shared);
  }
  getScope(e) {
    const r = [], n = this.reflection.getReferenceType(e), i = Sc(e.container).precomputedScopes;
    if (i) {
      let s = e.container;
      do {
        const o = i.get(s);
        o.length > 0 && r.push(hi(o).filter((l) => this.reflection.isSubtype(l.type, n))), s = s.$container;
      } while (s);
    }
    let a = this.getGlobalScope(n, e);
    for (let s = r.length - 1; s >= 0; s--)
      a = this.createScope(r[s], a);
    return a;
  }
  /**
   * Create a scope for the given collection of AST node descriptions.
   */
  createScope(e, r, n) {
    return new EW(hi(e), r, n);
  }
  /**
   * Create a scope for the given collection of AST nodes, which need to be transformed into respective
   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
   */
  createScopeForNodes(e, r, n) {
    const i = hi(e).map((a) => {
      const s = this.nameProvider.getName(a);
      if (s)
        return this.descriptions.createDescription(a, s);
    }).nonNullable();
    return new EW(i, r, n);
  }
  /**
   * Create a global scope filtered for the given reference type.
   */
  getGlobalScope(e, r) {
    return this.globalScopeCache.get(e, () => new uZe(this.indexManager.allElements(e)));
  }
}
function gZe(t) {
  return typeof t.$comment == "string";
}
function SW(t) {
  return typeof t == "object" && !!t && ("$ref" in t || "$error" in t);
}
class mZe {
  constructor(e) {
    this.ignoreProperties = /* @__PURE__ */ new Set(["$container", "$containerProperty", "$containerIndex", "$document", "$cstNode"]), this.langiumDocuments = e.shared.workspace.LangiumDocuments, this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider, this.commentProvider = e.documentation.CommentProvider;
  }
  serialize(e, r) {
    const n = r ?? {}, i = r?.replacer, a = (o, l) => this.replacer(o, l, n), s = i ? (o, l) => i(o, l, a) : a;
    try {
      return this.currentDocument = Sc(e), JSON.stringify(e, s, r?.space);
    } finally {
      this.currentDocument = void 0;
    }
  }
  deserialize(e, r) {
    const n = r ?? {}, i = JSON.parse(e);
    return this.linkNode(i, i, n), i;
  }
  replacer(e, r, { refText: n, sourceText: i, textRegions: a, comments: s, uriConverter: o }) {
    var l, u, h, f;
    if (!this.ignoreProperties.has(e))
      if (oo(r)) {
        const d = r.ref, p = n ? r.$refText : void 0;
        if (d) {
          const g = Sc(d);
          let m = "";
          this.currentDocument && this.currentDocument !== g && (o ? m = o(g.uri, r) : m = g.uri.toString());
          const v = this.astNodeLocator.getAstNodePath(d);
          return {
            $ref: `${m}#${v}`,
            $refText: p
          };
        } else
          return {
            $error: (u = (l = r.error) === null || l === void 0 ? void 0 : l.message) !== null && u !== void 0 ? u : "Could not resolve reference",
            $refText: p
          };
      } else if (Ci(r)) {
        let d;
        if (a && (d = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, r)), (!e || r.$document) && d?.$textRegion && (d.$textRegion.documentURI = (h = this.currentDocument) === null || h === void 0 ? void 0 : h.uri.toString())), i && !e && (d ?? (d = Object.assign({}, r)), d.$sourceText = (f = r.$cstNode) === null || f === void 0 ? void 0 : f.text), s) {
          d ?? (d = Object.assign({}, r));
          const p = this.commentProvider.getComment(r);
          p && (d.$comment = p.replace(/\r/g, ""));
        }
        return d ?? r;
      } else
        return r;
  }
  addAstNodeRegionWithAssignmentsTo(e) {
    const r = (n) => ({
      offset: n.offset,
      end: n.end,
      length: n.length,
      range: n.range
    });
    if (e.$cstNode) {
      const n = e.$textRegion = r(e.$cstNode), i = n.assignments = {};
      return Object.keys(e).filter((a) => !a.startsWith("$")).forEach((a) => {
        const s = q$e(e.$cstNode, a).map(r);
        s.length !== 0 && (i[a] = s);
      }), e;
    }
  }
  linkNode(e, r, n, i, a, s) {
    for (const [l, u] of Object.entries(e))
      if (Array.isArray(u))
        for (let h = 0; h < u.length; h++) {
          const f = u[h];
          SW(f) ? u[h] = this.reviveReference(e, l, r, f, n) : Ci(f) && this.linkNode(f, r, n, e, l, h);
        }
      else SW(u) ? e[l] = this.reviveReference(e, l, r, u, n) : Ci(u) && this.linkNode(u, r, n, e, l);
    const o = e;
    o.$container = i, o.$containerProperty = a, o.$containerIndex = s;
  }
  reviveReference(e, r, n, i, a) {
    let s = i.$refText, o = i.$error;
    if (i.$ref) {
      const l = this.getRefNode(n, i.$ref, a.uriConverter);
      if (Ci(l))
        return s || (s = this.nameProvider.getName(l)), {
          $refText: s ?? "",
          ref: l
        };
      o = l;
    }
    if (o) {
      const l = {
        $refText: s ?? ""
      };
      return l.error = {
        container: e,
        property: r,
        message: o,
        reference: l
      }, l;
    } else
      return;
  }
  getRefNode(e, r, n) {
    try {
      const i = r.indexOf("#");
      if (i === 0) {
        const l = this.astNodeLocator.getAstNode(e, r.substring(1));
        return l || "Could not resolve path: " + r;
      }
      if (i < 0) {
        const l = n ? n(r) : dh.parse(r), u = this.langiumDocuments.getDocument(l);
        return u ? u.parseResult.value : "Could not find document for URI: " + r;
      }
      const a = n ? n(r.substring(0, i)) : dh.parse(r.substring(0, i)), s = this.langiumDocuments.getDocument(a);
      if (!s)
        return "Could not find document for URI: " + r;
      if (i === r.length - 1)
        return s.parseResult.value;
      const o = this.astNodeLocator.getAstNode(s.parseResult.value, r.substring(i + 1));
      return o || "Could not resolve URI: " + r;
    } catch (i) {
      return String(i);
    }
  }
}
class vZe {
  /**
   * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.
   */
  get map() {
    return this.fileExtensionMap;
  }
  constructor(e) {
    this.languageIdMap = /* @__PURE__ */ new Map(), this.fileExtensionMap = /* @__PURE__ */ new Map(), this.textDocuments = e?.workspace.TextDocuments;
  }
  register(e) {
    const r = e.LanguageMetaData;
    for (const n of r.fileExtensions)
      this.fileExtensionMap.has(n) && console.warn(`The file extension ${n} is used by multiple languages. It is now assigned to '${r.languageId}'.`), this.fileExtensionMap.set(n, e);
    this.languageIdMap.set(r.languageId, e), this.languageIdMap.size === 1 ? this.singleton = e : this.singleton = void 0;
  }
  getServices(e) {
    var r, n;
    if (this.singleton !== void 0)
      return this.singleton;
    if (this.languageIdMap.size === 0)
      throw new Error("The service registry is empty. Use `register` to register the services of a language.");
    const i = (n = (r = this.textDocuments) === null || r === void 0 ? void 0 : r.get(e)) === null || n === void 0 ? void 0 : n.languageId;
    if (i !== void 0) {
      const o = this.languageIdMap.get(i);
      if (o)
        return o;
    }
    const a = Mc.extname(e), s = this.fileExtensionMap.get(a);
    if (!s)
      throw i ? new Error(`The service registry contains no services for the extension '${a}' for language '${i}'.`) : new Error(`The service registry contains no services for the extension '${a}'.`);
    return s;
  }
  hasServices(e) {
    try {
      return this.getServices(e), !0;
    } catch {
      return !1;
    }
  }
  get all() {
    return Array.from(this.languageIdMap.values());
  }
}
function Tg(t) {
  return { code: t };
}
var yx;
(function(t) {
  t.all = ["fast", "slow", "built-in"];
})(yx || (yx = {}));
class yZe {
  constructor(e) {
    this.entries = new vx(), this.entriesBefore = [], this.entriesAfter = [], this.reflection = e.shared.AstReflection;
  }
  /**
   * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
   * or an array of validation checks.
   *
   * @param checksRecord Set of validation checks to register.
   * @param category Optional category for the validation checks (defaults to `'fast'`).
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  register(e, r = this, n = "fast") {
    if (n === "built-in")
      throw new Error("The 'built-in' category is reserved for lexer, parser, and linker errors.");
    for (const [i, a] of Object.entries(e)) {
      const s = a;
      if (Array.isArray(s))
        for (const o of s) {
          const l = {
            check: this.wrapValidationException(o, r),
            category: n
          };
          this.addEntry(i, l);
        }
      else if (typeof s == "function") {
        const o = {
          check: this.wrapValidationException(s, r),
          category: n
        };
        this.addEntry(i, o);
      } else
        Im();
    }
  }
  wrapValidationException(e, r) {
    return async (n, i, a) => {
      await this.handleException(() => e.call(r, n, i, a), "An error occurred during validation", i, n);
    };
  }
  async handleException(e, r, n, i) {
    try {
      await e();
    } catch (a) {
      if (H3(a))
        throw a;
      console.error(`${r}:`, a), a instanceof Error && a.stack && console.error(a.stack);
      const s = a instanceof Error ? a.message : String(a);
      n("error", `${r}: ${s}`, { node: i });
    }
  }
  addEntry(e, r) {
    if (e === "AstNode") {
      this.entries.add("AstNode", r);
      return;
    }
    for (const n of this.reflection.getAllSubTypes(e))
      this.entries.add(n, r);
  }
  getChecks(e, r) {
    let n = hi(this.entries.get(e)).concat(this.entries.get("AstNode"));
    return r && (n = n.filter((i) => r.includes(i.category))), n.map((i) => i.check);
  }
  /**
   * Register logic which will be executed once before validating all the nodes of an AST/Langium document.
   * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.
   *
   * As an example, for validating unique fully-qualified names of nodes in the AST,
   * here the map for mapping names to nodes could be established.
   * During the usual checks on the nodes, they are put into this map with their name.
   *
   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
   * Therefore it is recommended to clear stored information
   * _before_ validating an AST to validate each AST unaffected from other ASTs
   * AND _after_ validating the AST to free memory by information which are no longer used.
   *
   * @param checkBefore a set-up function which will be called once before actually validating an AST
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  registerBeforeDocument(e, r = this) {
    this.entriesBefore.push(this.wrapPreparationException(e, "An error occurred during set-up of the validation", r));
  }
  /**
   * Register logic which will be executed once after validating all the nodes of an AST/Langium document.
   * This helps to finally evaluate information which are collected during the checks on the AstNodes.
   *
   * As an example, for validating unique fully-qualified names of nodes in the AST,
   * here the map with all the collected nodes and their names is checked
   * and validation hints are created for all nodes with the same name.
   *
   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
   * Therefore it is recommended to clear stored information
   * _before_ validating an AST to validate each AST unaffected from other ASTs
   * AND _after_ validating the AST to free memory by information which are no longer used.
   *
   * @param checkBefore a set-up function which will be called once before actually validating an AST
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  registerAfterDocument(e, r = this) {
    this.entriesAfter.push(this.wrapPreparationException(e, "An error occurred during tear-down of the validation", r));
  }
  wrapPreparationException(e, r, n) {
    return async (i, a, s, o) => {
      await this.handleException(() => e.call(n, i, a, s, o), r, a, i);
    };
  }
  get checksBefore() {
    return this.entriesBefore;
  }
  get checksAfter() {
    return this.entriesAfter;
  }
}
class bZe {
  constructor(e) {
    this.validationRegistry = e.validation.ValidationRegistry, this.metadata = e.LanguageMetaData;
  }
  async validateDocument(e, r = {}, n = on.CancellationToken.None) {
    const i = e.parseResult, a = [];
    if (await _a(n), (!r.categories || r.categories.includes("built-in")) && (this.processLexingErrors(i, a, r), r.stopAfterLexingErrors && a.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === Es.LexingError;
    }) || (this.processParsingErrors(i, a, r), r.stopAfterParsingErrors && a.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === Es.ParsingError;
    })) || (this.processLinkingErrors(e, a, r), r.stopAfterLinkingErrors && a.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === Es.LinkingError;
    }))))
      return a;
    try {
      a.push(...await this.validateAst(i.value, r, n));
    } catch (s) {
      if (H3(s))
        throw s;
      console.error("An error occurred during validation:", s);
    }
    return await _a(n), a;
  }
  processLexingErrors(e, r, n) {
    var i, a, s;
    const o = [...e.lexerErrors, ...(a = (i = e.lexerReport) === null || i === void 0 ? void 0 : i.diagnostics) !== null && a !== void 0 ? a : []];
    for (const l of o) {
      const u = (s = l.severity) !== null && s !== void 0 ? s : "error", h = {
        severity: C7(u),
        range: {
          start: {
            line: l.line - 1,
            character: l.column - 1
          },
          end: {
            line: l.line - 1,
            character: l.column + l.length - 1
          }
        },
        message: l.message,
        data: wZe(u),
        source: this.getSource()
      };
      r.push(h);
    }
  }
  processParsingErrors(e, r, n) {
    for (const i of e.parserErrors) {
      let a;
      if (isNaN(i.token.startOffset)) {
        if ("previousToken" in i) {
          const s = i.previousToken;
          if (isNaN(s.startOffset)) {
            const o = { line: 0, character: 0 };
            a = { start: o, end: o };
          } else {
            const o = { line: s.endLine - 1, character: s.endColumn };
            a = { start: o, end: o };
          }
        }
      } else
        a = BA(i.token);
      if (a) {
        const s = {
          severity: C7("error"),
          range: a,
          message: i.message,
          data: Tg(Es.ParsingError),
          source: this.getSource()
        };
        r.push(s);
      }
    }
  }
  processLinkingErrors(e, r, n) {
    for (const i of e.references) {
      const a = i.error;
      if (a) {
        const s = {
          node: a.container,
          property: a.property,
          index: a.index,
          data: {
            code: Es.LinkingError,
            containerType: a.container.$type,
            property: a.property,
            refText: a.reference.$refText
          }
        };
        r.push(this.toDiagnostic("error", a.message, s));
      }
    }
  }
  async validateAst(e, r, n = on.CancellationToken.None) {
    const i = [], a = (s, o, l) => {
      i.push(this.toDiagnostic(s, o, l));
    };
    return await this.validateAstBefore(e, r, a, n), await this.validateAstNodes(e, r, a, n), await this.validateAstAfter(e, r, a, n), i;
  }
  async validateAstBefore(e, r, n, i = on.CancellationToken.None) {
    var a;
    const s = this.validationRegistry.checksBefore;
    for (const o of s)
      await _a(i), await o(e, n, (a = r.categories) !== null && a !== void 0 ? a : [], i);
  }
  async validateAstNodes(e, r, n, i = on.CancellationToken.None) {
    await Promise.all(Gf(e).map(async (a) => {
      await _a(i);
      const s = this.validationRegistry.getChecks(a.$type, r.categories);
      for (const o of s)
        await o(a, n, i);
    }));
  }
  async validateAstAfter(e, r, n, i = on.CancellationToken.None) {
    var a;
    const s = this.validationRegistry.checksAfter;
    for (const o of s)
      await _a(i), await o(e, n, (a = r.categories) !== null && a !== void 0 ? a : [], i);
  }
  toDiagnostic(e, r, n) {
    return {
      message: r,
      range: xZe(n),
      severity: C7(e),
      code: n.code,
      codeDescription: n.codeDescription,
      tags: n.tags,
      relatedInformation: n.relatedInformation,
      data: n.data,
      source: this.getSource()
    };
  }
  getSource() {
    return this.metadata.languageId;
  }
}
function xZe(t) {
  if (t.range)
    return t.range;
  let e;
  return typeof t.property == "string" ? e = rse(t.node.$cstNode, t.property, t.index) : typeof t.keyword == "string" && (e = G$e(t.node.$cstNode, t.keyword, t.index)), e ?? (e = t.node.$cstNode), e ? e.range : {
    start: { line: 0, character: 0 },
    end: { line: 0, character: 0 }
  };
}
function C7(t) {
  switch (t) {
    case "error":
      return 1;
    case "warning":
      return 2;
    case "info":
      return 3;
    case "hint":
      return 4;
    default:
      throw new Error("Invalid diagnostic severity: " + t);
  }
}
function wZe(t) {
  switch (t) {
    case "error":
      return Tg(Es.LexingError);
    case "warning":
      return Tg(Es.LexingWarning);
    case "info":
      return Tg(Es.LexingInfo);
    case "hint":
      return Tg(Es.LexingHint);
    default:
      throw new Error("Invalid diagnostic severity: " + t);
  }
}
var Es;
(function(t) {
  t.LexingError = "lexing-error", t.LexingWarning = "lexing-warning", t.LexingInfo = "lexing-info", t.LexingHint = "lexing-hint", t.ParsingError = "parsing-error", t.LinkingError = "linking-error";
})(Es || (Es = {}));
class TZe {
  constructor(e) {
    this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider;
  }
  createDescription(e, r, n) {
    const i = n ?? Sc(e);
    r ?? (r = this.nameProvider.getName(e));
    const a = this.astNodeLocator.getAstNodePath(e);
    if (!r)
      throw new Error(`Node at path ${a} has no name.`);
    let s;
    const o = () => {
      var l;
      return s ?? (s = Wb((l = this.nameProvider.getNameNode(e)) !== null && l !== void 0 ? l : e.$cstNode));
    };
    return {
      node: e,
      name: r,
      get nameSegment() {
        return o();
      },
      selectionSegment: Wb(e.$cstNode),
      type: e.$type,
      documentUri: i.uri,
      path: a
    };
  }
}
class EZe {
  constructor(e) {
    this.nodeLocator = e.workspace.AstNodeLocator;
  }
  async createDescriptions(e, r = on.CancellationToken.None) {
    const n = [], i = e.parseResult.value;
    for (const a of Gf(i))
      await _a(r), Zae(a).filter((s) => !Ky(s)).forEach((s) => {
        const o = this.createDescription(s);
        o && n.push(o);
      });
    return n;
  }
  createDescription(e) {
    const r = e.reference.$nodeDescription, n = e.reference.$refNode;
    if (!r || !n)
      return;
    const i = Sc(e.container).uri;
    return {
      sourceUri: i,
      sourcePath: this.nodeLocator.getAstNodePath(e.container),
      targetUri: r.documentUri,
      targetPath: r.path,
      segment: Wb(n),
      local: Mc.equals(r.documentUri, i)
    };
  }
}
class SZe {
  constructor() {
    this.segmentSeparator = "/", this.indexSeparator = "@";
  }
  getAstNodePath(e) {
    if (e.$container) {
      const r = this.getAstNodePath(e.$container), n = this.getPathSegment(e);
      return r + this.segmentSeparator + n;
    }
    return "";
  }
  getPathSegment({ $containerProperty: e, $containerIndex: r }) {
    if (!e)
      throw new Error("Missing '$containerProperty' in AST node.");
    return r !== void 0 ? e + this.indexSeparator + r : e;
  }
  getAstNode(e, r) {
    return r.split(this.segmentSeparator).reduce((i, a) => {
      if (!i || a.length === 0)
        return i;
      const s = a.indexOf(this.indexSeparator);
      if (s > 0) {
        const o = a.substring(0, s), l = parseInt(a.substring(s + 1)), u = i[o];
        return u?.[l];
      }
      return i[a];
    }, e);
  }
}
var kZe = sle();
class CZe {
  constructor(e) {
    this._ready = new BI(), this.settings = {}, this.workspaceConfig = !1, this.onConfigurationSectionUpdateEmitter = new kZe.Emitter(), this.serviceRegistry = e.ServiceRegistry;
  }
  get ready() {
    return this._ready.promise;
  }
  initialize(e) {
    var r, n;
    this.workspaceConfig = (n = (r = e.capabilities.workspace) === null || r === void 0 ? void 0 : r.configuration) !== null && n !== void 0 ? n : !1;
  }
  async initialized(e) {
    if (this.workspaceConfig) {
      if (e.register) {
        const r = this.serviceRegistry.all;
        e.register({
          // Listen to configuration changes for all languages
          section: r.map((n) => this.toSectionName(n.LanguageMetaData.languageId))
        });
      }
      if (e.fetchConfiguration) {
        const r = this.serviceRegistry.all.map((i) => ({
          // Fetch the configuration changes for all languages
          section: this.toSectionName(i.LanguageMetaData.languageId)
        })), n = await e.fetchConfiguration(r);
        r.forEach((i, a) => {
          this.updateSectionConfiguration(i.section, n[a]);
        });
      }
    }
    this._ready.resolve();
  }
  /**
   *  Updates the cached configurations using the `change` notification parameters.
   *
   * @param change The parameters of a change configuration notification.
   * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
   */
  updateConfiguration(e) {
    e.settings && Object.keys(e.settings).forEach((r) => {
      const n = e.settings[r];
      this.updateSectionConfiguration(r, n), this.onConfigurationSectionUpdateEmitter.fire({ section: r, configuration: n });
    });
  }
  updateSectionConfiguration(e, r) {
    this.settings[e] = r;
  }
  /**
  * Returns a configuration value stored for the given language.
  *
  * @param language The language id
  * @param configuration Configuration name
  */
  async getConfiguration(e, r) {
    await this.ready;
    const n = this.toSectionName(e);
    if (this.settings[n])
      return this.settings[n][r];
  }
  toSectionName(e) {
    return `${e}`;
  }
  get onConfigurationSectionUpdate() {
    return this.onConfigurationSectionUpdateEmitter.event;
  }
}
var Yg;
(function(t) {
  function e(r) {
    return {
      dispose: async () => await r()
    };
  }
  t.create = e;
})(Yg || (Yg = {}));
class _Ze {
  constructor(e) {
    this.updateBuildOptions = {
      // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)
      validation: {
        categories: ["built-in", "fast"]
      }
    }, this.updateListeners = [], this.buildPhaseListeners = new vx(), this.documentPhaseListeners = new vx(), this.buildState = /* @__PURE__ */ new Map(), this.documentBuildWaiters = /* @__PURE__ */ new Map(), this.currentState = Qr.Changed, this.langiumDocuments = e.workspace.LangiumDocuments, this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.textDocuments = e.workspace.TextDocuments, this.indexManager = e.workspace.IndexManager, this.serviceRegistry = e.ServiceRegistry;
  }
  async build(e, r = {}, n = on.CancellationToken.None) {
    var i, a;
    for (const s of e) {
      const o = s.uri.toString();
      if (s.state === Qr.Validated) {
        if (typeof r.validation == "boolean" && r.validation)
          s.state = Qr.IndexedReferences, s.diagnostics = void 0, this.buildState.delete(o);
        else if (typeof r.validation == "object") {
          const l = this.buildState.get(o), u = (i = l?.result) === null || i === void 0 ? void 0 : i.validationChecks;
          if (u) {
            const f = ((a = r.validation.categories) !== null && a !== void 0 ? a : yx.all).filter((d) => !u.includes(d));
            f.length > 0 && (this.buildState.set(o, {
              completed: !1,
              options: {
                validation: Object.assign(Object.assign({}, r.validation), { categories: f })
              },
              result: l.result
            }), s.state = Qr.IndexedReferences);
          }
        }
      } else
        this.buildState.delete(o);
    }
    this.currentState = Qr.Changed, await this.emitUpdate(e.map((s) => s.uri), []), await this.buildDocuments(e, r, n);
  }
  async update(e, r, n = on.CancellationToken.None) {
    this.currentState = Qr.Changed;
    for (const s of r)
      this.langiumDocuments.deleteDocument(s), this.buildState.delete(s.toString()), this.indexManager.remove(s);
    for (const s of e) {
      if (!this.langiumDocuments.invalidateDocument(s)) {
        const l = this.langiumDocumentFactory.fromModel({ $type: "INVALID" }, s);
        l.state = Qr.Changed, this.langiumDocuments.addDocument(l);
      }
      this.buildState.delete(s.toString());
    }
    const i = hi(e).concat(r).map((s) => s.toString()).toSet();
    this.langiumDocuments.all.filter((s) => !i.has(s.uri.toString()) && this.shouldRelink(s, i)).forEach((s) => {
      this.serviceRegistry.getServices(s.uri).references.Linker.unlink(s), s.state = Math.min(s.state, Qr.ComputedScopes), s.diagnostics = void 0;
    }), await this.emitUpdate(e, r), await _a(n);
    const a = this.sortDocuments(this.langiumDocuments.all.filter((s) => {
      var o;
      return s.state < Qr.Linked || !(!((o = this.buildState.get(s.uri.toString())) === null || o === void 0) && o.completed);
    }).toArray());
    await this.buildDocuments(a, this.updateBuildOptions, n);
  }
  async emitUpdate(e, r) {
    await Promise.all(this.updateListeners.map((n) => n(e, r)));
  }
  /**
   * Sort the given documents by priority. By default, documents with an open text document are prioritized.
   * This is useful to ensure that visible documents show their diagnostics before all other documents.
   *
   * This improves the responsiveness in large workspaces as users usually don't care about diagnostics
   * in files that are currently not opened in the editor.
   */
  sortDocuments(e) {
    let r = 0, n = e.length - 1;
    for (; r < n; ) {
      for (; r < e.length && this.hasTextDocument(e[r]); )
        r++;
      for (; n >= 0 && !this.hasTextDocument(e[n]); )
        n--;
      r < n && ([e[r], e[n]] = [e[n], e[r]]);
    }
    return e;
  }
  hasTextDocument(e) {
    var r;
    return !!(!((r = this.textDocuments) === null || r === void 0) && r.get(e.uri));
  }
  /**
   * Check whether the given document should be relinked after changes were found in the given URIs.
   */
  shouldRelink(e, r) {
    return e.references.some((n) => n.error !== void 0) ? !0 : this.indexManager.isAffected(e, r);
  }
  onUpdate(e) {
    return this.updateListeners.push(e), Yg.create(() => {
      const r = this.updateListeners.indexOf(e);
      r >= 0 && this.updateListeners.splice(r, 1);
    });
  }
  /**
   * Build the given documents by stepping through all build phases. If a document's state indicates
   * that a certain build phase is already done, the phase is skipped for that document.
   *
   * @param documents The documents to build.
   * @param options the {@link BuildOptions} to use.
   * @param cancelToken A cancellation token that can be used to cancel the build.
   * @returns A promise that resolves when the build is done.
   */
  async buildDocuments(e, r, n) {
    this.prepareBuild(e, r), await this.runCancelable(e, Qr.Parsed, n, (a) => this.langiumDocumentFactory.update(a, n)), await this.runCancelable(e, Qr.IndexedContent, n, (a) => this.indexManager.updateContent(a, n)), await this.runCancelable(e, Qr.ComputedScopes, n, async (a) => {
      const s = this.serviceRegistry.getServices(a.uri).references.ScopeComputation;
      a.precomputedScopes = await s.computeLocalScopes(a, n);
    }), await this.runCancelable(e, Qr.Linked, n, (a) => this.serviceRegistry.getServices(a.uri).references.Linker.link(a, n)), await this.runCancelable(e, Qr.IndexedReferences, n, (a) => this.indexManager.updateReferences(a, n));
    const i = e.filter((a) => this.shouldValidate(a));
    await this.runCancelable(i, Qr.Validated, n, (a) => this.validate(a, n));
    for (const a of e) {
      const s = this.buildState.get(a.uri.toString());
      s && (s.completed = !0);
    }
  }
  /**
   * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document
   *
   * @param documents collection of documents to be built
   * @param options the {@link BuildOptions} to use
   */
  prepareBuild(e, r) {
    for (const n of e) {
      const i = n.uri.toString(), a = this.buildState.get(i);
      (!a || a.completed) && this.buildState.set(i, {
        completed: !1,
        options: r,
        result: a?.result
      });
    }
  }
  /**
   * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.
   *
   * @param documents The array of documents to process.
   * @param targetState The target {@link DocumentState} to bring the documents to.
   * @param cancelToken A token that can be used to cancel the operation.
   * @param callback A function to be called for each document.
   * @returns A promise that resolves when all documents have been processed or the operation is canceled.
   * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.
   */
  async runCancelable(e, r, n, i) {
    const a = e.filter((o) => o.state < r);
    for (const o of a)
      await _a(n), await i(o), o.state = r, await this.notifyDocumentPhase(o, r, n);
    const s = e.filter((o) => o.state === r);
    await this.notifyBuildPhase(s, r, n), this.currentState = r;
  }
  onBuildPhase(e, r) {
    return this.buildPhaseListeners.add(e, r), Yg.create(() => {
      this.buildPhaseListeners.delete(e, r);
    });
  }
  onDocumentPhase(e, r) {
    return this.documentPhaseListeners.add(e, r), Yg.create(() => {
      this.documentPhaseListeners.delete(e, r);
    });
  }
  waitUntil(e, r, n) {
    let i;
    if (r && "path" in r ? i = r : n = r, n ?? (n = on.CancellationToken.None), i) {
      const a = this.langiumDocuments.getDocument(i);
      if (a && a.state > e)
        return Promise.resolve(i);
    }
    return this.currentState >= e ? Promise.resolve(void 0) : n.isCancellationRequested ? Promise.reject(mx) : new Promise((a, s) => {
      const o = this.onBuildPhase(e, () => {
        if (o.dispose(), l.dispose(), i) {
          const u = this.langiumDocuments.getDocument(i);
          a(u?.uri);
        } else
          a(void 0);
      }), l = n.onCancellationRequested(() => {
        o.dispose(), l.dispose(), s(mx);
      });
    });
  }
  async notifyDocumentPhase(e, r, n) {
    const a = this.documentPhaseListeners.get(r).slice();
    for (const s of a)
      try {
        await s(e, n);
      } catch (o) {
        if (!H3(o))
          throw o;
      }
  }
  async notifyBuildPhase(e, r, n) {
    if (e.length === 0)
      return;
    const a = this.buildPhaseListeners.get(r).slice();
    for (const s of a)
      await _a(n), await s(e, n);
  }
  /**
   * Determine whether the given document should be validated during a build. The default
   * implementation checks the `validation` property of the build options. If it's set to `true`
   * or a `ValidationOptions` object, the document is included in the validation phase.
   */
  shouldValidate(e) {
    return !!this.getBuildOptions(e).validation;
  }
  /**
   * Run validation checks on the given document and store the resulting diagnostics in the document.
   * If the document already contains diagnostics, the new ones are added to the list.
   */
  async validate(e, r) {
    var n, i;
    const a = this.serviceRegistry.getServices(e.uri).validation.DocumentValidator, s = this.getBuildOptions(e).validation, o = typeof s == "object" ? s : void 0, l = await a.validateDocument(e, o, r);
    e.diagnostics ? e.diagnostics.push(...l) : e.diagnostics = l;
    const u = this.buildState.get(e.uri.toString());
    if (u) {
      (n = u.result) !== null && n !== void 0 || (u.result = {});
      const h = (i = o?.categories) !== null && i !== void 0 ? i : yx.all;
      u.result.validationChecks ? u.result.validationChecks.push(...h) : u.result.validationChecks = [...h];
    }
  }
  getBuildOptions(e) {
    var r, n;
    return (n = (r = this.buildState.get(e.uri.toString())) === null || r === void 0 ? void 0 : r.options) !== null && n !== void 0 ? n : {};
  }
}
class AZe {
  constructor(e) {
    this.symbolIndex = /* @__PURE__ */ new Map(), this.symbolByTypeIndex = new fZe(), this.referenceIndex = /* @__PURE__ */ new Map(), this.documents = e.workspace.LangiumDocuments, this.serviceRegistry = e.ServiceRegistry, this.astReflection = e.AstReflection;
  }
  findAllReferences(e, r) {
    const n = Sc(e).uri, i = [];
    return this.referenceIndex.forEach((a) => {
      a.forEach((s) => {
        Mc.equals(s.targetUri, n) && s.targetPath === r && i.push(s);
      });
    }), hi(i);
  }
  allElements(e, r) {
    let n = hi(this.symbolIndex.keys());
    return r && (n = n.filter((i) => !r || r.has(i))), n.map((i) => this.getFileDescriptions(i, e)).flat();
  }
  getFileDescriptions(e, r) {
    var n;
    return r ? this.symbolByTypeIndex.get(e, r, () => {
      var a;
      return ((a = this.symbolIndex.get(e)) !== null && a !== void 0 ? a : []).filter((o) => this.astReflection.isSubtype(o.type, r));
    }) : (n = this.symbolIndex.get(e)) !== null && n !== void 0 ? n : [];
  }
  remove(e) {
    const r = e.toString();
    this.symbolIndex.delete(r), this.symbolByTypeIndex.clear(r), this.referenceIndex.delete(r);
  }
  async updateContent(e, r = on.CancellationToken.None) {
    const i = await this.serviceRegistry.getServices(e.uri).references.ScopeComputation.computeExports(e, r), a = e.uri.toString();
    this.symbolIndex.set(a, i), this.symbolByTypeIndex.clear(a);
  }
  async updateReferences(e, r = on.CancellationToken.None) {
    const i = await this.serviceRegistry.getServices(e.uri).workspace.ReferenceDescriptionProvider.createDescriptions(e, r);
    this.referenceIndex.set(e.uri.toString(), i);
  }
  isAffected(e, r) {
    const n = this.referenceIndex.get(e.uri.toString());
    return n ? n.some((i) => !i.local && r.has(i.targetUri.toString())) : !1;
  }
}
class LZe {
  constructor(e) {
    this.initialBuildOptions = {}, this._ready = new BI(), this.serviceRegistry = e.ServiceRegistry, this.langiumDocuments = e.workspace.LangiumDocuments, this.documentBuilder = e.workspace.DocumentBuilder, this.fileSystemProvider = e.workspace.FileSystemProvider, this.mutex = e.workspace.WorkspaceLock;
  }
  get ready() {
    return this._ready.promise;
  }
  get workspaceFolders() {
    return this.folders;
  }
  initialize(e) {
    var r;
    this.folders = (r = e.workspaceFolders) !== null && r !== void 0 ? r : void 0;
  }
  initialized(e) {
    return this.mutex.write((r) => {
      var n;
      return this.initializeWorkspace((n = this.folders) !== null && n !== void 0 ? n : [], r);
    });
  }
  async initializeWorkspace(e, r = on.CancellationToken.None) {
    const n = await this.performStartup(e);
    await _a(r), await this.documentBuilder.build(n, this.initialBuildOptions, r);
  }
  /**
   * Performs the uninterruptable startup sequence of the workspace manager.
   * This methods loads all documents in the workspace and other documents and returns them.
   */
  async performStartup(e) {
    const r = this.serviceRegistry.all.flatMap((a) => a.LanguageMetaData.fileExtensions), n = [], i = (a) => {
      n.push(a), this.langiumDocuments.hasDocument(a.uri) || this.langiumDocuments.addDocument(a);
    };
    return await this.loadAdditionalDocuments(e, i), await Promise.all(e.map((a) => [a, this.getRootFolder(a)]).map(async (a) => this.traverseFolder(...a, r, i))), this._ready.resolve(), n;
  }
  /**
   * Load all additional documents that shall be visible in the context of the given workspace
   * folders and add them to the collector. This can be used to include built-in libraries of
   * your language, which can be either loaded from provided files or constructed in memory.
   */
  loadAdditionalDocuments(e, r) {
    return Promise.resolve();
  }
  /**
   * Determine the root folder of the source documents in the given workspace folder.
   * The default implementation returns the URI of the workspace folder, but you can override
   * this to return a subfolder like `src` instead.
   */
  getRootFolder(e) {
    return dh.parse(e.uri);
  }
  /**
   * Traverse the file system folder identified by the given URI and its subfolders. All
   * contained files that match the file extensions are added to the collector.
   */
  async traverseFolder(e, r, n, i) {
    const a = await this.fileSystemProvider.readDirectory(r);
    await Promise.all(a.map(async (s) => {
      if (this.includeEntry(e, s, n)) {
        if (s.isDirectory)
          await this.traverseFolder(e, s.uri, n, i);
        else if (s.isFile) {
          const o = await this.langiumDocuments.getOrCreateDocument(s.uri);
          i(o);
        }
      }
    }));
  }
  /**
   * Determine whether the given folder entry shall be included while indexing the workspace.
   */
  includeEntry(e, r, n) {
    const i = Mc.basename(r.uri);
    if (i.startsWith("."))
      return !1;
    if (r.isDirectory)
      return i !== "node_modules" && i !== "out";
    if (r.isFile) {
      const a = Mc.extname(r.uri);
      return n.includes(a);
    }
    return !1;
  }
}
class RZe {
  buildUnexpectedCharactersMessage(e, r, n, i, a) {
    return e8.buildUnexpectedCharactersMessage(e, r, n, i, a);
  }
  buildUnableToPopLexerModeMessage(e) {
    return e8.buildUnableToPopLexerModeMessage(e);
  }
}
const IZe = { mode: "full" };
class MZe {
  constructor(e) {
    this.errorMessageProvider = e.parser.LexerErrorMessageProvider, this.tokenBuilder = e.parser.TokenBuilder;
    const r = this.tokenBuilder.buildTokens(e.Grammar, {
      caseInsensitive: e.LanguageMetaData.caseInsensitive
    });
    this.tokenTypes = this.toTokenTypeDictionary(r);
    const n = kW(r) ? Object.values(r) : r, i = e.LanguageMetaData.mode === "production";
    this.chevrotainLexer = new ha(n, {
      positionTracking: "full",
      skipValidations: i,
      errorMessageProvider: this.errorMessageProvider
    });
  }
  get definition() {
    return this.tokenTypes;
  }
  tokenize(e, r = IZe) {
    var n, i, a;
    const s = this.chevrotainLexer.tokenize(e);
    return {
      tokens: s.tokens,
      errors: s.errors,
      hidden: (n = s.groups.hidden) !== null && n !== void 0 ? n : [],
      report: (a = (i = this.tokenBuilder).flushLexingReport) === null || a === void 0 ? void 0 : a.call(i, e)
    };
  }
  toTokenTypeDictionary(e) {
    if (kW(e))
      return e;
    const r = hle(e) ? Object.values(e.modes).flat() : e, n = {};
    return r.forEach((i) => n[i.name] = i), n;
  }
}
function NZe(t) {
  return Array.isArray(t) && (t.length === 0 || "name" in t[0]);
}
function hle(t) {
  return t && "modes" in t && "defaultMode" in t;
}
function kW(t) {
  return !NZe(t) && !hle(t);
}
function DZe(t, e, r) {
  let n, i;
  typeof t == "string" ? (i = e, n = r) : (i = t.range.start, n = e), i || (i = Cr.create(0, 0));
  const a = fle(t), s = FI(n), o = $Ze({
    lines: a,
    position: i,
    options: s
  });
  return GZe({
    index: 0,
    tokens: o,
    position: i
  });
}
function OZe(t, e) {
  const r = FI(e), n = fle(t);
  if (n.length === 0)
    return !1;
  const i = n[0], a = n[n.length - 1], s = r.start, o = r.end;
  return !!s?.exec(i) && !!o?.exec(a);
}
function fle(t) {
  let e = "";
  return typeof t == "string" ? e = t : e = t.text, e.split(L$e);
}
const CW = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy, PZe = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
function $Ze(t) {
  var e, r, n;
  const i = [];
  let a = t.position.line, s = t.position.character;
  for (let o = 0; o < t.lines.length; o++) {
    const l = o === 0, u = o === t.lines.length - 1;
    let h = t.lines[o], f = 0;
    if (l && t.options.start) {
      const p = (e = t.options.start) === null || e === void 0 ? void 0 : e.exec(h);
      p && (f = p.index + p[0].length);
    } else {
      const p = (r = t.options.line) === null || r === void 0 ? void 0 : r.exec(h);
      p && (f = p.index + p[0].length);
    }
    if (u) {
      const p = (n = t.options.end) === null || n === void 0 ? void 0 : n.exec(h);
      p && (h = h.substring(0, p.index));
    }
    if (h = h.substring(0, qZe(h)), C8(h, f) >= h.length) {
      if (i.length > 0) {
        const p = Cr.create(a, s);
        i.push({
          type: "break",
          content: "",
          range: gr.create(p, p)
        });
      }
    } else {
      CW.lastIndex = f;
      const p = CW.exec(h);
      if (p) {
        const g = p[0], m = p[1], v = Cr.create(a, s + f), y = Cr.create(a, s + f + g.length);
        i.push({
          type: "tag",
          content: m,
          range: gr.create(v, y)
        }), f += g.length, f = C8(h, f);
      }
      if (f < h.length) {
        const g = h.substring(f), m = Array.from(g.matchAll(PZe));
        i.push(...BZe(m, g, a, s + f));
      }
    }
    a++, s = 0;
  }
  return i.length > 0 && i[i.length - 1].type === "break" ? i.slice(0, -1) : i;
}
function BZe(t, e, r, n) {
  const i = [];
  if (t.length === 0) {
    const a = Cr.create(r, n), s = Cr.create(r, n + e.length);
    i.push({
      type: "text",
      content: e,
      range: gr.create(a, s)
    });
  } else {
    let a = 0;
    for (const o of t) {
      const l = o.index, u = e.substring(a, l);
      u.length > 0 && i.push({
        type: "text",
        content: e.substring(a, l),
        range: gr.create(Cr.create(r, a + n), Cr.create(r, l + n))
      });
      let h = u.length + 1;
      const f = o[1];
      if (i.push({
        type: "inline-tag",
        content: f,
        range: gr.create(Cr.create(r, a + h + n), Cr.create(r, a + h + f.length + n))
      }), h += f.length, o.length === 4) {
        h += o[2].length;
        const d = o[3];
        i.push({
          type: "text",
          content: d,
          range: gr.create(Cr.create(r, a + h + n), Cr.create(r, a + h + d.length + n))
        });
      } else
        i.push({
          type: "text",
          content: "",
          range: gr.create(Cr.create(r, a + h + n), Cr.create(r, a + h + n))
        });
      a = l + o[0].length;
    }
    const s = e.substring(a);
    s.length > 0 && i.push({
      type: "text",
      content: s,
      range: gr.create(Cr.create(r, a + n), Cr.create(r, a + n + s.length))
    });
  }
  return i;
}
const FZe = /\S/, zZe = /\s*$/;
function C8(t, e) {
  const r = t.substring(e).match(FZe);
  return r ? e + r.index : t.length;
}
function qZe(t) {
  const e = t.match(zZe);
  if (e && typeof e.index == "number")
    return e.index;
}
function GZe(t) {
  var e, r, n, i;
  const a = Cr.create(t.position.line, t.position.character);
  if (t.tokens.length === 0)
    return new _W([], gr.create(a, a));
  const s = [];
  for (; t.index < t.tokens.length; ) {
    const u = UZe(t, s[s.length - 1]);
    u && s.push(u);
  }
  const o = (r = (e = s[0]) === null || e === void 0 ? void 0 : e.range.start) !== null && r !== void 0 ? r : a, l = (i = (n = s[s.length - 1]) === null || n === void 0 ? void 0 : n.range.end) !== null && i !== void 0 ? i : a;
  return new _W(s, gr.create(o, l));
}
function UZe(t, e) {
  const r = t.tokens[t.index];
  if (r.type === "tag")
    return ple(t, !1);
  if (r.type === "text" || r.type === "inline-tag")
    return dle(t);
  VZe(r, e), t.index++;
}
function VZe(t, e) {
  if (e) {
    const r = new mle("", t.range);
    "inlines" in e ? e.inlines.push(r) : e.content.inlines.push(r);
  }
}
function dle(t) {
  let e = t.tokens[t.index];
  const r = e;
  let n = e;
  const i = [];
  for (; e && e.type !== "break" && e.type !== "tag"; )
    i.push(HZe(t)), n = e, e = t.tokens[t.index];
  return new _8(i, gr.create(r.range.start, n.range.end));
}
function HZe(t) {
  return t.tokens[t.index].type === "inline-tag" ? ple(t, !0) : gle(t);
}
function ple(t, e) {
  const r = t.tokens[t.index++], n = r.content.substring(1), i = t.tokens[t.index];
  if (i?.type === "text")
    if (e) {
      const a = gle(t);
      return new A7(n, new _8([a], a.range), e, gr.create(r.range.start, a.range.end));
    } else {
      const a = dle(t);
      return new A7(n, a, e, gr.create(r.range.start, a.range.end));
    }
  else {
    const a = r.range;
    return new A7(n, new _8([], a), e, a);
  }
}
function gle(t) {
  const e = t.tokens[t.index++];
  return new mle(e.content, e.range);
}
function FI(t) {
  if (!t)
    return FI({
      start: "/**",
      end: "*/",
      line: "*"
    });
  const { start: e, end: r, line: n } = t;
  return {
    start: _7(e, !0),
    end: _7(r, !1),
    line: _7(n, !0)
  };
}
function _7(t, e) {
  if (typeof t == "string" || typeof t == "object") {
    const r = typeof t == "string" ? g3(t) : t.source;
    return e ? new RegExp(`^\\s*${r}`) : new RegExp(`\\s*${r}\\s*$`);
  } else
    return t;
}
class _W {
  constructor(e, r) {
    this.elements = e, this.range = r;
  }
  getTag(e) {
    return this.getAllTags().find((r) => r.name === e);
  }
  getTags(e) {
    return this.getAllTags().filter((r) => r.name === e);
  }
  getAllTags() {
    return this.elements.filter((e) => "name" in e);
  }
  toString() {
    let e = "";
    for (const r of this.elements)
      if (e.length === 0)
        e = r.toString();
      else {
        const n = r.toString();
        e += AW(e) + n;
      }
    return e.trim();
  }
  toMarkdown(e) {
    let r = "";
    for (const n of this.elements)
      if (r.length === 0)
        r = n.toMarkdown(e);
      else {
        const i = n.toMarkdown(e);
        r += AW(r) + i;
      }
    return r.trim();
  }
}
class A7 {
  constructor(e, r, n, i) {
    this.name = e, this.content = r, this.inline = n, this.range = i;
  }
  toString() {
    let e = `@${this.name}`;
    const r = this.content.toString();
    return this.content.inlines.length === 1 ? e = `${e} ${r}` : this.content.inlines.length > 1 && (e = `${e}
${r}`), this.inline ? `{${e}}` : e;
  }
  toMarkdown(e) {
    var r, n;
    return (n = (r = e?.renderTag) === null || r === void 0 ? void 0 : r.call(e, this)) !== null && n !== void 0 ? n : this.toMarkdownDefault(e);
  }
  toMarkdownDefault(e) {
    const r = this.content.toMarkdown(e);
    if (this.inline) {
      const a = WZe(this.name, r, e ?? {});
      if (typeof a == "string")
        return a;
    }
    let n = "";
    e?.tag === "italic" || e?.tag === void 0 ? n = "*" : e?.tag === "bold" ? n = "**" : e?.tag === "bold-italic" && (n = "***");
    let i = `${n}@${this.name}${n}`;
    return this.content.inlines.length === 1 ? i = `${i} \u2014 ${r}` : this.content.inlines.length > 1 && (i = `${i}
${r}`), this.inline ? `{${i}}` : i;
  }
}
function WZe(t, e, r) {
  var n, i;
  if (t === "linkplain" || t === "linkcode" || t === "link") {
    const a = e.indexOf(" ");
    let s = e;
    if (a > 0) {
      const l = C8(e, a);
      s = e.substring(l), e = e.substring(0, a);
    }
    return (t === "linkcode" || t === "link" && r.link === "code") && (s = `\`${s}\``), (i = (n = r.renderLink) === null || n === void 0 ? void 0 : n.call(r, e, s)) !== null && i !== void 0 ? i : YZe(e, s);
  }
}
function YZe(t, e) {
  try {
    return dh.parse(t, !0), `[${e}](${t})`;
  } catch {
    return t;
  }
}
class _8 {
  constructor(e, r) {
    this.inlines = e, this.range = r;
  }
  toString() {
    let e = "";
    for (let r = 0; r < this.inlines.length; r++) {
      const n = this.inlines[r], i = this.inlines[r + 1];
      e += n.toString(), i && i.range.start.line > n.range.start.line && (e += `
`);
    }
    return e;
  }
  toMarkdown(e) {
    let r = "";
    for (let n = 0; n < this.inlines.length; n++) {
      const i = this.inlines[n], a = this.inlines[n + 1];
      r += i.toMarkdown(e), a && a.range.start.line > i.range.start.line && (r += `
`);
    }
    return r;
  }
}
class mle {
  constructor(e, r) {
    this.text = e, this.range = r;
  }
  toString() {
    return this.text;
  }
  toMarkdown() {
    return this.text;
  }
}
function AW(t) {
  return t.endsWith(`
`) ? `
` : `

`;
}
class XZe {
  constructor(e) {
    this.indexManager = e.shared.workspace.IndexManager, this.commentProvider = e.documentation.CommentProvider;
  }
  getDocumentation(e) {
    const r = this.commentProvider.getComment(e);
    if (r && OZe(r))
      return DZe(r).toMarkdown({
        renderLink: (i, a) => this.documentationLinkRenderer(e, i, a),
        renderTag: (i) => this.documentationTagRenderer(e, i)
      });
  }
  documentationLinkRenderer(e, r, n) {
    var i;
    const a = (i = this.findNameInPrecomputedScopes(e, r)) !== null && i !== void 0 ? i : this.findNameInGlobalScope(e, r);
    if (a && a.nameSegment) {
      const s = a.nameSegment.range.start.line + 1, o = a.nameSegment.range.start.character + 1, l = a.documentUri.with({ fragment: `L${s},${o}` });
      return `[${n}](${l.toString()})`;
    } else
      return;
  }
  documentationTagRenderer(e, r) {
  }
  findNameInPrecomputedScopes(e, r) {
    const i = Sc(e).precomputedScopes;
    if (!i)
      return;
    let a = e;
    do {
      const o = i.get(a).find((l) => l.name === r);
      if (o)
        return o;
      a = a.$container;
    } while (a);
  }
  findNameInGlobalScope(e, r) {
    return this.indexManager.allElements().find((i) => i.name === r);
  }
}
class jZe {
  constructor(e) {
    this.grammarConfig = () => e.parser.GrammarConfig;
  }
  getComment(e) {
    var r;
    return gZe(e) ? e.$comment : (r = a$e(e.$cstNode, this.grammarConfig().multilineCommentRules)) === null || r === void 0 ? void 0 : r.text;
  }
}
class KZe {
  constructor(e) {
    this.syncParser = e.parser.LangiumParser;
  }
  parse(e, r) {
    return Promise.resolve(this.syncParser.parse(e));
  }
}
class ZZe {
  constructor() {
    this.previousTokenSource = new on.CancellationTokenSource(), this.writeQueue = [], this.readQueue = [], this.done = !0;
  }
  write(e) {
    this.cancelWrite();
    const r = tZe();
    return this.previousTokenSource = r, this.enqueue(this.writeQueue, e, r.token);
  }
  read(e) {
    return this.enqueue(this.readQueue, e);
  }
  enqueue(e, r, n = on.CancellationToken.None) {
    const i = new BI(), a = {
      action: r,
      deferred: i,
      cancellationToken: n
    };
    return e.push(a), this.performNextOperation(), i.promise;
  }
  async performNextOperation() {
    if (!this.done)
      return;
    const e = [];
    if (this.writeQueue.length > 0)
      e.push(this.writeQueue.shift());
    else if (this.readQueue.length > 0)
      e.push(...this.readQueue.splice(0, this.readQueue.length));
    else
      return;
    this.done = !1, await Promise.all(e.map(async ({ action: r, deferred: n, cancellationToken: i }) => {
      try {
        const a = await Promise.resolve().then(() => r(i));
        n.resolve(a);
      } catch (a) {
        H3(a) ? n.resolve(void 0) : n.reject(a);
      }
    })), this.done = !0, this.performNextOperation();
  }
  cancelWrite() {
    this.previousTokenSource.cancel();
  }
}
class QZe {
  constructor(e) {
    this.grammarElementIdMap = new TW(), this.tokenTypeIdMap = new TW(), this.grammar = e.Grammar, this.lexer = e.parser.Lexer, this.linker = e.references.Linker;
  }
  dehydrate(e) {
    return {
      lexerErrors: e.lexerErrors,
      lexerReport: e.lexerReport ? this.dehydrateLexerReport(e.lexerReport) : void 0,
      // We need to create shallow copies of the errors
      // The original errors inherit from the `Error` class, which is not transferable across worker threads
      parserErrors: e.parserErrors.map((r) => Object.assign(Object.assign({}, r), { message: r.message })),
      value: this.dehydrateAstNode(e.value, this.createDehyrationContext(e.value))
    };
  }
  dehydrateLexerReport(e) {
    return e;
  }
  createDehyrationContext(e) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const i of Gf(e))
      r.set(i, {});
    if (e.$cstNode)
      for (const i of $A(e.$cstNode))
        n.set(i, {});
    return {
      astNodes: r,
      cstNodes: n
    };
  }
  dehydrateAstNode(e, r) {
    const n = r.astNodes.get(e);
    n.$type = e.$type, n.$containerIndex = e.$containerIndex, n.$containerProperty = e.$containerProperty, e.$cstNode !== void 0 && (n.$cstNode = this.dehydrateCstNode(e.$cstNode, r));
    for (const [i, a] of Object.entries(e))
      if (!i.startsWith("$"))
        if (Array.isArray(a)) {
          const s = [];
          n[i] = s;
          for (const o of a)
            Ci(o) ? s.push(this.dehydrateAstNode(o, r)) : oo(o) ? s.push(this.dehydrateReference(o, r)) : s.push(o);
        } else Ci(a) ? n[i] = this.dehydrateAstNode(a, r) : oo(a) ? n[i] = this.dehydrateReference(a, r) : a !== void 0 && (n[i] = a);
    return n;
  }
  dehydrateReference(e, r) {
    const n = {};
    return n.$refText = e.$refText, e.$refNode && (n.$refNode = r.cstNodes.get(e.$refNode)), n;
  }
  dehydrateCstNode(e, r) {
    const n = r.cstNodes.get(e);
    return Uae(e) ? n.fullText = e.fullText : n.grammarSource = this.getGrammarElementId(e.grammarSource), n.hidden = e.hidden, n.astNode = r.astNodes.get(e.astNode), N1(e) ? n.content = e.content.map((i) => this.dehydrateCstNode(i, r)) : Gae(e) && (n.tokenType = e.tokenType.name, n.offset = e.offset, n.length = e.length, n.startLine = e.range.start.line, n.startColumn = e.range.start.character, n.endLine = e.range.end.line, n.endColumn = e.range.end.character), n;
  }
  hydrate(e) {
    const r = e.value, n = this.createHydrationContext(r);
    return "$cstNode" in r && this.hydrateCstNode(r.$cstNode, n), {
      lexerErrors: e.lexerErrors,
      lexerReport: e.lexerReport,
      parserErrors: e.parserErrors,
      value: this.hydrateAstNode(r, n)
    };
  }
  createHydrationContext(e) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const a of Gf(e))
      r.set(a, {});
    let i;
    if (e.$cstNode)
      for (const a of $A(e.$cstNode)) {
        let s;
        "fullText" in a ? (s = new joe(a.fullText), i = s) : "content" in a ? s = new PI() : "tokenType" in a && (s = this.hydrateCstLeafNode(a)), s && (n.set(a, s), s.root = i);
      }
    return {
      astNodes: r,
      cstNodes: n
    };
  }
  hydrateAstNode(e, r) {
    const n = r.astNodes.get(e);
    n.$type = e.$type, n.$containerIndex = e.$containerIndex, n.$containerProperty = e.$containerProperty, e.$cstNode && (n.$cstNode = r.cstNodes.get(e.$cstNode));
    for (const [i, a] of Object.entries(e))
      if (!i.startsWith("$"))
        if (Array.isArray(a)) {
          const s = [];
          n[i] = s;
          for (const o of a)
            Ci(o) ? s.push(this.setParent(this.hydrateAstNode(o, r), n)) : oo(o) ? s.push(this.hydrateReference(o, n, i, r)) : s.push(o);
        } else Ci(a) ? n[i] = this.setParent(this.hydrateAstNode(a, r), n) : oo(a) ? n[i] = this.hydrateReference(a, n, i, r) : a !== void 0 && (n[i] = a);
    return n;
  }
  setParent(e, r) {
    return e.$container = r, e;
  }
  hydrateReference(e, r, n, i) {
    return this.linker.buildReference(r, n, i.cstNodes.get(e.$refNode), e.$refText);
  }
  hydrateCstNode(e, r, n = 0) {
    const i = r.cstNodes.get(e);
    if (typeof e.grammarSource == "number" && (i.grammarSource = this.getGrammarElement(e.grammarSource)), i.astNode = r.astNodes.get(e.astNode), N1(i))
      for (const a of e.content) {
        const s = this.hydrateCstNode(a, r, n++);
        i.content.push(s);
      }
    return i;
  }
  hydrateCstLeafNode(e) {
    const r = this.getTokenType(e.tokenType), n = e.offset, i = e.length, a = e.startLine, s = e.startColumn, o = e.endLine, l = e.endColumn, u = e.hidden;
    return new w8(n, i, {
      start: {
        line: a,
        character: s
      },
      end: {
        line: o,
        character: l
      }
    }, r, u);
  }
  getTokenType(e) {
    return this.lexer.definition[e];
  }
  getGrammarElementId(e) {
    if (e)
      return this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.get(e);
  }
  getGrammarElement(e) {
    return this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.getKey(e);
  }
  createGrammarElementIdMap() {
    let e = 0;
    for (const r of Gf(this.grammar))
      o$e(r) && this.grammarElementIdMap.set(r, e++);
  }
}
function Qc(t) {
  return {
    documentation: {
      CommentProvider: (e) => new jZe(e),
      DocumentationProvider: (e) => new XZe(e)
    },
    parser: {
      AsyncParser: (e) => new KZe(e),
      GrammarConfig: (e) => Q$e(e),
      LangiumParser: (e) => jKe(e),
      CompletionParser: (e) => XKe(e),
      ValueConverter: () => new ile(),
      TokenBuilder: () => new nle(),
      Lexer: (e) => new MZe(e),
      ParserErrorMessageProvider: () => new Qoe(),
      LexerErrorMessageProvider: () => new RZe()
    },
    workspace: {
      AstNodeLocator: () => new SZe(),
      AstNodeDescriptionProvider: (e) => new TZe(e),
      ReferenceDescriptionProvider: (e) => new EZe(e)
    },
    references: {
      Linker: (e) => new aZe(e),
      NameProvider: () => new oZe(),
      ScopeProvider: (e) => new pZe(e),
      ScopeComputation: (e) => new cZe(e),
      References: (e) => new lZe(e)
    },
    serializer: {
      Hydrator: (e) => new QZe(e),
      JsonSerializer: (e) => new mZe(e)
    },
    validation: {
      DocumentValidator: (e) => new bZe(e),
      ValidationRegistry: (e) => new yZe(e)
    },
    shared: () => t.shared
  };
}
function Jc(t) {
  return {
    ServiceRegistry: (e) => new vZe(e),
    workspace: {
      LangiumDocuments: (e) => new iZe(e),
      LangiumDocumentFactory: (e) => new nZe(e),
      DocumentBuilder: (e) => new _Ze(e),
      IndexManager: (e) => new AZe(e),
      WorkspaceManager: (e) => new LZe(e),
      FileSystemProvider: (e) => t.fileSystemProvider(e),
      WorkspaceLock: () => new ZZe(),
      ConfigurationProvider: (e) => new CZe(e)
    }
  };
}
var LW;
(function(t) {
  t.merge = (e, r) => bx(bx({}, e), r);
})(LW || (LW = {}));
function Ii(t, e, r, n, i, a, s, o, l) {
  const u = [t, e, r, n, i, a, s, o, l].reduce(bx, {});
  return vle(u);
}
const JZe = Symbol("isProxy");
function vle(t, e) {
  const r = new Proxy({}, {
    deleteProperty: () => !1,
    set: () => {
      throw new Error("Cannot set property on injected service container");
    },
    get: (n, i) => i === JZe ? !0 : IW(n, i, t, e || r),
    getOwnPropertyDescriptor: (n, i) => (IW(n, i, t, e || r), Object.getOwnPropertyDescriptor(n, i)),
    // used by for..in
    has: (n, i) => i in t,
    // used by ..in..
    ownKeys: () => [...Object.getOwnPropertyNames(t)]
    // used by for..in
  });
  return r;
}
const RW = Symbol();
function IW(t, e, r, n) {
  if (e in t) {
    if (t[e] instanceof Error)
      throw new Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: t[e] });
    if (t[e] === RW)
      throw new Error('Cycle detected. Please make "' + String(e) + '" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');
    return t[e];
  } else if (e in r) {
    const i = r[e];
    t[e] = RW;
    try {
      t[e] = typeof i == "function" ? i(n) : vle(i, n);
    } catch (a) {
      throw t[e] = a instanceof Error ? a : void 0, a;
    }
    return t[e];
  } else
    return;
}
function bx(t, e) {
  if (e) {
    for (const [r, n] of Object.entries(e))
      if (n !== void 0) {
        const i = t[r];
        i !== null && n !== null && typeof i == "object" && typeof n == "object" ? t[r] = bx(i, n) : t[r] = n;
      }
  }
  return t;
}
class eQe {
  readFile() {
    throw new Error("No file system is available.");
  }
  async readDirectory() {
    return [];
  }
}
const eu = {
  fileSystemProvider: () => new eQe()
}, tQe = {
  Grammar: () => {
  },
  LanguageMetaData: () => ({
    caseInsensitive: !1,
    fileExtensions: [".langium"],
    languageId: "langium"
  })
}, rQe = {
  AstReflection: () => new Kae()
};
function nQe() {
  const t = Ii(Jc(eu), rQe), e = Ii(Qc({ shared: t }), tQe);
  return t.ServiceRegistry.register(e), e;
}
function Hh(t) {
  var e;
  const r = nQe(), n = r.serializer.JsonSerializer.deserialize(t);
  return r.shared.workspace.LangiumDocumentFactory.fromModel(n, dh.parse(`memory://${(e = n.name) !== null && e !== void 0 ? e : "grammar"}.langium`)), n;
}
var iQe = Object.defineProperty, gt = (t, e) => iQe(t, "name", { value: e, configurable: !0 }), MW = "Statement", a2 = "Architecture";
function aQe(t) {
  return zs.isInstance(t, a2);
}
gt(aQe, "isArchitecture");
var ry = "Axis", Eg = "Branch";
function sQe(t) {
  return zs.isInstance(t, Eg);
}
gt(sQe, "isBranch");
var ny = "Checkout", iy = "CherryPicking", L7 = "ClassDefStatement", Sg = "Commit";
function oQe(t) {
  return zs.isInstance(t, Sg);
}
gt(oQe, "isCommit");
var R7 = "Curve", I7 = "Edge", M7 = "Entry", kg = "GitGraph";
function lQe(t) {
  return zs.isInstance(t, kg);
}
gt(lQe, "isGitGraph");
var N7 = "Group", s2 = "Info";
function cQe(t) {
  return zs.isInstance(t, s2);
}
gt(cQe, "isInfo");
var ay = "Item", D7 = "Junction", Cg = "Merge";
function uQe(t) {
  return zs.isInstance(t, Cg);
}
gt(uQe, "isMerge");
var O7 = "Option", o2 = "Packet";
function hQe(t) {
  return zs.isInstance(t, o2);
}
gt(hQe, "isPacket");
var l2 = "PacketBlock";
function fQe(t) {
  return zs.isInstance(t, l2);
}
gt(fQe, "isPacketBlock");
var c2 = "Pie";
function dQe(t) {
  return zs.isInstance(t, c2);
}
gt(dQe, "isPie");
var u2 = "PieSection";
function pQe(t) {
  return zs.isInstance(t, u2);
}
gt(pQe, "isPieSection");
var P7 = "Radar", $7 = "Service", h2 = "Treemap";
function gQe(t) {
  return zs.isInstance(t, h2);
}
gt(gQe, "isTreemap");
var B7 = "TreemapRow", sy = "Direction", oy = "Leaf", ly = "Section", sd, yle = (sd = class extends qae {
  getAllTypes() {
    return [a2, ry, Eg, ny, iy, L7, Sg, R7, sy, I7, M7, kg, N7, s2, ay, D7, oy, Cg, O7, o2, l2, c2, u2, P7, ly, $7, MW, h2, B7];
  }
  computeIsSubtype(e, r) {
    switch (e) {
      case Eg:
      case ny:
      case iy:
      case Sg:
      case Cg:
        return this.isSubtype(MW, r);
      case sy:
        return this.isSubtype(kg, r);
      case oy:
      case ly:
        return this.isSubtype(ay, r);
      default:
        return !1;
    }
  }
  getReferenceType(e) {
    const r = `${e.container.$type}:${e.property}`;
    switch (r) {
      case "Entry:axis":
        return ry;
      default:
        throw new Error(`${r} is not a valid reference id.`);
    }
  }
  getTypeMetaData(e) {
    switch (e) {
      case a2:
        return {
          name: a2,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "edges", defaultValue: [] },
            { name: "groups", defaultValue: [] },
            { name: "junctions", defaultValue: [] },
            { name: "services", defaultValue: [] },
            { name: "title" }
          ]
        };
      case ry:
        return {
          name: ry,
          properties: [
            { name: "label" },
            { name: "name" }
          ]
        };
      case Eg:
        return {
          name: Eg,
          properties: [
            { name: "name" },
            { name: "order" }
          ]
        };
      case ny:
        return {
          name: ny,
          properties: [
            { name: "branch" }
          ]
        };
      case iy:
        return {
          name: iy,
          properties: [
            { name: "id" },
            { name: "parent" },
            { name: "tags", defaultValue: [] }
          ]
        };
      case L7:
        return {
          name: L7,
          properties: [
            { name: "className" },
            { name: "styleText" }
          ]
        };
      case Sg:
        return {
          name: Sg,
          properties: [
            { name: "id" },
            { name: "message" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      case R7:
        return {
          name: R7,
          properties: [
            { name: "entries", defaultValue: [] },
            { name: "label" },
            { name: "name" }
          ]
        };
      case I7:
        return {
          name: I7,
          properties: [
            { name: "lhsDir" },
            { name: "lhsGroup", defaultValue: !1 },
            { name: "lhsId" },
            { name: "lhsInto", defaultValue: !1 },
            { name: "rhsDir" },
            { name: "rhsGroup", defaultValue: !1 },
            { name: "rhsId" },
            { name: "rhsInto", defaultValue: !1 },
            { name: "title" }
          ]
        };
      case M7:
        return {
          name: M7,
          properties: [
            { name: "axis" },
            { name: "value" }
          ]
        };
      case kg:
        return {
          name: kg,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      case N7:
        return {
          name: N7,
          properties: [
            { name: "icon" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      case s2:
        return {
          name: s2,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" }
          ]
        };
      case ay:
        return {
          name: ay,
          properties: [
            { name: "classSelector" },
            { name: "name" }
          ]
        };
      case D7:
        return {
          name: D7,
          properties: [
            { name: "id" },
            { name: "in" }
          ]
        };
      case Cg:
        return {
          name: Cg,
          properties: [
            { name: "branch" },
            { name: "id" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      case O7:
        return {
          name: O7,
          properties: [
            { name: "name" },
            { name: "value", defaultValue: !1 }
          ]
        };
      case o2:
        return {
          name: o2,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "blocks", defaultValue: [] },
            { name: "title" }
          ]
        };
      case l2:
        return {
          name: l2,
          properties: [
            { name: "bits" },
            { name: "end" },
            { name: "label" },
            { name: "start" }
          ]
        };
      case c2:
        return {
          name: c2,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "sections", defaultValue: [] },
            { name: "showData", defaultValue: !1 },
            { name: "title" }
          ]
        };
      case u2:
        return {
          name: u2,
          properties: [
            { name: "label" },
            { name: "value" }
          ]
        };
      case P7:
        return {
          name: P7,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "axes", defaultValue: [] },
            { name: "curves", defaultValue: [] },
            { name: "options", defaultValue: [] },
            { name: "title" }
          ]
        };
      case $7:
        return {
          name: $7,
          properties: [
            { name: "icon" },
            { name: "iconText" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      case h2:
        return {
          name: h2,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" },
            { name: "TreemapRows", defaultValue: [] }
          ]
        };
      case B7:
        return {
          name: B7,
          properties: [
            { name: "indent" },
            { name: "item" }
          ]
        };
      case sy:
        return {
          name: sy,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "dir" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      case oy:
        return {
          name: oy,
          properties: [
            { name: "classSelector" },
            { name: "name" },
            { name: "value" }
          ]
        };
      case ly:
        return {
          name: ly,
          properties: [
            { name: "classSelector" },
            { name: "name" }
          ]
        };
      default:
        return {
          name: e,
          properties: []
        };
    }
  }
}, gt(sd, "MermaidAstReflection"), sd), zs = new yle(), NW, mQe = /* @__PURE__ */ gt(() => NW ?? (NW = Hh(`{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Info","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@7"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "InfoGrammar"), DW, vQe = /* @__PURE__ */ gt(() => DW ?? (DW = Hh(`{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Packet","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"packet"},{"$type":"Keyword","value":"packet-beta"}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}],"cardinality":"?"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"+"},{"$type":"Assignment","feature":"bits","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]}]},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@9"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PacketGrammar"), OW, yQe = /* @__PURE__ */ gt(() => OW ?? (OW = Hh(`{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Pie","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"FLOAT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?(0|[1-9][0-9]*)(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@2"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@3"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@11"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@12"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PieGrammar"), PW, bQe = /* @__PURE__ */ gt(() => PW ?? (PW = Hh(`{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Architecture","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"LeftPort","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"RightPort","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Arrow","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\{group\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@18"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@19"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\([\\\\w-:]+\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\[[\\\\w ]+\\\\]/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "ArchitectureGrammar"), $W, xQe = /* @__PURE__ */ gt(() => $W ?? ($W = Hh(`{"$type":"Grammar","isDeclared":true,"name":"GitGraph","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"GitGraph","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@14"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"REFERENCE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\w([-\\\\./\\\\w]*[-\\\\w])?/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "GitGraphGrammar"), BW, wQe = /* @__PURE__ */ gt(() => BW ?? (BW = Hh(`{"$type":"Grammar","isDeclared":true,"name":"Radar","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Radar","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":"radar-beta:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},{"$type":"Group","elements":[{"$type":"Keyword","value":"axis"},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"curve"},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Label","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"["},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}},{"$type":"Keyword","value":"]"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Axis","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Curve","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"},{"$type":"Keyword","value":"{"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Keyword","value":"}"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Entries","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"DetailedEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"axis","operator":"=","terminal":{"$type":"CrossReference","type":{"$ref":"#/rules@2"},"terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"deprecatedSyntax":false}},{"$type":"Keyword","value":":","cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"NumberEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Option","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"showLegend"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"ticks"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"max"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"min"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"graticule"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"GRATICULE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"circle"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"polygon"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@16"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"interfaces":[{"$type":"Interface","name":"Entry","attributes":[{"$type":"TypeAttribute","name":"axis","isOptional":true,"type":{"$type":"ReferenceType","referenceType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@2"}}}},{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"types":[],"usedGrammars":[]}`)), "RadarGrammar"), FW, TQe = /* @__PURE__ */ gt(() => FW ?? (FW = Hh(`{"$type":"Grammar","isDeclared":true,"name":"Treemap","rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"ParserRule","entry":true,"name":"Treemap","returnType":{"$ref":"#/interfaces@4"},"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"TreemapRows","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"TREEMAP_KEYWORD","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap-beta"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"CLASS_DEF","definition":{"$type":"RegexToken","regex":"/classDef\\\\s+([a-zA-Z_][a-zA-Z0-9_]+)(?:\\\\s+([^;\\\\r\\\\n]*))?(?:;)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STYLE_SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":::"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"COMMA","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":","}},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WS","definition":{"$type":"RegexToken","regex":"/[ \\\\t]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"ML_COMMENT","definition":{"$type":"RegexToken","regex":"/\\\\%\\\\%[^\\\\n]*/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"NL","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false},{"$type":"ParserRule","name":"TreemapRow","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"indent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"item","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"ClassDef","dataType":"string","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Item","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Section","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Leaf","returnType":{"$ref":"#/interfaces@2"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INDENTATION","definition":{"$type":"RegexToken","regex":"/[ \\\\t]{1,}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID2","definition":{"$type":"RegexToken","regex":"/[a-zA-Z_][a-zA-Z0-9_]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER2","definition":{"$type":"RegexToken","regex":"/[0-9_\\\\.\\\\,]+/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"MyNumber","dataType":"number","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"STRING2","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"interfaces":[{"$type":"Interface","name":"Item","attributes":[{"$type":"TypeAttribute","name":"name","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"classSelector","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]},{"$type":"Interface","name":"Section","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[]},{"$type":"Interface","name":"Leaf","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}]},{"$type":"Interface","name":"ClassDefStatement","attributes":[{"$type":"TypeAttribute","name":"className","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"styleText","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false}],"superTypes":[]},{"$type":"Interface","name":"Treemap","attributes":[{"$type":"TypeAttribute","name":"TreemapRows","type":{"$type":"ArrayType","elementType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@14"}}},"isOptional":false},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[],"$comment":"/**\\n * Treemap grammar for Langium\\n * Converted from mindmap grammar\\n *\\n * The ML_COMMENT and NL hidden terminals handle whitespace, comments, and newlines\\n * before the treemap keyword, allowing for empty lines and comments before the\\n * treemap declaration.\\n */"}`)), "TreemapGrammar"), EQe = {
  languageId: "info",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, SQe = {
  languageId: "packet",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, kQe = {
  languageId: "pie",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, CQe = {
  languageId: "architecture",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, _Qe = {
  languageId: "gitGraph",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, AQe = {
  languageId: "radar",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, LQe = {
  languageId: "treemap",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, Wh = {
  AstReflection: /* @__PURE__ */ gt(() => new yle(), "AstReflection")
}, RQe = {
  Grammar: /* @__PURE__ */ gt(() => mQe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => EQe, "LanguageMetaData"),
  parser: {}
}, IQe = {
  Grammar: /* @__PURE__ */ gt(() => vQe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => SQe, "LanguageMetaData"),
  parser: {}
}, MQe = {
  Grammar: /* @__PURE__ */ gt(() => yQe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => kQe, "LanguageMetaData"),
  parser: {}
}, NQe = {
  Grammar: /* @__PURE__ */ gt(() => bQe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => CQe, "LanguageMetaData"),
  parser: {}
}, DQe = {
  Grammar: /* @__PURE__ */ gt(() => xQe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => _Qe, "LanguageMetaData"),
  parser: {}
}, OQe = {
  Grammar: /* @__PURE__ */ gt(() => wQe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => AQe, "LanguageMetaData"),
  parser: {}
}, PQe = {
  Grammar: /* @__PURE__ */ gt(() => TQe(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ gt(() => LQe, "LanguageMetaData"),
  parser: {}
}, $Qe = /accDescr(?:[\t ]*:([^\n\r]*)|\s*{([^}]*)})/, BQe = /accTitle[\t ]*:([^\n\r]*)/, FQe = /title([\t ][^\n\r]*|)/, zQe = {
  ACC_DESCR: $Qe,
  ACC_TITLE: BQe,
  TITLE: FQe
}, od, W3 = (od = class extends ile {
  runConverter(e, r, n) {
    let i = this.runCommonConverter(e, r, n);
    return i === void 0 && (i = this.runCustomConverter(e, r, n)), i === void 0 ? super.runConverter(e, r, n) : i;
  }
  runCommonConverter(e, r, n) {
    const i = zQe[e.name];
    if (i === void 0)
      return;
    const a = i.exec(r);
    if (a !== null) {
      if (a[1] !== void 0)
        return a[1].trim().replace(/[\t ]{2,}/gm, " ");
      if (a[2] !== void 0)
        return a[2].replace(/^\s*/gm, "").replace(/\s+$/gm, "").replace(/[\t ]{2,}/gm, " ").replace(/[\n\r]{2,}/gm, `
`);
    }
  }
}, gt(od, "AbstractMermaidValueConverter"), od), ld, Y3 = (ld = class extends W3 {
  runCustomConverter(e, r, n) {
  }
}, gt(ld, "CommonValueConverter"), ld), cd, tu = (cd = class extends nle {
  constructor(e) {
    super(), this.keywords = new Set(e);
  }
  buildKeywordTokens(e, r, n) {
    const i = super.buildKeywordTokens(e, r, n);
    return i.forEach((a) => {
      this.keywords.has(a.name) && a.PATTERN !== void 0 && (a.PATTERN = new RegExp(a.PATTERN.toString() + "(?:(?=%%)|(?!\\S))"));
    }), i;
  }
}, gt(cd, "AbstractMermaidTokenBuilder"), cd), ud;
ud = class extends tu {
}, gt(ud, "CommonTokenBuilder");
var hd, qQe = (hd = class extends tu {
  constructor() {
    super(["gitGraph"]);
  }
}, gt(hd, "GitGraphTokenBuilder"), hd), ble = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new qQe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new Y3(), "ValueConverter")
  }
};
function xle(t = eu) {
  const e = Ii(
    Jc(t),
    Wh
  ), r = Ii(
    Qc({ shared: e }),
    DQe,
    ble
  );
  return e.ServiceRegistry.register(r), { shared: e, GitGraph: r };
}
gt(xle, "createGitGraphServices");
var fd, GQe = (fd = class extends tu {
  constructor() {
    super(["info", "showInfo"]);
  }
}, gt(fd, "InfoTokenBuilder"), fd), wle = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new GQe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new Y3(), "ValueConverter")
  }
};
function Tle(t = eu) {
  const e = Ii(
    Jc(t),
    Wh
  ), r = Ii(
    Qc({ shared: e }),
    RQe,
    wle
  );
  return e.ServiceRegistry.register(r), { shared: e, Info: r };
}
gt(Tle, "createInfoServices");
var dd, UQe = (dd = class extends tu {
  constructor() {
    super(["packet"]);
  }
}, gt(dd, "PacketTokenBuilder"), dd), Ele = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new UQe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new Y3(), "ValueConverter")
  }
};
function Sle(t = eu) {
  const e = Ii(
    Jc(t),
    Wh
  ), r = Ii(
    Qc({ shared: e }),
    IQe,
    Ele
  );
  return e.ServiceRegistry.register(r), { shared: e, Packet: r };
}
gt(Sle, "createPacketServices");
var pd, VQe = (pd = class extends tu {
  constructor() {
    super(["pie", "showData"]);
  }
}, gt(pd, "PieTokenBuilder"), pd), gd, HQe = (gd = class extends W3 {
  runCustomConverter(e, r, n) {
    if (e.name === "PIE_SECTION_LABEL")
      return r.replace(/"/g, "").trim();
  }
}, gt(gd, "PieValueConverter"), gd), kle = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new VQe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new HQe(), "ValueConverter")
  }
};
function Cle(t = eu) {
  const e = Ii(
    Jc(t),
    Wh
  ), r = Ii(
    Qc({ shared: e }),
    MQe,
    kle
  );
  return e.ServiceRegistry.register(r), { shared: e, Pie: r };
}
gt(Cle, "createPieServices");
var md, WQe = (md = class extends tu {
  constructor() {
    super(["architecture"]);
  }
}, gt(md, "ArchitectureTokenBuilder"), md), vd, YQe = (vd = class extends W3 {
  runCustomConverter(e, r, n) {
    if (e.name === "ARCH_ICON")
      return r.replace(/[()]/g, "").trim();
    if (e.name === "ARCH_TEXT_ICON")
      return r.replace(/["()]/g, "");
    if (e.name === "ARCH_TITLE")
      return r.replace(/[[\]]/g, "").trim();
  }
}, gt(vd, "ArchitectureValueConverter"), vd), _le = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new WQe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new YQe(), "ValueConverter")
  }
};
function Ale(t = eu) {
  const e = Ii(
    Jc(t),
    Wh
  ), r = Ii(
    Qc({ shared: e }),
    NQe,
    _le
  );
  return e.ServiceRegistry.register(r), { shared: e, Architecture: r };
}
gt(Ale, "createArchitectureServices");
var yd, XQe = (yd = class extends tu {
  constructor() {
    super(["radar-beta"]);
  }
}, gt(yd, "RadarTokenBuilder"), yd), Lle = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new XQe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new Y3(), "ValueConverter")
  }
};
function Rle(t = eu) {
  const e = Ii(
    Jc(t),
    Wh
  ), r = Ii(
    Qc({ shared: e }),
    OQe,
    Lle
  );
  return e.ServiceRegistry.register(r), { shared: e, Radar: r };
}
gt(Rle, "createRadarServices");
var bd, jQe = (bd = class extends tu {
  constructor() {
    super(["treemap"]);
  }
}, gt(bd, "TreemapTokenBuilder"), bd), KQe = /classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/, xd, ZQe = (xd = class extends W3 {
  runCustomConverter(e, r, n) {
    if (e.name === "NUMBER2")
      return parseFloat(r.replace(/,/g, ""));
    if (e.name === "SEPARATOR")
      return r.substring(1, r.length - 1);
    if (e.name === "STRING2")
      return r.substring(1, r.length - 1);
    if (e.name === "INDENTATION")
      return r.length;
    if (e.name === "ClassDef") {
      if (typeof r != "string")
        return r;
      const i = KQe.exec(r);
      if (i)
        return {
          $type: "ClassDefStatement",
          className: i[1],
          styleText: i[2] || void 0
        };
    }
  }
}, gt(xd, "TreemapValueConverter"), xd);
function Ile(t) {
  const e = t.validation.TreemapValidator, r = t.validation.ValidationRegistry;
  if (r) {
    const n = {
      Treemap: e.checkSingleRoot.bind(e)
      // Remove unused validation for TreemapRow
    };
    r.register(n, e);
  }
}
gt(Ile, "registerValidationChecks");
var wd, QQe = (wd = class {
  /**
   * Validates that a treemap has only one root node.
   * A root node is defined as a node that has no indentation.
   */
  checkSingleRoot(e, r) {
    let n;
    for (const i of e.TreemapRows)
      i.item && (n === void 0 && // Check if this is a root node (no indentation)
      i.indent === void 0 ? n = 0 : i.indent === void 0 ? r("error", "Multiple root nodes are not allowed in a treemap.", {
        node: i,
        property: "item"
      }) : n !== void 0 && n >= parseInt(i.indent, 10) && r("error", "Multiple root nodes are not allowed in a treemap.", {
        node: i,
        property: "item"
      }));
  }
}, gt(wd, "TreemapValidator"), wd), Mle = {
  parser: {
    TokenBuilder: /* @__PURE__ */ gt(() => new jQe(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ gt(() => new ZQe(), "ValueConverter")
  },
  validation: {
    TreemapValidator: /* @__PURE__ */ gt(() => new QQe(), "TreemapValidator")
  }
};
function Nle(t = eu) {
  const e = Ii(
    Jc(t),
    Wh
  ), r = Ii(
    Qc({ shared: e }),
    PQe,
    Mle
  );
  return e.ServiceRegistry.register(r), Ile(r), { shared: e, Treemap: r };
}
gt(Nle, "createTreemapServices");
var Ho = {}, JQe = {
  info: /* @__PURE__ */ gt(async () => {
    const { createInfoServices: t } = await Promise.resolve().then(() => Vlt), e = t().Info.parser.LangiumParser;
    Ho.info = e;
  }, "info"),
  packet: /* @__PURE__ */ gt(async () => {
    const { createPacketServices: t } = await Promise.resolve().then(() => Hlt), e = t().Packet.parser.LangiumParser;
    Ho.packet = e;
  }, "packet"),
  pie: /* @__PURE__ */ gt(async () => {
    const { createPieServices: t } = await Promise.resolve().then(() => Wlt), e = t().Pie.parser.LangiumParser;
    Ho.pie = e;
  }, "pie"),
  architecture: /* @__PURE__ */ gt(async () => {
    const { createArchitectureServices: t } = await Promise.resolve().then(() => Ylt), e = t().Architecture.parser.LangiumParser;
    Ho.architecture = e;
  }, "architecture"),
  gitGraph: /* @__PURE__ */ gt(async () => {
    const { createGitGraphServices: t } = await Promise.resolve().then(() => Xlt), e = t().GitGraph.parser.LangiumParser;
    Ho.gitGraph = e;
  }, "gitGraph"),
  radar: /* @__PURE__ */ gt(async () => {
    const { createRadarServices: t } = await Promise.resolve().then(() => jlt), e = t().Radar.parser.LangiumParser;
    Ho.radar = e;
  }, "radar"),
  treemap: /* @__PURE__ */ gt(async () => {
    const { createTreemapServices: t } = await Promise.resolve().then(() => Klt), e = t().Treemap.parser.LangiumParser;
    Ho.treemap = e;
  }, "treemap")
};
async function ru(t, e) {
  const r = JQe[t];
  if (!r)
    throw new Error(`Unknown diagram type: ${t}`);
  Ho[t] || await r();
  const i = Ho[t].parse(e);
  if (i.lexerErrors.length > 0 || i.parserErrors.length > 0)
    throw new eJe(i);
  return i.value;
}
gt(ru, "parse");
var Td, eJe = (Td = class extends Error {
  constructor(e) {
    const r = e.lexerErrors.map((i) => i.message).join(`
`), n = e.parserErrors.map((i) => i.message).join(`
`);
    super(`Parsing failed: ${r} ${n}`), this.result = e;
  }
}, gt(Td, "MermaidParseError"), Td), Mr = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
}, tJe = fr.gitGraph, Yh = /* @__PURE__ */ w(() => Xi({
  ...tJe,
  ...mr().gitGraph
}), "getConfig"), vt = new zae(() => {
  const t = Yh(), e = t.mainBranchName, r = t.mainBranchOrder;
  return {
    mainBranchName: e,
    commits: /* @__PURE__ */ new Map(),
    head: null,
    branchConfig: /* @__PURE__ */ new Map([[e, { name: e, order: r }]]),
    branches: /* @__PURE__ */ new Map([[e, null]]),
    currBranch: e,
    direction: "LR",
    seq: 0,
    options: {}
  };
});
function X3() {
  return MZ({ length: 7 });
}
w(X3, "getID");
function Dle(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  return t.reduce((n, i) => {
    const a = e(i);
    return r[a] || (r[a] = !0, n.push(i)), n;
  }, []);
}
w(Dle, "uniqBy");
var rJe = /* @__PURE__ */ w(function(t) {
  vt.records.direction = t;
}, "setDirection"), nJe = /* @__PURE__ */ w(function(t) {
  ae.debug("options str", t), t = t?.trim(), t = t || "{}";
  try {
    vt.records.options = JSON.parse(t);
  } catch (e) {
    ae.error("error while parsing gitGraph options", e.message);
  }
}, "setOptions"), iJe = /* @__PURE__ */ w(function() {
  return vt.records.options;
}, "getOptions"), aJe = /* @__PURE__ */ w(function(t) {
  let e = t.msg, r = t.id;
  const n = t.type;
  let i = t.tags;
  ae.info("commit", e, r, n, i), ae.debug("Entering commit:", e, r, n, i);
  const a = Yh();
  r = at.sanitizeText(r, a), e = at.sanitizeText(e, a), i = i?.map((o) => at.sanitizeText(o, a));
  const s = {
    id: r || vt.records.seq + "-" + X3(),
    message: e,
    seq: vt.records.seq++,
    type: n ?? Mr.NORMAL,
    tags: i ?? [],
    parents: vt.records.head == null ? [] : [vt.records.head.id],
    branch: vt.records.currBranch
  };
  vt.records.head = s, ae.info("main branch", a.mainBranchName), vt.records.commits.has(s.id) && ae.warn(`Commit ID ${s.id} already exists`), vt.records.commits.set(s.id, s), vt.records.branches.set(vt.records.currBranch, s.id), ae.debug("in pushCommit " + s.id);
}, "commit"), sJe = /* @__PURE__ */ w(function(t) {
  let e = t.name;
  const r = t.order;
  if (e = at.sanitizeText(e, Yh()), vt.records.branches.has(e))
    throw new Error(
      `Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${e}")`
    );
  vt.records.branches.set(e, vt.records.head != null ? vt.records.head.id : null), vt.records.branchConfig.set(e, { name: e, order: r }), Ole(e), ae.debug("in createBranch");
}, "branch"), oJe = /* @__PURE__ */ w((t) => {
  let e = t.branch, r = t.id;
  const n = t.type, i = t.tags, a = Yh();
  e = at.sanitizeText(e, a), r && (r = at.sanitizeText(r, a));
  const s = vt.records.branches.get(vt.records.currBranch), o = vt.records.branches.get(e), l = s ? vt.records.commits.get(s) : void 0, u = o ? vt.records.commits.get(o) : void 0;
  if (l && u && l.branch === e)
    throw new Error(`Cannot merge branch '${e}' into itself.`);
  if (vt.records.currBranch === e) {
    const d = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
    throw d.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ["branch abc"]
    }, d;
  }
  if (l === void 0 || !l) {
    const d = new Error(
      `Incorrect usage of "merge". Current branch (${vt.records.currBranch})has no commits`
    );
    throw d.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ["commit"]
    }, d;
  }
  if (!vt.records.branches.has(e)) {
    const d = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + e + ") does not exist"
    );
    throw d.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: [`branch ${e}`]
    }, d;
  }
  if (u === void 0 || !u) {
    const d = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + e + ") has no commits"
    );
    throw d.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ['"commit"']
    }, d;
  }
  if (l === u) {
    const d = new Error('Incorrect usage of "merge". Both branches have same head');
    throw d.hash = {
      text: `merge ${e}`,
      token: `merge ${e}`,
      expected: ["branch abc"]
    }, d;
  }
  if (r && vt.records.commits.has(r)) {
    const d = new Error(
      'Incorrect usage of "merge". Commit with id:' + r + " already exists, use different custom id"
    );
    throw d.hash = {
      text: `merge ${e} ${r} ${n} ${i?.join(" ")}`,
      token: `merge ${e} ${r} ${n} ${i?.join(" ")}`,
      expected: [
        `merge ${e} ${r}_UNIQUE ${n} ${i?.join(" ")}`
      ]
    }, d;
  }
  const h = o || "", f = {
    id: r || `${vt.records.seq}-${X3()}`,
    message: `merged branch ${e} into ${vt.records.currBranch}`,
    seq: vt.records.seq++,
    parents: vt.records.head == null ? [] : [vt.records.head.id, h],
    branch: vt.records.currBranch,
    type: Mr.MERGE,
    customType: n,
    customId: !!r,
    tags: i ?? []
  };
  vt.records.head = f, vt.records.commits.set(f.id, f), vt.records.branches.set(vt.records.currBranch, f.id), ae.debug(vt.records.branches), ae.debug("in mergeBranch");
}, "merge"), lJe = /* @__PURE__ */ w(function(t) {
  let e = t.id, r = t.targetId, n = t.tags, i = t.parent;
  ae.debug("Entering cherryPick:", e, r, n);
  const a = Yh();
  if (e = at.sanitizeText(e, a), r = at.sanitizeText(r, a), n = n?.map((l) => at.sanitizeText(l, a)), i = at.sanitizeText(i, a), !e || !vt.records.commits.has(e)) {
    const l = new Error(
      'Incorrect usage of "cherryPick". Source commit id should exist and provided'
    );
    throw l.hash = {
      text: `cherryPick ${e} ${r}`,
      token: `cherryPick ${e} ${r}`,
      expected: ["cherry-pick abc"]
    }, l;
  }
  const s = vt.records.commits.get(e);
  if (s === void 0 || !s)
    throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');
  if (i && !(Array.isArray(s.parents) && s.parents.includes(i)))
    throw new Error(
      "Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit."
    );
  const o = s.branch;
  if (s.type === Mr.MERGE && !i)
    throw new Error(
      "Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified."
    );
  if (!r || !vt.records.commits.has(r)) {
    if (o === vt.records.currBranch) {
      const f = new Error(
        'Incorrect usage of "cherryPick". Source commit is already on current branch'
      );
      throw f.hash = {
        text: `cherryPick ${e} ${r}`,
        token: `cherryPick ${e} ${r}`,
        expected: ["cherry-pick abc"]
      }, f;
    }
    const l = vt.records.branches.get(vt.records.currBranch);
    if (l === void 0 || !l) {
      const f = new Error(
        `Incorrect usage of "cherry-pick". Current branch (${vt.records.currBranch})has no commits`
      );
      throw f.hash = {
        text: `cherryPick ${e} ${r}`,
        token: `cherryPick ${e} ${r}`,
        expected: ["cherry-pick abc"]
      }, f;
    }
    const u = vt.records.commits.get(l);
    if (u === void 0 || !u) {
      const f = new Error(
        `Incorrect usage of "cherry-pick". Current branch (${vt.records.currBranch})has no commits`
      );
      throw f.hash = {
        text: `cherryPick ${e} ${r}`,
        token: `cherryPick ${e} ${r}`,
        expected: ["cherry-pick abc"]
      }, f;
    }
    const h = {
      id: vt.records.seq + "-" + X3(),
      message: `cherry-picked ${s?.message} into ${vt.records.currBranch}`,
      seq: vt.records.seq++,
      parents: vt.records.head == null ? [] : [vt.records.head.id, s.id],
      branch: vt.records.currBranch,
      type: Mr.CHERRY_PICK,
      tags: n ? n.filter(Boolean) : [
        `cherry-pick:${s.id}${s.type === Mr.MERGE ? `|parent:${i}` : ""}`
      ]
    };
    vt.records.head = h, vt.records.commits.set(h.id, h), vt.records.branches.set(vt.records.currBranch, h.id), ae.debug(vt.records.branches), ae.debug("in cherryPick");
  }
}, "cherryPick"), Ole = /* @__PURE__ */ w(function(t) {
  if (t = at.sanitizeText(t, Yh()), vt.records.branches.has(t)) {
    vt.records.currBranch = t;
    const e = vt.records.branches.get(vt.records.currBranch);
    e === void 0 || !e ? vt.records.head = null : vt.records.head = vt.records.commits.get(e) ?? null;
  } else {
    const e = new Error(
      `Trying to checkout branch which is not yet created. (Help try using "branch ${t}")`
    );
    throw e.hash = {
      text: `checkout ${t}`,
      token: `checkout ${t}`,
      expected: [`branch ${t}`]
    }, e;
  }
}, "checkout");
function A8(t, e, r) {
  const n = t.indexOf(e);
  n === -1 ? t.push(r) : t.splice(n, 1, r);
}
w(A8, "upsert");
function zI(t) {
  const e = t.reduce((i, a) => i.seq > a.seq ? i : a, t[0]);
  let r = "";
  t.forEach(function(i) {
    i === e ? r += "	*" : r += "	|";
  });
  const n = [r, e.id, e.seq];
  for (const i in vt.records.branches)
    vt.records.branches.get(i) === e.id && n.push(i);
  if (ae.debug(n.join(" ")), e.parents && e.parents.length == 2 && e.parents[0] && e.parents[1]) {
    const i = vt.records.commits.get(e.parents[0]);
    A8(t, e, i), e.parents[1] && t.push(vt.records.commits.get(e.parents[1]));
  } else {
    if (e.parents.length == 0)
      return;
    if (e.parents[0]) {
      const i = vt.records.commits.get(e.parents[0]);
      A8(t, e, i);
    }
  }
  t = Dle(t, (i) => i.id), zI(t);
}
w(zI, "prettyPrintCommitHistory");
var cJe = /* @__PURE__ */ w(function() {
  ae.debug(vt.records.commits);
  const t = Ple()[0];
  zI([t]);
}, "prettyPrint"), uJe = /* @__PURE__ */ w(function() {
  vt.reset(), In();
}, "clear"), hJe = /* @__PURE__ */ w(function() {
  return [...vt.records.branchConfig.values()].map((e, r) => e.order !== null && e.order !== void 0 ? e : {
    ...e,
    order: parseFloat(`0.${r}`)
  }).sort((e, r) => (e.order ?? 0) - (r.order ?? 0)).map(({ name: e }) => ({ name: e }));
}, "getBranchesAsObjArray"), fJe = /* @__PURE__ */ w(function() {
  return vt.records.branches;
}, "getBranches"), dJe = /* @__PURE__ */ w(function() {
  return vt.records.commits;
}, "getCommits"), Ple = /* @__PURE__ */ w(function() {
  const t = [...vt.records.commits.values()];
  return t.forEach(function(e) {
    ae.debug(e.id);
  }), t.sort((e, r) => e.seq - r.seq), t;
}, "getCommitsArray"), pJe = /* @__PURE__ */ w(function() {
  return vt.records.currBranch;
}, "getCurrentBranch"), gJe = /* @__PURE__ */ w(function() {
  return vt.records.direction;
}, "getDirection"), mJe = /* @__PURE__ */ w(function() {
  return vt.records.head;
}, "getHead"), $le = {
  commitType: Mr,
  getConfig: Yh,
  setDirection: rJe,
  setOptions: nJe,
  getOptions: iJe,
  commit: aJe,
  branch: sJe,
  merge: oJe,
  cherryPick: lJe,
  checkout: Ole,
  //reset,
  prettyPrint: cJe,
  clear: uJe,
  getBranchesAsObjArray: hJe,
  getBranches: fJe,
  getCommits: dJe,
  getCommitsArray: Ple,
  getCurrentBranch: pJe,
  getDirection: gJe,
  getHead: mJe,
  setAccTitle: Ln,
  getAccTitle: Hn,
  getAccDescription: Yn,
  setAccDescription: Wn,
  setDiagramTitle: ti,
  getDiagramTitle: Mn
}, vJe = /* @__PURE__ */ w((t, e) => {
  Ph(t, e), t.dir && e.setDirection(t.dir);
  for (const r of t.statements)
    yJe(r, e);
}, "populate"), yJe = /* @__PURE__ */ w((t, e) => {
  const n = {
    Commit: /* @__PURE__ */ w((i) => e.commit(bJe(i)), "Commit"),
    Branch: /* @__PURE__ */ w((i) => e.branch(xJe(i)), "Branch"),
    Merge: /* @__PURE__ */ w((i) => e.merge(wJe(i)), "Merge"),
    Checkout: /* @__PURE__ */ w((i) => e.checkout(TJe(i)), "Checkout"),
    CherryPicking: /* @__PURE__ */ w((i) => e.cherryPick(EJe(i)), "CherryPicking")
  }[t.$type];
  n ? n(t) : ae.error(`Unknown statement type: ${t.$type}`);
}, "parseStatement"), bJe = /* @__PURE__ */ w((t) => ({
  id: t.id,
  msg: t.message ?? "",
  type: t.type !== void 0 ? Mr[t.type] : Mr.NORMAL,
  tags: t.tags ?? void 0
}), "parseCommit"), xJe = /* @__PURE__ */ w((t) => ({
  name: t.name,
  order: t.order ?? 0
}), "parseBranch"), wJe = /* @__PURE__ */ w((t) => ({
  branch: t.branch,
  id: t.id ?? "",
  type: t.type !== void 0 ? Mr[t.type] : void 0,
  tags: t.tags ?? void 0
}), "parseMerge"), TJe = /* @__PURE__ */ w((t) => t.branch, "parseCheckout"), EJe = /* @__PURE__ */ w((t) => ({
  id: t.id,
  targetId: "",
  tags: t.tags?.length === 0 ? void 0 : t.tags,
  parent: t.parent
}), "parseCherryPicking"), SJe = {
  parse: /* @__PURE__ */ w(async (t) => {
    const e = await ru("gitGraph", t);
    ae.debug(e), vJe(e, $le);
  }, "parse")
}, kJe = Te(), Xa = kJe?.gitGraph, nc = 10, ic = 40, Ks = 4, jo = 2, ku = 8, la = /* @__PURE__ */ new Map(), fa = /* @__PURE__ */ new Map(), xx = 30, _g = /* @__PURE__ */ new Map(), wx = [], jl = 0, dr = "LR", CJe = /* @__PURE__ */ w(() => {
  la.clear(), fa.clear(), _g.clear(), jl = 0, wx = [], dr = "LR";
}, "clear"), Ble = /* @__PURE__ */ w((t) => {
  const e = document.createElementNS("http://www.w3.org/2000/svg", "text");
  return (typeof t == "string" ? t.split(/\\n|\n|<br\s*\/?>/gi) : t).forEach((n) => {
    const i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    i.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), i.setAttribute("dy", "1em"), i.setAttribute("x", "0"), i.setAttribute("class", "row"), i.textContent = n.trim(), e.appendChild(i);
  }), e;
}, "drawText"), Fle = /* @__PURE__ */ w((t) => {
  let e, r, n;
  return dr === "BT" ? (r = /* @__PURE__ */ w((i, a) => i <= a, "comparisonFunc"), n = 1 / 0) : (r = /* @__PURE__ */ w((i, a) => i >= a, "comparisonFunc"), n = 0), t.forEach((i) => {
    const a = dr === "TB" || dr == "BT" ? fa.get(i)?.y : fa.get(i)?.x;
    a !== void 0 && r(a, n) && (e = i, n = a);
  }), e;
}, "findClosestParent"), _Je = /* @__PURE__ */ w((t) => {
  let e = "", r = 1 / 0;
  return t.forEach((n) => {
    const i = fa.get(n).y;
    i <= r && (e = n, r = i);
  }), e || void 0;
}, "findClosestParentBT"), AJe = /* @__PURE__ */ w((t, e, r) => {
  let n = r, i = r;
  const a = [];
  t.forEach((s) => {
    const o = e.get(s);
    if (!o)
      throw new Error(`Commit not found for key ${s}`);
    o.parents.length ? (n = RJe(o), i = Math.max(n, i)) : a.push(o), IJe(o, n);
  }), n = i, a.forEach((s) => {
    MJe(s, n, r);
  }), t.forEach((s) => {
    const o = e.get(s);
    if (o?.parents.length) {
      const l = _Je(o.parents);
      n = fa.get(l).y - ic, n <= i && (i = n);
      const u = la.get(o.branch).pos, h = n - nc;
      fa.set(o.id, { x: u, y: h });
    }
  });
}, "setParallelBTPos"), LJe = /* @__PURE__ */ w((t) => {
  const e = Fle(t.parents.filter((n) => n !== null));
  if (!e)
    throw new Error(`Closest parent not found for commit ${t.id}`);
  const r = fa.get(e)?.y;
  if (r === void 0)
    throw new Error(`Closest parent position not found for commit ${t.id}`);
  return r;
}, "findClosestParentPos"), RJe = /* @__PURE__ */ w((t) => LJe(t) + ic, "calculateCommitPosition"), IJe = /* @__PURE__ */ w((t, e) => {
  const r = la.get(t.branch);
  if (!r)
    throw new Error(`Branch not found for commit ${t.id}`);
  const n = r.pos, i = e + nc;
  return fa.set(t.id, { x: n, y: i }), { x: n, y: i };
}, "setCommitPosition"), MJe = /* @__PURE__ */ w((t, e, r) => {
  const n = la.get(t.branch);
  if (!n)
    throw new Error(`Branch not found for commit ${t.id}`);
  const i = e + r, a = n.pos;
  fa.set(t.id, { x: a, y: i });
}, "setRootPosition"), NJe = /* @__PURE__ */ w((t, e, r, n, i, a) => {
  if (a === Mr.HIGHLIGHT)
    t.append("rect").attr("x", r.x - 10).attr("y", r.y - 10).attr("width", 20).attr("height", 20).attr(
      "class",
      `commit ${e.id} commit-highlight${i % ku} ${n}-outer`
    ), t.append("rect").attr("x", r.x - 6).attr("y", r.y - 6).attr("width", 12).attr("height", 12).attr(
      "class",
      `commit ${e.id} commit${i % ku} ${n}-inner`
    );
  else if (a === Mr.CHERRY_PICK)
    t.append("circle").attr("cx", r.x).attr("cy", r.y).attr("r", 10).attr("class", `commit ${e.id} ${n}`), t.append("circle").attr("cx", r.x - 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${e.id} ${n}`), t.append("circle").attr("cx", r.x + 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${e.id} ${n}`), t.append("line").attr("x1", r.x + 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${e.id} ${n}`), t.append("line").attr("x1", r.x - 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${e.id} ${n}`);
  else {
    const s = t.append("circle");
    if (s.attr("cx", r.x), s.attr("cy", r.y), s.attr("r", e.type === Mr.MERGE ? 9 : 10), s.attr("class", `commit ${e.id} commit${i % ku}`), a === Mr.MERGE) {
      const o = t.append("circle");
      o.attr("cx", r.x), o.attr("cy", r.y), o.attr("r", 6), o.attr(
        "class",
        `commit ${n} ${e.id} commit${i % ku}`
      );
    }
    a === Mr.REVERSE && t.append("path").attr(
      "d",
      `M ${r.x - 5},${r.y - 5}L${r.x + 5},${r.y + 5}M${r.x - 5},${r.y + 5}L${r.x + 5},${r.y - 5}`
    ).attr("class", `commit ${n} ${e.id} commit${i % ku}`);
  }
}, "drawCommitBullet"), DJe = /* @__PURE__ */ w((t, e, r, n) => {
  if (e.type !== Mr.CHERRY_PICK && (e.customId && e.type === Mr.MERGE || e.type !== Mr.MERGE) && Xa?.showCommitLabel) {
    const i = t.append("g"), a = i.insert("rect").attr("class", "commit-label-bkg"), s = i.append("text").attr("x", n).attr("y", r.y + 25).attr("class", "commit-label").text(e.id), o = s.node()?.getBBox();
    if (o && (a.attr("x", r.posWithOffset - o.width / 2 - jo).attr("y", r.y + 13.5).attr("width", o.width + 2 * jo).attr("height", o.height + 2 * jo), dr === "TB" || dr === "BT" ? (a.attr("x", r.x - (o.width + 4 * Ks + 5)).attr("y", r.y - 12), s.attr("x", r.x - (o.width + 4 * Ks)).attr("y", r.y + o.height - 12)) : s.attr("x", r.posWithOffset - o.width / 2), Xa.rotateCommitLabel))
      if (dr === "TB" || dr === "BT")
        s.attr(
          "transform",
          "rotate(-45, " + r.x + ", " + r.y + ")"
        ), a.attr(
          "transform",
          "rotate(-45, " + r.x + ", " + r.y + ")"
        );
      else {
        const l = -7.5 - (o.width + 10) / 25 * 9.5, u = 10 + o.width / 25 * 8.5;
        i.attr(
          "transform",
          "translate(" + l + ", " + u + ") rotate(-45, " + n + ", " + r.y + ")"
        );
      }
  }
}, "drawCommitLabel"), OJe = /* @__PURE__ */ w((t, e, r, n) => {
  if (e.tags.length > 0) {
    let i = 0, a = 0, s = 0;
    const o = [];
    for (const l of e.tags.reverse()) {
      const u = t.insert("polygon"), h = t.append("circle"), f = t.append("text").attr("y", r.y - 16 - i).attr("class", "tag-label").text(l), d = f.node()?.getBBox();
      if (!d)
        throw new Error("Tag bbox not found");
      a = Math.max(a, d.width), s = Math.max(s, d.height), f.attr("x", r.posWithOffset - d.width / 2), o.push({
        tag: f,
        hole: h,
        rect: u,
        yOffset: i
      }), i += 20;
    }
    for (const { tag: l, hole: u, rect: h, yOffset: f } of o) {
      const d = s / 2, p = r.y - 19.2 - f;
      if (h.attr("class", "tag-label-bkg").attr(
        "points",
        `
      ${n - a / 2 - Ks / 2},${p + jo}  
      ${n - a / 2 - Ks / 2},${p - jo}
      ${r.posWithOffset - a / 2 - Ks},${p - d - jo}
      ${r.posWithOffset + a / 2 + Ks},${p - d - jo}
      ${r.posWithOffset + a / 2 + Ks},${p + d + jo}
      ${r.posWithOffset - a / 2 - Ks},${p + d + jo}`
      ), u.attr("cy", p).attr("cx", n - a / 2 + Ks / 2).attr("r", 1.5).attr("class", "tag-hole"), dr === "TB" || dr === "BT") {
        const g = n + f;
        h.attr("class", "tag-label-bkg").attr(
          "points",
          `
        ${r.x},${g + 2}
        ${r.x},${g - 2}
        ${r.x + nc},${g - d - 2}
        ${r.x + nc + a + 4},${g - d - 2}
        ${r.x + nc + a + 4},${g + d + 2}
        ${r.x + nc},${g + d + 2}`
        ).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + n + ")"), u.attr("cx", r.x + Ks / 2).attr("cy", g).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + n + ")"), l.attr("x", r.x + 5).attr("y", g + 3).attr("transform", "translate(14,14) rotate(45, " + r.x + "," + n + ")");
      }
    }
  }
}, "drawCommitTags"), PJe = /* @__PURE__ */ w((t) => {
  switch (t.customType ?? t.type) {
    case Mr.NORMAL:
      return "commit-normal";
    case Mr.REVERSE:
      return "commit-reverse";
    case Mr.HIGHLIGHT:
      return "commit-highlight";
    case Mr.MERGE:
      return "commit-merge";
    case Mr.CHERRY_PICK:
      return "commit-cherry-pick";
    default:
      return "commit-normal";
  }
}, "getCommitClassType"), $Je = /* @__PURE__ */ w((t, e, r, n) => {
  const i = { x: 0, y: 0 };
  if (t.parents.length > 0) {
    const a = Fle(t.parents);
    if (a) {
      const s = n.get(a) ?? i;
      return e === "TB" ? s.y + ic : e === "BT" ? (n.get(t.id) ?? i).y - ic : s.x + ic;
    }
  } else
    return e === "TB" ? xx : e === "BT" ? (n.get(t.id) ?? i).y - ic : 0;
  return 0;
}, "calculatePosition"), BJe = /* @__PURE__ */ w((t, e, r) => {
  const n = dr === "BT" && r ? e : e + nc, i = dr === "TB" || dr === "BT" ? n : la.get(t.branch)?.pos, a = dr === "TB" || dr === "BT" ? la.get(t.branch)?.pos : n;
  if (a === void 0 || i === void 0)
    throw new Error(`Position were undefined for commit ${t.id}`);
  return { x: a, y: i, posWithOffset: n };
}, "getCommitPosition"), zW = /* @__PURE__ */ w((t, e, r) => {
  if (!Xa)
    throw new Error("GitGraph config not found");
  const n = t.append("g").attr("class", "commit-bullets"), i = t.append("g").attr("class", "commit-labels");
  let a = dr === "TB" || dr === "BT" ? xx : 0;
  const s = [...e.keys()], o = Xa?.parallelCommits ?? !1, l = /* @__PURE__ */ w((h, f) => {
    const d = e.get(h)?.seq, p = e.get(f)?.seq;
    return d !== void 0 && p !== void 0 ? d - p : 0;
  }, "sortKeys");
  let u = s.sort(l);
  dr === "BT" && (o && AJe(u, e, a), u = u.reverse()), u.forEach((h) => {
    const f = e.get(h);
    if (!f)
      throw new Error(`Commit not found for key ${h}`);
    o && (a = $Je(f, dr, a, fa));
    const d = BJe(f, a, o);
    if (r) {
      const p = PJe(f), g = f.customType ?? f.type, m = la.get(f.branch)?.index ?? 0;
      NJe(n, f, d, p, m, g), DJe(i, f, d, a), OJe(i, f, d, a);
    }
    dr === "TB" || dr === "BT" ? fa.set(f.id, { x: d.x, y: d.posWithOffset }) : fa.set(f.id, { x: d.posWithOffset, y: d.y }), a = dr === "BT" && o ? a + ic : a + ic + nc, a > jl && (jl = a);
  });
}, "drawCommits"), FJe = /* @__PURE__ */ w((t, e, r, n, i) => {
  const s = (dr === "TB" || dr === "BT" ? r.x < n.x : r.y < n.y) ? e.branch : t.branch, o = /* @__PURE__ */ w((u) => u.branch === s, "isOnBranchToGetCurve"), l = /* @__PURE__ */ w((u) => u.seq > t.seq && u.seq < e.seq, "isBetweenCommits");
  return [...i.values()].some((u) => l(u) && o(u));
}, "shouldRerouteArrow"), Ag = /* @__PURE__ */ w((t, e, r = 0) => {
  const n = t + Math.abs(t - e) / 2;
  if (r > 5)
    return n;
  if (wx.every((s) => Math.abs(s - n) >= 10))
    return wx.push(n), n;
  const a = Math.abs(t - e);
  return Ag(t, e - a / 5, r + 1);
}, "findLane"), zJe = /* @__PURE__ */ w((t, e, r, n) => {
  const i = fa.get(e.id), a = fa.get(r.id);
  if (i === void 0 || a === void 0)
    throw new Error(`Commit positions not found for commits ${e.id} and ${r.id}`);
  const s = FJe(e, r, i, a, n);
  let o = "", l = "", u = 0, h = 0, f = la.get(r.branch)?.index;
  r.type === Mr.MERGE && e.id !== r.parents[0] && (f = la.get(e.branch)?.index);
  let d;
  if (s) {
    o = "A 10 10, 0, 0, 0,", l = "A 10 10, 0, 0, 1,", u = 10, h = 10;
    const p = i.y < a.y ? Ag(i.y, a.y) : Ag(a.y, i.y), g = i.x < a.x ? Ag(i.x, a.x) : Ag(a.x, i.x);
    dr === "TB" ? i.x < a.x ? d = `M ${i.x} ${i.y} L ${g - u} ${i.y} ${l} ${g} ${i.y + h} L ${g} ${a.y - u} ${o} ${g + h} ${a.y} L ${a.x} ${a.y}` : (f = la.get(e.branch)?.index, d = `M ${i.x} ${i.y} L ${g + u} ${i.y} ${o} ${g} ${i.y + h} L ${g} ${a.y - u} ${l} ${g - h} ${a.y} L ${a.x} ${a.y}`) : dr === "BT" ? i.x < a.x ? d = `M ${i.x} ${i.y} L ${g - u} ${i.y} ${o} ${g} ${i.y - h} L ${g} ${a.y + u} ${l} ${g + h} ${a.y} L ${a.x} ${a.y}` : (f = la.get(e.branch)?.index, d = `M ${i.x} ${i.y} L ${g + u} ${i.y} ${l} ${g} ${i.y - h} L ${g} ${a.y + u} ${o} ${g - h} ${a.y} L ${a.x} ${a.y}`) : i.y < a.y ? d = `M ${i.x} ${i.y} L ${i.x} ${p - u} ${o} ${i.x + h} ${p} L ${a.x - u} ${p} ${l} ${a.x} ${p + h} L ${a.x} ${a.y}` : (f = la.get(e.branch)?.index, d = `M ${i.x} ${i.y} L ${i.x} ${p + u} ${l} ${i.x + h} ${p} L ${a.x - u} ${p} ${o} ${a.x} ${p - h} L ${a.x} ${a.y}`);
  } else
    o = "A 20 20, 0, 0, 0,", l = "A 20 20, 0, 0, 1,", u = 20, h = 20, dr === "TB" ? (i.x < a.x && (r.type === Mr.MERGE && e.id !== r.parents[0] ? d = `M ${i.x} ${i.y} L ${i.x} ${a.y - u} ${o} ${i.x + h} ${a.y} L ${a.x} ${a.y}` : d = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${l} ${a.x} ${i.y + h} L ${a.x} ${a.y}`), i.x > a.x && (o = "A 20 20, 0, 0, 0,", l = "A 20 20, 0, 0, 1,", u = 20, h = 20, r.type === Mr.MERGE && e.id !== r.parents[0] ? d = `M ${i.x} ${i.y} L ${i.x} ${a.y - u} ${l} ${i.x - h} ${a.y} L ${a.x} ${a.y}` : d = `M ${i.x} ${i.y} L ${a.x + u} ${i.y} ${o} ${a.x} ${i.y + h} L ${a.x} ${a.y}`), i.x === a.x && (d = `M ${i.x} ${i.y} L ${a.x} ${a.y}`)) : dr === "BT" ? (i.x < a.x && (r.type === Mr.MERGE && e.id !== r.parents[0] ? d = `M ${i.x} ${i.y} L ${i.x} ${a.y + u} ${l} ${i.x + h} ${a.y} L ${a.x} ${a.y}` : d = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${o} ${a.x} ${i.y - h} L ${a.x} ${a.y}`), i.x > a.x && (o = "A 20 20, 0, 0, 0,", l = "A 20 20, 0, 0, 1,", u = 20, h = 20, r.type === Mr.MERGE && e.id !== r.parents[0] ? d = `M ${i.x} ${i.y} L ${i.x} ${a.y + u} ${o} ${i.x - h} ${a.y} L ${a.x} ${a.y}` : d = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${o} ${a.x} ${i.y - h} L ${a.x} ${a.y}`), i.x === a.x && (d = `M ${i.x} ${i.y} L ${a.x} ${a.y}`)) : (i.y < a.y && (r.type === Mr.MERGE && e.id !== r.parents[0] ? d = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${l} ${a.x} ${i.y + h} L ${a.x} ${a.y}` : d = `M ${i.x} ${i.y} L ${i.x} ${a.y - u} ${o} ${i.x + h} ${a.y} L ${a.x} ${a.y}`), i.y > a.y && (r.type === Mr.MERGE && e.id !== r.parents[0] ? d = `M ${i.x} ${i.y} L ${a.x - u} ${i.y} ${o} ${a.x} ${i.y - h} L ${a.x} ${a.y}` : d = `M ${i.x} ${i.y} L ${i.x} ${a.y + u} ${l} ${i.x + h} ${a.y} L ${a.x} ${a.y}`), i.y === a.y && (d = `M ${i.x} ${i.y} L ${a.x} ${a.y}`));
  if (d === void 0)
    throw new Error("Line definition not found");
  t.append("path").attr("d", d).attr("class", "arrow arrow" + f % ku);
}, "drawArrow"), qJe = /* @__PURE__ */ w((t, e) => {
  const r = t.append("g").attr("class", "commit-arrows");
  [...e.keys()].forEach((n) => {
    const i = e.get(n);
    i.parents && i.parents.length > 0 && i.parents.forEach((a) => {
      zJe(r, e.get(a), i, e);
    });
  });
}, "drawArrows"), GJe = /* @__PURE__ */ w((t, e) => {
  const r = t.append("g");
  e.forEach((n, i) => {
    const a = i % ku, s = la.get(n.name)?.pos;
    if (s === void 0)
      throw new Error(`Position not found for branch ${n.name}`);
    const o = r.append("line");
    o.attr("x1", 0), o.attr("y1", s), o.attr("x2", jl), o.attr("y2", s), o.attr("class", "branch branch" + a), dr === "TB" ? (o.attr("y1", xx), o.attr("x1", s), o.attr("y2", jl), o.attr("x2", s)) : dr === "BT" && (o.attr("y1", jl), o.attr("x1", s), o.attr("y2", xx), o.attr("x2", s)), wx.push(s);
    const l = n.name, u = Ble(l), h = r.insert("rect"), d = r.insert("g").attr("class", "branchLabel").insert("g").attr("class", "label branch-label" + a);
    d.node().appendChild(u);
    const p = u.getBBox();
    h.attr("class", "branchLabelBkg label" + a).attr("rx", 4).attr("ry", 4).attr("x", -p.width - 4 - (Xa?.rotateCommitLabel === !0 ? 30 : 0)).attr("y", -p.height / 2 + 8).attr("width", p.width + 18).attr("height", p.height + 4), d.attr(
      "transform",
      "translate(" + (-p.width - 14 - (Xa?.rotateCommitLabel === !0 ? 30 : 0)) + ", " + (s - p.height / 2 - 1) + ")"
    ), dr === "TB" ? (h.attr("x", s - p.width / 2 - 10).attr("y", 0), d.attr("transform", "translate(" + (s - p.width / 2 - 5) + ", 0)")) : dr === "BT" ? (h.attr("x", s - p.width / 2 - 10).attr("y", jl), d.attr("transform", "translate(" + (s - p.width / 2 - 5) + ", " + jl + ")")) : h.attr("transform", "translate(-19, " + (s - p.height / 2) + ")");
  });
}, "drawBranches"), UJe = /* @__PURE__ */ w(function(t, e, r, n, i) {
  return la.set(t, { pos: e, index: r }), e += 50 + (i ? 40 : 0) + (dr === "TB" || dr === "BT" ? n.width / 2 : 0), e;
}, "setBranchPosition"), VJe = /* @__PURE__ */ w(function(t, e, r, n) {
  if (CJe(), ae.debug("in gitgraph renderer", t + `
`, "id:", e, r), !Xa)
    throw new Error("GitGraph config not found");
  const i = Xa.rotateCommitLabel ?? !1, a = n.db;
  _g = a.getCommits();
  const s = a.getBranchesAsObjArray();
  dr = a.getDirection();
  const o = Qe(`[id="${e}"]`);
  let l = 0;
  s.forEach((u, h) => {
    const f = Ble(u.name), d = o.append("g"), p = d.insert("g").attr("class", "branchLabel"), g = p.insert("g").attr("class", "label branch-label");
    g.node()?.appendChild(f);
    const m = f.getBBox();
    l = UJe(u.name, l, h, m, i), g.remove(), p.remove(), d.remove();
  }), zW(o, _g, !1), Xa.showBranches && GJe(o, s), qJe(o, _g), zW(o, _g, !0), Jt.insertTitle(
    o,
    "gitTitleText",
    Xa.titleTopMargin ?? 0,
    a.getDiagramTitle()
  ), sX(
    void 0,
    o,
    Xa.diagramPadding,
    Xa.useMaxWidth
  );
}, "draw"), HJe = {
  draw: VJe
}, WJe = /* @__PURE__ */ w((t) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
  (e) => `
        .branch-label${e} { fill: ${t["gitBranchLabel" + e]}; }
        .commit${e} { stroke: ${t["git" + e]}; fill: ${t["git" + e]}; }
        .commit-highlight${e} { stroke: ${t["gitInv" + e]}; fill: ${t["gitInv" + e]}; }
        .label${e}  { fill: ${t["git" + e]}; }
        .arrow${e} { stroke: ${t["git" + e]}; }
        `
).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${t.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelColor};}
  .commit-label-bkg { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${t.tagLabelFontSize}; fill: ${t.tagLabelColor};}
  .tag-label-bkg { fill: ${t.tagLabelBackground}; stroke: ${t.tagLabelBorder}; }
  .tag-hole { fill: ${t.textColor}; }

  .commit-merge {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }
  .commit-reverse {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }
`, "getStyles"), YJe = WJe, XJe = {
  parser: SJe,
  db: $le,
  renderer: HJe,
  styles: YJe
};
const jJe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: XJe
}, Symbol.toStringTag, { value: "Module" }));
var f2 = { exports: {} }, KJe = f2.exports, qW;
function ZJe() {
  return qW || (qW = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(KJe, (function() {
      var r = "day";
      return function(n, i, a) {
        var s = function(u) {
          return u.add(4 - u.isoWeekday(), r);
        }, o = i.prototype;
        o.isoWeekYear = function() {
          return s(this).year();
        }, o.isoWeek = function(u) {
          if (!this.$utils().u(u)) return this.add(7 * (u - this.isoWeek()), r);
          var h, f, d, p, g = s(this), m = (h = this.isoWeekYear(), f = this.$u, d = (f ? a.utc : a)().year(h).startOf("year"), p = 4 - d.isoWeekday(), d.isoWeekday() > 4 && (p += 7), d.add(p, r));
          return g.diff(m, "week") + 1;
        }, o.isoWeekday = function(u) {
          return this.$utils().u(u) ? this.day() || 7 : this.day(this.day() % 7 ? u : u - 7);
        };
        var l = o.startOf;
        o.startOf = function(u, h) {
          var f = this.$utils(), d = !!f.u(h) || h;
          return f.p(u) === "isoweek" ? d ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : l.bind(this)(u, h);
        };
      };
    }));
  })(f2)), f2.exports;
}
var QJe = ZJe();
const JJe = /* @__PURE__ */ Oc(QJe);
var d2 = { exports: {} }, eet = d2.exports, GW;
function tet() {
  return GW || (GW = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(eet, (function() {
      var r = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, n = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, i = /\d/, a = /\d\d/, s = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, l = {}, u = function(v) {
        return (v = +v) + (v > 68 ? 1900 : 2e3);
      }, h = function(v) {
        return function(y) {
          this[v] = +y;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(v) {
        (this.zone || (this.zone = {})).offset = (function(y) {
          if (!y || y === "Z") return 0;
          var b = y.match(/([+-]|\d\d)/g), x = 60 * b[1] + (+b[2] || 0);
          return x === 0 ? 0 : b[0] === "+" ? -x : x;
        })(v);
      }], d = function(v) {
        var y = l[v];
        return y && (y.indexOf ? y : y.s.concat(y.f));
      }, p = function(v, y) {
        var b, x = l.meridiem;
        if (x) {
          for (var T = 1; T <= 24; T += 1) if (v.indexOf(x(T, 0, y)) > -1) {
            b = T > 12;
            break;
          }
        } else b = v === (y ? "pm" : "PM");
        return b;
      }, g = { A: [o, function(v) {
        this.afternoon = p(v, !1);
      }], a: [o, function(v) {
        this.afternoon = p(v, !0);
      }], Q: [i, function(v) {
        this.month = 3 * (v - 1) + 1;
      }], S: [i, function(v) {
        this.milliseconds = 100 * +v;
      }], SS: [a, function(v) {
        this.milliseconds = 10 * +v;
      }], SSS: [/\d{3}/, function(v) {
        this.milliseconds = +v;
      }], s: [s, h("seconds")], ss: [s, h("seconds")], m: [s, h("minutes")], mm: [s, h("minutes")], H: [s, h("hours")], h: [s, h("hours")], HH: [s, h("hours")], hh: [s, h("hours")], D: [s, h("day")], DD: [a, h("day")], Do: [o, function(v) {
        var y = l.ordinal, b = v.match(/\d+/);
        if (this.day = b[0], y) for (var x = 1; x <= 31; x += 1) y(x).replace(/\[|\]/g, "") === v && (this.day = x);
      }], w: [s, h("week")], ww: [a, h("week")], M: [s, h("month")], MM: [a, h("month")], MMM: [o, function(v) {
        var y = d("months"), b = (d("monthsShort") || y.map((function(x) {
          return x.slice(0, 3);
        }))).indexOf(v) + 1;
        if (b < 1) throw new Error();
        this.month = b % 12 || b;
      }], MMMM: [o, function(v) {
        var y = d("months").indexOf(v) + 1;
        if (y < 1) throw new Error();
        this.month = y % 12 || y;
      }], Y: [/[+-]?\d+/, h("year")], YY: [a, function(v) {
        this.year = u(v);
      }], YYYY: [/\d{4}/, h("year")], Z: f, ZZ: f };
      function m(v) {
        var y, b;
        y = v, b = l && l.formats;
        for (var x = (v = y.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(R, L, M) {
          var P = M && M.toUpperCase();
          return L || b[M] || r[M] || b[P].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(C, I, N) {
            return I || N.slice(1);
          }));
        }))).match(n), T = x.length, E = 0; E < T; E += 1) {
          var A = x[E], S = g[A], k = S && S[0], _ = S && S[1];
          x[E] = _ ? { regex: k, parser: _ } : A.replace(/^\[|\]$/g, "");
        }
        return function(R) {
          for (var L = {}, M = 0, P = 0; M < T; M += 1) {
            var C = x[M];
            if (typeof C == "string") P += C.length;
            else {
              var I = C.regex, N = C.parser, O = R.slice(P), D = I.exec(O)[0];
              N.call(L, D), R = R.replace(D, "");
            }
          }
          return (function($) {
            var z = $.afternoon;
            if (z !== void 0) {
              var B = $.hours;
              z ? B < 12 && ($.hours += 12) : B === 12 && ($.hours = 0), delete $.afternoon;
            }
          })(L), L;
        };
      }
      return function(v, y, b) {
        b.p.customParseFormat = !0, v && v.parseTwoDigitYear && (u = v.parseTwoDigitYear);
        var x = y.prototype, T = x.parse;
        x.parse = function(E) {
          var A = E.date, S = E.utc, k = E.args;
          this.$u = S;
          var _ = k[1];
          if (typeof _ == "string") {
            var R = k[2] === !0, L = k[3] === !0, M = R || L, P = k[2];
            L && (P = k[2]), l = this.$locale(), !R && P && (l = b.Ls[P]), this.$d = (function(O, D, $, z) {
              try {
                if (["x", "X"].indexOf(D) > -1) return new Date((D === "X" ? 1e3 : 1) * O);
                var B = m(D)(O), G = B.year, W = B.month, V = B.day, U = B.hours, Z = B.minutes, K = B.seconds, ce = B.milliseconds, J = B.zone, ee = B.week, j = /* @__PURE__ */ new Date(), X = V || (G || W ? 1 : j.getDate()), re = G || j.getFullYear(), Q = 0;
                G && !W || (Q = W > 0 ? W - 1 : j.getMonth());
                var ue, ne = U || 0, xe = Z || 0, Y = K || 0, Ne = ce || 0;
                return J ? new Date(Date.UTC(re, Q, X, ne, xe, Y, Ne + 60 * J.offset * 1e3)) : $ ? new Date(Date.UTC(re, Q, X, ne, xe, Y, Ne)) : (ue = new Date(re, Q, X, ne, xe, Y, Ne), ee && (ue = z(ue).week(ee).toDate()), ue);
              } catch {
                return /* @__PURE__ */ new Date("");
              }
            })(A, _, S, b), this.init(), P && P !== !0 && (this.$L = this.locale(P).$L), M && A != this.format(_) && (this.$d = /* @__PURE__ */ new Date("")), l = {};
          } else if (_ instanceof Array) for (var C = _.length, I = 1; I <= C; I += 1) {
            k[1] = _[I - 1];
            var N = b.apply(this, k);
            if (N.isValid()) {
              this.$d = N.$d, this.$L = N.$L, this.init();
              break;
            }
            I === C && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else T.call(this, E);
        };
      };
    }));
  })(d2)), d2.exports;
}
var ret = tet();
const net = /* @__PURE__ */ Oc(ret);
var p2 = { exports: {} }, iet = p2.exports, UW;
function aet() {
  return UW || (UW = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(iet, (function() {
      return function(r, n) {
        var i = n.prototype, a = i.format;
        i.format = function(s) {
          var o = this, l = this.$locale();
          if (!this.isValid()) return a.bind(this)(s);
          var u = this.$utils(), h = (s || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(f) {
            switch (f) {
              case "Q":
                return Math.ceil((o.$M + 1) / 3);
              case "Do":
                return l.ordinal(o.$D);
              case "gggg":
                return o.weekYear();
              case "GGGG":
                return o.isoWeekYear();
              case "wo":
                return l.ordinal(o.week(), "W");
              case "w":
              case "ww":
                return u.s(o.week(), f === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return u.s(o.isoWeek(), f === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return u.s(String(o.$H === 0 ? 24 : o.$H), f === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(o.$d.getTime() / 1e3);
              case "x":
                return o.$d.getTime();
              case "z":
                return "[" + o.offsetName() + "]";
              case "zzz":
                return "[" + o.offsetName("long") + "]";
              default:
                return f;
            }
          }));
          return a.bind(this)(h);
        };
      };
    }));
  })(p2)), p2.exports;
}
var set = aet();
const oet = /* @__PURE__ */ Oc(set);
var g2 = { exports: {} }, cet = g2.exports, VW;
function uet() {
  return VW || (VW = 1, (function(t, e) {
    (function(r, n) {
      t.exports = n();
    })(cet, (function() {
      var r, n, i = 1e3, a = 6e4, s = 36e5, o = 864e5, l = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u = 31536e6, h = 2628e6, f = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, d = { years: u, months: h, days: o, hours: s, minutes: a, seconds: i, milliseconds: 1, weeks: 6048e5 }, p = function(A) {
        return A instanceof T;
      }, g = function(A, S, k) {
        return new T(A, k, S.$l);
      }, m = function(A) {
        return n.p(A) + "s";
      }, v = function(A) {
        return A < 0;
      }, y = function(A) {
        return v(A) ? Math.ceil(A) : Math.floor(A);
      }, b = function(A) {
        return Math.abs(A);
      }, x = function(A, S) {
        return A ? v(A) ? { negative: !0, format: "" + b(A) + S } : { negative: !1, format: "" + A + S } : { negative: !1, format: "" };
      }, T = (function() {
        function A(k, _, R) {
          var L = this;
          if (this.$d = {}, this.$l = R, k === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), _) return g(k * d[m(_)], this);
          if (typeof k == "number") return this.$ms = k, this.parseFromMilliseconds(), this;
          if (typeof k == "object") return Object.keys(k).forEach((function(C) {
            L.$d[m(C)] = k[C];
          })), this.calMilliseconds(), this;
          if (typeof k == "string") {
            var M = k.match(f);
            if (M) {
              var P = M.slice(2).map((function(C) {
                return C != null ? Number(C) : 0;
              }));
              return this.$d.years = P[0], this.$d.months = P[1], this.$d.weeks = P[2], this.$d.days = P[3], this.$d.hours = P[4], this.$d.minutes = P[5], this.$d.seconds = P[6], this.calMilliseconds(), this;
            }
          }
          return this;
        }
        var S = A.prototype;
        return S.calMilliseconds = function() {
          var k = this;
          this.$ms = Object.keys(this.$d).reduce((function(_, R) {
            return _ + (k.$d[R] || 0) * d[R];
          }), 0);
        }, S.parseFromMilliseconds = function() {
          var k = this.$ms;
          this.$d.years = y(k / u), k %= u, this.$d.months = y(k / h), k %= h, this.$d.days = y(k / o), k %= o, this.$d.hours = y(k / s), k %= s, this.$d.minutes = y(k / a), k %= a, this.$d.seconds = y(k / i), k %= i, this.$d.milliseconds = k;
        }, S.toISOString = function() {
          var k = x(this.$d.years, "Y"), _ = x(this.$d.months, "M"), R = +this.$d.days || 0;
          this.$d.weeks && (R += 7 * this.$d.weeks);
          var L = x(R, "D"), M = x(this.$d.hours, "H"), P = x(this.$d.minutes, "M"), C = this.$d.seconds || 0;
          this.$d.milliseconds && (C += this.$d.milliseconds / 1e3, C = Math.round(1e3 * C) / 1e3);
          var I = x(C, "S"), N = k.negative || _.negative || L.negative || M.negative || P.negative || I.negative, O = M.format || P.format || I.format ? "T" : "", D = (N ? "-" : "") + "P" + k.format + _.format + L.format + O + M.format + P.format + I.format;
          return D === "P" || D === "-P" ? "P0D" : D;
        }, S.toJSON = function() {
          return this.toISOString();
        }, S.format = function(k) {
          var _ = k || "YYYY-MM-DDTHH:mm:ss", R = { Y: this.$d.years, YY: n.s(this.$d.years, 2, "0"), YYYY: n.s(this.$d.years, 4, "0"), M: this.$d.months, MM: n.s(this.$d.months, 2, "0"), D: this.$d.days, DD: n.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: n.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: n.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: n.s(this.$d.seconds, 2, "0"), SSS: n.s(this.$d.milliseconds, 3, "0") };
          return _.replace(l, (function(L, M) {
            return M || String(R[L]);
          }));
        }, S.as = function(k) {
          return this.$ms / d[m(k)];
        }, S.get = function(k) {
          var _ = this.$ms, R = m(k);
          return R === "milliseconds" ? _ %= 1e3 : _ = R === "weeks" ? y(_ / d[R]) : this.$d[R], _ || 0;
        }, S.add = function(k, _, R) {
          var L;
          return L = _ ? k * d[m(_)] : p(k) ? k.$ms : g(k, this).$ms, g(this.$ms + L * (R ? -1 : 1), this);
        }, S.subtract = function(k, _) {
          return this.add(k, _, !0);
        }, S.locale = function(k) {
          var _ = this.clone();
          return _.$l = k, _;
        }, S.clone = function() {
          return g(this.$ms, this);
        }, S.humanize = function(k) {
          return r().add(this.$ms, "ms").locale(this.$l).fromNow(!k);
        }, S.valueOf = function() {
          return this.asMilliseconds();
        }, S.milliseconds = function() {
          return this.get("milliseconds");
        }, S.asMilliseconds = function() {
          return this.as("milliseconds");
        }, S.seconds = function() {
          return this.get("seconds");
        }, S.asSeconds = function() {
          return this.as("seconds");
        }, S.minutes = function() {
          return this.get("minutes");
        }, S.asMinutes = function() {
          return this.as("minutes");
        }, S.hours = function() {
          return this.get("hours");
        }, S.asHours = function() {
          return this.as("hours");
        }, S.days = function() {
          return this.get("days");
        }, S.asDays = function() {
          return this.as("days");
        }, S.weeks = function() {
          return this.get("weeks");
        }, S.asWeeks = function() {
          return this.as("weeks");
        }, S.months = function() {
          return this.get("months");
        }, S.asMonths = function() {
          return this.as("months");
        }, S.years = function() {
          return this.get("years");
        }, S.asYears = function() {
          return this.as("years");
        }, A;
      })(), E = function(A, S, k) {
        return A.add(S.years() * k, "y").add(S.months() * k, "M").add(S.days() * k, "d").add(S.hours() * k, "h").add(S.minutes() * k, "m").add(S.seconds() * k, "s").add(S.milliseconds() * k, "ms");
      };
      return function(A, S, k) {
        r = k, n = k().$utils(), k.duration = function(L, M) {
          var P = k.locale();
          return g(L, { $l: P }, M);
        }, k.isDuration = p;
        var _ = S.prototype.add, R = S.prototype.subtract;
        S.prototype.add = function(L, M) {
          return p(L) ? E(this, L, 1) : _.bind(this)(L, M);
        }, S.prototype.subtract = function(L, M) {
          return p(L) ? E(this, L, -1) : R.bind(this)(L, M);
        };
      };
    }));
  })(g2)), g2.exports;
}
var het = uet();
const fet = /* @__PURE__ */ Oc(het);
var L8 = (function() {
  var t = /* @__PURE__ */ w(function(P, C, I, N) {
    for (I = I || {}, N = P.length; N--; I[P[N]] = C) ;
    return I;
  }, "o"), e = [6, 8, 10, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 35, 36, 38, 40], r = [1, 26], n = [1, 27], i = [1, 28], a = [1, 29], s = [1, 30], o = [1, 31], l = [1, 32], u = [1, 33], h = [1, 34], f = [1, 9], d = [1, 10], p = [1, 11], g = [1, 12], m = [1, 13], v = [1, 14], y = [1, 15], b = [1, 16], x = [1, 19], T = [1, 20], E = [1, 21], A = [1, 22], S = [1, 23], k = [1, 25], _ = [1, 35], R = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, gantt: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NL: 10, weekday: 11, weekday_monday: 12, weekday_tuesday: 13, weekday_wednesday: 14, weekday_thursday: 15, weekday_friday: 16, weekday_saturday: 17, weekday_sunday: 18, weekend: 19, weekend_friday: 20, weekend_saturday: 21, dateFormat: 22, inclusiveEndDates: 23, topAxis: 24, axisFormat: 25, tickInterval: 26, excludes: 27, includes: 28, todayMarker: 29, title: 30, acc_title: 31, acc_title_value: 32, acc_descr: 33, acc_descr_value: 34, acc_descr_multiline_value: 35, section: 36, clickStatement: 37, taskTxt: 38, taskData: 39, click: 40, callbackname: 41, callbackargs: 42, href: 43, clickStatementDebug: 44, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "gantt", 6: "EOF", 8: "SPACE", 10: "NL", 12: "weekday_monday", 13: "weekday_tuesday", 14: "weekday_wednesday", 15: "weekday_thursday", 16: "weekday_friday", 17: "weekday_saturday", 18: "weekday_sunday", 20: "weekend_friday", 21: "weekend_saturday", 22: "dateFormat", 23: "inclusiveEndDates", 24: "topAxis", 25: "axisFormat", 26: "tickInterval", 27: "excludes", 28: "includes", 29: "todayMarker", 30: "title", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 36: "section", 38: "taskTxt", 39: "taskData", 40: "click", 41: "callbackname", 42: "callbackargs", 43: "href" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [19, 1], [19, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 2], [37, 2], [37, 3], [37, 3], [37, 4], [37, 3], [37, 4], [37, 2], [44, 2], [44, 3], [44, 3], [44, 4], [44, 3], [44, 4], [44, 2]],
    performAction: /* @__PURE__ */ w(function(C, I, N, O, D, $, z) {
      var B = $.length - 1;
      switch (D) {
        case 1:
          return $[B - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          $[B - 1].push($[B]), this.$ = $[B - 1];
          break;
        case 4:
        case 5:
          this.$ = $[B];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          O.setWeekday("monday");
          break;
        case 9:
          O.setWeekday("tuesday");
          break;
        case 10:
          O.setWeekday("wednesday");
          break;
        case 11:
          O.setWeekday("thursday");
          break;
        case 12:
          O.setWeekday("friday");
          break;
        case 13:
          O.setWeekday("saturday");
          break;
        case 14:
          O.setWeekday("sunday");
          break;
        case 15:
          O.setWeekend("friday");
          break;
        case 16:
          O.setWeekend("saturday");
          break;
        case 17:
          O.setDateFormat($[B].substr(11)), this.$ = $[B].substr(11);
          break;
        case 18:
          O.enableInclusiveEndDates(), this.$ = $[B].substr(18);
          break;
        case 19:
          O.TopAxis(), this.$ = $[B].substr(8);
          break;
        case 20:
          O.setAxisFormat($[B].substr(11)), this.$ = $[B].substr(11);
          break;
        case 21:
          O.setTickInterval($[B].substr(13)), this.$ = $[B].substr(13);
          break;
        case 22:
          O.setExcludes($[B].substr(9)), this.$ = $[B].substr(9);
          break;
        case 23:
          O.setIncludes($[B].substr(9)), this.$ = $[B].substr(9);
          break;
        case 24:
          O.setTodayMarker($[B].substr(12)), this.$ = $[B].substr(12);
          break;
        case 27:
          O.setDiagramTitle($[B].substr(6)), this.$ = $[B].substr(6);
          break;
        case 28:
          this.$ = $[B].trim(), O.setAccTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = $[B].trim(), O.setAccDescription(this.$);
          break;
        case 31:
          O.addSection($[B].substr(8)), this.$ = $[B].substr(8);
          break;
        case 33:
          O.addTask($[B - 1], $[B]), this.$ = "task";
          break;
        case 34:
          this.$ = $[B - 1], O.setClickEvent($[B - 1], $[B], null);
          break;
        case 35:
          this.$ = $[B - 2], O.setClickEvent($[B - 2], $[B - 1], $[B]);
          break;
        case 36:
          this.$ = $[B - 2], O.setClickEvent($[B - 2], $[B - 1], null), O.setLink($[B - 2], $[B]);
          break;
        case 37:
          this.$ = $[B - 3], O.setClickEvent($[B - 3], $[B - 2], $[B - 1]), O.setLink($[B - 3], $[B]);
          break;
        case 38:
          this.$ = $[B - 2], O.setClickEvent($[B - 2], $[B], null), O.setLink($[B - 2], $[B - 1]);
          break;
        case 39:
          this.$ = $[B - 3], O.setClickEvent($[B - 3], $[B - 1], $[B]), O.setLink($[B - 3], $[B - 2]);
          break;
        case 40:
          this.$ = $[B - 1], O.setLink($[B - 1], $[B]);
          break;
        case 41:
        case 47:
          this.$ = $[B - 1] + " " + $[B];
          break;
        case 42:
        case 43:
        case 45:
          this.$ = $[B - 2] + " " + $[B - 1] + " " + $[B];
          break;
        case 44:
        case 46:
          this.$ = $[B - 3] + " " + $[B - 2] + " " + $[B - 1] + " " + $[B];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: 17, 12: r, 13: n, 14: i, 15: a, 16: s, 17: o, 18: l, 19: 18, 20: u, 21: h, 22: f, 23: d, 24: p, 25: g, 26: m, 27: v, 28: y, 29: b, 30: x, 31: T, 33: E, 35: A, 36: S, 37: 24, 38: k, 40: _ }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 36, 11: 17, 12: r, 13: n, 14: i, 15: a, 16: s, 17: o, 18: l, 19: 18, 20: u, 21: h, 22: f, 23: d, 24: p, 25: g, 26: m, 27: v, 28: y, 29: b, 30: x, 31: T, 33: E, 35: A, 36: S, 37: 24, 38: k, 40: _ }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 17]), t(e, [2, 18]), t(e, [2, 19]), t(e, [2, 20]), t(e, [2, 21]), t(e, [2, 22]), t(e, [2, 23]), t(e, [2, 24]), t(e, [2, 25]), t(e, [2, 26]), t(e, [2, 27]), { 32: [1, 37] }, { 34: [1, 38] }, t(e, [2, 30]), t(e, [2, 31]), t(e, [2, 32]), { 39: [1, 39] }, t(e, [2, 8]), t(e, [2, 9]), t(e, [2, 10]), t(e, [2, 11]), t(e, [2, 12]), t(e, [2, 13]), t(e, [2, 14]), t(e, [2, 15]), t(e, [2, 16]), { 41: [1, 40], 43: [1, 41] }, t(e, [2, 4]), t(e, [2, 28]), t(e, [2, 29]), t(e, [2, 33]), t(e, [2, 34], { 42: [1, 42], 43: [1, 43] }), t(e, [2, 40], { 41: [1, 44] }), t(e, [2, 35], { 43: [1, 45] }), t(e, [2, 36]), t(e, [2, 38], { 42: [1, 46] }), t(e, [2, 37]), t(e, [2, 39])],
    defaultActions: {},
    parseError: /* @__PURE__ */ w(function(C, I) {
      if (I.recoverable)
        this.trace(C);
      else {
        var N = new Error(C);
        throw N.hash = I, N;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(C) {
      var I = this, N = [0], O = [], D = [null], $ = [], z = this.table, B = "", G = 0, W = 0, V = 2, U = 1, Z = $.slice.call(arguments, 1), K = Object.create(this.lexer), ce = { yy: {} };
      for (var J in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, J) && (ce.yy[J] = this.yy[J]);
      K.setInput(C, ce.yy), ce.yy.lexer = K, ce.yy.parser = this, typeof K.yylloc > "u" && (K.yylloc = {});
      var ee = K.yylloc;
      $.push(ee);
      var j = K.options && K.options.ranges;
      typeof ce.yy.parseError == "function" ? this.parseError = ce.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function X(Ee) {
        N.length = N.length - 2 * Ee, D.length = D.length - Ee, $.length = $.length - Ee;
      }
      w(X, "popStack");
      function re() {
        var Ee;
        return Ee = O.pop() || K.lex() || U, typeof Ee != "number" && (Ee instanceof Array && (O = Ee, Ee = O.pop()), Ee = I.symbols_[Ee] || Ee), Ee;
      }
      w(re, "lex");
      for (var Q, ue, ne, xe, Y = {}, Ne, fe, qe, ze; ; ) {
        if (ue = N[N.length - 1], this.defaultActions[ue] ? ne = this.defaultActions[ue] : ((Q === null || typeof Q > "u") && (Q = re()), ne = z[ue] && z[ue][Q]), typeof ne > "u" || !ne.length || !ne[0]) {
          var Ge = "";
          ze = [];
          for (Ne in z[ue])
            this.terminals_[Ne] && Ne > V && ze.push("'" + this.terminals_[Ne] + "'");
          K.showPosition ? Ge = "Parse error on line " + (G + 1) + `:
` + K.showPosition() + `
Expecting ` + ze.join(", ") + ", got '" + (this.terminals_[Q] || Q) + "'" : Ge = "Parse error on line " + (G + 1) + ": Unexpected " + (Q == U ? "end of input" : "'" + (this.terminals_[Q] || Q) + "'"), this.parseError(Ge, {
            text: K.match,
            token: this.terminals_[Q] || Q,
            line: K.yylineno,
            loc: ee,
            expected: ze
          });
        }
        if (ne[0] instanceof Array && ne.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ue + ", token: " + Q);
        switch (ne[0]) {
          case 1:
            N.push(Q), D.push(K.yytext), $.push(K.yylloc), N.push(ne[1]), Q = null, W = K.yyleng, B = K.yytext, G = K.yylineno, ee = K.yylloc;
            break;
          case 2:
            if (fe = this.productions_[ne[1]][1], Y.$ = D[D.length - fe], Y._$ = {
              first_line: $[$.length - (fe || 1)].first_line,
              last_line: $[$.length - 1].last_line,
              first_column: $[$.length - (fe || 1)].first_column,
              last_column: $[$.length - 1].last_column
            }, j && (Y._$.range = [
              $[$.length - (fe || 1)].range[0],
              $[$.length - 1].range[1]
            ]), xe = this.performAction.apply(Y, [
              B,
              W,
              G,
              ce.yy,
              ne[1],
              D,
              $
            ].concat(Z)), typeof xe < "u")
              return xe;
            fe && (N = N.slice(0, -1 * fe * 2), D = D.slice(0, -1 * fe), $ = $.slice(0, -1 * fe)), N.push(this.productions_[ne[1]][0]), D.push(Y.$), $.push(Y._$), qe = z[N[N.length - 2]][N[N.length - 1]], N.push(qe);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, L = /* @__PURE__ */ (function() {
    var P = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(I, N) {
        if (this.yy.parser)
          this.yy.parser.parseError(I, N);
        else
          throw new Error(I);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(C, I) {
        return this.yy = I || this.yy || {}, this._input = C, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var C = this._input[0];
        this.yytext += C, this.yyleng++, this.offset++, this.match += C, this.matched += C;
        var I = C.match(/(?:\r\n?|\n).*/g);
        return I ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), C;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(C) {
        var I = C.length, N = C.split(/(?:\r\n?|\n)/g);
        this._input = C + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - I), this.offset -= I;
        var O = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), N.length - 1 && (this.yylineno -= N.length - 1);
        var D = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: N ? (N.length === O.length ? this.yylloc.first_column : 0) + O[O.length - N.length].length - N[0].length : this.yylloc.first_column - I
        }, this.options.ranges && (this.yylloc.range = [D[0], D[0] + this.yyleng - I]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(C) {
        this.unput(this.match.slice(C));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var C = this.matched.substr(0, this.matched.length - this.match.length);
        return (C.length > 20 ? "..." : "") + C.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var C = this.match;
        return C.length < 20 && (C += this._input.substr(0, 20 - C.length)), (C.substr(0, 20) + (C.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var C = this.pastInput(), I = new Array(C.length + 1).join("-");
        return C + this.upcomingInput() + `
` + I + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(C, I) {
        var N, O, D;
        if (this.options.backtrack_lexer && (D = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (D.yylloc.range = this.yylloc.range.slice(0))), O = C[0].match(/(?:\r\n?|\n).*/g), O && (this.yylineno += O.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: O ? O[O.length - 1].length - O[O.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + C[0].length
        }, this.yytext += C[0], this.match += C[0], this.matches = C, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(C[0].length), this.matched += C[0], N = this.performAction.call(this, this.yy, this, I, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), N)
          return N;
        if (this._backtrack) {
          for (var $ in D)
            this[$] = D[$];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var C, I, N, O;
        this._more || (this.yytext = "", this.match = "");
        for (var D = this._currentRules(), $ = 0; $ < D.length; $++)
          if (N = this._input.match(this.rules[D[$]]), N && (!I || N[0].length > I[0].length)) {
            if (I = N, O = $, this.options.backtrack_lexer) {
              if (C = this.test_match(N, D[$]), C !== !1)
                return C;
              if (this._backtrack) {
                I = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return I ? (C = this.test_match(I, D[O]), C !== !1 ? C : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var I = this.next();
        return I || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(I) {
        this.conditionStack.push(I);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var I = this.conditionStack.length - 1;
        return I > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(I) {
        return I = this.conditionStack.length - 1 - Math.abs(I || 0), I >= 0 ? this.conditionStack[I] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(I) {
        this.begin(I);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(I, N, O, D) {
        switch (O) {
          case 0:
            return this.begin("open_directive"), "open_directive";
          case 1:
            return this.begin("acc_title"), 31;
          case 2:
            return this.popState(), "acc_title_value";
          case 3:
            return this.begin("acc_descr"), 33;
          case 4:
            return this.popState(), "acc_descr_value";
          case 5:
            this.begin("acc_descr_multiline");
            break;
          case 6:
            this.popState();
            break;
          case 7:
            return "acc_descr_multiline_value";
          case 8:
            break;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 10;
          case 12:
            break;
          case 13:
            break;
          case 14:
            this.begin("href");
            break;
          case 15:
            this.popState();
            break;
          case 16:
            return 43;
          case 17:
            this.begin("callbackname");
            break;
          case 18:
            this.popState();
            break;
          case 19:
            this.popState(), this.begin("callbackargs");
            break;
          case 20:
            return 41;
          case 21:
            this.popState();
            break;
          case 22:
            return 42;
          case 23:
            this.begin("click");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return 40;
          case 26:
            return 4;
          case 27:
            return 22;
          case 28:
            return 23;
          case 29:
            return 24;
          case 30:
            return 25;
          case 31:
            return 26;
          case 32:
            return 28;
          case 33:
            return 27;
          case 34:
            return 29;
          case 35:
            return 12;
          case 36:
            return 13;
          case 37:
            return 14;
          case 38:
            return 15;
          case 39:
            return 16;
          case 40:
            return 17;
          case 41:
            return 18;
          case 42:
            return 20;
          case 43:
            return 21;
          case 44:
            return "date";
          case 45:
            return 30;
          case 46:
            return "accDescription";
          case 47:
            return 36;
          case 48:
            return 38;
          case 49:
            return 39;
          case 50:
            return ":";
          case 51:
            return 6;
          case 52:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%%\{)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:tickInterval\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:weekday\s+monday\b)/i, /^(?:weekday\s+tuesday\b)/i, /^(?:weekday\s+wednesday\b)/i, /^(?:weekday\s+thursday\b)/i, /^(?:weekday\s+friday\b)/i, /^(?:weekday\s+saturday\b)/i, /^(?:weekday\s+sunday\b)/i, /^(?:weekend\s+friday\b)/i, /^(?:weekend\s+saturday\b)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^\n]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^\n]+)/i, /^(?:[^:\n]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [6, 7], inclusive: !1 }, acc_descr: { rules: [4], inclusive: !1 }, acc_title: { rules: [2], inclusive: !1 }, callbackargs: { rules: [21, 22], inclusive: !1 }, callbackname: { rules: [18, 19, 20], inclusive: !1 }, href: { rules: [15, 16], inclusive: !1 }, click: { rules: [24, 25], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 17, 23, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52], inclusive: !0 } }
    };
    return P;
  })();
  R.lexer = L;
  function M() {
    this.yy = {};
  }
  return w(M, "Parser"), M.prototype = R, R.Parser = M, new M();
})();
L8.parser = L8;
var det = L8;
Qn.extend(JJe);
Qn.extend(net);
Qn.extend(oet);
var HW = { friday: 5, saturday: 6 }, lo = "", qI = "", GI = void 0, UI = "", Hm = [], Wm = [], VI = /* @__PURE__ */ new Map(), HI = [], Tx = [], w0 = "", WI = "", zle = ["active", "done", "crit", "milestone", "vert"], YI = [], Ym = !1, XI = !1, jI = "sunday", Ex = "saturday", R8 = 0, pet = /* @__PURE__ */ w(function() {
  HI = [], Tx = [], w0 = "", YI = [], m2 = 0, M8 = void 0, v2 = void 0, $n = [], lo = "", qI = "", WI = "", GI = void 0, UI = "", Hm = [], Wm = [], Ym = !1, XI = !1, R8 = 0, VI = /* @__PURE__ */ new Map(), In(), jI = "sunday", Ex = "saturday";
}, "clear"), get = /* @__PURE__ */ w(function(t) {
  qI = t;
}, "setAxisFormat"), met = /* @__PURE__ */ w(function() {
  return qI;
}, "getAxisFormat"), vet = /* @__PURE__ */ w(function(t) {
  GI = t;
}, "setTickInterval"), yet = /* @__PURE__ */ w(function() {
  return GI;
}, "getTickInterval"), bet = /* @__PURE__ */ w(function(t) {
  UI = t;
}, "setTodayMarker"), xet = /* @__PURE__ */ w(function() {
  return UI;
}, "getTodayMarker"), wet = /* @__PURE__ */ w(function(t) {
  lo = t;
}, "setDateFormat"), Tet = /* @__PURE__ */ w(function() {
  Ym = !0;
}, "enableInclusiveEndDates"), Eet = /* @__PURE__ */ w(function() {
  return Ym;
}, "endDatesAreInclusive"), ket = /* @__PURE__ */ w(function() {
  XI = !0;
}, "enableTopAxis"), Cet = /* @__PURE__ */ w(function() {
  return XI;
}, "topAxisEnabled"), _et = /* @__PURE__ */ w(function(t) {
  WI = t;
}, "setDisplayMode"), Aet = /* @__PURE__ */ w(function() {
  return WI;
}, "getDisplayMode"), Let = /* @__PURE__ */ w(function() {
  return lo;
}, "getDateFormat"), Ret = /* @__PURE__ */ w(function(t) {
  Hm = t.toLowerCase().split(/[\s,]+/);
}, "setIncludes"), Iet = /* @__PURE__ */ w(function() {
  return Hm;
}, "getIncludes"), Met = /* @__PURE__ */ w(function(t) {
  Wm = t.toLowerCase().split(/[\s,]+/);
}, "setExcludes"), Net = /* @__PURE__ */ w(function() {
  return Wm;
}, "getExcludes"), Det = /* @__PURE__ */ w(function() {
  return VI;
}, "getLinks"), Oet = /* @__PURE__ */ w(function(t) {
  w0 = t, HI.push(t);
}, "addSection"), Pet = /* @__PURE__ */ w(function() {
  return HI;
}, "getSections"), $et = /* @__PURE__ */ w(function() {
  let t = WW();
  const e = 10;
  let r = 0;
  for (; !t && r < e; )
    t = WW(), r++;
  return Tx = $n, Tx;
}, "getTasks"), qle = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = t.format(e.trim()), a = t.format("YYYY-MM-DD");
  return n.includes(i) || n.includes(a) ? !1 : r.includes("weekends") && (t.isoWeekday() === HW[Ex] || t.isoWeekday() === HW[Ex] + 1) || r.includes(t.format("dddd").toLowerCase()) ? !0 : r.includes(i) || r.includes(a);
}, "isInvalidDate"), Bet = /* @__PURE__ */ w(function(t) {
  jI = t;
}, "setWeekday"), Fet = /* @__PURE__ */ w(function() {
  return jI;
}, "getWeekday"), zet = /* @__PURE__ */ w(function(t) {
  Ex = t;
}, "setWeekend"), Gle = /* @__PURE__ */ w(function(t, e, r, n) {
  if (!r.length || t.manualEndTime)
    return;
  let i;
  t.startTime instanceof Date ? i = Qn(t.startTime) : i = Qn(t.startTime, e, !0), i = i.add(1, "d");
  let a;
  t.endTime instanceof Date ? a = Qn(t.endTime) : a = Qn(t.endTime, e, !0);
  const [s, o] = qet(
    i,
    a,
    e,
    r,
    n
  );
  t.endTime = s.toDate(), t.renderEndTime = o;
}, "checkTaskDates"), qet = /* @__PURE__ */ w(function(t, e, r, n, i) {
  let a = !1, s = null;
  for (; t <= e; )
    a || (s = e.toDate()), a = qle(t, r, n, i), a && (e = e.add(1, "d")), t = t.add(1, "d");
  return [e, s];
}, "fixTaskDates"), I8 = /* @__PURE__ */ w(function(t, e, r) {
  if (r = r.trim(), (/* @__PURE__ */ w((o) => {
    const l = o.trim();
    return l === "x" || l === "X";
  }, "isTimestampFormat"))(e) && /^\d+$/.test(r))
    return new Date(Number(r));
  const a = /^after\s+(?<ids>[\d\w- ]+)/.exec(r);
  if (a !== null) {
    let o = null;
    for (const u of a.groups.ids.split(" ")) {
      let h = Xh(u);
      h !== void 0 && (!o || h.endTime > o.endTime) && (o = h);
    }
    if (o)
      return o.endTime;
    const l = /* @__PURE__ */ new Date();
    return l.setHours(0, 0, 0, 0), l;
  }
  let s = Qn(r, e.trim(), !0);
  if (s.isValid())
    return s.toDate();
  {
    ae.debug("Invalid date:" + r), ae.debug("With date format:" + e.trim());
    const o = new Date(r);
    if (o === void 0 || isNaN(o.getTime()) || // WebKit browsers can mis-parse invalid dates to be ridiculously
    // huge numbers, e.g. new Date('202304') gets parsed as January 1, 202304.
    // This can cause virtually infinite loops while rendering, so for the
    // purposes of Gantt charts we'll just treat any date beyond 10,000 AD/BC as
    // invalid.
    o.getFullYear() < -1e4 || o.getFullYear() > 1e4)
      throw new Error("Invalid date:" + r);
    return o;
  }
}, "getStartDate"), Ule = /* @__PURE__ */ w(function(t) {
  const e = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(t.trim());
  return e !== null ? [Number.parseFloat(e[1]), e[2]] : [NaN, "ms"];
}, "parseDuration"), Vle = /* @__PURE__ */ w(function(t, e, r, n = !1) {
  r = r.trim();
  const a = /^until\s+(?<ids>[\d\w- ]+)/.exec(r);
  if (a !== null) {
    let h = null;
    for (const d of a.groups.ids.split(" ")) {
      let p = Xh(d);
      p !== void 0 && (!h || p.startTime < h.startTime) && (h = p);
    }
    if (h)
      return h.startTime;
    const f = /* @__PURE__ */ new Date();
    return f.setHours(0, 0, 0, 0), f;
  }
  let s = Qn(r, e.trim(), !0);
  if (s.isValid())
    return n && (s = s.add(1, "d")), s.toDate();
  let o = Qn(t);
  const [l, u] = Ule(r);
  if (!Number.isNaN(l)) {
    const h = o.add(l, u);
    h.isValid() && (o = h);
  }
  return o.toDate();
}, "getEndDate"), m2 = 0, Hf = /* @__PURE__ */ w(function(t) {
  return t === void 0 ? (m2 = m2 + 1, "task" + m2) : t;
}, "parseId"), Get = /* @__PURE__ */ w(function(t, e) {
  let r;
  e.substr(0, 1) === ":" ? r = e.substr(1, e.length) : r = e;
  const n = r.split(","), i = {};
  KI(n, i, zle);
  for (let s = 0; s < n.length; s++)
    n[s] = n[s].trim();
  let a = "";
  switch (n.length) {
    case 1:
      i.id = Hf(), i.startTime = t.endTime, a = n[0];
      break;
    case 2:
      i.id = Hf(), i.startTime = I8(void 0, lo, n[0]), a = n[1];
      break;
    case 3:
      i.id = Hf(n[0]), i.startTime = I8(void 0, lo, n[1]), a = n[2];
      break;
  }
  return a && (i.endTime = Vle(i.startTime, lo, a, Ym), i.manualEndTime = Qn(a, "YYYY-MM-DD", !0).isValid(), Gle(i, lo, Wm, Hm)), i;
}, "compileData"), Uet = /* @__PURE__ */ w(function(t, e) {
  let r;
  e.substr(0, 1) === ":" ? r = e.substr(1, e.length) : r = e;
  const n = r.split(","), i = {};
  KI(n, i, zle);
  for (let a = 0; a < n.length; a++)
    n[a] = n[a].trim();
  switch (n.length) {
    case 1:
      i.id = Hf(), i.startTime = {
        type: "prevTaskEnd",
        id: t
      }, i.endTime = {
        data: n[0]
      };
      break;
    case 2:
      i.id = Hf(), i.startTime = {
        type: "getStartDate",
        startData: n[0]
      }, i.endTime = {
        data: n[1]
      };
      break;
    case 3:
      i.id = Hf(n[0]), i.startTime = {
        type: "getStartDate",
        startData: n[1]
      }, i.endTime = {
        data: n[2]
      };
      break;
  }
  return i;
}, "parseData"), M8, v2, $n = [], Hle = {}, Vet = /* @__PURE__ */ w(function(t, e) {
  const r = {
    section: w0,
    type: w0,
    processed: !1,
    manualEndTime: !1,
    renderEndTime: null,
    raw: { data: e },
    task: t,
    classes: []
  }, n = Uet(v2, e);
  r.raw.startTime = n.startTime, r.raw.endTime = n.endTime, r.id = n.id, r.prevTaskId = v2, r.active = n.active, r.done = n.done, r.crit = n.crit, r.milestone = n.milestone, r.vert = n.vert, r.order = R8, R8++;
  const i = $n.push(r);
  v2 = r.id, Hle[r.id] = i - 1;
}, "addTask"), Xh = /* @__PURE__ */ w(function(t) {
  const e = Hle[t];
  return $n[e];
}, "findTaskById"), Het = /* @__PURE__ */ w(function(t, e) {
  const r = {
    section: w0,
    type: w0,
    description: t,
    task: t,
    classes: []
  }, n = Get(M8, e);
  r.startTime = n.startTime, r.endTime = n.endTime, r.id = n.id, r.active = n.active, r.done = n.done, r.crit = n.crit, r.milestone = n.milestone, r.vert = n.vert, M8 = r, Tx.push(r);
}, "addTaskOrg"), WW = /* @__PURE__ */ w(function() {
  const t = /* @__PURE__ */ w(function(r) {
    const n = $n[r];
    let i = "";
    switch ($n[r].raw.startTime.type) {
      case "prevTaskEnd": {
        const a = Xh(n.prevTaskId);
        n.startTime = a.endTime;
        break;
      }
      case "getStartDate":
        i = I8(void 0, lo, $n[r].raw.startTime.startData), i && ($n[r].startTime = i);
        break;
    }
    return $n[r].startTime && ($n[r].endTime = Vle(
      $n[r].startTime,
      lo,
      $n[r].raw.endTime.data,
      Ym
    ), $n[r].endTime && ($n[r].processed = !0, $n[r].manualEndTime = Qn(
      $n[r].raw.endTime.data,
      "YYYY-MM-DD",
      !0
    ).isValid(), Gle($n[r], lo, Wm, Hm))), $n[r].processed;
  }, "compileTask");
  let e = !0;
  for (const [r, n] of $n.entries())
    t(r), e = e && n.processed;
  return e;
}, "compileTasks"), Wet = /* @__PURE__ */ w(function(t, e) {
  let r = e;
  Te().securityLevel !== "loose" && (r = yh.sanitizeUrl(e)), t.split(",").forEach(function(n) {
    Xh(n) !== void 0 && (Yle(n, () => {
      window.open(r, "_self");
    }), VI.set(n, r));
  }), Wle(t, "clickable");
}, "setLink"), Wle = /* @__PURE__ */ w(function(t, e) {
  t.split(",").forEach(function(r) {
    let n = Xh(r);
    n !== void 0 && n.classes.push(e);
  });
}, "setClass"), Yet = /* @__PURE__ */ w(function(t, e, r) {
  if (Te().securityLevel !== "loose" || e === void 0)
    return;
  let n = [];
  if (typeof r == "string") {
    n = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let a = 0; a < n.length; a++) {
      let s = n[a].trim();
      s.startsWith('"') && s.endsWith('"') && (s = s.substr(1, s.length - 2)), n[a] = s;
    }
  }
  n.length === 0 && n.push(t), Xh(t) !== void 0 && Yle(t, () => {
    Jt.runFunc(e, ...n);
  });
}, "setClickFun"), Yle = /* @__PURE__ */ w(function(t, e) {
  YI.push(
    function() {
      const r = document.querySelector(`[id="${t}"]`);
      r !== null && r.addEventListener("click", function() {
        e();
      });
    },
    function() {
      const r = document.querySelector(`[id="${t}-text"]`);
      r !== null && r.addEventListener("click", function() {
        e();
      });
    }
  );
}, "pushFun"), Xet = /* @__PURE__ */ w(function(t, e, r) {
  t.split(",").forEach(function(n) {
    Yet(n, e, r);
  }), Wle(t, "clickable");
}, "setClickEvent"), jet = /* @__PURE__ */ w(function(t) {
  YI.forEach(function(e) {
    e(t);
  });
}, "bindFunctions"), Ket = {
  getConfig: /* @__PURE__ */ w(() => Te().gantt, "getConfig"),
  clear: pet,
  setDateFormat: wet,
  getDateFormat: Let,
  enableInclusiveEndDates: Tet,
  endDatesAreInclusive: Eet,
  enableTopAxis: ket,
  topAxisEnabled: Cet,
  setAxisFormat: get,
  getAxisFormat: met,
  setTickInterval: vet,
  getTickInterval: yet,
  setTodayMarker: bet,
  getTodayMarker: xet,
  setAccTitle: Ln,
  getAccTitle: Hn,
  setDiagramTitle: ti,
  getDiagramTitle: Mn,
  setDisplayMode: _et,
  getDisplayMode: Aet,
  setAccDescription: Wn,
  getAccDescription: Yn,
  addSection: Oet,
  getSections: Pet,
  getTasks: $et,
  addTask: Vet,
  findTaskById: Xh,
  addTaskOrg: Het,
  setIncludes: Ret,
  getIncludes: Iet,
  setExcludes: Met,
  getExcludes: Net,
  setClickEvent: Xet,
  setLink: Wet,
  getLinks: Det,
  bindFunctions: jet,
  parseDuration: Ule,
  isInvalidDate: qle,
  setWeekday: Bet,
  getWeekday: Fet,
  setWeekend: zet
};
function KI(t, e, r) {
  let n = !0;
  for (; n; )
    n = !1, r.forEach(function(i) {
      const a = "^\\s*" + i + "\\s*$", s = new RegExp(a);
      t[0].match(s) && (e[i] = !0, t.shift(1), n = !0);
    });
}
w(KI, "getTaskTags");
Qn.extend(fet);
var Zet = /* @__PURE__ */ w(function() {
  ae.debug("Something is calling, setConf, remove the call");
}, "setConf"), YW = {
  monday: t1,
  tuesday: HX,
  wednesday: WX,
  thursday: Wu,
  friday: YX,
  saturday: XX,
  sunday: tm
}, Qet = /* @__PURE__ */ w((t, e) => {
  let r = [...t].map(() => -1 / 0), n = [...t].sort((a, s) => a.startTime - s.startTime || a.order - s.order), i = 0;
  for (const a of n)
    for (let s = 0; s < r.length; s++)
      if (a.startTime >= r[s]) {
        r[s] = a.endTime, a.order = s + e, s > i && (i = s);
        break;
      }
  return i;
}, "getMaxIntersections"), zo, F7 = 1e4, Jet = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = Te().gantt, a = Te().securityLevel;
  let s;
  a === "sandbox" && (s = Qe("#i" + e));
  const o = Qe(a === "sandbox" ? s.nodes()[0].contentDocument.body : "body"), l = a === "sandbox" ? s.nodes()[0].contentDocument : document, u = l.getElementById(e);
  zo = u.parentElement.offsetWidth, zo === void 0 && (zo = 1200), i.useWidth !== void 0 && (zo = i.useWidth);
  const h = n.db.getTasks();
  let f = [];
  for (const _ of h)
    f.push(_.type);
  f = k(f);
  const d = {};
  let p = 2 * i.topPadding;
  if (n.db.getDisplayMode() === "compact" || i.displayMode === "compact") {
    const _ = {};
    for (const L of h)
      _[L.section] === void 0 ? _[L.section] = [L] : _[L.section].push(L);
    let R = 0;
    for (const L of Object.keys(_)) {
      const M = Qet(_[L], R) + 1;
      R += M, p += M * (i.barHeight + i.barGap), d[L] = M;
    }
  } else {
    p += h.length * (i.barHeight + i.barGap);
    for (const _ of f)
      d[_] = h.filter((R) => R.type === _).length;
  }
  u.setAttribute("viewBox", "0 0 " + zo + " " + p);
  const g = o.select(`[id="${e}"]`), m = Bme().domain([
    Hfe(h, function(_) {
      return _.startTime;
    }),
    Vfe(h, function(_) {
      return _.endTime;
    })
  ]).rangeRound([0, zo - i.leftPadding - i.rightPadding]);
  function v(_, R) {
    const L = _.startTime, M = R.startTime;
    let P = 0;
    return L > M ? P = 1 : L < M && (P = -1), P;
  }
  w(v, "taskCompare"), h.sort(v), y(h, zo, p), Qi(g, p, zo, i.useMaxWidth), g.append("text").text(n.db.getDiagramTitle()).attr("x", zo / 2).attr("y", i.titleTopMargin).attr("class", "titleText");
  function y(_, R, L) {
    const M = i.barHeight, P = M + i.barGap, C = i.topPadding, I = i.leftPadding, N = Kd().domain([0, f.length]).range(["#00B9FA", "#F95002"]).interpolate(ppe);
    x(
      P,
      C,
      I,
      R,
      L,
      _,
      n.db.getExcludes(),
      n.db.getIncludes()
    ), E(I, C, R, L), b(_, P, C, I, M, N, R), A(P, C), S(I, C, R, L);
  }
  w(y, "makeGantt");
  function b(_, R, L, M, P, C, I) {
    _.sort((B, G) => B.vert === G.vert ? 0 : B.vert ? 1 : -1);
    const O = [...new Set(_.map((B) => B.order))].map((B) => _.find((G) => G.order === B));
    g.append("g").selectAll("rect").data(O).enter().append("rect").attr("x", 0).attr("y", function(B, G) {
      return G = B.order, G * R + L - 2;
    }).attr("width", function() {
      return I - i.rightPadding / 2;
    }).attr("height", R).attr("class", function(B) {
      for (const [G, W] of f.entries())
        if (B.type === W)
          return "section section" + G % i.numberSectionStyles;
      return "section section0";
    }).enter();
    const D = g.append("g").selectAll("rect").data(_).enter(), $ = n.db.getLinks();
    if (D.append("rect").attr("id", function(B) {
      return B.id;
    }).attr("rx", 3).attr("ry", 3).attr("x", function(B) {
      return B.milestone ? m(B.startTime) + M + 0.5 * (m(B.endTime) - m(B.startTime)) - 0.5 * P : m(B.startTime) + M;
    }).attr("y", function(B, G) {
      return G = B.order, B.vert ? i.gridLineStartPadding : G * R + L;
    }).attr("width", function(B) {
      return B.milestone ? P : B.vert ? 0.08 * P : m(B.renderEndTime || B.endTime) - m(B.startTime);
    }).attr("height", function(B) {
      return B.vert ? h.length * (i.barHeight + i.barGap) + i.barHeight * 2 : P;
    }).attr("transform-origin", function(B, G) {
      return G = B.order, (m(B.startTime) + M + 0.5 * (m(B.endTime) - m(B.startTime))).toString() + "px " + (G * R + L + 0.5 * P).toString() + "px";
    }).attr("class", function(B) {
      const G = "task";
      let W = "";
      B.classes.length > 0 && (W = B.classes.join(" "));
      let V = 0;
      for (const [Z, K] of f.entries())
        B.type === K && (V = Z % i.numberSectionStyles);
      let U = "";
      return B.active ? B.crit ? U += " activeCrit" : U = " active" : B.done ? B.crit ? U = " doneCrit" : U = " done" : B.crit && (U += " crit"), U.length === 0 && (U = " task"), B.milestone && (U = " milestone " + U), B.vert && (U = " vert " + U), U += V, U += " " + W, G + U;
    }), D.append("text").attr("id", function(B) {
      return B.id + "-text";
    }).text(function(B) {
      return B.task;
    }).attr("font-size", i.fontSize).attr("x", function(B) {
      let G = m(B.startTime), W = m(B.renderEndTime || B.endTime);
      if (B.milestone && (G += 0.5 * (m(B.endTime) - m(B.startTime)) - 0.5 * P, W = G + P), B.vert)
        return m(B.startTime) + M;
      const V = this.getBBox().width;
      return V > W - G ? W + V + 1.5 * i.leftPadding > I ? G + M - 5 : W + M + 5 : (W - G) / 2 + G + M;
    }).attr("y", function(B, G) {
      return B.vert ? i.gridLineStartPadding + h.length * (i.barHeight + i.barGap) + 60 : (G = B.order, G * R + i.barHeight / 2 + (i.fontSize / 2 - 2) + L);
    }).attr("text-height", P).attr("class", function(B) {
      const G = m(B.startTime);
      let W = m(B.endTime);
      B.milestone && (W = G + P);
      const V = this.getBBox().width;
      let U = "";
      B.classes.length > 0 && (U = B.classes.join(" "));
      let Z = 0;
      for (const [ce, J] of f.entries())
        B.type === J && (Z = ce % i.numberSectionStyles);
      let K = "";
      return B.active && (B.crit ? K = "activeCritText" + Z : K = "activeText" + Z), B.done ? B.crit ? K = K + " doneCritText" + Z : K = K + " doneText" + Z : B.crit && (K = K + " critText" + Z), B.milestone && (K += " milestoneText"), B.vert && (K += " vertText"), V > W - G ? W + V + 1.5 * i.leftPadding > I ? U + " taskTextOutsideLeft taskTextOutside" + Z + " " + K : U + " taskTextOutsideRight taskTextOutside" + Z + " " + K + " width-" + V : U + " taskText taskText" + Z + " " + K + " width-" + V;
    }), Te().securityLevel === "sandbox") {
      let B;
      B = Qe("#i" + e);
      const G = B.nodes()[0].contentDocument;
      D.filter(function(W) {
        return $.has(W.id);
      }).each(function(W) {
        var V = G.querySelector("#" + W.id), U = G.querySelector("#" + W.id + "-text");
        const Z = V.parentNode;
        var K = G.createElement("a");
        K.setAttribute("xlink:href", $.get(W.id)), K.setAttribute("target", "_top"), Z.appendChild(K), K.appendChild(V), K.appendChild(U);
      });
    }
  }
  w(b, "drawRects");
  function x(_, R, L, M, P, C, I, N) {
    if (I.length === 0 && N.length === 0)
      return;
    let O, D;
    for (const { startTime: V, endTime: U } of C)
      (O === void 0 || V < O) && (O = V), (D === void 0 || U > D) && (D = U);
    if (!O || !D)
      return;
    if (Qn(D).diff(Qn(O), "year") > 5) {
      ae.warn(
        "The difference between the min and max time is more than 5 years. This will cause performance issues. Skipping drawing exclude days."
      );
      return;
    }
    const $ = n.db.getDateFormat(), z = [];
    let B = null, G = Qn(O);
    for (; G.valueOf() <= D; )
      n.db.isInvalidDate(G, $, I, N) ? B ? B.end = G : B = {
        start: G,
        end: G
      } : B && (z.push(B), B = null), G = G.add(1, "d");
    g.append("g").selectAll("rect").data(z).enter().append("rect").attr("id", (V) => "exclude-" + V.start.format("YYYY-MM-DD")).attr("x", (V) => m(V.start.startOf("day")) + L).attr("y", i.gridLineStartPadding).attr("width", (V) => m(V.end.endOf("day")) - m(V.start.startOf("day"))).attr("height", P - R - i.gridLineStartPadding).attr("transform-origin", function(V, U) {
      return (m(V.start) + L + 0.5 * (m(V.end) - m(V.start))).toString() + "px " + (U * _ + 0.5 * P).toString() + "px";
    }).attr("class", "exclude-range");
  }
  w(x, "drawExcludeDays");
  function T(_, R, L, M) {
    if (L <= 0 || _ > R)
      return 1 / 0;
    const P = R - _, C = Qn.duration({ [M ?? "day"]: L }).asMilliseconds();
    return C <= 0 ? 1 / 0 : Math.ceil(P / C);
  }
  w(T, "getEstimatedTickCount");
  function E(_, R, L, M) {
    const P = n.db.getDateFormat(), C = n.db.getAxisFormat();
    let I;
    C ? I = C : P === "D" ? I = "%d" : I = i.axisFormat ?? "%Y-%m-%d";
    let N = ede(m).tickSize(-M + R + i.gridLineStartPadding).tickFormat(V2(I));
    const D = /^([1-9]\d*)(millisecond|second|minute|hour|day|week|month)$/.exec(
      n.db.getTickInterval() || i.tickInterval
    );
    if (D !== null) {
      const $ = parseInt(D[1], 10);
      if (isNaN($) || $ <= 0)
        ae.warn(
          `Invalid tick interval value: "${D[1]}". Skipping custom tick interval.`
        );
      else {
        const z = D[2], B = n.db.getWeekday() || i.weekday, G = m.domain(), W = G[0], V = G[1], U = T(W, V, $, z);
        if (U > F7)
          ae.warn(
            `The tick interval "${$}${z}" would generate ${U} ticks, which exceeds the maximum allowed (${F7}). This may indicate an invalid date or time range. Skipping custom tick interval.`
          );
        else
          switch (z) {
            case "millisecond":
              N.ticks(Zd.every($));
              break;
            case "second":
              N.ticks(Zl.every($));
              break;
            case "minute":
              N.ticks(Jg.every($));
              break;
            case "hour":
              N.ticks(e1.every($));
              break;
            case "day":
              N.ticks(Hu.every($));
              break;
            case "week":
              N.ticks(YW[B].every($));
              break;
            case "month":
              N.ticks(r1.every($));
              break;
          }
      }
    }
    if (g.append("g").attr("class", "grid").attr("transform", "translate(" + _ + ", " + (M - 50) + ")").call(N).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em"), n.db.topAxisEnabled() || i.topAxis) {
      let $ = Jfe(m).tickSize(-M + R + i.gridLineStartPadding).tickFormat(V2(I));
      if (D !== null) {
        const z = parseInt(D[1], 10);
        if (isNaN(z) || z <= 0)
          ae.warn(
            `Invalid tick interval value: "${D[1]}". Skipping custom tick interval.`
          );
        else {
          const B = D[2], G = n.db.getWeekday() || i.weekday, W = m.domain(), V = W[0], U = W[1];
          if (T(V, U, z, B) <= F7)
            switch (B) {
              case "millisecond":
                $.ticks(Zd.every(z));
                break;
              case "second":
                $.ticks(Zl.every(z));
                break;
              case "minute":
                $.ticks(Jg.every(z));
                break;
              case "hour":
                $.ticks(e1.every(z));
                break;
              case "day":
                $.ticks(Hu.every(z));
                break;
              case "week":
                $.ticks(YW[G].every(z));
                break;
              case "month":
                $.ticks(r1.every(z));
                break;
            }
        }
      }
      g.append("g").attr("class", "grid").attr("transform", "translate(" + _ + ", " + R + ")").call($).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
    }
  }
  w(E, "makeGrid");
  function A(_, R) {
    let L = 0;
    const M = Object.keys(d).map((P) => [P, d[P]]);
    g.append("g").selectAll("text").data(M).enter().append(function(P) {
      const C = P[0].split(at.lineBreakRegex), I = -(C.length - 1) / 2, N = l.createElementNS("http://www.w3.org/2000/svg", "text");
      N.setAttribute("dy", I + "em");
      for (const [O, D] of C.entries()) {
        const $ = l.createElementNS("http://www.w3.org/2000/svg", "tspan");
        $.setAttribute("alignment-baseline", "central"), $.setAttribute("x", "10"), O > 0 && $.setAttribute("dy", "1em"), $.textContent = D, N.appendChild($);
      }
      return N;
    }).attr("x", 10).attr("y", function(P, C) {
      if (C > 0)
        for (let I = 0; I < C; I++)
          return L += M[C - 1][1], P[1] * _ / 2 + L * _ + R;
      else
        return P[1] * _ / 2 + R;
    }).attr("font-size", i.sectionFontSize).attr("class", function(P) {
      for (const [C, I] of f.entries())
        if (P[0] === I)
          return "sectionTitle sectionTitle" + C % i.numberSectionStyles;
      return "sectionTitle";
    });
  }
  w(A, "vertLabels");
  function S(_, R, L, M) {
    const P = n.db.getTodayMarker();
    if (P === "off")
      return;
    const C = g.append("g").attr("class", "today"), I = /* @__PURE__ */ new Date(), N = C.append("line");
    N.attr("x1", m(I) + _).attr("x2", m(I) + _).attr("y1", i.titleTopMargin).attr("y2", M - i.titleTopMargin).attr("class", "today"), P !== "" && N.attr("style", P.replace(/,/g, ";"));
  }
  w(S, "drawToday");
  function k(_) {
    const R = {}, L = [];
    for (let M = 0, P = _.length; M < P; ++M)
      Object.prototype.hasOwnProperty.call(R, _[M]) || (R[_[M]] = !0, L.push(_[M]));
    return L;
  }
  w(k, "checkUnique");
}, "draw"), ett = {
  setConf: Zet,
  draw: Jet
}, ttt = /* @__PURE__ */ w((t) => `
  .mermaid-main-font {
        font-family: ${t.fontFamily};
  }

  .exclude-range {
    fill: ${t.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${t.sectionBkgColor};
  }

  .section2 {
    fill: ${t.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${t.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${t.titleColor};
  }

  .sectionTitle1 {
    fill: ${t.titleColor};
  }

  .sectionTitle2 {
    fill: ${t.titleColor};
  }

  .sectionTitle3 {
    fill: ${t.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    font-family: ${t.fontFamily};
  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${t.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
  }

  .grid .tick text {
    font-family: ${t.fontFamily};
    fill: ${t.textColor};
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${t.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: ${t.fontFamily};
  }

  .taskTextOutsideRight {
    fill: ${t.taskTextDarkColor};
    text-anchor: start;
    font-family: ${t.fontFamily};
  }

  .taskTextOutsideLeft {
    fill: ${t.taskTextDarkColor};
    text-anchor: end;
  }


  /* Special case clickable */

  .task.clickable {
    cursor: pointer;
  }

  .taskText.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }


  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${t.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${t.taskBkgColor};
    stroke: ${t.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${t.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${t.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${t.activeTaskBkgColor};
    stroke: ${t.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${t.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${t.doneTaskBorderColor};
    fill: ${t.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${t.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${t.taskTextDarkColor} !important;
  }

  .vert {
    stroke: ${t.vertLineColor};
  }

  .vertText {
    font-size: 15px;
    text-anchor: middle;
    fill: ${t.vertLineColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${t.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.titleColor || t.textColor};
    font-family: ${t.fontFamily};
  }
`, "getStyles"), rtt = ttt, ntt = {
  parser: det,
  db: Ket,
  renderer: ett,
  styles: rtt
};
const itt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: ntt
}, Symbol.toStringTag, { value: "Module" }));
var att = {
  parse: /* @__PURE__ */ w(async (t) => {
    const e = await ru("info", t);
    ae.debug(e);
  }, "parse")
}, stt = {
  version: Y7.version + ""
}, ott = /* @__PURE__ */ w(() => stt.version, "getVersion"), ltt = {
  getVersion: ott
}, ctt = /* @__PURE__ */ w((t, e, r) => {
  ae.debug(`rendering info diagram
` + t);
  const n = El(e);
  Qi(n, 100, 400, !0), n.append("g").append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", 32).style("text-anchor", "middle").text(`v${r}`);
}, "draw"), utt = { draw: ctt }, htt = {
  parser: att,
  db: ltt,
  renderer: utt
};
const ftt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: htt
}, Symbol.toStringTag, { value: "Module" }));
var dtt = fr.pie, ZI = {
  sections: /* @__PURE__ */ new Map(),
  showData: !1
}, Sx = ZI.sections, QI = ZI.showData, ptt = structuredClone(dtt), gtt = /* @__PURE__ */ w(() => structuredClone(ptt), "getConfig"), mtt = /* @__PURE__ */ w(() => {
  Sx = /* @__PURE__ */ new Map(), QI = ZI.showData, In();
}, "clear"), vtt = /* @__PURE__ */ w(({ label: t, value: e }) => {
  if (e < 0)
    throw new Error(
      `"${t}" has invalid value: ${e}. Negative values are not allowed in pie charts. All slice values must be >= 0.`
    );
  Sx.has(t) || (Sx.set(t, e), ae.debug(`added new section: ${t}, with value: ${e}`));
}, "addSection"), ytt = /* @__PURE__ */ w(() => Sx, "getSections"), btt = /* @__PURE__ */ w((t) => {
  QI = t;
}, "setShowData"), xtt = /* @__PURE__ */ w(() => QI, "getShowData"), Xle = {
  getConfig: gtt,
  clear: mtt,
  setDiagramTitle: ti,
  getDiagramTitle: Mn,
  setAccTitle: Ln,
  getAccTitle: Hn,
  setAccDescription: Wn,
  getAccDescription: Yn,
  addSection: vtt,
  getSections: ytt,
  setShowData: btt,
  getShowData: xtt
}, wtt = /* @__PURE__ */ w((t, e) => {
  Ph(t, e), e.setShowData(t.showData), t.sections.map(e.addSection);
}, "populateDb"), Ttt = {
  parse: /* @__PURE__ */ w(async (t) => {
    const e = await ru("pie", t);
    ae.debug(e), wtt(e, Xle);
  }, "parse")
}, Ett = /* @__PURE__ */ w((t) => `
  .pieCircle{
    stroke: ${t.pieStrokeColor};
    stroke-width : ${t.pieStrokeWidth};
    opacity : ${t.pieOpacity};
  }
  .pieOuterCircle{
    stroke: ${t.pieOuterStrokeColor};
    stroke-width: ${t.pieOuterStrokeWidth};
    fill: none;
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${t.pieTitleTextSize};
    fill: ${t.pieTitleTextColor};
    font-family: ${t.fontFamily};
  }
  .slice {
    font-family: ${t.fontFamily};
    fill: ${t.pieSectionTextColor};
    font-size:${t.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${t.pieLegendTextColor};
    font-family: ${t.fontFamily};
    font-size: ${t.pieLegendTextSize};
  }
`, "getStyles"), Stt = Ett, ktt = /* @__PURE__ */ w((t) => {
  const e = [...t.values()].reduce((i, a) => i + a, 0), r = [...t.entries()].map(([i, a]) => ({ label: i, value: a })).filter((i) => i.value / e * 100 >= 1).sort((i, a) => a.value - i.value);
  return Jme().value((i) => i.value)(r);
}, "createPieArcs"), Ctt = /* @__PURE__ */ w((t, e, r, n) => {
  ae.debug(`rendering pie chart
` + t);
  const i = n.db, a = Te(), s = Xi(i.getConfig(), a.pie), o = 40, l = 18, u = 4, h = 450, f = h, d = El(e), p = d.append("g");
  p.attr("transform", "translate(" + f / 2 + "," + h / 2 + ")");
  const { themeVariables: g } = a;
  let [m] = Sh(g.pieOuterStrokeWidth);
  m ??= 2;
  const v = s.textPosition, y = Math.min(f, h) / 2 - o, b = Jd().innerRadius(0).outerRadius(y), x = Jd().innerRadius(y * v).outerRadius(y * v);
  p.append("circle").attr("cx", 0).attr("cy", 0).attr("r", y + m / 2).attr("class", "pieOuterCircle");
  const T = i.getSections(), E = ktt(T), A = [
    g.pie1,
    g.pie2,
    g.pie3,
    g.pie4,
    g.pie5,
    g.pie6,
    g.pie7,
    g.pie8,
    g.pie9,
    g.pie10,
    g.pie11,
    g.pie12
  ];
  let S = 0;
  T.forEach((C) => {
    S += C;
  });
  const k = E.filter((C) => (C.data.value / S * 100).toFixed(0) !== "0"), _ = Bu(A);
  p.selectAll("mySlices").data(k).enter().append("path").attr("d", b).attr("fill", (C) => _(C.data.label)).attr("class", "pieCircle"), p.selectAll("mySlices").data(k).enter().append("text").text((C) => (C.data.value / S * 100).toFixed(0) + "%").attr("transform", (C) => "translate(" + x.centroid(C) + ")").style("text-anchor", "middle").attr("class", "slice"), p.append("text").text(i.getDiagramTitle()).attr("x", 0).attr("y", -400 / 2).attr("class", "pieTitleText");
  const R = [...T.entries()].map(([C, I]) => ({
    label: C,
    value: I
  })), L = p.selectAll(".legend").data(R).enter().append("g").attr("class", "legend").attr("transform", (C, I) => {
    const N = l + u, O = N * R.length / 2, D = 12 * l, $ = I * N - O;
    return "translate(" + D + "," + $ + ")";
  });
  L.append("rect").attr("width", l).attr("height", l).style("fill", (C) => _(C.label)).style("stroke", (C) => _(C.label)), L.append("text").attr("x", l + u).attr("y", l - u).text((C) => i.getShowData() ? `${C.label} [${C.value}]` : C.label);
  const M = Math.max(
    ...L.selectAll("text").nodes().map((C) => C?.getBoundingClientRect().width ?? 0)
  ), P = f + o + l + u + M;
  d.attr("viewBox", `0 0 ${P} ${h}`), Qi(d, h, P, s.useMaxWidth);
}, "draw"), _tt = { draw: Ctt }, Att = {
  parser: Ttt,
  db: Xle,
  renderer: _tt,
  styles: Stt
};
const Ltt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Att
}, Symbol.toStringTag, { value: "Module" }));
var N8 = (function() {
  var t = /* @__PURE__ */ w(function(he, F, oe, se) {
    for (oe = oe || {}, se = he.length; se--; oe[he[se]] = F) ;
    return oe;
  }, "o"), e = [1, 3], r = [1, 4], n = [1, 5], i = [1, 6], a = [1, 7], s = [1, 4, 5, 10, 12, 13, 14, 18, 25, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67], o = [1, 4, 5, 10, 12, 13, 14, 18, 25, 28, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67], l = [55, 56, 57], u = [2, 36], h = [1, 37], f = [1, 36], d = [1, 38], p = [1, 35], g = [1, 43], m = [1, 41], v = [1, 14], y = [1, 23], b = [1, 18], x = [1, 19], T = [1, 20], E = [1, 21], A = [1, 22], S = [1, 24], k = [1, 25], _ = [1, 26], R = [1, 27], L = [1, 28], M = [1, 29], P = [1, 32], C = [1, 33], I = [1, 34], N = [1, 39], O = [1, 40], D = [1, 42], $ = [1, 44], z = [1, 62], B = [1, 61], G = [4, 5, 8, 10, 12, 13, 14, 18, 44, 47, 49, 55, 56, 57, 63, 64, 65, 66, 67], W = [1, 65], V = [1, 66], U = [1, 67], Z = [1, 68], K = [1, 69], ce = [1, 70], J = [1, 71], ee = [1, 72], j = [1, 73], X = [1, 74], re = [1, 75], Q = [1, 76], ue = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18], ne = [1, 90], xe = [1, 91], Y = [1, 92], Ne = [1, 99], fe = [1, 93], qe = [1, 96], ze = [1, 94], Ge = [1, 95], Ee = [1, 97], Oe = [1, 98], Ce = [1, 102], Ae = [10, 55, 56, 57], $e = [4, 5, 6, 8, 10, 11, 13, 17, 18, 19, 20, 55, 56, 57], me = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, idStringToken: 3, ALPHA: 4, NUM: 5, NODE_STRING: 6, DOWN: 7, MINUS: 8, DEFAULT: 9, COMMA: 10, COLON: 11, AMP: 12, BRKT: 13, MULT: 14, UNICODE_TEXT: 15, styleComponent: 16, UNIT: 17, SPACE: 18, STYLE: 19, PCT: 20, idString: 21, style: 22, stylesOpt: 23, classDefStatement: 24, CLASSDEF: 25, start: 26, eol: 27, QUADRANT: 28, document: 29, line: 30, statement: 31, axisDetails: 32, quadrantDetails: 33, points: 34, title: 35, title_value: 36, acc_title: 37, acc_title_value: 38, acc_descr: 39, acc_descr_value: 40, acc_descr_multiline_value: 41, section: 42, text: 43, point_start: 44, point_x: 45, point_y: 46, class_name: 47, "X-AXIS": 48, "AXIS-TEXT-DELIMITER": 49, "Y-AXIS": 50, QUADRANT_1: 51, QUADRANT_2: 52, QUADRANT_3: 53, QUADRANT_4: 54, NEWLINE: 55, SEMI: 56, EOF: 57, alphaNumToken: 58, textNoTagsToken: 59, STR: 60, MD_STR: 61, alphaNum: 62, PUNCTUATION: 63, PLUS: 64, EQUALS: 65, DOT: 66, UNDERSCORE: 67, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ALPHA", 5: "NUM", 6: "NODE_STRING", 7: "DOWN", 8: "MINUS", 9: "DEFAULT", 10: "COMMA", 11: "COLON", 12: "AMP", 13: "BRKT", 14: "MULT", 15: "UNICODE_TEXT", 17: "UNIT", 18: "SPACE", 19: "STYLE", 20: "PCT", 25: "CLASSDEF", 28: "QUADRANT", 35: "title", 36: "title_value", 37: "acc_title", 38: "acc_title_value", 39: "acc_descr", 40: "acc_descr_value", 41: "acc_descr_multiline_value", 42: "section", 44: "point_start", 45: "point_x", 46: "point_y", 47: "class_name", 48: "X-AXIS", 49: "AXIS-TEXT-DELIMITER", 50: "Y-AXIS", 51: "QUADRANT_1", 52: "QUADRANT_2", 53: "QUADRANT_3", 54: "QUADRANT_4", 55: "NEWLINE", 56: "SEMI", 57: "EOF", 60: "STR", 61: "MD_STR", 63: "PUNCTUATION", 64: "PLUS", 65: "EQUALS", 66: "DOT", 67: "UNDERSCORE" },
    productions_: [0, [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [21, 1], [21, 2], [22, 1], [22, 2], [23, 1], [23, 3], [24, 5], [26, 2], [26, 2], [26, 2], [29, 0], [29, 2], [30, 2], [31, 0], [31, 1], [31, 2], [31, 1], [31, 1], [31, 1], [31, 2], [31, 2], [31, 2], [31, 1], [31, 1], [34, 4], [34, 5], [34, 5], [34, 6], [32, 4], [32, 3], [32, 2], [32, 4], [32, 3], [32, 2], [33, 2], [33, 2], [33, 2], [33, 2], [27, 1], [27, 1], [27, 1], [43, 1], [43, 2], [43, 1], [43, 1], [62, 1], [62, 2], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [59, 1], [59, 1], [59, 1]],
    performAction: /* @__PURE__ */ w(function(F, oe, se, ge, de, we, _e) {
      var Se = we.length - 1;
      switch (de) {
        case 23:
          this.$ = we[Se];
          break;
        case 24:
          this.$ = we[Se - 1] + "" + we[Se];
          break;
        case 26:
          this.$ = we[Se - 1] + we[Se];
          break;
        case 27:
          this.$ = [we[Se].trim()];
          break;
        case 28:
          we[Se - 2].push(we[Se].trim()), this.$ = we[Se - 2];
          break;
        case 29:
          this.$ = we[Se - 4], ge.addClass(we[Se - 2], we[Se]);
          break;
        case 37:
          this.$ = [];
          break;
        case 42:
          this.$ = we[Se].trim(), ge.setDiagramTitle(this.$);
          break;
        case 43:
          this.$ = we[Se].trim(), ge.setAccTitle(this.$);
          break;
        case 44:
        case 45:
          this.$ = we[Se].trim(), ge.setAccDescription(this.$);
          break;
        case 46:
          ge.addSection(we[Se].substr(8)), this.$ = we[Se].substr(8);
          break;
        case 47:
          ge.addPoint(we[Se - 3], "", we[Se - 1], we[Se], []);
          break;
        case 48:
          ge.addPoint(we[Se - 4], we[Se - 3], we[Se - 1], we[Se], []);
          break;
        case 49:
          ge.addPoint(we[Se - 4], "", we[Se - 2], we[Se - 1], we[Se]);
          break;
        case 50:
          ge.addPoint(we[Se - 5], we[Se - 4], we[Se - 2], we[Se - 1], we[Se]);
          break;
        case 51:
          ge.setXAxisLeftText(we[Se - 2]), ge.setXAxisRightText(we[Se]);
          break;
        case 52:
          we[Se - 1].text += " \u27F6 ", ge.setXAxisLeftText(we[Se - 1]);
          break;
        case 53:
          ge.setXAxisLeftText(we[Se]);
          break;
        case 54:
          ge.setYAxisBottomText(we[Se - 2]), ge.setYAxisTopText(we[Se]);
          break;
        case 55:
          we[Se - 1].text += " \u27F6 ", ge.setYAxisBottomText(we[Se - 1]);
          break;
        case 56:
          ge.setYAxisBottomText(we[Se]);
          break;
        case 57:
          ge.setQuadrant1Text(we[Se]);
          break;
        case 58:
          ge.setQuadrant2Text(we[Se]);
          break;
        case 59:
          ge.setQuadrant3Text(we[Se]);
          break;
        case 60:
          ge.setQuadrant4Text(we[Se]);
          break;
        case 64:
          this.$ = { text: we[Se], type: "text" };
          break;
        case 65:
          this.$ = { text: we[Se - 1].text + "" + we[Se], type: we[Se - 1].type };
          break;
        case 66:
          this.$ = { text: we[Se], type: "text" };
          break;
        case 67:
          this.$ = { text: we[Se], type: "markdown" };
          break;
        case 68:
          this.$ = we[Se];
          break;
        case 69:
          this.$ = we[Se - 1] + "" + we[Se];
          break;
      }
    }, "anonymous"),
    table: [{ 18: e, 26: 1, 27: 2, 28: r, 55: n, 56: i, 57: a }, { 1: [3] }, { 18: e, 26: 8, 27: 2, 28: r, 55: n, 56: i, 57: a }, { 18: e, 26: 9, 27: 2, 28: r, 55: n, 56: i, 57: a }, t(s, [2, 33], { 29: 10 }), t(o, [2, 61]), t(o, [2, 62]), t(o, [2, 63]), { 1: [2, 30] }, { 1: [2, 31] }, t(l, u, { 30: 11, 31: 12, 24: 13, 32: 15, 33: 16, 34: 17, 43: 30, 58: 31, 1: [2, 32], 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 18: v, 25: y, 35: b, 37: x, 39: T, 41: E, 42: A, 48: S, 50: k, 51: _, 52: R, 53: L, 54: M, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(s, [2, 34]), { 27: 45, 55: n, 56: i, 57: a }, t(l, [2, 37]), t(l, u, { 24: 13, 32: 15, 33: 16, 34: 17, 43: 30, 58: 31, 31: 46, 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 18: v, 25: y, 35: b, 37: x, 39: T, 41: E, 42: A, 48: S, 50: k, 51: _, 52: R, 53: L, 54: M, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 39]), t(l, [2, 40]), t(l, [2, 41]), { 36: [1, 47] }, { 38: [1, 48] }, { 40: [1, 49] }, t(l, [2, 45]), t(l, [2, 46]), { 18: [1, 50] }, { 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 43: 51, 58: 31, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }, { 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 43: 52, 58: 31, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }, { 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 43: 53, 58: 31, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }, { 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 43: 54, 58: 31, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }, { 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 43: 55, 58: 31, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }, { 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 43: 56, 58: 31, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }, { 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 44: [1, 57], 47: [1, 58], 58: 60, 59: 59, 63: I, 64: N, 65: O, 66: D, 67: $ }, t(G, [2, 64]), t(G, [2, 66]), t(G, [2, 67]), t(G, [2, 70]), t(G, [2, 71]), t(G, [2, 72]), t(G, [2, 73]), t(G, [2, 74]), t(G, [2, 75]), t(G, [2, 76]), t(G, [2, 77]), t(G, [2, 78]), t(G, [2, 79]), t(G, [2, 80]), t(s, [2, 35]), t(l, [2, 38]), t(l, [2, 42]), t(l, [2, 43]), t(l, [2, 44]), { 3: 64, 4: W, 5: V, 6: U, 7: Z, 8: K, 9: ce, 10: J, 11: ee, 12: j, 13: X, 14: re, 15: Q, 21: 63 }, t(l, [2, 53], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 49: [1, 77], 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 56], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 49: [1, 78], 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 57], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 58], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 59], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 60], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 63: I, 64: N, 65: O, 66: D, 67: $ }), { 45: [1, 79] }, { 44: [1, 80] }, t(G, [2, 65]), t(G, [2, 81]), t(G, [2, 82]), t(G, [2, 83]), { 3: 82, 4: W, 5: V, 6: U, 7: Z, 8: K, 9: ce, 10: J, 11: ee, 12: j, 13: X, 14: re, 15: Q, 18: [1, 81] }, t(ue, [2, 23]), t(ue, [2, 1]), t(ue, [2, 2]), t(ue, [2, 3]), t(ue, [2, 4]), t(ue, [2, 5]), t(ue, [2, 6]), t(ue, [2, 7]), t(ue, [2, 8]), t(ue, [2, 9]), t(ue, [2, 10]), t(ue, [2, 11]), t(ue, [2, 12]), t(l, [2, 52], { 58: 31, 43: 83, 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 55], { 58: 31, 43: 84, 4: h, 5: f, 10: d, 12: p, 13: g, 14: m, 60: P, 61: C, 63: I, 64: N, 65: O, 66: D, 67: $ }), { 46: [1, 85] }, { 45: [1, 86] }, { 4: ne, 5: xe, 6: Y, 8: Ne, 11: fe, 13: qe, 16: 89, 17: ze, 18: Ge, 19: Ee, 20: Oe, 22: 88, 23: 87 }, t(ue, [2, 24]), t(l, [2, 51], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 54], { 59: 59, 58: 60, 4: h, 5: f, 8: z, 10: d, 12: p, 13: g, 14: m, 18: B, 63: I, 64: N, 65: O, 66: D, 67: $ }), t(l, [2, 47], { 22: 88, 16: 89, 23: 100, 4: ne, 5: xe, 6: Y, 8: Ne, 11: fe, 13: qe, 17: ze, 18: Ge, 19: Ee, 20: Oe }), { 46: [1, 101] }, t(l, [2, 29], { 10: Ce }), t(Ae, [2, 27], { 16: 103, 4: ne, 5: xe, 6: Y, 8: Ne, 11: fe, 13: qe, 17: ze, 18: Ge, 19: Ee, 20: Oe }), t($e, [2, 25]), t($e, [2, 13]), t($e, [2, 14]), t($e, [2, 15]), t($e, [2, 16]), t($e, [2, 17]), t($e, [2, 18]), t($e, [2, 19]), t($e, [2, 20]), t($e, [2, 21]), t($e, [2, 22]), t(l, [2, 49], { 10: Ce }), t(l, [2, 48], { 22: 88, 16: 89, 23: 104, 4: ne, 5: xe, 6: Y, 8: Ne, 11: fe, 13: qe, 17: ze, 18: Ge, 19: Ee, 20: Oe }), { 4: ne, 5: xe, 6: Y, 8: Ne, 11: fe, 13: qe, 16: 89, 17: ze, 18: Ge, 19: Ee, 20: Oe, 22: 105 }, t($e, [2, 26]), t(l, [2, 50], { 10: Ce }), t(Ae, [2, 28], { 16: 103, 4: ne, 5: xe, 6: Y, 8: Ne, 11: fe, 13: qe, 17: ze, 18: Ge, 19: Ee, 20: Oe })],
    defaultActions: { 8: [2, 30], 9: [2, 31] },
    parseError: /* @__PURE__ */ w(function(F, oe) {
      if (oe.recoverable)
        this.trace(F);
      else {
        var se = new Error(F);
        throw se.hash = oe, se;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(F) {
      var oe = this, se = [0], ge = [], de = [null], we = [], _e = this.table, Se = "", Me = 0, Xe = 0, We = 2, Ke = 1, Ze = we.slice.call(arguments, 1), Pe = Object.create(this.lexer), Ve = { yy: {} };
      for (var ht in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ht) && (Ve.yy[ht] = this.yy[ht]);
      Pe.setInput(F, Ve.yy), Ve.yy.lexer = Pe, Ve.yy.parser = this, typeof Pe.yylloc > "u" && (Pe.yylloc = {});
      var st = Pe.yylloc;
      we.push(st);
      var Ue = Pe.options && Pe.options.ranges;
      typeof Ve.yy.parseError == "function" ? this.parseError = Ve.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Et(Wt) {
        se.length = se.length - 2 * Wt, de.length = de.length - Wt, we.length = we.length - Wt;
      }
      w(Et, "popStack");
      function He() {
        var Wt;
        return Wt = ge.pop() || Pe.lex() || Ke, typeof Wt != "number" && (Wt instanceof Array && (ge = Wt, Wt = ge.pop()), Wt = oe.symbols_[Wt] || Wt), Wt;
      }
      w(He, "lex");
      for (var rt, ct, ut, nt, bt = {}, er, Dt, ir, wr; ; ) {
        if (ct = se[se.length - 1], this.defaultActions[ct] ? ut = this.defaultActions[ct] : ((rt === null || typeof rt > "u") && (rt = He()), ut = _e[ct] && _e[ct][rt]), typeof ut > "u" || !ut.length || !ut[0]) {
          var ar = "";
          wr = [];
          for (er in _e[ct])
            this.terminals_[er] && er > We && wr.push("'" + this.terminals_[er] + "'");
          Pe.showPosition ? ar = "Parse error on line " + (Me + 1) + `:
` + Pe.showPosition() + `
Expecting ` + wr.join(", ") + ", got '" + (this.terminals_[rt] || rt) + "'" : ar = "Parse error on line " + (Me + 1) + ": Unexpected " + (rt == Ke ? "end of input" : "'" + (this.terminals_[rt] || rt) + "'"), this.parseError(ar, {
            text: Pe.match,
            token: this.terminals_[rt] || rt,
            line: Pe.yylineno,
            loc: st,
            expected: wr
          });
        }
        if (ut[0] instanceof Array && ut.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ct + ", token: " + rt);
        switch (ut[0]) {
          case 1:
            se.push(rt), de.push(Pe.yytext), we.push(Pe.yylloc), se.push(ut[1]), rt = null, Xe = Pe.yyleng, Se = Pe.yytext, Me = Pe.yylineno, st = Pe.yylloc;
            break;
          case 2:
            if (Dt = this.productions_[ut[1]][1], bt.$ = de[de.length - Dt], bt._$ = {
              first_line: we[we.length - (Dt || 1)].first_line,
              last_line: we[we.length - 1].last_line,
              first_column: we[we.length - (Dt || 1)].first_column,
              last_column: we[we.length - 1].last_column
            }, Ue && (bt._$.range = [
              we[we.length - (Dt || 1)].range[0],
              we[we.length - 1].range[1]
            ]), nt = this.performAction.apply(bt, [
              Se,
              Xe,
              Me,
              Ve.yy,
              ut[1],
              de,
              we
            ].concat(Ze)), typeof nt < "u")
              return nt;
            Dt && (se = se.slice(0, -1 * Dt * 2), de = de.slice(0, -1 * Dt), we = we.slice(0, -1 * Dt)), se.push(this.productions_[ut[1]][0]), de.push(bt.$), we.push(bt._$), ir = _e[se[se.length - 2]][se[se.length - 1]], se.push(ir);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Ie = /* @__PURE__ */ (function() {
    var he = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(oe, se) {
        if (this.yy.parser)
          this.yy.parser.parseError(oe, se);
        else
          throw new Error(oe);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(F, oe) {
        return this.yy = oe || this.yy || {}, this._input = F, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var F = this._input[0];
        this.yytext += F, this.yyleng++, this.offset++, this.match += F, this.matched += F;
        var oe = F.match(/(?:\r\n?|\n).*/g);
        return oe ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), F;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(F) {
        var oe = F.length, se = F.split(/(?:\r\n?|\n)/g);
        this._input = F + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - oe), this.offset -= oe;
        var ge = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), se.length - 1 && (this.yylineno -= se.length - 1);
        var de = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: se ? (se.length === ge.length ? this.yylloc.first_column : 0) + ge[ge.length - se.length].length - se[0].length : this.yylloc.first_column - oe
        }, this.options.ranges && (this.yylloc.range = [de[0], de[0] + this.yyleng - oe]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(F) {
        this.unput(this.match.slice(F));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var F = this.matched.substr(0, this.matched.length - this.match.length);
        return (F.length > 20 ? "..." : "") + F.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var F = this.match;
        return F.length < 20 && (F += this._input.substr(0, 20 - F.length)), (F.substr(0, 20) + (F.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var F = this.pastInput(), oe = new Array(F.length + 1).join("-");
        return F + this.upcomingInput() + `
` + oe + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(F, oe) {
        var se, ge, de;
        if (this.options.backtrack_lexer && (de = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (de.yylloc.range = this.yylloc.range.slice(0))), ge = F[0].match(/(?:\r\n?|\n).*/g), ge && (this.yylineno += ge.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: ge ? ge[ge.length - 1].length - ge[ge.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + F[0].length
        }, this.yytext += F[0], this.match += F[0], this.matches = F, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(F[0].length), this.matched += F[0], se = this.performAction.call(this, this.yy, this, oe, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), se)
          return se;
        if (this._backtrack) {
          for (var we in de)
            this[we] = de[we];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var F, oe, se, ge;
        this._more || (this.yytext = "", this.match = "");
        for (var de = this._currentRules(), we = 0; we < de.length; we++)
          if (se = this._input.match(this.rules[de[we]]), se && (!oe || se[0].length > oe[0].length)) {
            if (oe = se, ge = we, this.options.backtrack_lexer) {
              if (F = this.test_match(se, de[we]), F !== !1)
                return F;
              if (this._backtrack) {
                oe = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return oe ? (F = this.test_match(oe, de[ge]), F !== !1 ? F : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var oe = this.next();
        return oe || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(oe) {
        this.conditionStack.push(oe);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var oe = this.conditionStack.length - 1;
        return oe > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(oe) {
        return oe = this.conditionStack.length - 1 - Math.abs(oe || 0), oe >= 0 ? this.conditionStack[oe] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(oe) {
        this.begin(oe);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(oe, se, ge, de) {
        switch (ge) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 55;
          case 3:
            break;
          case 4:
            return this.begin("title"), 35;
          case 5:
            return this.popState(), "title_value";
          case 6:
            return this.begin("acc_title"), 37;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 39;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 48;
          case 14:
            return 50;
          case 15:
            return 49;
          case 16:
            return 51;
          case 17:
            return 52;
          case 18:
            return 53;
          case 19:
            return 54;
          case 20:
            return 25;
          case 21:
            this.begin("md_string");
            break;
          case 22:
            return "MD_STR";
          case 23:
            this.popState();
            break;
          case 24:
            this.begin("string");
            break;
          case 25:
            this.popState();
            break;
          case 26:
            return "STR";
          case 27:
            this.begin("class_name");
            break;
          case 28:
            return this.popState(), 47;
          case 29:
            return this.begin("point_start"), 44;
          case 30:
            return this.begin("point_x"), 45;
          case 31:
            this.popState();
            break;
          case 32:
            this.popState(), this.begin("point_y");
            break;
          case 33:
            return this.popState(), 46;
          case 34:
            return 28;
          case 35:
            return 4;
          case 36:
            return 11;
          case 37:
            return 64;
          case 38:
            return 10;
          case 39:
            return 65;
          case 40:
            return 65;
          case 41:
            return 14;
          case 42:
            return 13;
          case 43:
            return 67;
          case 44:
            return 66;
          case 45:
            return 12;
          case 46:
            return 8;
          case 47:
            return 5;
          case 48:
            return 18;
          case 49:
            return 56;
          case 50:
            return 63;
          case 51:
            return 57;
        }
      }, "anonymous"),
      rules: [/^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?: *x-axis *)/i, /^(?: *y-axis *)/i, /^(?: *--+> *)/i, /^(?: *quadrant-1 *)/i, /^(?: *quadrant-2 *)/i, /^(?: *quadrant-3 *)/i, /^(?: *quadrant-4 *)/i, /^(?:classDef\b)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?::::)/i, /^(?:^\w+)/i, /^(?:\s*:\s*\[\s*)/i, /^(?:(1)|(0(.\d+)?))/i, /^(?:\s*\] *)/i, /^(?:\s*,\s*)/i, /^(?:(1)|(0(.\d+)?))/i, /^(?: *quadrantChart *)/i, /^(?:[A-Za-z]+)/i, /^(?::)/i, /^(?:\+)/i, /^(?:,)/i, /^(?:=)/i, /^(?:=)/i, /^(?:\*)/i, /^(?:#)/i, /^(?:[\_])/i, /^(?:\.)/i, /^(?:&)/i, /^(?:-)/i, /^(?:[0-9]+)/i, /^(?:\s)/i, /^(?:;)/i, /^(?:[!"#$%&'*+,-.`?\\_/])/i, /^(?:$)/i],
      conditions: { class_name: { rules: [28], inclusive: !1 }, point_y: { rules: [33], inclusive: !1 }, point_x: { rules: [32], inclusive: !1 }, point_start: { rules: [30, 31], inclusive: !1 }, acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, title: { rules: [5], inclusive: !1 }, md_string: { rules: [22, 23], inclusive: !1 }, string: { rules: [25, 26], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 29, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], inclusive: !0 } }
    };
    return he;
  })();
  me.lexer = Ie;
  function te() {
    this.yy = {};
  }
  return w(te, "Parser"), te.prototype = me, me.Parser = te, new te();
})();
N8.parser = N8;
var Rtt = N8, Pi = Px(), Ed, Itt = (Ed = class {
  constructor() {
    this.classes = /* @__PURE__ */ new Map(), this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData();
  }
  getDefaultData() {
    return {
      titleText: "",
      quadrant1Text: "",
      quadrant2Text: "",
      quadrant3Text: "",
      quadrant4Text: "",
      xAxisLeftText: "",
      xAxisRightText: "",
      yAxisBottomText: "",
      yAxisTopText: "",
      points: []
    };
  }
  getDefaultConfig() {
    return {
      showXAxis: !0,
      showYAxis: !0,
      showTitle: !0,
      chartHeight: fr.quadrantChart?.chartWidth || 500,
      chartWidth: fr.quadrantChart?.chartHeight || 500,
      titlePadding: fr.quadrantChart?.titlePadding || 10,
      titleFontSize: fr.quadrantChart?.titleFontSize || 20,
      quadrantPadding: fr.quadrantChart?.quadrantPadding || 5,
      xAxisLabelPadding: fr.quadrantChart?.xAxisLabelPadding || 5,
      yAxisLabelPadding: fr.quadrantChart?.yAxisLabelPadding || 5,
      xAxisLabelFontSize: fr.quadrantChart?.xAxisLabelFontSize || 16,
      yAxisLabelFontSize: fr.quadrantChart?.yAxisLabelFontSize || 16,
      quadrantLabelFontSize: fr.quadrantChart?.quadrantLabelFontSize || 16,
      quadrantTextTopPadding: fr.quadrantChart?.quadrantTextTopPadding || 5,
      pointTextPadding: fr.quadrantChart?.pointTextPadding || 5,
      pointLabelFontSize: fr.quadrantChart?.pointLabelFontSize || 12,
      pointRadius: fr.quadrantChart?.pointRadius || 5,
      xAxisPosition: fr.quadrantChart?.xAxisPosition || "top",
      yAxisPosition: fr.quadrantChart?.yAxisPosition || "left",
      quadrantInternalBorderStrokeWidth: fr.quadrantChart?.quadrantInternalBorderStrokeWidth || 1,
      quadrantExternalBorderStrokeWidth: fr.quadrantChart?.quadrantExternalBorderStrokeWidth || 2
    };
  }
  getDefaultThemeConfig() {
    return {
      quadrant1Fill: Pi.quadrant1Fill,
      quadrant2Fill: Pi.quadrant2Fill,
      quadrant3Fill: Pi.quadrant3Fill,
      quadrant4Fill: Pi.quadrant4Fill,
      quadrant1TextFill: Pi.quadrant1TextFill,
      quadrant2TextFill: Pi.quadrant2TextFill,
      quadrant3TextFill: Pi.quadrant3TextFill,
      quadrant4TextFill: Pi.quadrant4TextFill,
      quadrantPointFill: Pi.quadrantPointFill,
      quadrantPointTextFill: Pi.quadrantPointTextFill,
      quadrantXAxisTextFill: Pi.quadrantXAxisTextFill,
      quadrantYAxisTextFill: Pi.quadrantYAxisTextFill,
      quadrantTitleFill: Pi.quadrantTitleFill,
      quadrantInternalBorderStrokeFill: Pi.quadrantInternalBorderStrokeFill,
      quadrantExternalBorderStrokeFill: Pi.quadrantExternalBorderStrokeFill
    };
  }
  clear() {
    this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData(), this.classes = /* @__PURE__ */ new Map(), ae.info("clear called");
  }
  setData(e) {
    this.data = { ...this.data, ...e };
  }
  addPoints(e) {
    this.data.points = [...e, ...this.data.points];
  }
  addClass(e, r) {
    this.classes.set(e, r);
  }
  setConfig(e) {
    ae.trace("setConfig called with: ", e), this.config = { ...this.config, ...e };
  }
  setThemeConfig(e) {
    ae.trace("setThemeConfig called with: ", e), this.themeConfig = { ...this.themeConfig, ...e };
  }
  calculateSpace(e, r, n, i) {
    const a = this.config.xAxisLabelPadding * 2 + this.config.xAxisLabelFontSize, s = {
      top: e === "top" && r ? a : 0,
      bottom: e === "bottom" && r ? a : 0
    }, o = this.config.yAxisLabelPadding * 2 + this.config.yAxisLabelFontSize, l = {
      left: this.config.yAxisPosition === "left" && n ? o : 0,
      right: this.config.yAxisPosition === "right" && n ? o : 0
    }, u = this.config.titleFontSize + this.config.titlePadding * 2, h = {
      top: i ? u : 0
    }, f = this.config.quadrantPadding + l.left, d = this.config.quadrantPadding + s.top + h.top, p = this.config.chartWidth - this.config.quadrantPadding * 2 - l.left - l.right, g = this.config.chartHeight - this.config.quadrantPadding * 2 - s.top - s.bottom - h.top, m = p / 2, v = g / 2;
    return {
      xAxisSpace: s,
      yAxisSpace: l,
      titleSpace: h,
      quadrantSpace: {
        quadrantLeft: f,
        quadrantTop: d,
        quadrantWidth: p,
        quadrantHalfWidth: m,
        quadrantHeight: g,
        quadrantHalfHeight: v
      }
    };
  }
  getAxisLabels(e, r, n, i) {
    const { quadrantSpace: a, titleSpace: s } = i, {
      quadrantHalfHeight: o,
      quadrantHeight: l,
      quadrantLeft: u,
      quadrantHalfWidth: h,
      quadrantTop: f,
      quadrantWidth: d
    } = a, p = !!this.data.xAxisRightText, g = !!this.data.yAxisTopText, m = [];
    return this.data.xAxisLeftText && r && m.push({
      text: this.data.xAxisLeftText,
      fill: this.themeConfig.quadrantXAxisTextFill,
      x: u + (p ? h / 2 : 0),
      y: e === "top" ? this.config.xAxisLabelPadding + s.top : this.config.xAxisLabelPadding + f + l + this.config.quadrantPadding,
      fontSize: this.config.xAxisLabelFontSize,
      verticalPos: p ? "center" : "left",
      horizontalPos: "top",
      rotation: 0
    }), this.data.xAxisRightText && r && m.push({
      text: this.data.xAxisRightText,
      fill: this.themeConfig.quadrantXAxisTextFill,
      x: u + h + (p ? h / 2 : 0),
      y: e === "top" ? this.config.xAxisLabelPadding + s.top : this.config.xAxisLabelPadding + f + l + this.config.quadrantPadding,
      fontSize: this.config.xAxisLabelFontSize,
      verticalPos: p ? "center" : "left",
      horizontalPos: "top",
      rotation: 0
    }), this.data.yAxisBottomText && n && m.push({
      text: this.data.yAxisBottomText,
      fill: this.themeConfig.quadrantYAxisTextFill,
      x: this.config.yAxisPosition === "left" ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + u + d + this.config.quadrantPadding,
      y: f + l - (g ? o / 2 : 0),
      fontSize: this.config.yAxisLabelFontSize,
      verticalPos: g ? "center" : "left",
      horizontalPos: "top",
      rotation: -90
    }), this.data.yAxisTopText && n && m.push({
      text: this.data.yAxisTopText,
      fill: this.themeConfig.quadrantYAxisTextFill,
      x: this.config.yAxisPosition === "left" ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + u + d + this.config.quadrantPadding,
      y: f + o - (g ? o / 2 : 0),
      fontSize: this.config.yAxisLabelFontSize,
      verticalPos: g ? "center" : "left",
      horizontalPos: "top",
      rotation: -90
    }), m;
  }
  getQuadrants(e) {
    const { quadrantSpace: r } = e, { quadrantHalfHeight: n, quadrantLeft: i, quadrantHalfWidth: a, quadrantTop: s } = r, o = [
      {
        text: {
          text: this.data.quadrant1Text,
          fill: this.themeConfig.quadrant1TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: i + a,
        y: s,
        width: a,
        height: n,
        fill: this.themeConfig.quadrant1Fill
      },
      {
        text: {
          text: this.data.quadrant2Text,
          fill: this.themeConfig.quadrant2TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: i,
        y: s,
        width: a,
        height: n,
        fill: this.themeConfig.quadrant2Fill
      },
      {
        text: {
          text: this.data.quadrant3Text,
          fill: this.themeConfig.quadrant3TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: i,
        y: s + n,
        width: a,
        height: n,
        fill: this.themeConfig.quadrant3Fill
      },
      {
        text: {
          text: this.data.quadrant4Text,
          fill: this.themeConfig.quadrant4TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: i + a,
        y: s + n,
        width: a,
        height: n,
        fill: this.themeConfig.quadrant4Fill
      }
    ];
    for (const l of o)
      l.text.x = l.x + l.width / 2, this.data.points.length === 0 ? (l.text.y = l.y + l.height / 2, l.text.horizontalPos = "middle") : (l.text.y = l.y + this.config.quadrantTextTopPadding, l.text.horizontalPos = "top");
    return o;
  }
  getQuadrantPoints(e) {
    const { quadrantSpace: r } = e, { quadrantHeight: n, quadrantLeft: i, quadrantTop: a, quadrantWidth: s } = r, o = Kd().domain([0, 1]).range([i, s + i]), l = Kd().domain([0, 1]).range([n + a, a]);
    return this.data.points.map((h) => {
      const f = this.classes.get(h.className);
      return f && (h = { ...f, ...h }), {
        x: o(h.x),
        y: l(h.y),
        fill: h.color ?? this.themeConfig.quadrantPointFill,
        radius: h.radius ?? this.config.pointRadius,
        text: {
          text: h.text,
          fill: this.themeConfig.quadrantPointTextFill,
          x: o(h.x),
          y: l(h.y) + this.config.pointTextPadding,
          verticalPos: "center",
          horizontalPos: "top",
          fontSize: this.config.pointLabelFontSize,
          rotation: 0
        },
        strokeColor: h.strokeColor ?? this.themeConfig.quadrantPointFill,
        strokeWidth: h.strokeWidth ?? "0px"
      };
    });
  }
  getBorders(e) {
    const r = this.config.quadrantExternalBorderStrokeWidth / 2, { quadrantSpace: n } = e, {
      quadrantHalfHeight: i,
      quadrantHeight: a,
      quadrantLeft: s,
      quadrantHalfWidth: o,
      quadrantTop: l,
      quadrantWidth: u
    } = n;
    return [
      // top border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: s - r,
        y1: l,
        x2: s + u + r,
        y2: l
      },
      // right border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: s + u,
        y1: l + r,
        x2: s + u,
        y2: l + a - r
      },
      // bottom border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: s - r,
        y1: l + a,
        x2: s + u + r,
        y2: l + a
      },
      // left border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: s,
        y1: l + r,
        x2: s,
        y2: l + a - r
      },
      // vertical inner border
      {
        strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
        strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
        x1: s + o,
        y1: l + r,
        x2: s + o,
        y2: l + a - r
      },
      // horizontal inner border
      {
        strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
        strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
        x1: s + r,
        y1: l + i,
        x2: s + u - r,
        y2: l + i
      }
    ];
  }
  getTitle(e) {
    if (e)
      return {
        text: this.data.titleText,
        fill: this.themeConfig.quadrantTitleFill,
        fontSize: this.config.titleFontSize,
        horizontalPos: "top",
        verticalPos: "center",
        rotation: 0,
        y: this.config.titlePadding,
        x: this.config.chartWidth / 2
      };
  }
  build() {
    const e = this.config.showXAxis && !!(this.data.xAxisLeftText || this.data.xAxisRightText), r = this.config.showYAxis && !!(this.data.yAxisTopText || this.data.yAxisBottomText), n = this.config.showTitle && !!this.data.titleText, i = this.data.points.length > 0 ? "bottom" : this.config.xAxisPosition, a = this.calculateSpace(i, e, r, n);
    return {
      points: this.getQuadrantPoints(a),
      quadrants: this.getQuadrants(a),
      axisLabels: this.getAxisLabels(i, e, r, a),
      borderLines: this.getBorders(a),
      title: this.getTitle(n)
    };
  }
}, w(Ed, "QuadrantBuilder"), Ed), Sd, cy = (Sd = class extends Error {
  constructor(e, r, n) {
    super(`value for ${e} ${r} is invalid, please use a valid ${n}`), this.name = "InvalidStyleError";
  }
}, w(Sd, "InvalidStyleError"), Sd);
function D8(t) {
  return !/^#?([\dA-Fa-f]{6}|[\dA-Fa-f]{3})$/.test(t);
}
w(D8, "validateHexCode");
function jle(t) {
  return !/^\d+$/.test(t);
}
w(jle, "validateNumber");
function Kle(t) {
  return !/^\d+px$/.test(t);
}
w(Kle, "validateSizeInPixels");
var Mtt = Te();
function Do(t) {
  return pr(t.trim(), Mtt);
}
w(Do, "textSanitizer");
var fi = new Itt();
function Zle(t) {
  fi.setData({ quadrant1Text: Do(t.text) });
}
w(Zle, "setQuadrant1Text");
function Qle(t) {
  fi.setData({ quadrant2Text: Do(t.text) });
}
w(Qle, "setQuadrant2Text");
function Jle(t) {
  fi.setData({ quadrant3Text: Do(t.text) });
}
w(Jle, "setQuadrant3Text");
function ece(t) {
  fi.setData({ quadrant4Text: Do(t.text) });
}
w(ece, "setQuadrant4Text");
function tce(t) {
  fi.setData({ xAxisLeftText: Do(t.text) });
}
w(tce, "setXAxisLeftText");
function rce(t) {
  fi.setData({ xAxisRightText: Do(t.text) });
}
w(rce, "setXAxisRightText");
function nce(t) {
  fi.setData({ yAxisTopText: Do(t.text) });
}
w(nce, "setYAxisTopText");
function ice(t) {
  fi.setData({ yAxisBottomText: Do(t.text) });
}
w(ice, "setYAxisBottomText");
function j3(t) {
  const e = {};
  for (const r of t) {
    const [n, i] = r.trim().split(/\s*:\s*/);
    if (n === "radius") {
      if (jle(i))
        throw new cy(n, i, "number");
      e.radius = parseInt(i);
    } else if (n === "color") {
      if (D8(i))
        throw new cy(n, i, "hex code");
      e.color = i;
    } else if (n === "stroke-color") {
      if (D8(i))
        throw new cy(n, i, "hex code");
      e.strokeColor = i;
    } else if (n === "stroke-width") {
      if (Kle(i))
        throw new cy(n, i, "number of pixels (eg. 10px)");
      e.strokeWidth = i;
    } else
      throw new Error(`style named ${n} is not supported.`);
  }
  return e;
}
w(j3, "parseStyles");
function ace(t, e, r, n, i) {
  const a = j3(i);
  fi.addPoints([
    {
      x: r,
      y: n,
      text: Do(t.text),
      className: e,
      ...a
    }
  ]);
}
w(ace, "addPoint");
function sce(t, e) {
  fi.addClass(t, j3(e));
}
w(sce, "addClass");
function oce(t) {
  fi.setConfig({ chartWidth: t });
}
w(oce, "setWidth");
function lce(t) {
  fi.setConfig({ chartHeight: t });
}
w(lce, "setHeight");
function cce() {
  const t = Te(), { themeVariables: e, quadrantChart: r } = t;
  return r && fi.setConfig(r), fi.setThemeConfig({
    quadrant1Fill: e.quadrant1Fill,
    quadrant2Fill: e.quadrant2Fill,
    quadrant3Fill: e.quadrant3Fill,
    quadrant4Fill: e.quadrant4Fill,
    quadrant1TextFill: e.quadrant1TextFill,
    quadrant2TextFill: e.quadrant2TextFill,
    quadrant3TextFill: e.quadrant3TextFill,
    quadrant4TextFill: e.quadrant4TextFill,
    quadrantPointFill: e.quadrantPointFill,
    quadrantPointTextFill: e.quadrantPointTextFill,
    quadrantXAxisTextFill: e.quadrantXAxisTextFill,
    quadrantYAxisTextFill: e.quadrantYAxisTextFill,
    quadrantExternalBorderStrokeFill: e.quadrantExternalBorderStrokeFill,
    quadrantInternalBorderStrokeFill: e.quadrantInternalBorderStrokeFill,
    quadrantTitleFill: e.quadrantTitleFill
  }), fi.setData({ titleText: Mn() }), fi.build();
}
w(cce, "getQuadrantData");
var Ntt = /* @__PURE__ */ w(function() {
  fi.clear(), In();
}, "clear"), Dtt = {
  setWidth: oce,
  setHeight: lce,
  setQuadrant1Text: Zle,
  setQuadrant2Text: Qle,
  setQuadrant3Text: Jle,
  setQuadrant4Text: ece,
  setXAxisLeftText: tce,
  setXAxisRightText: rce,
  setYAxisTopText: nce,
  setYAxisBottomText: ice,
  parseStyles: j3,
  addPoint: ace,
  addClass: sce,
  getQuadrantData: cce,
  clear: Ntt,
  setAccTitle: Ln,
  getAccTitle: Hn,
  setDiagramTitle: ti,
  getDiagramTitle: Mn,
  getAccDescription: Yn,
  setAccDescription: Wn
}, Ott = /* @__PURE__ */ w((t, e, r, n) => {
  function i(k) {
    return k === "top" ? "hanging" : "middle";
  }
  w(i, "getDominantBaseLine");
  function a(k) {
    return k === "left" ? "start" : "middle";
  }
  w(a, "getTextAnchor");
  function s(k) {
    return `translate(${k.x}, ${k.y}) rotate(${k.rotation || 0})`;
  }
  w(s, "getTransformation");
  const o = Te();
  ae.debug(`Rendering quadrant chart
` + t);
  const l = o.securityLevel;
  let u;
  l === "sandbox" && (u = Qe("#i" + e));
  const f = Qe(l === "sandbox" ? u.nodes()[0].contentDocument.body : "body").select(`[id="${e}"]`), d = f.append("g").attr("class", "main"), p = o.quadrantChart?.chartWidth ?? 500, g = o.quadrantChart?.chartHeight ?? 500;
  Qi(f, g, p, o.quadrantChart?.useMaxWidth ?? !0), f.attr("viewBox", "0 0 " + p + " " + g), n.db.setHeight(g), n.db.setWidth(p);
  const m = n.db.getQuadrantData(), v = d.append("g").attr("class", "quadrants"), y = d.append("g").attr("class", "border"), b = d.append("g").attr("class", "data-points"), x = d.append("g").attr("class", "labels"), T = d.append("g").attr("class", "title");
  m.title && T.append("text").attr("x", 0).attr("y", 0).attr("fill", m.title.fill).attr("font-size", m.title.fontSize).attr("dominant-baseline", i(m.title.horizontalPos)).attr("text-anchor", a(m.title.verticalPos)).attr("transform", s(m.title)).text(m.title.text), m.borderLines && y.selectAll("line").data(m.borderLines).enter().append("line").attr("x1", (k) => k.x1).attr("y1", (k) => k.y1).attr("x2", (k) => k.x2).attr("y2", (k) => k.y2).style("stroke", (k) => k.strokeFill).style("stroke-width", (k) => k.strokeWidth);
  const E = v.selectAll("g.quadrant").data(m.quadrants).enter().append("g").attr("class", "quadrant");
  E.append("rect").attr("x", (k) => k.x).attr("y", (k) => k.y).attr("width", (k) => k.width).attr("height", (k) => k.height).attr("fill", (k) => k.fill), E.append("text").attr("x", 0).attr("y", 0).attr("fill", (k) => k.text.fill).attr("font-size", (k) => k.text.fontSize).attr(
    "dominant-baseline",
    (k) => i(k.text.horizontalPos)
  ).attr("text-anchor", (k) => a(k.text.verticalPos)).attr("transform", (k) => s(k.text)).text((k) => k.text.text), x.selectAll("g.label").data(m.axisLabels).enter().append("g").attr("class", "label").append("text").attr("x", 0).attr("y", 0).text((k) => k.text).attr("fill", (k) => k.fill).attr("font-size", (k) => k.fontSize).attr("dominant-baseline", (k) => i(k.horizontalPos)).attr("text-anchor", (k) => a(k.verticalPos)).attr("transform", (k) => s(k));
  const S = b.selectAll("g.data-point").data(m.points).enter().append("g").attr("class", "data-point");
  S.append("circle").attr("cx", (k) => k.x).attr("cy", (k) => k.y).attr("r", (k) => k.radius).attr("fill", (k) => k.fill).attr("stroke", (k) => k.strokeColor).attr("stroke-width", (k) => k.strokeWidth), S.append("text").attr("x", 0).attr("y", 0).text((k) => k.text.text).attr("fill", (k) => k.text.fill).attr("font-size", (k) => k.text.fontSize).attr(
    "dominant-baseline",
    (k) => i(k.text.horizontalPos)
  ).attr("text-anchor", (k) => a(k.text.verticalPos)).attr("transform", (k) => s(k.text));
}, "draw"), Ptt = {
  draw: Ott
}, $tt = {
  parser: Rtt,
  db: Dtt,
  renderer: Ptt,
  styles: /* @__PURE__ */ w(() => "", "styles")
};
const Btt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: $tt
}, Symbol.toStringTag, { value: "Module" }));
var O8 = (function() {
  var t = /* @__PURE__ */ w(function(I, N, O, D) {
    for (O = O || {}, D = I.length; D--; O[I[D]] = N) ;
    return O;
  }, "o"), e = [1, 10, 12, 14, 16, 18, 19, 21, 23], r = [2, 6], n = [1, 3], i = [1, 5], a = [1, 6], s = [1, 7], o = [1, 5, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36], l = [1, 25], u = [1, 26], h = [1, 28], f = [1, 29], d = [1, 30], p = [1, 31], g = [1, 32], m = [1, 33], v = [1, 34], y = [1, 35], b = [1, 36], x = [1, 37], T = [1, 43], E = [1, 42], A = [1, 47], S = [1, 50], k = [1, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36], _ = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36], R = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], L = [1, 64], M = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, eol: 4, XYCHART: 5, chartConfig: 6, document: 7, CHART_ORIENTATION: 8, statement: 9, title: 10, text: 11, X_AXIS: 12, parseXAxis: 13, Y_AXIS: 14, parseYAxis: 15, LINE: 16, plotData: 17, BAR: 18, acc_title: 19, acc_title_value: 20, acc_descr: 21, acc_descr_value: 22, acc_descr_multiline_value: 23, SQUARE_BRACES_START: 24, commaSeparatedNumbers: 25, SQUARE_BRACES_END: 26, NUMBER_WITH_DECIMAL: 27, COMMA: 28, xAxisData: 29, bandData: 30, ARROW_DELIMITER: 31, commaSeparatedTexts: 32, yAxisData: 33, NEWLINE: 34, SEMI: 35, EOF: 36, alphaNum: 37, STR: 38, MD_STR: 39, alphaNumToken: 40, AMP: 41, NUM: 42, ALPHA: 43, PLUS: 44, EQUALS: 45, MULT: 46, DOT: 47, BRKT: 48, MINUS: 49, UNDERSCORE: 50, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "XYCHART", 8: "CHART_ORIENTATION", 10: "title", 12: "X_AXIS", 14: "Y_AXIS", 16: "LINE", 18: "BAR", 19: "acc_title", 20: "acc_title_value", 21: "acc_descr", 22: "acc_descr_value", 23: "acc_descr_multiline_value", 24: "SQUARE_BRACES_START", 26: "SQUARE_BRACES_END", 27: "NUMBER_WITH_DECIMAL", 28: "COMMA", 31: "ARROW_DELIMITER", 34: "NEWLINE", 35: "SEMI", 36: "EOF", 38: "STR", 39: "MD_STR", 41: "AMP", 42: "NUM", 43: "ALPHA", 44: "PLUS", 45: "EQUALS", 46: "MULT", 47: "DOT", 48: "BRKT", 49: "MINUS", 50: "UNDERSCORE" },
    productions_: [0, [3, 2], [3, 3], [3, 2], [3, 1], [6, 1], [7, 0], [7, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 3], [9, 2], [9, 3], [9, 2], [9, 2], [9, 1], [17, 3], [25, 3], [25, 1], [13, 1], [13, 2], [13, 1], [29, 1], [29, 3], [30, 3], [32, 3], [32, 1], [15, 1], [15, 2], [15, 1], [33, 3], [4, 1], [4, 1], [4, 1], [11, 1], [11, 1], [11, 1], [37, 1], [37, 2], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1]],
    performAction: /* @__PURE__ */ w(function(N, O, D, $, z, B, G) {
      var W = B.length - 1;
      switch (z) {
        case 5:
          $.setOrientation(B[W]);
          break;
        case 9:
          $.setDiagramTitle(B[W].text.trim());
          break;
        case 12:
          $.setLineData({ text: "", type: "text" }, B[W]);
          break;
        case 13:
          $.setLineData(B[W - 1], B[W]);
          break;
        case 14:
          $.setBarData({ text: "", type: "text" }, B[W]);
          break;
        case 15:
          $.setBarData(B[W - 1], B[W]);
          break;
        case 16:
          this.$ = B[W].trim(), $.setAccTitle(this.$);
          break;
        case 17:
        case 18:
          this.$ = B[W].trim(), $.setAccDescription(this.$);
          break;
        case 19:
          this.$ = B[W - 1];
          break;
        case 20:
          this.$ = [Number(B[W - 2]), ...B[W]];
          break;
        case 21:
          this.$ = [Number(B[W])];
          break;
        case 22:
          $.setXAxisTitle(B[W]);
          break;
        case 23:
          $.setXAxisTitle(B[W - 1]);
          break;
        case 24:
          $.setXAxisTitle({ type: "text", text: "" });
          break;
        case 25:
          $.setXAxisBand(B[W]);
          break;
        case 26:
          $.setXAxisRangeData(Number(B[W - 2]), Number(B[W]));
          break;
        case 27:
          this.$ = B[W - 1];
          break;
        case 28:
          this.$ = [B[W - 2], ...B[W]];
          break;
        case 29:
          this.$ = [B[W]];
          break;
        case 30:
          $.setYAxisTitle(B[W]);
          break;
        case 31:
          $.setYAxisTitle(B[W - 1]);
          break;
        case 32:
          $.setYAxisTitle({ type: "text", text: "" });
          break;
        case 33:
          $.setYAxisRangeData(Number(B[W - 2]), Number(B[W]));
          break;
        case 37:
          this.$ = { text: B[W], type: "text" };
          break;
        case 38:
          this.$ = { text: B[W], type: "text" };
          break;
        case 39:
          this.$ = { text: B[W], type: "markdown" };
          break;
        case 40:
          this.$ = B[W];
          break;
        case 41:
          this.$ = B[W - 1] + "" + B[W];
          break;
      }
    }, "anonymous"),
    table: [t(e, r, { 3: 1, 4: 2, 7: 4, 5: n, 34: i, 35: a, 36: s }), { 1: [3] }, t(e, r, { 4: 2, 7: 4, 3: 8, 5: n, 34: i, 35: a, 36: s }), t(e, r, { 4: 2, 7: 4, 6: 9, 3: 10, 5: n, 8: [1, 11], 34: i, 35: a, 36: s }), { 1: [2, 4], 9: 12, 10: [1, 13], 12: [1, 14], 14: [1, 15], 16: [1, 16], 18: [1, 17], 19: [1, 18], 21: [1, 19], 23: [1, 20] }, t(o, [2, 34]), t(o, [2, 35]), t(o, [2, 36]), { 1: [2, 1] }, t(e, r, { 4: 2, 7: 4, 3: 21, 5: n, 34: i, 35: a, 36: s }), { 1: [2, 3] }, t(o, [2, 5]), t(e, [2, 7], { 4: 22, 34: i, 35: a, 36: s }), { 11: 23, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }, { 11: 39, 13: 38, 24: T, 27: E, 29: 40, 30: 41, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }, { 11: 45, 15: 44, 27: A, 33: 46, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }, { 11: 49, 17: 48, 24: S, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }, { 11: 52, 17: 51, 24: S, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }, { 20: [1, 53] }, { 22: [1, 54] }, t(k, [2, 18]), { 1: [2, 2] }, t(k, [2, 8]), t(k, [2, 9]), t(_, [2, 37], { 40: 55, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }), t(_, [2, 38]), t(_, [2, 39]), t(R, [2, 40]), t(R, [2, 42]), t(R, [2, 43]), t(R, [2, 44]), t(R, [2, 45]), t(R, [2, 46]), t(R, [2, 47]), t(R, [2, 48]), t(R, [2, 49]), t(R, [2, 50]), t(R, [2, 51]), t(k, [2, 10]), t(k, [2, 22], { 30: 41, 29: 56, 24: T, 27: E }), t(k, [2, 24]), t(k, [2, 25]), { 31: [1, 57] }, { 11: 59, 32: 58, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }, t(k, [2, 11]), t(k, [2, 30], { 33: 60, 27: A }), t(k, [2, 32]), { 31: [1, 61] }, t(k, [2, 12]), { 17: 62, 24: S }, { 25: 63, 27: L }, t(k, [2, 14]), { 17: 65, 24: S }, t(k, [2, 16]), t(k, [2, 17]), t(R, [2, 41]), t(k, [2, 23]), { 27: [1, 66] }, { 26: [1, 67] }, { 26: [2, 29], 28: [1, 68] }, t(k, [2, 31]), { 27: [1, 69] }, t(k, [2, 13]), { 26: [1, 70] }, { 26: [2, 21], 28: [1, 71] }, t(k, [2, 15]), t(k, [2, 26]), t(k, [2, 27]), { 11: 59, 32: 72, 37: 24, 38: l, 39: u, 40: 27, 41: h, 42: f, 43: d, 44: p, 45: g, 46: m, 47: v, 48: y, 49: b, 50: x }, t(k, [2, 33]), t(k, [2, 19]), { 25: 73, 27: L }, { 26: [2, 28] }, { 26: [2, 20] }],
    defaultActions: { 8: [2, 1], 10: [2, 3], 21: [2, 2], 72: [2, 28], 73: [2, 20] },
    parseError: /* @__PURE__ */ w(function(N, O) {
      if (O.recoverable)
        this.trace(N);
      else {
        var D = new Error(N);
        throw D.hash = O, D;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(N) {
      var O = this, D = [0], $ = [], z = [null], B = [], G = this.table, W = "", V = 0, U = 0, Z = 2, K = 1, ce = B.slice.call(arguments, 1), J = Object.create(this.lexer), ee = { yy: {} };
      for (var j in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, j) && (ee.yy[j] = this.yy[j]);
      J.setInput(N, ee.yy), ee.yy.lexer = J, ee.yy.parser = this, typeof J.yylloc > "u" && (J.yylloc = {});
      var X = J.yylloc;
      B.push(X);
      var re = J.options && J.options.ranges;
      typeof ee.yy.parseError == "function" ? this.parseError = ee.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Q(Ce) {
        D.length = D.length - 2 * Ce, z.length = z.length - Ce, B.length = B.length - Ce;
      }
      w(Q, "popStack");
      function ue() {
        var Ce;
        return Ce = $.pop() || J.lex() || K, typeof Ce != "number" && (Ce instanceof Array && ($ = Ce, Ce = $.pop()), Ce = O.symbols_[Ce] || Ce), Ce;
      }
      w(ue, "lex");
      for (var ne, xe, Y, Ne, fe = {}, qe, ze, Ge, Ee; ; ) {
        if (xe = D[D.length - 1], this.defaultActions[xe] ? Y = this.defaultActions[xe] : ((ne === null || typeof ne > "u") && (ne = ue()), Y = G[xe] && G[xe][ne]), typeof Y > "u" || !Y.length || !Y[0]) {
          var Oe = "";
          Ee = [];
          for (qe in G[xe])
            this.terminals_[qe] && qe > Z && Ee.push("'" + this.terminals_[qe] + "'");
          J.showPosition ? Oe = "Parse error on line " + (V + 1) + `:
` + J.showPosition() + `
Expecting ` + Ee.join(", ") + ", got '" + (this.terminals_[ne] || ne) + "'" : Oe = "Parse error on line " + (V + 1) + ": Unexpected " + (ne == K ? "end of input" : "'" + (this.terminals_[ne] || ne) + "'"), this.parseError(Oe, {
            text: J.match,
            token: this.terminals_[ne] || ne,
            line: J.yylineno,
            loc: X,
            expected: Ee
          });
        }
        if (Y[0] instanceof Array && Y.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + xe + ", token: " + ne);
        switch (Y[0]) {
          case 1:
            D.push(ne), z.push(J.yytext), B.push(J.yylloc), D.push(Y[1]), ne = null, U = J.yyleng, W = J.yytext, V = J.yylineno, X = J.yylloc;
            break;
          case 2:
            if (ze = this.productions_[Y[1]][1], fe.$ = z[z.length - ze], fe._$ = {
              first_line: B[B.length - (ze || 1)].first_line,
              last_line: B[B.length - 1].last_line,
              first_column: B[B.length - (ze || 1)].first_column,
              last_column: B[B.length - 1].last_column
            }, re && (fe._$.range = [
              B[B.length - (ze || 1)].range[0],
              B[B.length - 1].range[1]
            ]), Ne = this.performAction.apply(fe, [
              W,
              U,
              V,
              ee.yy,
              Y[1],
              z,
              B
            ].concat(ce)), typeof Ne < "u")
              return Ne;
            ze && (D = D.slice(0, -1 * ze * 2), z = z.slice(0, -1 * ze), B = B.slice(0, -1 * ze)), D.push(this.productions_[Y[1]][0]), z.push(fe.$), B.push(fe._$), Ge = G[D[D.length - 2]][D[D.length - 1]], D.push(Ge);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, P = /* @__PURE__ */ (function() {
    var I = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(O, D) {
        if (this.yy.parser)
          this.yy.parser.parseError(O, D);
        else
          throw new Error(O);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(N, O) {
        return this.yy = O || this.yy || {}, this._input = N, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var N = this._input[0];
        this.yytext += N, this.yyleng++, this.offset++, this.match += N, this.matched += N;
        var O = N.match(/(?:\r\n?|\n).*/g);
        return O ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), N;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(N) {
        var O = N.length, D = N.split(/(?:\r\n?|\n)/g);
        this._input = N + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - O), this.offset -= O;
        var $ = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), D.length - 1 && (this.yylineno -= D.length - 1);
        var z = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: D ? (D.length === $.length ? this.yylloc.first_column : 0) + $[$.length - D.length].length - D[0].length : this.yylloc.first_column - O
        }, this.options.ranges && (this.yylloc.range = [z[0], z[0] + this.yyleng - O]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(N) {
        this.unput(this.match.slice(N));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var N = this.matched.substr(0, this.matched.length - this.match.length);
        return (N.length > 20 ? "..." : "") + N.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var N = this.match;
        return N.length < 20 && (N += this._input.substr(0, 20 - N.length)), (N.substr(0, 20) + (N.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var N = this.pastInput(), O = new Array(N.length + 1).join("-");
        return N + this.upcomingInput() + `
` + O + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(N, O) {
        var D, $, z;
        if (this.options.backtrack_lexer && (z = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (z.yylloc.range = this.yylloc.range.slice(0))), $ = N[0].match(/(?:\r\n?|\n).*/g), $ && (this.yylineno += $.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: $ ? $[$.length - 1].length - $[$.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + N[0].length
        }, this.yytext += N[0], this.match += N[0], this.matches = N, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(N[0].length), this.matched += N[0], D = this.performAction.call(this, this.yy, this, O, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), D)
          return D;
        if (this._backtrack) {
          for (var B in z)
            this[B] = z[B];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var N, O, D, $;
        this._more || (this.yytext = "", this.match = "");
        for (var z = this._currentRules(), B = 0; B < z.length; B++)
          if (D = this._input.match(this.rules[z[B]]), D && (!O || D[0].length > O[0].length)) {
            if (O = D, $ = B, this.options.backtrack_lexer) {
              if (N = this.test_match(D, z[B]), N !== !1)
                return N;
              if (this._backtrack) {
                O = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return O ? (N = this.test_match(O, z[$]), N !== !1 ? N : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var O = this.next();
        return O || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(O) {
        this.conditionStack.push(O);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var O = this.conditionStack.length - 1;
        return O > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(O) {
        return O = this.conditionStack.length - 1 - Math.abs(O || 0), O >= 0 ? this.conditionStack[O] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(O) {
        this.begin(O);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(O, D, $, z) {
        switch ($) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return this.popState(), 34;
          case 3:
            return this.popState(), 34;
          case 4:
            return 34;
          case 5:
            break;
          case 6:
            return 10;
          case 7:
            return this.pushState("acc_title"), 19;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.pushState("acc_descr"), 21;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.pushState("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 5;
          case 15:
            return 5;
          case 16:
            return 8;
          case 17:
            return this.pushState("axis_data"), "X_AXIS";
          case 18:
            return this.pushState("axis_data"), "Y_AXIS";
          case 19:
            return this.pushState("axis_band_data"), 24;
          case 20:
            return 31;
          case 21:
            return this.pushState("data"), 16;
          case 22:
            return this.pushState("data"), 18;
          case 23:
            return this.pushState("data_inner"), 24;
          case 24:
            return 27;
          case 25:
            return this.popState(), 26;
          case 26:
            this.popState();
            break;
          case 27:
            this.pushState("string");
            break;
          case 28:
            this.popState();
            break;
          case 29:
            return "STR";
          case 30:
            return 24;
          case 31:
            return 26;
          case 32:
            return 43;
          case 33:
            return "COLON";
          case 34:
            return 44;
          case 35:
            return 28;
          case 36:
            return 45;
          case 37:
            return 46;
          case 38:
            return 48;
          case 39:
            return 50;
          case 40:
            return 47;
          case 41:
            return 41;
          case 42:
            return 49;
          case 43:
            return 42;
          case 44:
            break;
          case 45:
            return 35;
          case 46:
            return 36;
        }
      }, "anonymous"),
      rules: [/^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:(\r?\n))/i, /^(?:(\r?\n))/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:title\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:\{)/i, /^(?:[^\}]*)/i, /^(?:xychart-beta\b)/i, /^(?:xychart\b)/i, /^(?:(?:vertical|horizontal))/i, /^(?:x-axis\b)/i, /^(?:y-axis\b)/i, /^(?:\[)/i, /^(?:-->)/i, /^(?:line\b)/i, /^(?:bar\b)/i, /^(?:\[)/i, /^(?:[+-]?(?:\d+(?:\.\d+)?|\.\d+))/i, /^(?:\])/i, /^(?:(?:`\)                                    \{ this\.pushState\(md_string\); \}\n<md_string>\(\?:\(\?!`"\)\.\)\+                  \{ return MD_STR; \}\n<md_string>\(\?:`))/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:[A-Za-z]+)/i, /^(?::)/i, /^(?:\+)/i, /^(?:,)/i, /^(?:=)/i, /^(?:\*)/i, /^(?:#)/i, /^(?:[\_])/i, /^(?:\.)/i, /^(?:&)/i, /^(?:-)/i, /^(?:[0-9]+)/i, /^(?:\s+)/i, /^(?:;)/i, /^(?:$)/i],
      conditions: { data_inner: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, data: { rules: [0, 1, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 23, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, axis_band_data: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, axis_data: { rules: [0, 1, 2, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, title: { rules: [], inclusive: !1 }, md_string: { rules: [], inclusive: !1 }, string: { rules: [28, 29], inclusive: !1 }, INITIAL: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 } }
    };
    return I;
  })();
  M.lexer = P;
  function C() {
    this.yy = {};
  }
  return w(C, "Parser"), C.prototype = M, M.Parser = C, new C();
})();
O8.parser = O8;
var Ftt = O8;
function P8(t) {
  return t.type === "bar";
}
w(P8, "isBarPlot");
function JI(t) {
  return t.type === "band";
}
w(JI, "isBandAxisData");
function Wf(t) {
  return t.type === "linear";
}
w(Wf, "isLinearAxisData");
var kd, uce = (kd = class {
  constructor(e) {
    this.parentGroup = e;
  }
  getMaxDimension(e, r) {
    if (!this.parentGroup)
      return {
        width: e.reduce((a, s) => Math.max(s.length, a), 0) * r,
        height: r
      };
    const n = {
      width: 0,
      height: 0
    }, i = this.parentGroup.append("g").attr("visibility", "hidden").attr("font-size", r);
    for (const a of e) {
      const s = sQ(i, 1, a), o = s ? s.width : a.length * r, l = s ? s.height : r;
      n.width = Math.max(n.width, o), n.height = Math.max(n.height, l);
    }
    return i.remove(), n;
  }
}, w(kd, "TextDimensionCalculatorWithFont"), kd), XW = 0.7, jW = 0.2, Cd, hce = (Cd = class {
  constructor(e, r, n, i) {
    this.axisConfig = e, this.title = r, this.textDimensionCalculator = n, this.axisThemeConfig = i, this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }, this.axisPosition = "left", this.showTitle = !1, this.showLabel = !1, this.showTick = !1, this.showAxisLine = !1, this.outerPadding = 0, this.titleTextHeight = 0, this.labelTextHeight = 0, this.range = [0, 10], this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }, this.axisPosition = "left";
  }
  setRange(e) {
    this.range = e, this.axisPosition === "left" || this.axisPosition === "right" ? this.boundingRect.height = e[1] - e[0] : this.boundingRect.width = e[1] - e[0], this.recalculateScale();
  }
  getRange() {
    return [this.range[0] + this.outerPadding, this.range[1] - this.outerPadding];
  }
  setAxisPosition(e) {
    this.axisPosition = e, this.setRange(this.range);
  }
  getTickDistance() {
    const e = this.getRange();
    return Math.abs(e[0] - e[1]) / this.getTickValues().length;
  }
  getAxisOuterPadding() {
    return this.outerPadding;
  }
  getLabelDimension() {
    return this.textDimensionCalculator.getMaxDimension(
      this.getTickValues().map((e) => e.toString()),
      this.axisConfig.labelFontSize
    );
  }
  recalculateOuterPaddingToDrawBar() {
    XW * this.getTickDistance() > this.outerPadding * 2 && (this.outerPadding = Math.floor(XW * this.getTickDistance() / 2)), this.recalculateScale();
  }
  calculateSpaceIfDrawnHorizontally(e) {
    let r = e.height;
    if (this.axisConfig.showAxisLine && r > this.axisConfig.axisLineWidth && (r -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
      const n = this.getLabelDimension(), i = jW * e.width;
      this.outerPadding = Math.min(n.width / 2, i);
      const a = n.height + this.axisConfig.labelPadding * 2;
      this.labelTextHeight = n.height, a <= r && (r -= a, this.showLabel = !0);
    }
    if (this.axisConfig.showTick && r >= this.axisConfig.tickLength && (this.showTick = !0, r -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
      const n = this.textDimensionCalculator.getMaxDimension(
        [this.title],
        this.axisConfig.titleFontSize
      ), i = n.height + this.axisConfig.titlePadding * 2;
      this.titleTextHeight = n.height, i <= r && (r -= i, this.showTitle = !0);
    }
    this.boundingRect.width = e.width, this.boundingRect.height = e.height - r;
  }
  calculateSpaceIfDrawnVertical(e) {
    let r = e.width;
    if (this.axisConfig.showAxisLine && r > this.axisConfig.axisLineWidth && (r -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
      const n = this.getLabelDimension(), i = jW * e.height;
      this.outerPadding = Math.min(n.height / 2, i);
      const a = n.width + this.axisConfig.labelPadding * 2;
      a <= r && (r -= a, this.showLabel = !0);
    }
    if (this.axisConfig.showTick && r >= this.axisConfig.tickLength && (this.showTick = !0, r -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
      const n = this.textDimensionCalculator.getMaxDimension(
        [this.title],
        this.axisConfig.titleFontSize
      ), i = n.height + this.axisConfig.titlePadding * 2;
      this.titleTextHeight = n.height, i <= r && (r -= i, this.showTitle = !0);
    }
    this.boundingRect.width = e.width - r, this.boundingRect.height = e.height;
  }
  calculateSpace(e) {
    return this.axisPosition === "left" || this.axisPosition === "right" ? this.calculateSpaceIfDrawnVertical(e) : this.calculateSpaceIfDrawnHorizontally(e), this.recalculateScale(), {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  setBoundingBoxXY(e) {
    this.boundingRect.x = e.x, this.boundingRect.y = e.y;
  }
  getDrawableElementsForLeftAxis() {
    const e = [];
    if (this.showAxisLine) {
      const r = this.boundingRect.x + this.boundingRect.width - this.axisConfig.axisLineWidth / 2;
      e.push({
        type: "path",
        groupTexts: ["left-axis", "axisl-line"],
        data: [
          {
            path: `M ${r},${this.boundingRect.y} L ${r},${this.boundingRect.y + this.boundingRect.height} `,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && e.push({
      type: "text",
      groupTexts: ["left-axis", "label"],
      data: this.getTickValues().map((r) => ({
        text: r.toString(),
        x: this.boundingRect.x + this.boundingRect.width - (this.showLabel ? this.axisConfig.labelPadding : 0) - (this.showTick ? this.axisConfig.tickLength : 0) - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
        y: this.getScaleValue(r),
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "middle",
        horizontalPos: "right"
      }))
    }), this.showTick) {
      const r = this.boundingRect.x + this.boundingRect.width - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
      e.push({
        type: "path",
        groupTexts: ["left-axis", "ticks"],
        data: this.getTickValues().map((n) => ({
          path: `M ${r},${this.getScaleValue(n)} L ${r - this.axisConfig.tickLength},${this.getScaleValue(n)}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && e.push({
      type: "text",
      groupTexts: ["left-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.boundingRect.x + this.axisConfig.titlePadding,
          y: this.boundingRect.y + this.boundingRect.height / 2,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 270,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), e;
  }
  getDrawableElementsForBottomAxis() {
    const e = [];
    if (this.showAxisLine) {
      const r = this.boundingRect.y + this.axisConfig.axisLineWidth / 2;
      e.push({
        type: "path",
        groupTexts: ["bottom-axis", "axis-line"],
        data: [
          {
            path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && e.push({
      type: "text",
      groupTexts: ["bottom-axis", "label"],
      data: this.getTickValues().map((r) => ({
        text: r.toString(),
        x: this.getScaleValue(r),
        y: this.boundingRect.y + this.axisConfig.labelPadding + (this.showTick ? this.axisConfig.tickLength : 0) + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "top",
        horizontalPos: "center"
      }))
    }), this.showTick) {
      const r = this.boundingRect.y + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
      e.push({
        type: "path",
        groupTexts: ["bottom-axis", "ticks"],
        data: this.getTickValues().map((n) => ({
          path: `M ${this.getScaleValue(n)},${r} L ${this.getScaleValue(n)},${r + this.axisConfig.tickLength}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && e.push({
      type: "text",
      groupTexts: ["bottom-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.range[0] + (this.range[1] - this.range[0]) / 2,
          y: this.boundingRect.y + this.boundingRect.height - this.axisConfig.titlePadding - this.titleTextHeight,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 0,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), e;
  }
  getDrawableElementsForTopAxis() {
    const e = [];
    if (this.showAxisLine) {
      const r = this.boundingRect.y + this.boundingRect.height - this.axisConfig.axisLineWidth / 2;
      e.push({
        type: "path",
        groupTexts: ["top-axis", "axis-line"],
        data: [
          {
            path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && e.push({
      type: "text",
      groupTexts: ["top-axis", "label"],
      data: this.getTickValues().map((r) => ({
        text: r.toString(),
        x: this.getScaleValue(r),
        y: this.boundingRect.y + (this.showTitle ? this.titleTextHeight + this.axisConfig.titlePadding * 2 : 0) + this.axisConfig.labelPadding,
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "top",
        horizontalPos: "center"
      }))
    }), this.showTick) {
      const r = this.boundingRect.y;
      e.push({
        type: "path",
        groupTexts: ["top-axis", "ticks"],
        data: this.getTickValues().map((n) => ({
          path: `M ${this.getScaleValue(n)},${r + this.boundingRect.height - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)} L ${this.getScaleValue(n)},${r + this.boundingRect.height - this.axisConfig.tickLength - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && e.push({
      type: "text",
      groupTexts: ["top-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.boundingRect.x + this.boundingRect.width / 2,
          y: this.boundingRect.y + this.axisConfig.titlePadding,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 0,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), e;
  }
  getDrawableElements() {
    if (this.axisPosition === "left")
      return this.getDrawableElementsForLeftAxis();
    if (this.axisPosition === "right")
      throw Error("Drawing of right axis is not implemented");
    return this.axisPosition === "bottom" ? this.getDrawableElementsForBottomAxis() : this.axisPosition === "top" ? this.getDrawableElementsForTopAxis() : [];
  }
}, w(Cd, "BaseAxis"), Cd), _d, ztt = (_d = class extends hce {
  constructor(e, r, n, i, a) {
    super(e, i, a, r), this.categories = n, this.scale = m_().domain(this.categories).range(this.getRange());
  }
  setRange(e) {
    super.setRange(e);
  }
  recalculateScale() {
    this.scale = m_().domain(this.categories).range(this.getRange()).paddingInner(1).paddingOuter(0).align(0.5), ae.trace("BandAxis axis final categories, range: ", this.categories, this.getRange());
  }
  getTickValues() {
    return this.categories;
  }
  getScaleValue(e) {
    return this.scale(e) ?? this.getRange()[0];
  }
}, w(_d, "BandAxis"), _d), Ad, qtt = (Ad = class extends hce {
  constructor(e, r, n, i, a) {
    super(e, i, a, r), this.domain = n, this.scale = Kd().domain(this.domain).range(this.getRange());
  }
  getTickValues() {
    return this.scale.ticks();
  }
  recalculateScale() {
    const e = [...this.domain];
    this.axisPosition === "left" && e.reverse(), this.scale = Kd().domain(e).range(this.getRange());
  }
  getScaleValue(e) {
    return this.scale(e);
  }
}, w(Ad, "LinearAxis"), Ad);
function $8(t, e, r, n) {
  const i = new uce(n);
  return JI(t) ? new ztt(
    e,
    r,
    t.categories,
    t.title,
    i
  ) : new qtt(
    e,
    r,
    [t.min, t.max],
    t.title,
    i
  );
}
w($8, "getAxis");
var Ld, Gtt = (Ld = class {
  constructor(e, r, n, i) {
    this.textDimensionCalculator = e, this.chartConfig = r, this.chartData = n, this.chartThemeConfig = i, this.boundingRect = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, this.showChartTitle = !1;
  }
  setBoundingBoxXY(e) {
    this.boundingRect.x = e.x, this.boundingRect.y = e.y;
  }
  calculateSpace(e) {
    const r = this.textDimensionCalculator.getMaxDimension(
      [this.chartData.title],
      this.chartConfig.titleFontSize
    ), n = Math.max(r.width, e.width), i = r.height + 2 * this.chartConfig.titlePadding;
    return r.width <= n && r.height <= i && this.chartConfig.showTitle && this.chartData.title && (this.boundingRect.width = n, this.boundingRect.height = i, this.showChartTitle = !0), {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  getDrawableElements() {
    const e = [];
    return this.showChartTitle && e.push({
      groupTexts: ["chart-title"],
      type: "text",
      data: [
        {
          fontSize: this.chartConfig.titleFontSize,
          text: this.chartData.title,
          verticalPos: "middle",
          horizontalPos: "center",
          x: this.boundingRect.x + this.boundingRect.width / 2,
          y: this.boundingRect.y + this.boundingRect.height / 2,
          fill: this.chartThemeConfig.titleColor,
          rotation: 0
        }
      ]
    }), e;
  }
}, w(Ld, "ChartTitle"), Ld);
function fce(t, e, r, n) {
  const i = new uce(n);
  return new Gtt(i, t, e, r);
}
w(fce, "getChartTitleComponent");
var Rd, Utt = (Rd = class {
  constructor(e, r, n, i, a) {
    this.plotData = e, this.xAxis = r, this.yAxis = n, this.orientation = i, this.plotIndex = a;
  }
  getDrawableElement() {
    const e = this.plotData.data.map((n) => [
      this.xAxis.getScaleValue(n[0]),
      this.yAxis.getScaleValue(n[1])
    ]);
    let r;
    return this.orientation === "horizontal" ? r = i1().y((n) => n[0]).x((n) => n[1])(e) : r = i1().x((n) => n[0]).y((n) => n[1])(e), r ? [
      {
        groupTexts: ["plot", `line-plot-${this.plotIndex}`],
        type: "path",
        data: [
          {
            path: r,
            strokeFill: this.plotData.strokeFill,
            strokeWidth: this.plotData.strokeWidth
          }
        ]
      }
    ] : [];
  }
}, w(Rd, "LinePlot"), Rd), Id, Vtt = (Id = class {
  constructor(e, r, n, i, a, s) {
    this.barData = e, this.boundingRect = r, this.xAxis = n, this.yAxis = i, this.orientation = a, this.plotIndex = s;
  }
  getDrawableElement() {
    const e = this.barData.data.map((a) => [
      this.xAxis.getScaleValue(a[0]),
      this.yAxis.getScaleValue(a[1])
    ]), n = Math.min(this.xAxis.getAxisOuterPadding() * 2, this.xAxis.getTickDistance()) * (1 - 0.05), i = n / 2;
    return this.orientation === "horizontal" ? [
      {
        groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
        type: "rect",
        data: e.map((a) => ({
          x: this.boundingRect.x,
          y: a[0] - i,
          height: n,
          width: a[1] - this.boundingRect.x,
          fill: this.barData.fill,
          strokeWidth: 0,
          strokeFill: this.barData.fill
        }))
      }
    ] : [
      {
        groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
        type: "rect",
        data: e.map((a) => ({
          x: a[0] - i,
          y: a[1],
          width: n,
          height: this.boundingRect.y + this.boundingRect.height - a[1],
          fill: this.barData.fill,
          strokeWidth: 0,
          strokeFill: this.barData.fill
        }))
      }
    ];
  }
}, w(Id, "BarPlot"), Id), Md, Htt = (Md = class {
  constructor(e, r, n) {
    this.chartConfig = e, this.chartData = r, this.chartThemeConfig = n, this.boundingRect = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  setAxes(e, r) {
    this.xAxis = e, this.yAxis = r;
  }
  setBoundingBoxXY(e) {
    this.boundingRect.x = e.x, this.boundingRect.y = e.y;
  }
  calculateSpace(e) {
    return this.boundingRect.width = e.width, this.boundingRect.height = e.height, {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  getDrawableElements() {
    if (!(this.xAxis && this.yAxis))
      throw Error("Axes must be passed to render Plots");
    const e = [];
    for (const [r, n] of this.chartData.plots.entries())
      switch (n.type) {
        case "line":
          {
            const i = new Utt(
              n,
              this.xAxis,
              this.yAxis,
              this.chartConfig.chartOrientation,
              r
            );
            e.push(...i.getDrawableElement());
          }
          break;
        case "bar":
          {
            const i = new Vtt(
              n,
              this.boundingRect,
              this.xAxis,
              this.yAxis,
              this.chartConfig.chartOrientation,
              r
            );
            e.push(...i.getDrawableElement());
          }
          break;
      }
    return e;
  }
}, w(Md, "BasePlot"), Md);
function dce(t, e, r) {
  return new Htt(t, e, r);
}
w(dce, "getPlotComponent");
var Nd, Wtt = (Nd = class {
  constructor(e, r, n, i) {
    this.chartConfig = e, this.chartData = r, this.componentStore = {
      title: fce(e, r, n, i),
      plot: dce(e, r, n),
      xAxis: $8(
        r.xAxis,
        e.xAxis,
        {
          titleColor: n.xAxisTitleColor,
          labelColor: n.xAxisLabelColor,
          tickColor: n.xAxisTickColor,
          axisLineColor: n.xAxisLineColor
        },
        i
      ),
      yAxis: $8(
        r.yAxis,
        e.yAxis,
        {
          titleColor: n.yAxisTitleColor,
          labelColor: n.yAxisLabelColor,
          tickColor: n.yAxisTickColor,
          axisLineColor: n.yAxisLineColor
        },
        i
      )
    };
  }
  calculateVerticalSpace() {
    let e = this.chartConfig.width, r = this.chartConfig.height, n = 0, i = 0, a = Math.floor(e * this.chartConfig.plotReservedSpacePercent / 100), s = Math.floor(
      r * this.chartConfig.plotReservedSpacePercent / 100
    ), o = this.componentStore.plot.calculateSpace({
      width: a,
      height: s
    });
    e -= o.width, r -= o.height, o = this.componentStore.title.calculateSpace({
      width: this.chartConfig.width,
      height: r
    }), i = o.height, r -= o.height, this.componentStore.xAxis.setAxisPosition("bottom"), o = this.componentStore.xAxis.calculateSpace({
      width: e,
      height: r
    }), r -= o.height, this.componentStore.yAxis.setAxisPosition("left"), o = this.componentStore.yAxis.calculateSpace({
      width: e,
      height: r
    }), n = o.width, e -= o.width, e > 0 && (a += e, e = 0), r > 0 && (s += r, r = 0), this.componentStore.plot.calculateSpace({
      width: a,
      height: s
    }), this.componentStore.plot.setBoundingBoxXY({ x: n, y: i }), this.componentStore.xAxis.setRange([n, n + a]), this.componentStore.xAxis.setBoundingBoxXY({ x: n, y: i + s }), this.componentStore.yAxis.setRange([i, i + s]), this.componentStore.yAxis.setBoundingBoxXY({ x: 0, y: i }), this.chartData.plots.some((l) => P8(l)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
  }
  calculateHorizontalSpace() {
    let e = this.chartConfig.width, r = this.chartConfig.height, n = 0, i = 0, a = 0, s = Math.floor(e * this.chartConfig.plotReservedSpacePercent / 100), o = Math.floor(
      r * this.chartConfig.plotReservedSpacePercent / 100
    ), l = this.componentStore.plot.calculateSpace({
      width: s,
      height: o
    });
    e -= l.width, r -= l.height, l = this.componentStore.title.calculateSpace({
      width: this.chartConfig.width,
      height: r
    }), n = l.height, r -= l.height, this.componentStore.xAxis.setAxisPosition("left"), l = this.componentStore.xAxis.calculateSpace({
      width: e,
      height: r
    }), e -= l.width, i = l.width, this.componentStore.yAxis.setAxisPosition("top"), l = this.componentStore.yAxis.calculateSpace({
      width: e,
      height: r
    }), r -= l.height, a = n + l.height, e > 0 && (s += e, e = 0), r > 0 && (o += r, r = 0), this.componentStore.plot.calculateSpace({
      width: s,
      height: o
    }), this.componentStore.plot.setBoundingBoxXY({ x: i, y: a }), this.componentStore.yAxis.setRange([i, i + s]), this.componentStore.yAxis.setBoundingBoxXY({ x: i, y: n }), this.componentStore.xAxis.setRange([a, a + o]), this.componentStore.xAxis.setBoundingBoxXY({ x: 0, y: a }), this.chartData.plots.some((u) => P8(u)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
  }
  calculateSpace() {
    this.chartConfig.chartOrientation === "horizontal" ? this.calculateHorizontalSpace() : this.calculateVerticalSpace();
  }
  getDrawableElement() {
    this.calculateSpace();
    const e = [];
    this.componentStore.plot.setAxes(this.componentStore.xAxis, this.componentStore.yAxis);
    for (const r of Object.values(this.componentStore))
      e.push(...r.getDrawableElements());
    return e;
  }
}, w(Nd, "Orchestrator"), Nd), Dd, Ytt = (Dd = class {
  static build(e, r, n, i) {
    return new Wtt(e, r, n, i).getDrawableElement();
  }
}, w(Dd, "XYChartBuilder"), Dd), G1 = 0, pce, U1 = rM(), V1 = tM(), _r = nM(), B8 = V1.plotColorPalette.split(",").map((t) => t.trim()), K3 = !1, eM = !1;
function tM() {
  const t = Px(), e = mr();
  return Xi(t.xyChart, e.themeVariables.xyChart);
}
w(tM, "getChartDefaultThemeConfig");
function rM() {
  const t = mr();
  return Xi(
    fr.xyChart,
    t.xyChart
  );
}
w(rM, "getChartDefaultConfig");
function nM() {
  return {
    yAxis: {
      type: "linear",
      title: "",
      min: 1 / 0,
      max: -1 / 0
    },
    xAxis: {
      type: "band",
      title: "",
      categories: []
    },
    title: "",
    plots: []
  };
}
w(nM, "getChartDefaultData");
function Z3(t) {
  const e = mr();
  return pr(t.trim(), e);
}
w(Z3, "textSanitizer");
function gce(t) {
  pce = t;
}
w(gce, "setTmpSVGG");
function mce(t) {
  t === "horizontal" ? U1.chartOrientation = "horizontal" : U1.chartOrientation = "vertical";
}
w(mce, "setOrientation");
function vce(t) {
  _r.xAxis.title = Z3(t.text);
}
w(vce, "setXAxisTitle");
function iM(t, e) {
  _r.xAxis = { type: "linear", title: _r.xAxis.title, min: t, max: e }, K3 = !0;
}
w(iM, "setXAxisRangeData");
function yce(t) {
  _r.xAxis = {
    type: "band",
    title: _r.xAxis.title,
    categories: t.map((e) => Z3(e.text))
  }, K3 = !0;
}
w(yce, "setXAxisBand");
function bce(t) {
  _r.yAxis.title = Z3(t.text);
}
w(bce, "setYAxisTitle");
function xce(t, e) {
  _r.yAxis = { type: "linear", title: _r.yAxis.title, min: t, max: e }, eM = !0;
}
w(xce, "setYAxisRangeData");
function wce(t) {
  const e = Math.min(...t), r = Math.max(...t), n = Wf(_r.yAxis) ? _r.yAxis.min : 1 / 0, i = Wf(_r.yAxis) ? _r.yAxis.max : -1 / 0;
  _r.yAxis = {
    type: "linear",
    title: _r.yAxis.title,
    min: Math.min(n, e),
    max: Math.max(i, r)
  };
}
w(wce, "setYAxisRangeFromPlotData");
function aM(t) {
  let e = [];
  if (t.length === 0)
    return e;
  if (!K3) {
    const r = Wf(_r.xAxis) ? _r.xAxis.min : 1 / 0, n = Wf(_r.xAxis) ? _r.xAxis.max : -1 / 0;
    iM(Math.min(r, 1), Math.max(n, t.length));
  }
  if (eM || wce(t), JI(_r.xAxis) && (e = _r.xAxis.categories.map((r, n) => [r, t[n]])), Wf(_r.xAxis)) {
    const r = _r.xAxis.min, n = _r.xAxis.max, i = (n - r) / (t.length - 1), a = [];
    for (let s = r; s <= n; s += i)
      a.push(`${s}`);
    e = a.map((s, o) => [s, t[o]]);
  }
  return e;
}
w(aM, "transformDataWithoutCategory");
function sM(t) {
  return B8[t === 0 ? 0 : t % B8.length];
}
w(sM, "getPlotColorFromPalette");
function Tce(t, e) {
  const r = aM(e);
  _r.plots.push({
    type: "line",
    strokeFill: sM(G1),
    strokeWidth: 2,
    data: r
  }), G1++;
}
w(Tce, "setLineData");
function Ece(t, e) {
  const r = aM(e);
  _r.plots.push({
    type: "bar",
    fill: sM(G1),
    data: r
  }), G1++;
}
w(Ece, "setBarData");
function Sce() {
  if (_r.plots.length === 0)
    throw Error("No Plot to render, please provide a plot with some data");
  return _r.title = Mn(), Ytt.build(U1, _r, V1, pce);
}
w(Sce, "getDrawableElem");
function kce() {
  return V1;
}
w(kce, "getChartThemeConfig");
function Cce() {
  return U1;
}
w(Cce, "getChartConfig");
function _ce() {
  return _r;
}
w(_ce, "getXYChartData");
var Xtt = /* @__PURE__ */ w(function() {
  In(), G1 = 0, U1 = rM(), _r = nM(), V1 = tM(), B8 = V1.plotColorPalette.split(",").map((t) => t.trim()), K3 = !1, eM = !1;
}, "clear"), jtt = {
  getDrawableElem: Sce,
  clear: Xtt,
  setAccTitle: Ln,
  getAccTitle: Hn,
  setDiagramTitle: ti,
  getDiagramTitle: Mn,
  getAccDescription: Yn,
  setAccDescription: Wn,
  setOrientation: mce,
  setXAxisTitle: vce,
  setXAxisRangeData: iM,
  setXAxisBand: yce,
  setYAxisTitle: bce,
  setYAxisRangeData: xce,
  setLineData: Tce,
  setBarData: Ece,
  setTmpSVGG: gce,
  getChartThemeConfig: kce,
  getChartConfig: Cce,
  getXYChartData: _ce
}, Ktt = /* @__PURE__ */ w((t, e, r, n) => {
  const i = n.db, a = i.getChartThemeConfig(), s = i.getChartConfig(), o = i.getXYChartData().plots[0].data.map((y) => y[1]);
  function l(y) {
    return y === "top" ? "text-before-edge" : "middle";
  }
  w(l, "getDominantBaseLine");
  function u(y) {
    return y === "left" ? "start" : y === "right" ? "end" : "middle";
  }
  w(u, "getTextAnchor");
  function h(y) {
    return `translate(${y.x}, ${y.y}) rotate(${y.rotation || 0})`;
  }
  w(h, "getTextTransformation"), ae.debug(`Rendering xychart chart
` + t);
  const f = El(e), d = f.append("g").attr("class", "main"), p = d.append("rect").attr("width", s.width).attr("height", s.height).attr("class", "background");
  Qi(f, s.height, s.width, !0), f.attr("viewBox", `0 0 ${s.width} ${s.height}`), p.attr("fill", a.backgroundColor), i.setTmpSVGG(f.append("g").attr("class", "mermaid-tmp-group"));
  const g = i.getDrawableElem(), m = {};
  function v(y) {
    let b = d, x = "";
    for (const [T] of y.entries()) {
      let E = d;
      T > 0 && m[x] && (E = m[x]), x += y[T], b = m[x], b || (b = m[x] = E.append("g").attr("class", y[T]));
    }
    return b;
  }
  w(v, "getGroup");
  for (const y of g) {
    if (y.data.length === 0)
      continue;
    const b = v(y.groupTexts);
    switch (y.type) {
      case "rect":
        if (b.selectAll("rect").data(y.data).enter().append("rect").attr("x", (x) => x.x).attr("y", (x) => x.y).attr("width", (x) => x.width).attr("height", (x) => x.height).attr("fill", (x) => x.fill).attr("stroke", (x) => x.strokeFill).attr("stroke-width", (x) => x.strokeWidth), s.showDataLabel)
          if (s.chartOrientation === "horizontal") {
            let x = function(k, _) {
              const { data: R, label: L } = k;
              return _ * L.length * T <= R.width - 10;
            };
            w(x, "fitsHorizontally");
            const T = 0.7, E = y.data.map((k, _) => ({ data: k, label: o[_].toString() })).filter((k) => k.data.width > 0 && k.data.height > 0), A = E.map((k) => {
              const { data: _ } = k;
              let R = _.height * 0.7;
              for (; !x(k, R) && R > 0; )
                R -= 1;
              return R;
            }), S = Math.floor(Math.min(...A));
            b.selectAll("text").data(E).enter().append("text").attr("x", (k) => k.data.x + k.data.width - 10).attr("y", (k) => k.data.y + k.data.height / 2).attr("text-anchor", "end").attr("dominant-baseline", "middle").attr("fill", "black").attr("font-size", `${S}px`).text((k) => k.label);
          } else {
            let x = function(k, _, R) {
              const { data: L, label: M } = k, C = _ * M.length * 0.7, I = L.x + L.width / 2, N = I - C / 2, O = I + C / 2, D = N >= L.x && O <= L.x + L.width, $ = L.y + R + _ <= L.y + L.height;
              return D && $;
            };
            w(x, "fitsInBar");
            const T = 10, E = y.data.map((k, _) => ({ data: k, label: o[_].toString() })).filter((k) => k.data.width > 0 && k.data.height > 0), A = E.map((k) => {
              const { data: _, label: R } = k;
              let L = _.width / (R.length * 0.7);
              for (; !x(k, L, T) && L > 0; )
                L -= 1;
              return L;
            }), S = Math.floor(Math.min(...A));
            b.selectAll("text").data(E).enter().append("text").attr("x", (k) => k.data.x + k.data.width / 2).attr("y", (k) => k.data.y + T).attr("text-anchor", "middle").attr("dominant-baseline", "hanging").attr("fill", "black").attr("font-size", `${S}px`).text((k) => k.label);
          }
        break;
      case "text":
        b.selectAll("text").data(y.data).enter().append("text").attr("x", 0).attr("y", 0).attr("fill", (x) => x.fill).attr("font-size", (x) => x.fontSize).attr("dominant-baseline", (x) => l(x.verticalPos)).attr("text-anchor", (x) => u(x.horizontalPos)).attr("transform", (x) => h(x)).text((x) => x.text);
        break;
      case "path":
        b.selectAll("path").data(y.data).enter().append("path").attr("d", (x) => x.path).attr("fill", (x) => x.fill ? x.fill : "none").attr("stroke", (x) => x.strokeFill).attr("stroke-width", (x) => x.strokeWidth);
        break;
    }
  }
}, "draw"), Ztt = {
  draw: Ktt
}, Qtt = {
  parser: Ftt,
  db: jtt,
  renderer: Ztt
};
const Jtt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Qtt
}, Symbol.toStringTag, { value: "Module" }));
var F8 = (function() {
  var t = /* @__PURE__ */ w(function(me, Ie, te, he) {
    for (te = te || {}, he = me.length; he--; te[me[he]] = Ie) ;
    return te;
  }, "o"), e = [1, 3], r = [1, 4], n = [1, 5], i = [1, 6], a = [5, 6, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90], s = [1, 22], o = [2, 7], l = [1, 26], u = [1, 27], h = [1, 28], f = [1, 29], d = [1, 33], p = [1, 34], g = [1, 35], m = [1, 36], v = [1, 37], y = [1, 38], b = [1, 24], x = [1, 31], T = [1, 32], E = [1, 30], A = [1, 39], S = [1, 40], k = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90], _ = [1, 61], R = [89, 90], L = [5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 29, 41, 42, 43, 44, 45, 46, 54, 61, 63, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], M = [27, 29], P = [1, 70], C = [1, 71], I = [1, 72], N = [1, 73], O = [1, 74], D = [1, 75], $ = [1, 76], z = [1, 83], B = [1, 80], G = [1, 84], W = [1, 85], V = [1, 86], U = [1, 87], Z = [1, 88], K = [1, 89], ce = [1, 90], J = [1, 91], ee = [1, 92], j = [5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], X = [63, 64], re = [1, 101], Q = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 76, 77, 89, 90], ue = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], ne = [1, 110], xe = [1, 106], Y = [1, 107], Ne = [1, 108], fe = [1, 109], qe = [1, 111], ze = [1, 116], Ge = [1, 117], Ee = [1, 114], Oe = [1, 115], Ce = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, directive: 4, NEWLINE: 5, RD: 6, diagram: 7, EOF: 8, acc_title: 9, acc_title_value: 10, acc_descr: 11, acc_descr_value: 12, acc_descr_multiline_value: 13, requirementDef: 14, elementDef: 15, relationshipDef: 16, direction: 17, styleStatement: 18, classDefStatement: 19, classStatement: 20, direction_tb: 21, direction_bt: 22, direction_rl: 23, direction_lr: 24, requirementType: 25, requirementName: 26, STRUCT_START: 27, requirementBody: 28, STYLE_SEPARATOR: 29, idList: 30, ID: 31, COLONSEP: 32, id: 33, TEXT: 34, text: 35, RISK: 36, riskLevel: 37, VERIFYMTHD: 38, verifyType: 39, STRUCT_STOP: 40, REQUIREMENT: 41, FUNCTIONAL_REQUIREMENT: 42, INTERFACE_REQUIREMENT: 43, PERFORMANCE_REQUIREMENT: 44, PHYSICAL_REQUIREMENT: 45, DESIGN_CONSTRAINT: 46, LOW_RISK: 47, MED_RISK: 48, HIGH_RISK: 49, VERIFY_ANALYSIS: 50, VERIFY_DEMONSTRATION: 51, VERIFY_INSPECTION: 52, VERIFY_TEST: 53, ELEMENT: 54, elementName: 55, elementBody: 56, TYPE: 57, type: 58, DOCREF: 59, ref: 60, END_ARROW_L: 61, relationship: 62, LINE: 63, END_ARROW_R: 64, CONTAINS: 65, COPIES: 66, DERIVES: 67, SATISFIES: 68, VERIFIES: 69, REFINES: 70, TRACES: 71, CLASSDEF: 72, stylesOpt: 73, CLASS: 74, ALPHA: 75, COMMA: 76, STYLE: 77, style: 78, styleComponent: 79, NUM: 80, COLON: 81, UNIT: 82, SPACE: 83, BRKT: 84, PCT: 85, MINUS: 86, LABEL: 87, SEMICOLON: 88, unqString: 89, qString: 90, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 9: "acc_title", 10: "acc_title_value", 11: "acc_descr", 12: "acc_descr_value", 13: "acc_descr_multiline_value", 21: "direction_tb", 22: "direction_bt", 23: "direction_rl", 24: "direction_lr", 27: "STRUCT_START", 29: "STYLE_SEPARATOR", 31: "ID", 32: "COLONSEP", 34: "TEXT", 36: "RISK", 38: "VERIFYMTHD", 40: "STRUCT_STOP", 41: "REQUIREMENT", 42: "FUNCTIONAL_REQUIREMENT", 43: "INTERFACE_REQUIREMENT", 44: "PERFORMANCE_REQUIREMENT", 45: "PHYSICAL_REQUIREMENT", 46: "DESIGN_CONSTRAINT", 47: "LOW_RISK", 48: "MED_RISK", 49: "HIGH_RISK", 50: "VERIFY_ANALYSIS", 51: "VERIFY_DEMONSTRATION", 52: "VERIFY_INSPECTION", 53: "VERIFY_TEST", 54: "ELEMENT", 57: "TYPE", 59: "DOCREF", 61: "END_ARROW_L", 63: "LINE", 64: "END_ARROW_R", 65: "CONTAINS", 66: "COPIES", 67: "DERIVES", 68: "SATISFIES", 69: "VERIFIES", 70: "REFINES", 71: "TRACES", 72: "CLASSDEF", 74: "CLASS", 75: "ALPHA", 76: "COMMA", 77: "STYLE", 80: "NUM", 81: "COLON", 82: "UNIT", 83: "SPACE", 84: "BRKT", 85: "PCT", 86: "MINUS", 87: "LABEL", 88: "SEMICOLON", 89: "unqString", 90: "qString" },
    productions_: [0, [3, 3], [3, 2], [3, 4], [4, 2], [4, 2], [4, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [17, 1], [17, 1], [17, 1], [17, 1], [14, 5], [14, 7], [28, 5], [28, 5], [28, 5], [28, 5], [28, 2], [28, 1], [25, 1], [25, 1], [25, 1], [25, 1], [25, 1], [25, 1], [37, 1], [37, 1], [37, 1], [39, 1], [39, 1], [39, 1], [39, 1], [15, 5], [15, 7], [56, 5], [56, 5], [56, 2], [56, 1], [16, 5], [16, 5], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [19, 3], [20, 3], [20, 3], [30, 1], [30, 3], [30, 1], [30, 3], [18, 3], [73, 1], [73, 3], [78, 1], [78, 2], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [26, 1], [26, 1], [33, 1], [33, 1], [35, 1], [35, 1], [55, 1], [55, 1], [58, 1], [58, 1], [60, 1], [60, 1]],
    performAction: /* @__PURE__ */ w(function(Ie, te, he, F, oe, se, ge) {
      var de = se.length - 1;
      switch (oe) {
        case 4:
          this.$ = se[de].trim(), F.setAccTitle(this.$);
          break;
        case 5:
        case 6:
          this.$ = se[de].trim(), F.setAccDescription(this.$);
          break;
        case 7:
          this.$ = [];
          break;
        case 17:
          F.setDirection("TB");
          break;
        case 18:
          F.setDirection("BT");
          break;
        case 19:
          F.setDirection("RL");
          break;
        case 20:
          F.setDirection("LR");
          break;
        case 21:
          F.addRequirement(se[de - 3], se[de - 4]);
          break;
        case 22:
          F.addRequirement(se[de - 5], se[de - 6]), F.setClass([se[de - 5]], se[de - 3]);
          break;
        case 23:
          F.setNewReqId(se[de - 2]);
          break;
        case 24:
          F.setNewReqText(se[de - 2]);
          break;
        case 25:
          F.setNewReqRisk(se[de - 2]);
          break;
        case 26:
          F.setNewReqVerifyMethod(se[de - 2]);
          break;
        case 29:
          this.$ = F.RequirementType.REQUIREMENT;
          break;
        case 30:
          this.$ = F.RequirementType.FUNCTIONAL_REQUIREMENT;
          break;
        case 31:
          this.$ = F.RequirementType.INTERFACE_REQUIREMENT;
          break;
        case 32:
          this.$ = F.RequirementType.PERFORMANCE_REQUIREMENT;
          break;
        case 33:
          this.$ = F.RequirementType.PHYSICAL_REQUIREMENT;
          break;
        case 34:
          this.$ = F.RequirementType.DESIGN_CONSTRAINT;
          break;
        case 35:
          this.$ = F.RiskLevel.LOW_RISK;
          break;
        case 36:
          this.$ = F.RiskLevel.MED_RISK;
          break;
        case 37:
          this.$ = F.RiskLevel.HIGH_RISK;
          break;
        case 38:
          this.$ = F.VerifyType.VERIFY_ANALYSIS;
          break;
        case 39:
          this.$ = F.VerifyType.VERIFY_DEMONSTRATION;
          break;
        case 40:
          this.$ = F.VerifyType.VERIFY_INSPECTION;
          break;
        case 41:
          this.$ = F.VerifyType.VERIFY_TEST;
          break;
        case 42:
          F.addElement(se[de - 3]);
          break;
        case 43:
          F.addElement(se[de - 5]), F.setClass([se[de - 5]], se[de - 3]);
          break;
        case 44:
          F.setNewElementType(se[de - 2]);
          break;
        case 45:
          F.setNewElementDocRef(se[de - 2]);
          break;
        case 48:
          F.addRelationship(se[de - 2], se[de], se[de - 4]);
          break;
        case 49:
          F.addRelationship(se[de - 2], se[de - 4], se[de]);
          break;
        case 50:
          this.$ = F.Relationships.CONTAINS;
          break;
        case 51:
          this.$ = F.Relationships.COPIES;
          break;
        case 52:
          this.$ = F.Relationships.DERIVES;
          break;
        case 53:
          this.$ = F.Relationships.SATISFIES;
          break;
        case 54:
          this.$ = F.Relationships.VERIFIES;
          break;
        case 55:
          this.$ = F.Relationships.REFINES;
          break;
        case 56:
          this.$ = F.Relationships.TRACES;
          break;
        case 57:
          this.$ = se[de - 2], F.defineClass(se[de - 1], se[de]);
          break;
        case 58:
          F.setClass(se[de - 1], se[de]);
          break;
        case 59:
          F.setClass([se[de - 2]], se[de]);
          break;
        case 60:
        case 62:
          this.$ = [se[de]];
          break;
        case 61:
        case 63:
          this.$ = se[de - 2].concat([se[de]]);
          break;
        case 64:
          this.$ = se[de - 2], F.setCssStyle(se[de - 1], se[de]);
          break;
        case 65:
          this.$ = [se[de]];
          break;
        case 66:
          se[de - 2].push(se[de]), this.$ = se[de - 2];
          break;
        case 68:
          this.$ = se[de - 1] + se[de];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 6: e, 9: r, 11: n, 13: i }, { 1: [3] }, { 3: 8, 4: 2, 5: [1, 7], 6: e, 9: r, 11: n, 13: i }, { 5: [1, 9] }, { 10: [1, 10] }, { 12: [1, 11] }, t(a, [2, 6]), { 3: 12, 4: 2, 6: e, 9: r, 11: n, 13: i }, { 1: [2, 2] }, { 4: 17, 5: s, 7: 13, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, t(a, [2, 4]), t(a, [2, 5]), { 1: [2, 1] }, { 8: [1, 41] }, { 4: 17, 5: s, 7: 42, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 43, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 44, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 45, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 46, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 47, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 48, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 49, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 4: 17, 5: s, 7: 50, 8: o, 9: r, 11: n, 13: i, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: l, 22: u, 23: h, 24: f, 25: 23, 33: 25, 41: d, 42: p, 43: g, 44: m, 45: v, 46: y, 54: b, 72: x, 74: T, 77: E, 89: A, 90: S }, { 26: 51, 89: [1, 52], 90: [1, 53] }, { 55: 54, 89: [1, 55], 90: [1, 56] }, { 29: [1, 59], 61: [1, 57], 63: [1, 58] }, t(k, [2, 17]), t(k, [2, 18]), t(k, [2, 19]), t(k, [2, 20]), { 30: 60, 33: 62, 75: _, 89: A, 90: S }, { 30: 63, 33: 62, 75: _, 89: A, 90: S }, { 30: 64, 33: 62, 75: _, 89: A, 90: S }, t(R, [2, 29]), t(R, [2, 30]), t(R, [2, 31]), t(R, [2, 32]), t(R, [2, 33]), t(R, [2, 34]), t(L, [2, 81]), t(L, [2, 82]), { 1: [2, 3] }, { 8: [2, 8] }, { 8: [2, 9] }, { 8: [2, 10] }, { 8: [2, 11] }, { 8: [2, 12] }, { 8: [2, 13] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 27: [1, 65], 29: [1, 66] }, t(M, [2, 79]), t(M, [2, 80]), { 27: [1, 67], 29: [1, 68] }, t(M, [2, 85]), t(M, [2, 86]), { 62: 69, 65: P, 66: C, 67: I, 68: N, 69: O, 70: D, 71: $ }, { 62: 77, 65: P, 66: C, 67: I, 68: N, 69: O, 70: D, 71: $ }, { 30: 78, 33: 62, 75: _, 89: A, 90: S }, { 73: 79, 75: z, 76: B, 78: 81, 79: 82, 80: G, 81: W, 82: V, 83: U, 84: Z, 85: K, 86: ce, 87: J, 88: ee }, t(j, [2, 60]), t(j, [2, 62]), { 73: 93, 75: z, 76: B, 78: 81, 79: 82, 80: G, 81: W, 82: V, 83: U, 84: Z, 85: K, 86: ce, 87: J, 88: ee }, { 30: 94, 33: 62, 75: _, 76: B, 89: A, 90: S }, { 5: [1, 95] }, { 30: 96, 33: 62, 75: _, 89: A, 90: S }, { 5: [1, 97] }, { 30: 98, 33: 62, 75: _, 89: A, 90: S }, { 63: [1, 99] }, t(X, [2, 50]), t(X, [2, 51]), t(X, [2, 52]), t(X, [2, 53]), t(X, [2, 54]), t(X, [2, 55]), t(X, [2, 56]), { 64: [1, 100] }, t(k, [2, 59], { 76: B }), t(k, [2, 64], { 76: re }), { 33: 103, 75: [1, 102], 89: A, 90: S }, t(Q, [2, 65], { 79: 104, 75: z, 80: G, 81: W, 82: V, 83: U, 84: Z, 85: K, 86: ce, 87: J, 88: ee }), t(ue, [2, 67]), t(ue, [2, 69]), t(ue, [2, 70]), t(ue, [2, 71]), t(ue, [2, 72]), t(ue, [2, 73]), t(ue, [2, 74]), t(ue, [2, 75]), t(ue, [2, 76]), t(ue, [2, 77]), t(ue, [2, 78]), t(k, [2, 57], { 76: re }), t(k, [2, 58], { 76: B }), { 5: ne, 28: 105, 31: xe, 34: Y, 36: Ne, 38: fe, 40: qe }, { 27: [1, 112], 76: B }, { 5: ze, 40: Ge, 56: 113, 57: Ee, 59: Oe }, { 27: [1, 118], 76: B }, { 33: 119, 89: A, 90: S }, { 33: 120, 89: A, 90: S }, { 75: z, 78: 121, 79: 82, 80: G, 81: W, 82: V, 83: U, 84: Z, 85: K, 86: ce, 87: J, 88: ee }, t(j, [2, 61]), t(j, [2, 63]), t(ue, [2, 68]), t(k, [2, 21]), { 32: [1, 122] }, { 32: [1, 123] }, { 32: [1, 124] }, { 32: [1, 125] }, { 5: ne, 28: 126, 31: xe, 34: Y, 36: Ne, 38: fe, 40: qe }, t(k, [2, 28]), { 5: [1, 127] }, t(k, [2, 42]), { 32: [1, 128] }, { 32: [1, 129] }, { 5: ze, 40: Ge, 56: 130, 57: Ee, 59: Oe }, t(k, [2, 47]), { 5: [1, 131] }, t(k, [2, 48]), t(k, [2, 49]), t(Q, [2, 66], { 79: 104, 75: z, 80: G, 81: W, 82: V, 83: U, 84: Z, 85: K, 86: ce, 87: J, 88: ee }), { 33: 132, 89: A, 90: S }, { 35: 133, 89: [1, 134], 90: [1, 135] }, { 37: 136, 47: [1, 137], 48: [1, 138], 49: [1, 139] }, { 39: 140, 50: [1, 141], 51: [1, 142], 52: [1, 143], 53: [1, 144] }, t(k, [2, 27]), { 5: ne, 28: 145, 31: xe, 34: Y, 36: Ne, 38: fe, 40: qe }, { 58: 146, 89: [1, 147], 90: [1, 148] }, { 60: 149, 89: [1, 150], 90: [1, 151] }, t(k, [2, 46]), { 5: ze, 40: Ge, 56: 152, 57: Ee, 59: Oe }, { 5: [1, 153] }, { 5: [1, 154] }, { 5: [2, 83] }, { 5: [2, 84] }, { 5: [1, 155] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [1, 156] }, { 5: [2, 38] }, { 5: [2, 39] }, { 5: [2, 40] }, { 5: [2, 41] }, t(k, [2, 22]), { 5: [1, 157] }, { 5: [2, 87] }, { 5: [2, 88] }, { 5: [1, 158] }, { 5: [2, 89] }, { 5: [2, 90] }, t(k, [2, 43]), { 5: ne, 28: 159, 31: xe, 34: Y, 36: Ne, 38: fe, 40: qe }, { 5: ne, 28: 160, 31: xe, 34: Y, 36: Ne, 38: fe, 40: qe }, { 5: ne, 28: 161, 31: xe, 34: Y, 36: Ne, 38: fe, 40: qe }, { 5: ne, 28: 162, 31: xe, 34: Y, 36: Ne, 38: fe, 40: qe }, { 5: ze, 40: Ge, 56: 163, 57: Ee, 59: Oe }, { 5: ze, 40: Ge, 56: 164, 57: Ee, 59: Oe }, t(k, [2, 23]), t(k, [2, 24]), t(k, [2, 25]), t(k, [2, 26]), t(k, [2, 44]), t(k, [2, 45])],
    defaultActions: { 8: [2, 2], 12: [2, 1], 41: [2, 3], 42: [2, 8], 43: [2, 9], 44: [2, 10], 45: [2, 11], 46: [2, 12], 47: [2, 13], 48: [2, 14], 49: [2, 15], 50: [2, 16], 134: [2, 83], 135: [2, 84], 137: [2, 35], 138: [2, 36], 139: [2, 37], 141: [2, 38], 142: [2, 39], 143: [2, 40], 144: [2, 41], 147: [2, 87], 148: [2, 88], 150: [2, 89], 151: [2, 90] },
    parseError: /* @__PURE__ */ w(function(Ie, te) {
      if (te.recoverable)
        this.trace(Ie);
      else {
        var he = new Error(Ie);
        throw he.hash = te, he;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(Ie) {
      var te = this, he = [0], F = [], oe = [null], se = [], ge = this.table, de = "", we = 0, _e = 0, Se = 2, Me = 1, Xe = se.slice.call(arguments, 1), We = Object.create(this.lexer), Ke = { yy: {} };
      for (var Ze in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Ze) && (Ke.yy[Ze] = this.yy[Ze]);
      We.setInput(Ie, Ke.yy), Ke.yy.lexer = We, Ke.yy.parser = this, typeof We.yylloc > "u" && (We.yylloc = {});
      var Pe = We.yylloc;
      se.push(Pe);
      var Ve = We.options && We.options.ranges;
      typeof Ke.yy.parseError == "function" ? this.parseError = Ke.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ht(ir) {
        he.length = he.length - 2 * ir, oe.length = oe.length - ir, se.length = se.length - ir;
      }
      w(ht, "popStack");
      function st() {
        var ir;
        return ir = F.pop() || We.lex() || Me, typeof ir != "number" && (ir instanceof Array && (F = ir, ir = F.pop()), ir = te.symbols_[ir] || ir), ir;
      }
      w(st, "lex");
      for (var Ue, Et, He, rt, ct = {}, ut, nt, bt, er; ; ) {
        if (Et = he[he.length - 1], this.defaultActions[Et] ? He = this.defaultActions[Et] : ((Ue === null || typeof Ue > "u") && (Ue = st()), He = ge[Et] && ge[Et][Ue]), typeof He > "u" || !He.length || !He[0]) {
          var Dt = "";
          er = [];
          for (ut in ge[Et])
            this.terminals_[ut] && ut > Se && er.push("'" + this.terminals_[ut] + "'");
          We.showPosition ? Dt = "Parse error on line " + (we + 1) + `:
` + We.showPosition() + `
Expecting ` + er.join(", ") + ", got '" + (this.terminals_[Ue] || Ue) + "'" : Dt = "Parse error on line " + (we + 1) + ": Unexpected " + (Ue == Me ? "end of input" : "'" + (this.terminals_[Ue] || Ue) + "'"), this.parseError(Dt, {
            text: We.match,
            token: this.terminals_[Ue] || Ue,
            line: We.yylineno,
            loc: Pe,
            expected: er
          });
        }
        if (He[0] instanceof Array && He.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Et + ", token: " + Ue);
        switch (He[0]) {
          case 1:
            he.push(Ue), oe.push(We.yytext), se.push(We.yylloc), he.push(He[1]), Ue = null, _e = We.yyleng, de = We.yytext, we = We.yylineno, Pe = We.yylloc;
            break;
          case 2:
            if (nt = this.productions_[He[1]][1], ct.$ = oe[oe.length - nt], ct._$ = {
              first_line: se[se.length - (nt || 1)].first_line,
              last_line: se[se.length - 1].last_line,
              first_column: se[se.length - (nt || 1)].first_column,
              last_column: se[se.length - 1].last_column
            }, Ve && (ct._$.range = [
              se[se.length - (nt || 1)].range[0],
              se[se.length - 1].range[1]
            ]), rt = this.performAction.apply(ct, [
              de,
              _e,
              we,
              Ke.yy,
              He[1],
              oe,
              se
            ].concat(Xe)), typeof rt < "u")
              return rt;
            nt && (he = he.slice(0, -1 * nt * 2), oe = oe.slice(0, -1 * nt), se = se.slice(0, -1 * nt)), he.push(this.productions_[He[1]][0]), oe.push(ct.$), se.push(ct._$), bt = ge[he[he.length - 2]][he[he.length - 1]], he.push(bt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Ae = /* @__PURE__ */ (function() {
    var me = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(te, he) {
        if (this.yy.parser)
          this.yy.parser.parseError(te, he);
        else
          throw new Error(te);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(Ie, te) {
        return this.yy = te || this.yy || {}, this._input = Ie, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var Ie = this._input[0];
        this.yytext += Ie, this.yyleng++, this.offset++, this.match += Ie, this.matched += Ie;
        var te = Ie.match(/(?:\r\n?|\n).*/g);
        return te ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Ie;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(Ie) {
        var te = Ie.length, he = Ie.split(/(?:\r\n?|\n)/g);
        this._input = Ie + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - te), this.offset -= te;
        var F = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), he.length - 1 && (this.yylineno -= he.length - 1);
        var oe = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: he ? (he.length === F.length ? this.yylloc.first_column : 0) + F[F.length - he.length].length - he[0].length : this.yylloc.first_column - te
        }, this.options.ranges && (this.yylloc.range = [oe[0], oe[0] + this.yyleng - te]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(Ie) {
        this.unput(this.match.slice(Ie));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var Ie = this.matched.substr(0, this.matched.length - this.match.length);
        return (Ie.length > 20 ? "..." : "") + Ie.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var Ie = this.match;
        return Ie.length < 20 && (Ie += this._input.substr(0, 20 - Ie.length)), (Ie.substr(0, 20) + (Ie.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var Ie = this.pastInput(), te = new Array(Ie.length + 1).join("-");
        return Ie + this.upcomingInput() + `
` + te + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(Ie, te) {
        var he, F, oe;
        if (this.options.backtrack_lexer && (oe = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (oe.yylloc.range = this.yylloc.range.slice(0))), F = Ie[0].match(/(?:\r\n?|\n).*/g), F && (this.yylineno += F.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: F ? F[F.length - 1].length - F[F.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Ie[0].length
        }, this.yytext += Ie[0], this.match += Ie[0], this.matches = Ie, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Ie[0].length), this.matched += Ie[0], he = this.performAction.call(this, this.yy, this, te, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), he)
          return he;
        if (this._backtrack) {
          for (var se in oe)
            this[se] = oe[se];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Ie, te, he, F;
        this._more || (this.yytext = "", this.match = "");
        for (var oe = this._currentRules(), se = 0; se < oe.length; se++)
          if (he = this._input.match(this.rules[oe[se]]), he && (!te || he[0].length > te[0].length)) {
            if (te = he, F = se, this.options.backtrack_lexer) {
              if (Ie = this.test_match(he, oe[se]), Ie !== !1)
                return Ie;
              if (this._backtrack) {
                te = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return te ? (Ie = this.test_match(te, oe[F]), Ie !== !1 ? Ie : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var te = this.next();
        return te || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(te) {
        this.conditionStack.push(te);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var te = this.conditionStack.length - 1;
        return te > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(te) {
        return te = this.conditionStack.length - 1 - Math.abs(te || 0), te >= 0 ? this.conditionStack[te] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(te) {
        this.begin(te);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(te, he, F, oe) {
        switch (F) {
          case 0:
            return "title";
          case 1:
            return this.begin("acc_title"), 9;
          case 2:
            return this.popState(), "acc_title_value";
          case 3:
            return this.begin("acc_descr"), 11;
          case 4:
            return this.popState(), "acc_descr_value";
          case 5:
            this.begin("acc_descr_multiline");
            break;
          case 6:
            this.popState();
            break;
          case 7:
            return "acc_descr_multiline_value";
          case 8:
            return 21;
          case 9:
            return 22;
          case 10:
            return 23;
          case 11:
            return 24;
          case 12:
            return 5;
          case 13:
            break;
          case 14:
            break;
          case 15:
            break;
          case 16:
            return 8;
          case 17:
            return 6;
          case 18:
            return 27;
          case 19:
            return 40;
          case 20:
            return 29;
          case 21:
            return 32;
          case 22:
            return 31;
          case 23:
            return 34;
          case 24:
            return 36;
          case 25:
            return 38;
          case 26:
            return 41;
          case 27:
            return 42;
          case 28:
            return 43;
          case 29:
            return 44;
          case 30:
            return 45;
          case 31:
            return 46;
          case 32:
            return 47;
          case 33:
            return 48;
          case 34:
            return 49;
          case 35:
            return 50;
          case 36:
            return 51;
          case 37:
            return 52;
          case 38:
            return 53;
          case 39:
            return 54;
          case 40:
            return 65;
          case 41:
            return 66;
          case 42:
            return 67;
          case 43:
            return 68;
          case 44:
            return 69;
          case 45:
            return 70;
          case 46:
            return 71;
          case 47:
            return 57;
          case 48:
            return 59;
          case 49:
            return this.begin("style"), 77;
          case 50:
            return 75;
          case 51:
            return 81;
          case 52:
            return 88;
          case 53:
            return "PERCENT";
          case 54:
            return 86;
          case 55:
            return 84;
          case 56:
            break;
          case 57:
            this.begin("string");
            break;
          case 58:
            this.popState();
            break;
          case 59:
            return this.begin("style"), 72;
          case 60:
            return this.begin("style"), 74;
          case 61:
            return 61;
          case 62:
            return 64;
          case 63:
            return 63;
          case 64:
            this.begin("string");
            break;
          case 65:
            this.popState();
            break;
          case 66:
            return "qString";
          case 67:
            return he.yytext = he.yytext.trim(), 89;
          case 68:
            return 75;
          case 69:
            return 80;
          case 70:
            return 76;
        }
      }, "anonymous"),
      rules: [/^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::{3})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:style\b)/i, /^(?:\w+)/i, /^(?::)/i, /^(?:;)/i, /^(?:%)/i, /^(?:-)/i, /^(?:#)/i, /^(?: )/i, /^(?:["])/i, /^(?:\n)/i, /^(?:classDef\b)/i, /^(?:class\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^:,\r\n\{\<\>\-\=]*)/i, /^(?:\w+)/i, /^(?:[0-9]+)/i, /^(?:,)/i],
      conditions: { acc_descr_multiline: { rules: [6, 7, 68, 69, 70], inclusive: !1 }, acc_descr: { rules: [4, 68, 69, 70], inclusive: !1 }, acc_title: { rules: [2, 68, 69, 70], inclusive: !1 }, style: { rules: [50, 51, 52, 53, 54, 55, 56, 57, 58, 68, 69, 70], inclusive: !1 }, unqString: { rules: [68, 69, 70], inclusive: !1 }, token: { rules: [68, 69, 70], inclusive: !1 }, string: { rules: [65, 66, 68, 69, 70], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 59, 60, 61, 62, 63, 64, 67, 68, 69, 70], inclusive: !0 } }
    };
    return me;
  })();
  Ce.lexer = Ae;
  function $e() {
    this.yy = {};
  }
  return w($e, "Parser"), $e.prototype = Ce, Ce.Parser = $e, new $e();
})();
F8.parser = F8;
var ert = F8, Od, trt = (Od = class {
  constructor() {
    this.relations = [], this.latestRequirement = this.getInitialRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.latestElement = this.getInitialElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.RequirementType = {
      REQUIREMENT: "Requirement",
      FUNCTIONAL_REQUIREMENT: "Functional Requirement",
      INTERFACE_REQUIREMENT: "Interface Requirement",
      PERFORMANCE_REQUIREMENT: "Performance Requirement",
      PHYSICAL_REQUIREMENT: "Physical Requirement",
      DESIGN_CONSTRAINT: "Design Constraint"
    }, this.RiskLevel = {
      LOW_RISK: "Low",
      MED_RISK: "Medium",
      HIGH_RISK: "High"
    }, this.VerifyType = {
      VERIFY_ANALYSIS: "Analysis",
      VERIFY_DEMONSTRATION: "Demonstration",
      VERIFY_INSPECTION: "Inspection",
      VERIFY_TEST: "Test"
    }, this.Relationships = {
      CONTAINS: "contains",
      COPIES: "copies",
      DERIVES: "derives",
      SATISFIES: "satisfies",
      VERIFIES: "verifies",
      REFINES: "refines",
      TRACES: "traces"
    }, this.setAccTitle = Ln, this.getAccTitle = Hn, this.setAccDescription = Wn, this.getAccDescription = Yn, this.setDiagramTitle = ti, this.getDiagramTitle = Mn, this.getConfig = /* @__PURE__ */ w(() => Te().requirement, "getConfig"), this.clear(), this.setDirection = this.setDirection.bind(this), this.addRequirement = this.addRequirement.bind(this), this.setNewReqId = this.setNewReqId.bind(this), this.setNewReqRisk = this.setNewReqRisk.bind(this), this.setNewReqText = this.setNewReqText.bind(this), this.setNewReqVerifyMethod = this.setNewReqVerifyMethod.bind(this), this.addElement = this.addElement.bind(this), this.setNewElementType = this.setNewElementType.bind(this), this.setNewElementDocRef = this.setNewElementDocRef.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setCssStyle = this.setCssStyle.bind(this), this.setClass = this.setClass.bind(this), this.defineClass = this.defineClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
  }
  getDirection() {
    return this.direction;
  }
  setDirection(e) {
    this.direction = e;
  }
  resetLatestRequirement() {
    this.latestRequirement = this.getInitialRequirement();
  }
  resetLatestElement() {
    this.latestElement = this.getInitialElement();
  }
  getInitialRequirement() {
    return {
      requirementId: "",
      text: "",
      risk: "",
      verifyMethod: "",
      name: "",
      type: "",
      cssStyles: [],
      classes: ["default"]
    };
  }
  getInitialElement() {
    return {
      name: "",
      type: "",
      docRef: "",
      cssStyles: [],
      classes: ["default"]
    };
  }
  addRequirement(e, r) {
    return this.requirements.has(e) || this.requirements.set(e, {
      name: e,
      type: r,
      requirementId: this.latestRequirement.requirementId,
      text: this.latestRequirement.text,
      risk: this.latestRequirement.risk,
      verifyMethod: this.latestRequirement.verifyMethod,
      cssStyles: [],
      classes: ["default"]
    }), this.resetLatestRequirement(), this.requirements.get(e);
  }
  getRequirements() {
    return this.requirements;
  }
  setNewReqId(e) {
    this.latestRequirement !== void 0 && (this.latestRequirement.requirementId = e);
  }
  setNewReqText(e) {
    this.latestRequirement !== void 0 && (this.latestRequirement.text = e);
  }
  setNewReqRisk(e) {
    this.latestRequirement !== void 0 && (this.latestRequirement.risk = e);
  }
  setNewReqVerifyMethod(e) {
    this.latestRequirement !== void 0 && (this.latestRequirement.verifyMethod = e);
  }
  addElement(e) {
    return this.elements.has(e) || (this.elements.set(e, {
      name: e,
      type: this.latestElement.type,
      docRef: this.latestElement.docRef,
      cssStyles: [],
      classes: ["default"]
    }), ae.info("Added new element: ", e)), this.resetLatestElement(), this.elements.get(e);
  }
  getElements() {
    return this.elements;
  }
  setNewElementType(e) {
    this.latestElement !== void 0 && (this.latestElement.type = e);
  }
  setNewElementDocRef(e) {
    this.latestElement !== void 0 && (this.latestElement.docRef = e);
  }
  addRelationship(e, r, n) {
    this.relations.push({
      type: e,
      src: r,
      dst: n
    });
  }
  getRelationships() {
    return this.relations;
  }
  clear() {
    this.relations = [], this.resetLatestRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.resetLatestElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), In();
  }
  setCssStyle(e, r) {
    for (const n of e) {
      const i = this.requirements.get(n) ?? this.elements.get(n);
      if (!r || !i)
        return;
      for (const a of r)
        a.includes(",") ? i.cssStyles.push(...a.split(",")) : i.cssStyles.push(a);
    }
  }
  setClass(e, r) {
    for (const n of e) {
      const i = this.requirements.get(n) ?? this.elements.get(n);
      if (i)
        for (const a of r) {
          i.classes.push(a);
          const s = this.classes.get(a)?.styles;
          s && i.cssStyles.push(...s);
        }
    }
  }
  defineClass(e, r) {
    for (const n of e) {
      let i = this.classes.get(n);
      i === void 0 && (i = { id: n, styles: [], textStyles: [] }, this.classes.set(n, i)), r && r.forEach(function(a) {
        if (/color/.exec(a)) {
          const s = a.replace("fill", "bgFill");
          i.textStyles.push(s);
        }
        i.styles.push(a);
      }), this.requirements.forEach((a) => {
        a.classes.includes(n) && a.cssStyles.push(...r.flatMap((s) => s.split(",")));
      }), this.elements.forEach((a) => {
        a.classes.includes(n) && a.cssStyles.push(...r.flatMap((s) => s.split(",")));
      });
    }
  }
  getClasses() {
    return this.classes;
  }
  getData() {
    const e = Te(), r = [], n = [];
    for (const i of this.requirements.values()) {
      const a = i;
      a.id = i.name, a.cssStyles = i.cssStyles, a.cssClasses = i.classes.join(" "), a.shape = "requirementBox", a.look = e.look, r.push(a);
    }
    for (const i of this.elements.values()) {
      const a = i;
      a.shape = "requirementBox", a.look = e.look, a.id = i.name, a.cssStyles = i.cssStyles, a.cssClasses = i.classes.join(" "), r.push(a);
    }
    for (const i of this.relations) {
      let a = 0;
      const s = i.type === this.Relationships.CONTAINS, o = {
        id: `${i.src}-${i.dst}-${a}`,
        start: this.requirements.get(i.src)?.name ?? this.elements.get(i.src)?.name,
        end: this.requirements.get(i.dst)?.name ?? this.elements.get(i.dst)?.name,
        label: `&lt;&lt;${i.type}&gt;&gt;`,
        classes: "relationshipLine",
        style: ["fill:none", s ? "" : "stroke-dasharray: 10,7"],
        labelpos: "c",
        thickness: "normal",
        type: "normal",
        pattern: s ? "normal" : "dashed",
        arrowTypeStart: s ? "requirement_contains" : "",
        arrowTypeEnd: s ? "" : "requirement_arrow",
        look: e.look
      };
      n.push(o), a++;
    }
    return { nodes: r, edges: n, other: {}, config: e, direction: this.getDirection() };
  }
}, w(Od, "RequirementDB"), Od), rrt = /* @__PURE__ */ w((t) => `

  marker {
    fill: ${t.relationColor};
    stroke: ${t.relationColor};
  }

  marker.cross {
    stroke: ${t.lineColor};
  }

  svg {
    font-family: ${t.fontFamily};
    font-size: ${t.fontSize};
  }

  .reqBox {
    fill: ${t.requirementBackground};
    fill-opacity: 1.0;
    stroke: ${t.requirementBorderColor};
    stroke-width: ${t.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${t.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${t.relationLabelBackground};
    fill-opacity: 1.0;
  }

  .req-title-line {
    stroke: ${t.requirementBorderColor};
    stroke-width: ${t.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${t.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${t.relationLabelColor};
  }
  .divider {
    stroke: ${t.nodeBorder};
    stroke-width: 1;
  }
  .label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }
  .label text,span {
    fill: ${t.nodeTextColor || t.textColor};
    color: ${t.nodeTextColor || t.textColor};
  }
  .labelBkg {
    background-color: ${t.edgeLabelBackground};
  }

`, "getStyles"), nrt = rrt, Ace = {};
Mx(Ace, {
  draw: () => irt
});
var irt = /* @__PURE__ */ w(async function(t, e, r, n) {
  ae.info("REF0:"), ae.info("Drawing requirement diagram (unified)", e);
  const { securityLevel: i, state: a, layout: s } = Te(), o = n.db.getData(), l = Y0(e, i);
  o.type = n.type, o.layoutAlgorithm = om(s), o.nodeSpacing = a?.nodeSpacing ?? 50, o.rankSpacing = a?.rankSpacing ?? 50, o.markers = ["requirement_contains", "requirement_arrow"], o.diagramId = e, await I0(o, l);
  const u = 8;
  Jt.insertTitle(
    l,
    "requirementDiagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), Oh(l, u, "requirementDiagram", a?.useMaxWidth ?? !0);
}, "draw"), art = {
  parser: ert,
  get db() {
    return new trt();
  },
  renderer: Ace,
  styles: nrt
};
const srt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: art
}, Symbol.toStringTag, { value: "Module" }));
var z8 = (function() {
  var t = /* @__PURE__ */ w(function(ee, j, X, re) {
    for (X = X || {}, re = ee.length; re--; X[ee[re]] = j) ;
    return X;
  }, "o"), e = [1, 2], r = [1, 3], n = [1, 4], i = [2, 4], a = [1, 9], s = [1, 11], o = [1, 13], l = [1, 14], u = [1, 16], h = [1, 17], f = [1, 18], d = [1, 24], p = [1, 25], g = [1, 26], m = [1, 27], v = [1, 28], y = [1, 29], b = [1, 30], x = [1, 31], T = [1, 32], E = [1, 33], A = [1, 34], S = [1, 35], k = [1, 36], _ = [1, 37], R = [1, 38], L = [1, 39], M = [1, 41], P = [1, 42], C = [1, 43], I = [1, 44], N = [1, 45], O = [1, 46], D = [1, 4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 48, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71], $ = [2, 71], z = [4, 5, 16, 50, 52, 53], B = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71], G = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71], W = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 48, 50, 52, 53, 55, 60, 61, 62, 63, 71], V = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 50, 52, 53, 55, 60, 61, 62, 63, 71], U = [69, 70, 71], Z = [1, 127], K = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NEWLINE: 5, SD: 6, document: 7, line: 8, statement: 9, box_section: 10, box_line: 11, participant_statement: 12, create: 13, box: 14, restOfLine: 15, end: 16, signal: 17, autonumber: 18, NUM: 19, off: 20, activate: 21, actor: 22, deactivate: 23, note_statement: 24, links_statement: 25, link_statement: 26, properties_statement: 27, details_statement: 28, title: 29, legacy_title: 30, acc_title: 31, acc_title_value: 32, acc_descr: 33, acc_descr_value: 34, acc_descr_multiline_value: 35, loop: 36, rect: 37, opt: 38, alt: 39, else_sections: 40, par: 41, par_sections: 42, par_over: 43, critical: 44, option_sections: 45, break: 46, option: 47, and: 48, else: 49, participant: 50, AS: 51, participant_actor: 52, destroy: 53, actor_with_config: 54, note: 55, placement: 56, text2: 57, over: 58, actor_pair: 59, links: 60, link: 61, properties: 62, details: 63, spaceList: 64, ",": 65, left_of: 66, right_of: 67, signaltype: 68, "+": 69, "-": 70, ACTOR: 71, config_object: 72, CONFIG_START: 73, CONFIG_CONTENT: 74, CONFIG_END: 75, SOLID_OPEN_ARROW: 76, DOTTED_OPEN_ARROW: 77, SOLID_ARROW: 78, BIDIRECTIONAL_SOLID_ARROW: 79, DOTTED_ARROW: 80, BIDIRECTIONAL_DOTTED_ARROW: 81, SOLID_CROSS: 82, DOTTED_CROSS: 83, SOLID_POINT: 84, DOTTED_POINT: 85, TXT: 86, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 6: "SD", 13: "create", 14: "box", 15: "restOfLine", 16: "end", 18: "autonumber", 19: "NUM", 20: "off", 21: "activate", 23: "deactivate", 29: "title", 30: "legacy_title", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 36: "loop", 37: "rect", 38: "opt", 39: "alt", 41: "par", 43: "par_over", 44: "critical", 46: "break", 47: "option", 48: "and", 49: "else", 50: "participant", 51: "AS", 52: "participant_actor", 53: "destroy", 55: "note", 58: "over", 60: "links", 61: "link", 62: "properties", 63: "details", 65: ",", 66: "left_of", 67: "right_of", 69: "+", 70: "-", 71: "ACTOR", 73: "CONFIG_START", 74: "CONFIG_CONTENT", 75: "CONFIG_END", 76: "SOLID_OPEN_ARROW", 77: "DOTTED_OPEN_ARROW", 78: "SOLID_ARROW", 79: "BIDIRECTIONAL_SOLID_ARROW", 80: "DOTTED_ARROW", 81: "BIDIRECTIONAL_DOTTED_ARROW", 82: "SOLID_CROSS", 83: "DOTTED_CROSS", 84: "SOLID_POINT", 85: "DOTTED_POINT", 86: "TXT" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [10, 0], [10, 2], [11, 2], [11, 1], [11, 1], [9, 1], [9, 2], [9, 4], [9, 2], [9, 4], [9, 3], [9, 3], [9, 2], [9, 3], [9, 3], [9, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [45, 1], [45, 4], [42, 1], [42, 4], [40, 1], [40, 4], [12, 5], [12, 3], [12, 5], [12, 3], [12, 3], [12, 3], [24, 4], [24, 4], [25, 3], [26, 3], [27, 3], [28, 3], [64, 2], [64, 1], [59, 3], [59, 1], [56, 1], [56, 1], [17, 5], [17, 5], [17, 4], [54, 2], [72, 3], [22, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [57, 1]],
    performAction: /* @__PURE__ */ w(function(j, X, re, Q, ue, ne, xe) {
      var Y = ne.length - 1;
      switch (ue) {
        case 3:
          return Q.apply(ne[Y]), ne[Y];
        case 4:
        case 9:
          this.$ = [];
          break;
        case 5:
        case 10:
          ne[Y - 1].push(ne[Y]), this.$ = ne[Y - 1];
          break;
        case 6:
        case 7:
        case 11:
        case 12:
          this.$ = ne[Y];
          break;
        case 8:
        case 13:
          this.$ = [];
          break;
        case 15:
          ne[Y].type = "createParticipant", this.$ = ne[Y];
          break;
        case 16:
          ne[Y - 1].unshift({ type: "boxStart", boxData: Q.parseBoxData(ne[Y - 2]) }), ne[Y - 1].push({ type: "boxEnd", boxText: ne[Y - 2] }), this.$ = ne[Y - 1];
          break;
        case 18:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(ne[Y - 2]), sequenceIndexStep: Number(ne[Y - 1]), sequenceVisible: !0, signalType: Q.LINETYPE.AUTONUMBER };
          break;
        case 19:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(ne[Y - 1]), sequenceIndexStep: 1, sequenceVisible: !0, signalType: Q.LINETYPE.AUTONUMBER };
          break;
        case 20:
          this.$ = { type: "sequenceIndex", sequenceVisible: !1, signalType: Q.LINETYPE.AUTONUMBER };
          break;
        case 21:
          this.$ = { type: "sequenceIndex", sequenceVisible: !0, signalType: Q.LINETYPE.AUTONUMBER };
          break;
        case 22:
          this.$ = { type: "activeStart", signalType: Q.LINETYPE.ACTIVE_START, actor: ne[Y - 1].actor };
          break;
        case 23:
          this.$ = { type: "activeEnd", signalType: Q.LINETYPE.ACTIVE_END, actor: ne[Y - 1].actor };
          break;
        case 29:
          Q.setDiagramTitle(ne[Y].substring(6)), this.$ = ne[Y].substring(6);
          break;
        case 30:
          Q.setDiagramTitle(ne[Y].substring(7)), this.$ = ne[Y].substring(7);
          break;
        case 31:
          this.$ = ne[Y].trim(), Q.setAccTitle(this.$);
          break;
        case 32:
        case 33:
          this.$ = ne[Y].trim(), Q.setAccDescription(this.$);
          break;
        case 34:
          ne[Y - 1].unshift({ type: "loopStart", loopText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.LOOP_START }), ne[Y - 1].push({ type: "loopEnd", loopText: ne[Y - 2], signalType: Q.LINETYPE.LOOP_END }), this.$ = ne[Y - 1];
          break;
        case 35:
          ne[Y - 1].unshift({ type: "rectStart", color: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.RECT_START }), ne[Y - 1].push({ type: "rectEnd", color: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.RECT_END }), this.$ = ne[Y - 1];
          break;
        case 36:
          ne[Y - 1].unshift({ type: "optStart", optText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.OPT_START }), ne[Y - 1].push({ type: "optEnd", optText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.OPT_END }), this.$ = ne[Y - 1];
          break;
        case 37:
          ne[Y - 1].unshift({ type: "altStart", altText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.ALT_START }), ne[Y - 1].push({ type: "altEnd", signalType: Q.LINETYPE.ALT_END }), this.$ = ne[Y - 1];
          break;
        case 38:
          ne[Y - 1].unshift({ type: "parStart", parText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.PAR_START }), ne[Y - 1].push({ type: "parEnd", signalType: Q.LINETYPE.PAR_END }), this.$ = ne[Y - 1];
          break;
        case 39:
          ne[Y - 1].unshift({ type: "parStart", parText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.PAR_OVER_START }), ne[Y - 1].push({ type: "parEnd", signalType: Q.LINETYPE.PAR_END }), this.$ = ne[Y - 1];
          break;
        case 40:
          ne[Y - 1].unshift({ type: "criticalStart", criticalText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.CRITICAL_START }), ne[Y - 1].push({ type: "criticalEnd", signalType: Q.LINETYPE.CRITICAL_END }), this.$ = ne[Y - 1];
          break;
        case 41:
          ne[Y - 1].unshift({ type: "breakStart", breakText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.BREAK_START }), ne[Y - 1].push({ type: "breakEnd", optText: Q.parseMessage(ne[Y - 2]), signalType: Q.LINETYPE.BREAK_END }), this.$ = ne[Y - 1];
          break;
        case 43:
          this.$ = ne[Y - 3].concat([{ type: "option", optionText: Q.parseMessage(ne[Y - 1]), signalType: Q.LINETYPE.CRITICAL_OPTION }, ne[Y]]);
          break;
        case 45:
          this.$ = ne[Y - 3].concat([{ type: "and", parText: Q.parseMessage(ne[Y - 1]), signalType: Q.LINETYPE.PAR_AND }, ne[Y]]);
          break;
        case 47:
          this.$ = ne[Y - 3].concat([{ type: "else", altText: Q.parseMessage(ne[Y - 1]), signalType: Q.LINETYPE.ALT_ELSE }, ne[Y]]);
          break;
        case 48:
          ne[Y - 3].draw = "participant", ne[Y - 3].type = "addParticipant", ne[Y - 3].description = Q.parseMessage(ne[Y - 1]), this.$ = ne[Y - 3];
          break;
        case 49:
          ne[Y - 1].draw = "participant", ne[Y - 1].type = "addParticipant", this.$ = ne[Y - 1];
          break;
        case 50:
          ne[Y - 3].draw = "actor", ne[Y - 3].type = "addParticipant", ne[Y - 3].description = Q.parseMessage(ne[Y - 1]), this.$ = ne[Y - 3];
          break;
        case 51:
          ne[Y - 1].draw = "actor", ne[Y - 1].type = "addParticipant", this.$ = ne[Y - 1];
          break;
        case 52:
          ne[Y - 1].type = "destroyParticipant", this.$ = ne[Y - 1];
          break;
        case 53:
          ne[Y - 1].draw = "participant", ne[Y - 1].type = "addParticipant", this.$ = ne[Y - 1];
          break;
        case 54:
          this.$ = [ne[Y - 1], { type: "addNote", placement: ne[Y - 2], actor: ne[Y - 1].actor, text: ne[Y] }];
          break;
        case 55:
          ne[Y - 2] = [].concat(ne[Y - 1], ne[Y - 1]).slice(0, 2), ne[Y - 2][0] = ne[Y - 2][0].actor, ne[Y - 2][1] = ne[Y - 2][1].actor, this.$ = [ne[Y - 1], { type: "addNote", placement: Q.PLACEMENT.OVER, actor: ne[Y - 2].slice(0, 2), text: ne[Y] }];
          break;
        case 56:
          this.$ = [ne[Y - 1], { type: "addLinks", actor: ne[Y - 1].actor, text: ne[Y] }];
          break;
        case 57:
          this.$ = [ne[Y - 1], { type: "addALink", actor: ne[Y - 1].actor, text: ne[Y] }];
          break;
        case 58:
          this.$ = [ne[Y - 1], { type: "addProperties", actor: ne[Y - 1].actor, text: ne[Y] }];
          break;
        case 59:
          this.$ = [ne[Y - 1], { type: "addDetails", actor: ne[Y - 1].actor, text: ne[Y] }];
          break;
        case 62:
          this.$ = [ne[Y - 2], ne[Y]];
          break;
        case 63:
          this.$ = ne[Y];
          break;
        case 64:
          this.$ = Q.PLACEMENT.LEFTOF;
          break;
        case 65:
          this.$ = Q.PLACEMENT.RIGHTOF;
          break;
        case 66:
          this.$ = [
            ne[Y - 4],
            ne[Y - 1],
            { type: "addMessage", from: ne[Y - 4].actor, to: ne[Y - 1].actor, signalType: ne[Y - 3], msg: ne[Y], activate: !0 },
            { type: "activeStart", signalType: Q.LINETYPE.ACTIVE_START, actor: ne[Y - 1].actor }
          ];
          break;
        case 67:
          this.$ = [
            ne[Y - 4],
            ne[Y - 1],
            { type: "addMessage", from: ne[Y - 4].actor, to: ne[Y - 1].actor, signalType: ne[Y - 3], msg: ne[Y] },
            { type: "activeEnd", signalType: Q.LINETYPE.ACTIVE_END, actor: ne[Y - 4].actor }
          ];
          break;
        case 68:
          this.$ = [ne[Y - 3], ne[Y - 1], { type: "addMessage", from: ne[Y - 3].actor, to: ne[Y - 1].actor, signalType: ne[Y - 2], msg: ne[Y] }];
          break;
        case 69:
          this.$ = {
            type: "addParticipant",
            actor: ne[Y - 1],
            config: ne[Y]
          };
          break;
        case 70:
          this.$ = ne[Y - 1].trim();
          break;
        case 71:
          this.$ = { type: "addParticipant", actor: ne[Y] };
          break;
        case 72:
          this.$ = Q.LINETYPE.SOLID_OPEN;
          break;
        case 73:
          this.$ = Q.LINETYPE.DOTTED_OPEN;
          break;
        case 74:
          this.$ = Q.LINETYPE.SOLID;
          break;
        case 75:
          this.$ = Q.LINETYPE.BIDIRECTIONAL_SOLID;
          break;
        case 76:
          this.$ = Q.LINETYPE.DOTTED;
          break;
        case 77:
          this.$ = Q.LINETYPE.BIDIRECTIONAL_DOTTED;
          break;
        case 78:
          this.$ = Q.LINETYPE.SOLID_CROSS;
          break;
        case 79:
          this.$ = Q.LINETYPE.DOTTED_CROSS;
          break;
        case 80:
          this.$ = Q.LINETYPE.SOLID_POINT;
          break;
        case 81:
          this.$ = Q.LINETYPE.DOTTED_POINT;
          break;
        case 82:
          this.$ = Q.parseMessage(ne[Y].trim().substring(1));
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: e, 5: r, 6: n }, { 1: [3] }, { 3: 5, 4: e, 5: r, 6: n }, { 3: 6, 4: e, 5: r, 6: n }, t([1, 4, 5, 13, 14, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71], i, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, t(D, [2, 5]), { 9: 47, 12: 12, 13: o, 14: l, 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, t(D, [2, 7]), t(D, [2, 8]), t(D, [2, 14]), { 12: 48, 50: _, 52: R, 53: L }, { 15: [1, 49] }, { 5: [1, 50] }, { 5: [1, 53], 19: [1, 51], 20: [1, 52] }, { 22: 54, 71: O }, { 22: 55, 71: O }, { 5: [1, 56] }, { 5: [1, 57] }, { 5: [1, 58] }, { 5: [1, 59] }, { 5: [1, 60] }, t(D, [2, 29]), t(D, [2, 30]), { 32: [1, 61] }, { 34: [1, 62] }, t(D, [2, 33]), { 15: [1, 63] }, { 15: [1, 64] }, { 15: [1, 65] }, { 15: [1, 66] }, { 15: [1, 67] }, { 15: [1, 68] }, { 15: [1, 69] }, { 15: [1, 70] }, { 22: 71, 54: 72, 71: [1, 73] }, { 22: 74, 71: O }, { 22: 75, 71: O }, { 68: 76, 76: [1, 77], 77: [1, 78], 78: [1, 79], 79: [1, 80], 80: [1, 81], 81: [1, 82], 82: [1, 83], 83: [1, 84], 84: [1, 85], 85: [1, 86] }, { 56: 87, 58: [1, 88], 66: [1, 89], 67: [1, 90] }, { 22: 91, 71: O }, { 22: 92, 71: O }, { 22: 93, 71: O }, { 22: 94, 71: O }, t([5, 51, 65, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], $), t(D, [2, 6]), t(D, [2, 15]), t(z, [2, 9], { 10: 95 }), t(D, [2, 17]), { 5: [1, 97], 19: [1, 96] }, { 5: [1, 98] }, t(D, [2, 21]), { 5: [1, 99] }, { 5: [1, 100] }, t(D, [2, 24]), t(D, [2, 25]), t(D, [2, 26]), t(D, [2, 27]), t(D, [2, 28]), t(D, [2, 31]), t(D, [2, 32]), t(B, i, { 7: 101 }), t(B, i, { 7: 102 }), t(B, i, { 7: 103 }), t(G, i, { 40: 104, 7: 105 }), t(W, i, { 42: 106, 7: 107 }), t(W, i, { 7: 107, 42: 108 }), t(V, i, { 45: 109, 7: 110 }), t(B, i, { 7: 111 }), { 5: [1, 113], 51: [1, 112] }, { 5: [1, 114] }, t([5, 51], $, { 72: 115, 73: [1, 116] }), { 5: [1, 118], 51: [1, 117] }, { 5: [1, 119] }, { 22: 122, 69: [1, 120], 70: [1, 121], 71: O }, t(U, [2, 72]), t(U, [2, 73]), t(U, [2, 74]), t(U, [2, 75]), t(U, [2, 76]), t(U, [2, 77]), t(U, [2, 78]), t(U, [2, 79]), t(U, [2, 80]), t(U, [2, 81]), { 22: 123, 71: O }, { 22: 125, 59: 124, 71: O }, { 71: [2, 64] }, { 71: [2, 65] }, { 57: 126, 86: Z }, { 57: 128, 86: Z }, { 57: 129, 86: Z }, { 57: 130, 86: Z }, { 4: [1, 133], 5: [1, 135], 11: 132, 12: 134, 16: [1, 131], 50: _, 52: R, 53: L }, { 5: [1, 136] }, t(D, [2, 19]), t(D, [2, 20]), t(D, [2, 22]), t(D, [2, 23]), { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 137], 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 138], 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 139], 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, { 16: [1, 140] }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [2, 46], 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 49: [1, 141], 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, { 16: [1, 142] }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [2, 44], 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 48: [1, 143], 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, { 16: [1, 144] }, { 16: [1, 145] }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [2, 42], 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 47: [1, 146], 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, { 4: a, 5: s, 8: 8, 9: 10, 12: 12, 13: o, 14: l, 16: [1, 147], 17: 15, 18: u, 21: h, 22: 40, 23: f, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: d, 30: p, 31: g, 33: m, 35: v, 36: y, 37: b, 38: x, 39: T, 41: E, 43: A, 44: S, 46: k, 50: _, 52: R, 53: L, 55: M, 60: P, 61: C, 62: I, 63: N, 71: O }, { 15: [1, 148] }, t(D, [2, 49]), t(D, [2, 53]), { 5: [2, 69] }, { 74: [1, 149] }, { 15: [1, 150] }, t(D, [2, 51]), t(D, [2, 52]), { 22: 151, 71: O }, { 22: 152, 71: O }, { 57: 153, 86: Z }, { 57: 154, 86: Z }, { 57: 155, 86: Z }, { 65: [1, 156], 86: [2, 63] }, { 5: [2, 56] }, { 5: [2, 82] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [2, 59] }, t(D, [2, 16]), t(z, [2, 10]), { 12: 157, 50: _, 52: R, 53: L }, t(z, [2, 12]), t(z, [2, 13]), t(D, [2, 18]), t(D, [2, 34]), t(D, [2, 35]), t(D, [2, 36]), t(D, [2, 37]), { 15: [1, 158] }, t(D, [2, 38]), { 15: [1, 159] }, t(D, [2, 39]), t(D, [2, 40]), { 15: [1, 160] }, t(D, [2, 41]), { 5: [1, 161] }, { 75: [1, 162] }, { 5: [1, 163] }, { 57: 164, 86: Z }, { 57: 165, 86: Z }, { 5: [2, 68] }, { 5: [2, 54] }, { 5: [2, 55] }, { 22: 166, 71: O }, t(z, [2, 11]), t(G, i, { 7: 105, 40: 167 }), t(W, i, { 7: 107, 42: 168 }), t(V, i, { 7: 110, 45: 169 }), t(D, [2, 48]), { 5: [2, 70] }, t(D, [2, 50]), { 5: [2, 66] }, { 5: [2, 67] }, { 86: [2, 62] }, { 16: [2, 47] }, { 16: [2, 45] }, { 16: [2, 43] }],
    defaultActions: { 5: [2, 1], 6: [2, 2], 89: [2, 64], 90: [2, 65], 115: [2, 69], 126: [2, 56], 127: [2, 82], 128: [2, 57], 129: [2, 58], 130: [2, 59], 153: [2, 68], 154: [2, 54], 155: [2, 55], 162: [2, 70], 164: [2, 66], 165: [2, 67], 166: [2, 62], 167: [2, 47], 168: [2, 45], 169: [2, 43] },
    parseError: /* @__PURE__ */ w(function(j, X) {
      if (X.recoverable)
        this.trace(j);
      else {
        var re = new Error(j);
        throw re.hash = X, re;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(j) {
      var X = this, re = [0], Q = [], ue = [null], ne = [], xe = this.table, Y = "", Ne = 0, fe = 0, qe = 2, ze = 1, Ge = ne.slice.call(arguments, 1), Ee = Object.create(this.lexer), Oe = { yy: {} };
      for (var Ce in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Ce) && (Oe.yy[Ce] = this.yy[Ce]);
      Ee.setInput(j, Oe.yy), Oe.yy.lexer = Ee, Oe.yy.parser = this, typeof Ee.yylloc > "u" && (Ee.yylloc = {});
      var Ae = Ee.yylloc;
      ne.push(Ae);
      var $e = Ee.options && Ee.options.ranges;
      typeof Oe.yy.parseError == "function" ? this.parseError = Oe.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function me(Me) {
        re.length = re.length - 2 * Me, ue.length = ue.length - Me, ne.length = ne.length - Me;
      }
      w(me, "popStack");
      function Ie() {
        var Me;
        return Me = Q.pop() || Ee.lex() || ze, typeof Me != "number" && (Me instanceof Array && (Q = Me, Me = Q.pop()), Me = X.symbols_[Me] || Me), Me;
      }
      w(Ie, "lex");
      for (var te, he, F, oe, se = {}, ge, de, we, _e; ; ) {
        if (he = re[re.length - 1], this.defaultActions[he] ? F = this.defaultActions[he] : ((te === null || typeof te > "u") && (te = Ie()), F = xe[he] && xe[he][te]), typeof F > "u" || !F.length || !F[0]) {
          var Se = "";
          _e = [];
          for (ge in xe[he])
            this.terminals_[ge] && ge > qe && _e.push("'" + this.terminals_[ge] + "'");
          Ee.showPosition ? Se = "Parse error on line " + (Ne + 1) + `:
` + Ee.showPosition() + `
Expecting ` + _e.join(", ") + ", got '" + (this.terminals_[te] || te) + "'" : Se = "Parse error on line " + (Ne + 1) + ": Unexpected " + (te == ze ? "end of input" : "'" + (this.terminals_[te] || te) + "'"), this.parseError(Se, {
            text: Ee.match,
            token: this.terminals_[te] || te,
            line: Ee.yylineno,
            loc: Ae,
            expected: _e
          });
        }
        if (F[0] instanceof Array && F.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + he + ", token: " + te);
        switch (F[0]) {
          case 1:
            re.push(te), ue.push(Ee.yytext), ne.push(Ee.yylloc), re.push(F[1]), te = null, fe = Ee.yyleng, Y = Ee.yytext, Ne = Ee.yylineno, Ae = Ee.yylloc;
            break;
          case 2:
            if (de = this.productions_[F[1]][1], se.$ = ue[ue.length - de], se._$ = {
              first_line: ne[ne.length - (de || 1)].first_line,
              last_line: ne[ne.length - 1].last_line,
              first_column: ne[ne.length - (de || 1)].first_column,
              last_column: ne[ne.length - 1].last_column
            }, $e && (se._$.range = [
              ne[ne.length - (de || 1)].range[0],
              ne[ne.length - 1].range[1]
            ]), oe = this.performAction.apply(se, [
              Y,
              fe,
              Ne,
              Oe.yy,
              F[1],
              ue,
              ne
            ].concat(Ge)), typeof oe < "u")
              return oe;
            de && (re = re.slice(0, -1 * de * 2), ue = ue.slice(0, -1 * de), ne = ne.slice(0, -1 * de)), re.push(this.productions_[F[1]][0]), ue.push(se.$), ne.push(se._$), we = xe[re[re.length - 2]][re[re.length - 1]], re.push(we);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, ce = /* @__PURE__ */ (function() {
    var ee = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(X, re) {
        if (this.yy.parser)
          this.yy.parser.parseError(X, re);
        else
          throw new Error(X);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(j, X) {
        return this.yy = X || this.yy || {}, this._input = j, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var j = this._input[0];
        this.yytext += j, this.yyleng++, this.offset++, this.match += j, this.matched += j;
        var X = j.match(/(?:\r\n?|\n).*/g);
        return X ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), j;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(j) {
        var X = j.length, re = j.split(/(?:\r\n?|\n)/g);
        this._input = j + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - X), this.offset -= X;
        var Q = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), re.length - 1 && (this.yylineno -= re.length - 1);
        var ue = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: re ? (re.length === Q.length ? this.yylloc.first_column : 0) + Q[Q.length - re.length].length - re[0].length : this.yylloc.first_column - X
        }, this.options.ranges && (this.yylloc.range = [ue[0], ue[0] + this.yyleng - X]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(j) {
        this.unput(this.match.slice(j));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var j = this.matched.substr(0, this.matched.length - this.match.length);
        return (j.length > 20 ? "..." : "") + j.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var j = this.match;
        return j.length < 20 && (j += this._input.substr(0, 20 - j.length)), (j.substr(0, 20) + (j.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var j = this.pastInput(), X = new Array(j.length + 1).join("-");
        return j + this.upcomingInput() + `
` + X + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(j, X) {
        var re, Q, ue;
        if (this.options.backtrack_lexer && (ue = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (ue.yylloc.range = this.yylloc.range.slice(0))), Q = j[0].match(/(?:\r\n?|\n).*/g), Q && (this.yylineno += Q.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: Q ? Q[Q.length - 1].length - Q[Q.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + j[0].length
        }, this.yytext += j[0], this.match += j[0], this.matches = j, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(j[0].length), this.matched += j[0], re = this.performAction.call(this, this.yy, this, X, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), re)
          return re;
        if (this._backtrack) {
          for (var ne in ue)
            this[ne] = ue[ne];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var j, X, re, Q;
        this._more || (this.yytext = "", this.match = "");
        for (var ue = this._currentRules(), ne = 0; ne < ue.length; ne++)
          if (re = this._input.match(this.rules[ue[ne]]), re && (!X || re[0].length > X[0].length)) {
            if (X = re, Q = ne, this.options.backtrack_lexer) {
              if (j = this.test_match(re, ue[ne]), j !== !1)
                return j;
              if (this._backtrack) {
                X = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return X ? (j = this.test_match(X, ue[Q]), j !== !1 ? j : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var X = this.next();
        return X || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(X) {
        this.conditionStack.push(X);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var X = this.conditionStack.length - 1;
        return X > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(X) {
        return X = this.conditionStack.length - 1 - Math.abs(X || 0), X >= 0 ? this.conditionStack[X] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(X) {
        this.begin(X);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(X, re, Q, ue) {
        switch (Q) {
          case 0:
            return 5;
          case 1:
            break;
          case 2:
            break;
          case 3:
            break;
          case 4:
            break;
          case 5:
            break;
          case 6:
            return 19;
          case 7:
            return this.begin("CONFIG"), 73;
          case 8:
            return 74;
          case 9:
            return this.popState(), this.popState(), 75;
          case 10:
            return re.yytext = re.yytext.trim(), 71;
          case 11:
            return re.yytext = re.yytext.trim(), this.begin("ALIAS"), 71;
          case 12:
            return this.begin("LINE"), 14;
          case 13:
            return this.begin("ID"), 50;
          case 14:
            return this.begin("ID"), 52;
          case 15:
            return 13;
          case 16:
            return this.begin("ID"), 53;
          case 17:
            return re.yytext = re.yytext.trim(), this.begin("ALIAS"), 71;
          case 18:
            return this.popState(), this.popState(), this.begin("LINE"), 51;
          case 19:
            return this.popState(), this.popState(), 5;
          case 20:
            return this.begin("LINE"), 36;
          case 21:
            return this.begin("LINE"), 37;
          case 22:
            return this.begin("LINE"), 38;
          case 23:
            return this.begin("LINE"), 39;
          case 24:
            return this.begin("LINE"), 49;
          case 25:
            return this.begin("LINE"), 41;
          case 26:
            return this.begin("LINE"), 43;
          case 27:
            return this.begin("LINE"), 48;
          case 28:
            return this.begin("LINE"), 44;
          case 29:
            return this.begin("LINE"), 47;
          case 30:
            return this.begin("LINE"), 46;
          case 31:
            return this.popState(), 15;
          case 32:
            return 16;
          case 33:
            return 66;
          case 34:
            return 67;
          case 35:
            return 60;
          case 36:
            return 61;
          case 37:
            return 62;
          case 38:
            return 63;
          case 39:
            return 58;
          case 40:
            return 55;
          case 41:
            return this.begin("ID"), 21;
          case 42:
            return this.begin("ID"), 23;
          case 43:
            return 29;
          case 44:
            return 30;
          case 45:
            return this.begin("acc_title"), 31;
          case 46:
            return this.popState(), "acc_title_value";
          case 47:
            return this.begin("acc_descr"), 33;
          case 48:
            return this.popState(), "acc_descr_value";
          case 49:
            this.begin("acc_descr_multiline");
            break;
          case 50:
            this.popState();
            break;
          case 51:
            return "acc_descr_multiline_value";
          case 52:
            return 6;
          case 53:
            return 18;
          case 54:
            return 20;
          case 55:
            return 65;
          case 56:
            return 5;
          case 57:
            return re.yytext = re.yytext.trim(), 71;
          case 58:
            return 78;
          case 59:
            return 79;
          case 60:
            return 80;
          case 61:
            return 81;
          case 62:
            return 76;
          case 63:
            return 77;
          case 64:
            return 82;
          case 65:
            return 83;
          case 66:
            return 84;
          case 67:
            return 85;
          case 68:
            return 86;
          case 69:
            return 86;
          case 70:
            return 69;
          case 71:
            return 70;
          case 72:
            return 5;
          case 73:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:@\{)/i, /^(?:[^\}]+)/i, /^(?:\})/i, /^(?:[^\<->\->:\n,;@\s]+(?=@\{))/i, /^(?:[^\<->\->:\n,;@]+?([\-]*[^\<->\->:\n,;@]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:box\b)/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:create\b)/i, /^(?:destroy\b)/i, /^(?:[^<\->\->:\n,;]+?([\-]*[^<\->\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:par_over\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^+<\->\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+<\->\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:<<->>)/i, /^(?:-->>)/i, /^(?:<<-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]*)/i, /^(?::)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [50, 51], inclusive: !1 }, acc_descr: { rules: [48], inclusive: !1 }, acc_title: { rules: [46], inclusive: !1 }, ID: { rules: [2, 3, 7, 10, 11, 17], inclusive: !1 }, ALIAS: { rules: [2, 3, 18, 19], inclusive: !1 }, LINE: { rules: [2, 3, 31], inclusive: !1 }, CONFIG: { rules: [8, 9], inclusive: !1 }, CONFIG_DATA: { rules: [], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 4, 5, 6, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 49, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73], inclusive: !0 } }
    };
    return ee;
  })();
  K.lexer = ce;
  function J() {
    this.yy = {};
  }
  return w(J, "Parser"), J.prototype = K, K.Parser = J, new J();
})();
z8.parser = z8;
var ort = z8, lrt = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31,
  PAR_OVER_START: 32,
  BIDIRECTIONAL_SOLID: 33,
  BIDIRECTIONAL_DOTTED: 34
}, crt = {
  FILLED: 0,
  OPEN: 1
}, urt = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, uy = {
  ACTOR: "actor",
  CONTROL: "control",
  DATABASE: "database",
  ENTITY: "entity"
}, Pd, hrt = (Pd = class {
  constructor() {
    this.state = new zae(() => ({
      prevActor: void 0,
      actors: /* @__PURE__ */ new Map(),
      createdActors: /* @__PURE__ */ new Map(),
      destroyedActors: /* @__PURE__ */ new Map(),
      boxes: [],
      messages: [],
      notes: [],
      sequenceNumbersEnabled: !1,
      wrapEnabled: void 0,
      currentBox: void 0,
      lastCreated: void 0,
      lastDestroyed: void 0
    })), this.setAccTitle = Ln, this.setAccDescription = Wn, this.setDiagramTitle = ti, this.getAccTitle = Hn, this.getAccDescription = Yn, this.getDiagramTitle = Mn, this.apply = this.apply.bind(this), this.parseBoxData = this.parseBoxData.bind(this), this.parseMessage = this.parseMessage.bind(this), this.clear(), this.setWrap(Te().wrap), this.LINETYPE = lrt, this.ARROWTYPE = crt, this.PLACEMENT = urt;
  }
  addBox(e) {
    this.state.records.boxes.push({
      name: e.text,
      wrap: e.wrap ?? this.autoWrap(),
      fill: e.color,
      actorKeys: []
    }), this.state.records.currentBox = this.state.records.boxes.slice(-1)[0];
  }
  addActor(e, r, n, i, a) {
    let s = this.state.records.currentBox, o;
    if (a !== void 0) {
      let u;
      a.includes(`
`) ? u = a + `
` : u = `{
` + a + `
}`, o = Kx(u, { schema: jx });
    }
    i = o?.type ?? i;
    const l = this.state.records.actors.get(e);
    if (l) {
      if (this.state.records.currentBox && l.box && this.state.records.currentBox !== l.box)
        throw new Error(
          `A same participant should only be defined in one Box: ${l.name} can't be in '${l.box.name}' and in '${this.state.records.currentBox.name}' at the same time.`
        );
      if (s = l.box ? l.box : this.state.records.currentBox, l.box = s, l && r === l.name && n == null)
        return;
    }
    if (n?.text == null && (n = { text: r, type: i }), (i == null || n.text == null) && (n = { text: r, type: i }), this.state.records.actors.set(e, {
      box: s,
      name: r,
      description: n.text,
      wrap: n.wrap ?? this.autoWrap(),
      prevActor: this.state.records.prevActor,
      links: {},
      properties: {},
      actorCnt: null,
      rectData: null,
      type: i ?? "participant"
    }), this.state.records.prevActor) {
      const u = this.state.records.actors.get(this.state.records.prevActor);
      u && (u.nextActor = e);
    }
    this.state.records.currentBox && this.state.records.currentBox.actorKeys.push(e), this.state.records.prevActor = e;
  }
  activationCount(e) {
    let r, n = 0;
    if (!e)
      return 0;
    for (r = 0; r < this.state.records.messages.length; r++)
      this.state.records.messages[r].type === this.LINETYPE.ACTIVE_START && this.state.records.messages[r].from === e && n++, this.state.records.messages[r].type === this.LINETYPE.ACTIVE_END && this.state.records.messages[r].from === e && n--;
    return n;
  }
  addMessage(e, r, n, i) {
    this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: e,
      to: r,
      message: n.text,
      wrap: n.wrap ?? this.autoWrap(),
      answer: i
    });
  }
  addSignal(e, r, n, i, a = !1) {
    if (i === this.LINETYPE.ACTIVE_END && this.activationCount(e ?? "") < 1) {
      const o = new Error("Trying to inactivate an inactive participant (" + e + ")");
      throw o.hash = {
        text: "->>-",
        token: "->>-",
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["'ACTIVE_PARTICIPANT'"]
      }, o;
    }
    return this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: e,
      to: r,
      message: n?.text ?? "",
      wrap: n?.wrap ?? this.autoWrap(),
      type: i,
      activate: a
    }), !0;
  }
  hasAtLeastOneBox() {
    return this.state.records.boxes.length > 0;
  }
  hasAtLeastOneBoxWithTitle() {
    return this.state.records.boxes.some((e) => e.name);
  }
  getMessages() {
    return this.state.records.messages;
  }
  getBoxes() {
    return this.state.records.boxes;
  }
  getActors() {
    return this.state.records.actors;
  }
  getCreatedActors() {
    return this.state.records.createdActors;
  }
  getDestroyedActors() {
    return this.state.records.destroyedActors;
  }
  getActor(e) {
    return this.state.records.actors.get(e);
  }
  getActorKeys() {
    return [...this.state.records.actors.keys()];
  }
  enableSequenceNumbers() {
    this.state.records.sequenceNumbersEnabled = !0;
  }
  disableSequenceNumbers() {
    this.state.records.sequenceNumbersEnabled = !1;
  }
  showSequenceNumbers() {
    return this.state.records.sequenceNumbersEnabled;
  }
  setWrap(e) {
    this.state.records.wrapEnabled = e;
  }
  extractWrap(e) {
    if (e === void 0)
      return {};
    e = e.trim();
    const r = /^:?wrap:/.exec(e) !== null ? !0 : /^:?nowrap:/.exec(e) !== null ? !1 : void 0;
    return { cleanedText: (r === void 0 ? e : e.replace(/^:?(?:no)?wrap:/, "")).trim(), wrap: r };
  }
  autoWrap() {
    return this.state.records.wrapEnabled !== void 0 ? this.state.records.wrapEnabled : Te().sequence?.wrap ?? !1;
  }
  clear() {
    this.state.reset(), In();
  }
  parseMessage(e) {
    const r = e.trim(), { wrap: n, cleanedText: i } = this.extractWrap(r), a = {
      text: i,
      wrap: n
    };
    return ae.debug(`parseMessage: ${JSON.stringify(a)}`), a;
  }
  // We expect the box statement to be color first then description
  // The color can be rgb,rgba,hsl,hsla, or css code names  #hex codes are not supported for now because of the way the char # is handled
  // We extract first segment as color, the rest of the line is considered as text
  parseBoxData(e) {
    const r = /^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/.exec(e);
    let n = r?.[1] ? r[1].trim() : "transparent", i = r?.[2] ? r[2].trim() : void 0;
    if (window?.CSS)
      window.CSS.supports("color", n) || (n = "transparent", i = e.trim());
    else {
      const o = new Option().style;
      o.color = n, o.color !== n && (n = "transparent", i = e.trim());
    }
    const { wrap: a, cleanedText: s } = this.extractWrap(i);
    return {
      text: s ? pr(s, Te()) : void 0,
      color: n,
      wrap: a
    };
  }
  addNote(e, r, n) {
    const i = {
      actor: e,
      placement: r,
      message: n.text,
      wrap: n.wrap ?? this.autoWrap()
    }, a = [].concat(e, e);
    this.state.records.notes.push(i), this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: a[0],
      to: a[1],
      message: n.text,
      wrap: n.wrap ?? this.autoWrap(),
      type: this.LINETYPE.NOTE,
      placement: r
    });
  }
  addLinks(e, r) {
    const n = this.getActor(e);
    try {
      let i = pr(r.text, Te());
      i = i.replace(/&equals;/g, "="), i = i.replace(/&amp;/g, "&");
      const a = JSON.parse(i);
      this.insertLinks(n, a);
    } catch (i) {
      ae.error("error while parsing actor link text", i);
    }
  }
  addALink(e, r) {
    const n = this.getActor(e);
    try {
      const i = {};
      let a = pr(r.text, Te());
      const s = a.indexOf("@");
      a = a.replace(/&equals;/g, "="), a = a.replace(/&amp;/g, "&");
      const o = a.slice(0, s - 1).trim(), l = a.slice(s + 1).trim();
      i[o] = l, this.insertLinks(n, i);
    } catch (i) {
      ae.error("error while parsing actor link text", i);
    }
  }
  insertLinks(e, r) {
    if (e.links == null)
      e.links = r;
    else
      for (const n in r)
        e.links[n] = r[n];
  }
  addProperties(e, r) {
    const n = this.getActor(e);
    try {
      const i = pr(r.text, Te()), a = JSON.parse(i);
      this.insertProperties(n, a);
    } catch (i) {
      ae.error("error while parsing actor properties text", i);
    }
  }
  insertProperties(e, r) {
    if (e.properties == null)
      e.properties = r;
    else
      for (const n in r)
        e.properties[n] = r[n];
  }
  boxEnd() {
    this.state.records.currentBox = void 0;
  }
  addDetails(e, r) {
    const n = this.getActor(e), i = document.getElementById(r.text);
    try {
      const a = i.innerHTML, s = JSON.parse(a);
      s.properties && this.insertProperties(n, s.properties), s.links && this.insertLinks(n, s.links);
    } catch (a) {
      ae.error("error while parsing actor details text", a);
    }
  }
  getActorProperty(e, r) {
    if (e?.properties !== void 0)
      return e.properties[r];
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-redundant-type-constituents
  apply(e) {
    if (Array.isArray(e))
      e.forEach((r) => {
        this.apply(r);
      });
    else
      switch (e.type) {
        case "sequenceIndex":
          this.state.records.messages.push({
            id: this.state.records.messages.length.toString(),
            from: void 0,
            to: void 0,
            message: {
              start: e.sequenceIndex,
              step: e.sequenceIndexStep,
              visible: e.sequenceVisible
            },
            wrap: !1,
            type: e.signalType
          });
          break;
        case "addParticipant":
          this.addActor(e.actor, e.actor, e.description, e.draw, e.config);
          break;
        case "createParticipant":
          if (this.state.records.actors.has(e.actor))
            throw new Error(
              "It is not possible to have actors with the same id, even if one is destroyed before the next is created. Use 'AS' aliases to simulate the behavior"
            );
          this.state.records.lastCreated = e.actor, this.addActor(e.actor, e.actor, e.description, e.draw, e.config), this.state.records.createdActors.set(e.actor, this.state.records.messages.length);
          break;
        case "destroyParticipant":
          this.state.records.lastDestroyed = e.actor, this.state.records.destroyedActors.set(e.actor, this.state.records.messages.length);
          break;
        case "activeStart":
          this.addSignal(e.actor, void 0, void 0, e.signalType);
          break;
        case "activeEnd":
          this.addSignal(e.actor, void 0, void 0, e.signalType);
          break;
        case "addNote":
          this.addNote(e.actor, e.placement, e.text);
          break;
        case "addLinks":
          this.addLinks(e.actor, e.text);
          break;
        case "addALink":
          this.addALink(e.actor, e.text);
          break;
        case "addProperties":
          this.addProperties(e.actor, e.text);
          break;
        case "addDetails":
          this.addDetails(e.actor, e.text);
          break;
        case "addMessage":
          if (this.state.records.lastCreated) {
            if (e.to !== this.state.records.lastCreated)
              throw new Error(
                "The created participant " + this.state.records.lastCreated.name + " does not have an associated creating message after its declaration. Please check the sequence diagram."
              );
            this.state.records.lastCreated = void 0;
          } else if (this.state.records.lastDestroyed) {
            if (e.to !== this.state.records.lastDestroyed && e.from !== this.state.records.lastDestroyed)
              throw new Error(
                "The destroyed participant " + this.state.records.lastDestroyed.name + " does not have an associated destroying message after its declaration. Please check the sequence diagram."
              );
            this.state.records.lastDestroyed = void 0;
          }
          this.addSignal(e.from, e.to, e.msg, e.signalType, e.activate);
          break;
        case "boxStart":
          this.addBox(e.boxData);
          break;
        case "boxEnd":
          this.boxEnd();
          break;
        case "loopStart":
          this.addSignal(void 0, void 0, e.loopText, e.signalType);
          break;
        case "loopEnd":
          this.addSignal(void 0, void 0, void 0, e.signalType);
          break;
        case "rectStart":
          this.addSignal(void 0, void 0, e.color, e.signalType);
          break;
        case "rectEnd":
          this.addSignal(void 0, void 0, void 0, e.signalType);
          break;
        case "optStart":
          this.addSignal(void 0, void 0, e.optText, e.signalType);
          break;
        case "optEnd":
          this.addSignal(void 0, void 0, void 0, e.signalType);
          break;
        case "altStart":
          this.addSignal(void 0, void 0, e.altText, e.signalType);
          break;
        case "else":
          this.addSignal(void 0, void 0, e.altText, e.signalType);
          break;
        case "altEnd":
          this.addSignal(void 0, void 0, void 0, e.signalType);
          break;
        case "setAccTitle":
          Ln(e.text);
          break;
        case "parStart":
          this.addSignal(void 0, void 0, e.parText, e.signalType);
          break;
        case "and":
          this.addSignal(void 0, void 0, e.parText, e.signalType);
          break;
        case "parEnd":
          this.addSignal(void 0, void 0, void 0, e.signalType);
          break;
        case "criticalStart":
          this.addSignal(void 0, void 0, e.criticalText, e.signalType);
          break;
        case "option":
          this.addSignal(void 0, void 0, e.optionText, e.signalType);
          break;
        case "criticalEnd":
          this.addSignal(void 0, void 0, void 0, e.signalType);
          break;
        case "breakStart":
          this.addSignal(void 0, void 0, e.breakText, e.signalType);
          break;
        case "breakEnd":
          this.addSignal(void 0, void 0, void 0, e.signalType);
          break;
      }
  }
  getConfig() {
    return Te().sequence;
  }
}, w(Pd, "SequenceDB"), Pd), frt = /* @__PURE__ */ w((t) => `.actor {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
  }

  text.actor > tspan {
    fill: ${t.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${t.actorLineColor};
  }
  
  .innerArc {
    stroke-width: 1.5;
    stroke-dasharray: none;
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${t.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${t.signalColor};
  }

  #arrowhead path {
    fill: ${t.signalColor};
    stroke: ${t.signalColor};
  }

  .sequenceNumber {
    fill: ${t.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${t.signalColor};
  }

  #crosshead path {
    fill: ${t.signalColor};
    stroke: ${t.signalColor};
  }

  .messageText {
    fill: ${t.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${t.labelBoxBorderColor};
    fill: ${t.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${t.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${t.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${t.labelBoxBorderColor};
    fill: ${t.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${t.noteBorderColor};
    fill: ${t.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${t.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .activation1 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .activation2 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${t.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
    stroke-width: 2px;
  }

`, "getStyles"), drt = frt, Pu = 36, nu = "actor-top", iu = "actor-bottom", Q3 = "actor-box", Nc = "actor-man", H1 = /* @__PURE__ */ w(function(t, e) {
  return h3(t, e);
}, "drawRect"), prt = /* @__PURE__ */ w(function(t, e, r, n, i) {
  if (e.links === void 0 || e.links === null || Object.keys(e.links).length === 0)
    return { height: 0, width: 0 };
  const a = e.links, s = e.actorCnt, o = e.rectData;
  var l = "none";
  i && (l = "block !important");
  const u = t.append("g");
  u.attr("id", "actor" + s + "_popup"), u.attr("class", "actorPopupMenu"), u.attr("display", l);
  var h = "";
  o.class !== void 0 && (h = " " + o.class);
  let f = o.width > r ? o.width : r;
  const d = u.append("rect");
  if (d.attr("class", "actorPopupMenuPanel" + h), d.attr("x", o.x), d.attr("y", o.height), d.attr("fill", o.fill), d.attr("stroke", o.stroke), d.attr("width", f), d.attr("height", o.height), d.attr("rx", o.rx), d.attr("ry", o.ry), a != null) {
    var p = 20;
    for (let v in a) {
      var g = u.append("a"), m = yh.sanitizeUrl(a[v]);
      g.attr("xlink:href", m), g.attr("target", "_blank"), Prt(n)(
        v,
        g,
        o.x + 10,
        o.height + p,
        f,
        20,
        { class: "actor" },
        n
      ), p += 30;
    }
  }
  return d.attr("height", p), { height: o.height + p, width: f };
}, "drawPopup"), J3 = /* @__PURE__ */ w(function(t) {
  return "var pu = document.getElementById('" + t + "'); if (pu != null) { pu.style.display = pu.style.display == 'block' ? 'none' : 'block'; }";
}, "popupMenuToggle"), kx = /* @__PURE__ */ w(async function(t, e, r = null) {
  let n = t.append("foreignObject");
  const i = await Z1(e.text, mr()), s = n.append("xhtml:div").attr("style", "width: fit-content;").attr("xmlns", "http://www.w3.org/1999/xhtml").html(i).node().getBoundingClientRect();
  if (n.attr("height", Math.round(s.height)).attr("width", Math.round(s.width)), e.class === "noteText") {
    const o = t.node().firstChild;
    o.setAttribute("height", s.height + 2 * e.textMargin);
    const l = o.getBBox();
    n.attr("x", Math.round(l.x + l.width / 2 - s.width / 2)).attr("y", Math.round(l.y + l.height / 2 - s.height / 2));
  } else if (r) {
    let { startx: o, stopx: l, starty: u } = r;
    if (o > l) {
      const h = o;
      o = l, l = h;
    }
    n.attr("x", Math.round(o + Math.abs(o - l) / 2 - s.width / 2)), e.class === "loopText" ? n.attr("y", Math.round(u)) : n.attr("y", Math.round(u - s.height));
  }
  return [n];
}, "drawKatex"), T0 = /* @__PURE__ */ w(function(t, e) {
  let r = 0, n = 0;
  const i = e.text.split(at.lineBreakRegex), [a, s] = Sh(e.fontSize);
  let o = [], l = 0, u = /* @__PURE__ */ w(() => e.y, "yfunc");
  if (e.valign !== void 0 && e.textMargin !== void 0 && e.textMargin > 0)
    switch (e.valign) {
      case "top":
      case "start":
        u = /* @__PURE__ */ w(() => Math.round(e.y + e.textMargin), "yfunc");
        break;
      case "middle":
      case "center":
        u = /* @__PURE__ */ w(() => Math.round(e.y + (r + n + e.textMargin) / 2), "yfunc");
        break;
      case "bottom":
      case "end":
        u = /* @__PURE__ */ w(() => Math.round(
          e.y + (r + n + 2 * e.textMargin) - e.textMargin
        ), "yfunc");
        break;
    }
  if (e.anchor !== void 0 && e.textMargin !== void 0 && e.width !== void 0)
    switch (e.anchor) {
      case "left":
      case "start":
        e.x = Math.round(e.x + e.textMargin), e.anchor = "start", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        e.x = Math.round(e.x + e.width / 2), e.anchor = "middle", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        e.x = Math.round(e.x + e.width - e.textMargin), e.anchor = "end", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
    }
  for (let [h, f] of i.entries()) {
    e.textMargin !== void 0 && e.textMargin === 0 && a !== void 0 && (l = h * a);
    const d = t.append("text");
    d.attr("x", e.x), d.attr("y", u()), e.anchor !== void 0 && d.attr("text-anchor", e.anchor).attr("dominant-baseline", e.dominantBaseline).attr("alignment-baseline", e.alignmentBaseline), e.fontFamily !== void 0 && d.style("font-family", e.fontFamily), s !== void 0 && d.style("font-size", s), e.fontWeight !== void 0 && d.style("font-weight", e.fontWeight), e.fill !== void 0 && d.attr("fill", e.fill), e.class !== void 0 && d.attr("class", e.class), e.dy !== void 0 ? d.attr("dy", e.dy) : l !== 0 && d.attr("dy", l);
    const p = f || SZ;
    if (e.tspan) {
      const g = d.append("tspan");
      g.attr("x", e.x), e.fill !== void 0 && g.attr("fill", e.fill), g.text(p);
    } else
      d.text(p);
    e.valign !== void 0 && e.textMargin !== void 0 && e.textMargin > 0 && (n += (d._groups || d)[0][0].getBBox().height, r = n), o.push(d);
  }
  return o;
}, "drawText"), Lce = /* @__PURE__ */ w(function(t, e) {
  function r(i, a, s, o, l) {
    return i + "," + a + " " + (i + s) + "," + a + " " + (i + s) + "," + (a + o - l) + " " + (i + s - l * 1.2) + "," + (a + o) + " " + i + "," + (a + o);
  }
  w(r, "genPoints");
  const n = t.append("polygon");
  return n.attr("points", r(e.x, e.y, e.width, e.height, 7)), n.attr("class", "labelBox"), e.y = e.y + e.height / 2, T0(t, e), n;
}, "drawLabel"), cr = -1, Rce = /* @__PURE__ */ w((t, e, r, n) => {
  t.select && r.forEach((i) => {
    const a = e.get(i), s = t.select("#actor" + a.actorCnt);
    !n.mirrorActors && a.stopy ? s.attr("y2", a.stopy + a.height / 2) : n.mirrorActors && s.attr("y2", a.stopy);
  });
}, "fixLifeLineHeights"), grt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height, o = t.append("g").lower();
  var l = o;
  n || (cr++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", J3(`actor${cr}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = cr, e.links != null && l.attr("id", "root-" + cr));
  const u = Oa();
  var h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${iu}` : h += ` ${nu}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.rx = 3, u.ry = 3, u.name = e.name;
  const f = H1(l, u);
  if (e.rectData = u, e.properties?.icon) {
    const p = e.properties.icon.trim();
    p.charAt(0) === "@" ? FR(l, u.x + u.width - 20, u.y + 10, p.substr(1)) : BR(l, u.x + u.width - 20, u.y + 10, p);
  }
  Bl(r, dn(e.description))(
    e.description,
    l,
    u.x,
    u.y,
    u.width,
    u.height,
    { class: `actor ${Q3}` },
    r
  );
  let d = e.height;
  if (f.node) {
    const p = f.node().getBBox();
    e.height = p.height, d = p.height;
  }
  return d;
}, "drawActorTypeParticipant"), mrt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height, o = t.append("g").lower();
  var l = o;
  n || (cr++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", J3(`actor${cr}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = cr, e.links != null && l.attr("id", "root-" + cr));
  const u = Oa();
  var h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${iu}` : h += ` ${nu}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.name = e.name;
  const f = 6, d = {
    ...u,
    x: u.x + -f,
    y: u.y + +f,
    class: "actor"
  }, p = H1(l, u);
  if (H1(l, d), e.rectData = u, e.properties?.icon) {
    const m = e.properties.icon.trim();
    m.charAt(0) === "@" ? FR(l, u.x + u.width - 20, u.y + 10, m.substr(1)) : BR(l, u.x + u.width - 20, u.y + 10, m);
  }
  Bl(r, dn(e.description))(
    e.description,
    l,
    u.x - f,
    u.y + f,
    u.width,
    u.height,
    { class: `actor ${Q3}` },
    r
  );
  let g = e.height;
  if (p.node) {
    const m = p.node().getBBox();
    e.height = m.height, g = m.height;
  }
  return g;
}, "drawActorTypeCollections"), vrt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height, o = t.append("g").lower();
  let l = o;
  n || (cr++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", J3(`actor${cr}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = cr, e.links != null && l.attr("id", "root-" + cr));
  const u = Oa();
  let h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${iu}` : h += ` ${nu}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.name = e.name;
  const f = u.height / 2, d = f / (2.5 + u.height / 50), p = l.append("g"), g = l.append("g");
  if (p.append("path").attr(
    "d",
    `M ${u.x},${u.y + f}
    a ${d},${f} 0 0 0 0,${u.height}
    h ${u.width - 2 * d}
    a ${d},${f} 0 0 0 0,-${u.height}
    Z
  `
  ).attr("class", h), g.append("path").attr(
    "d",
    `M ${u.x},${u.y + f}
      a ${d},${f} 0 0 0 0,${u.height}`
  ).attr("stroke", "#666").attr("stroke-width", "1px").attr("class", h), p.attr("transform", `translate(${d}, ${-(u.height / 2)})`), g.attr("transform", `translate(${u.width - d}, ${-u.height / 2})`), e.rectData = u, e.properties?.icon) {
    const y = e.properties.icon.trim(), b = u.x + u.width - 20, x = u.y + 10;
    y.charAt(0) === "@" ? FR(l, b, x, y.substr(1)) : BR(l, b, x, y);
  }
  Bl(r, dn(e.description))(
    e.description,
    l,
    u.x,
    u.y,
    u.width,
    u.height,
    { class: `actor ${Q3}` },
    r
  );
  let m = e.height;
  const v = p.select("path:last-child");
  if (v.node()) {
    const y = v.node().getBBox();
    e.height = y.height, m = y.height;
  }
  return m;
}, "drawActorTypeQueue"), yrt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 75, o = t.append("g").lower();
  n || (cr++, o.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = cr);
  const l = t.append("g");
  let u = Nc;
  n ? u += ` ${iu}` : u += ` ${nu}`, l.attr("class", u), l.attr("name", e.name);
  const h = Oa();
  h.x = e.x, h.y = i, h.fill = "#eaeaea", h.width = e.width, h.height = e.height, h.class = "actor";
  const f = e.x + e.width / 2, d = i + 30, p = 18;
  l.append("defs").append("marker").attr("id", "filled-head-control").attr("refX", 11).attr("refY", 5.8).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "172.5").append("path").attr("d", "M 14.4 5.6 L 7.2 10.4 L 8.8 5.6 L 7.2 0.8 Z"), l.append("circle").attr("cx", f).attr("cy", d).attr("r", p).attr("fill", "#eaeaf7").attr("stroke", "#666").attr("stroke-width", 1.2), l.append("line").attr("marker-end", "url(#filled-head-control)").attr("transform", `translate(${f}, ${d - p})`);
  const g = l.node().getBBox();
  return e.height = g.height + 2 * (r?.sequence?.labelBoxHeight ?? 0), Bl(r, dn(e.description))(
    e.description,
    l,
    h.x,
    h.y + p + (n ? 5 : 10),
    h.width,
    h.height,
    { class: `actor ${Nc}` },
    r
  ), e.height;
}, "drawActorTypeControl"), brt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 75, o = t.append("g").lower(), l = t.append("g");
  let u = Nc;
  n ? u += ` ${iu}` : u += ` ${nu}`, l.attr("class", u), l.attr("name", e.name);
  const h = Oa();
  h.x = e.x, h.y = i, h.fill = "#eaeaea", h.width = e.width, h.height = e.height, h.class = "actor";
  const f = e.x + e.width / 2, d = i + (n ? 10 : 25), p = 18;
  l.append("circle").attr("cx", f).attr("cy", d).attr("r", p).attr("width", e.width).attr("height", e.height), l.append("line").attr("x1", f - p).attr("x2", f + p).attr("y1", d + p).attr("y2", d + p).attr("stroke", "#333").attr("stroke-width", 2);
  const g = l.node().getBBox();
  return e.height = g.height + (r?.sequence?.labelBoxHeight ?? 0), n || (cr++, o.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = cr), Bl(r, dn(e.description))(
    e.description,
    l,
    h.x,
    h.y + (n ? (d - i + p - 5) / 2 : (d + p - i) / 2),
    h.width,
    h.height,
    { class: `actor ${Nc}` },
    r
  ), n ? l.attr("transform", `translate(0, ${p / 2})`) : l.attr("transform", `translate(0, ${p / 2})`), e.height;
}, "drawActorTypeEntity"), xrt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + e.height + 2 * r.boxTextMargin, o = t.append("g").lower();
  let l = o;
  n || (cr++, Object.keys(e.links || {}).length && !r.forceMenus && l.attr("onclick", J3(`actor${cr}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), l = o.append("g"), e.actorCnt = cr, e.links != null && l.attr("id", "root-" + cr));
  const u = Oa();
  let h = "actor";
  e.properties?.class ? h = e.properties.class : u.fill = "#eaeaea", n ? h += ` ${iu}` : h += ` ${nu}`, u.x = e.x, u.y = i, u.width = e.width, u.height = e.height, u.class = h, u.name = e.name, u.x = e.x, u.y = i;
  const f = u.width / 4, d = u.width / 4, p = f / 2, g = p / (2.5 + f / 50), m = l.append("g"), v = `
  M ${u.x},${u.y + g}
  a ${p},${g} 0 0 0 ${f},0
  a ${p},${g} 0 0 0 -${f},0
  l 0,${d - 2 * g}
  a ${p},${g} 0 0 0 ${f},0
  l 0,-${d - 2 * g}
`;
  m.append("path").attr("d", v).attr("fill", "#eaeaea").attr("stroke", "#000").attr("stroke-width", 1).attr("class", h), n ? m.attr("transform", `translate(${f * 1.5}, ${u.height / 4 - 2 * g})`) : m.attr("transform", `translate(${f * 1.5}, ${(u.height + g) / 4})`), e.rectData = u, Bl(r, dn(e.description))(
    e.description,
    l,
    u.x,
    u.y + (n ? (u.height + d) / 4 : (u.height + g) / 2),
    u.width,
    u.height,
    { class: `actor ${Q3}` },
    r
  );
  const y = m.select("path:last-child");
  if (y.node()) {
    const b = y.node().getBBox();
    e.height = b.height + (r.sequence.labelBoxHeight ?? 0);
  }
  return e.height;
}, "drawActorTypeDatabase"), wrt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 80, o = 30, l = t.append("g").lower();
  n || (cr++, l.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = cr);
  const u = t.append("g");
  let h = Nc;
  n ? h += ` ${iu}` : h += ` ${nu}`, u.attr("class", h), u.attr("name", e.name);
  const f = Oa();
  f.x = e.x, f.y = i, f.fill = "#eaeaea", f.width = e.width, f.height = e.height, f.class = "actor", u.append("line").attr("id", "actor-man-torso" + cr).attr("x1", e.x + e.width / 2 - o * 2.5).attr("y1", i + 10).attr("x2", e.x + e.width / 2 - 15).attr("y2", i + 10), u.append("line").attr("id", "actor-man-arms" + cr).attr("x1", e.x + e.width / 2 - o * 2.5).attr("y1", i + 0).attr("x2", e.x + e.width / 2 - o * 2.5).attr("y2", i + 20), u.append("circle").attr("cx", e.x + e.width / 2).attr("cy", i + 10).attr("r", o);
  const d = u.node().getBBox();
  return e.height = d.height + (r.sequence.labelBoxHeight ?? 0), Bl(r, dn(e.description))(
    e.description,
    u,
    f.x,
    f.y + (n ? o / 2 - 4 : o / 2 + 3),
    f.width,
    f.height,
    { class: `actor ${Nc}` },
    r
  ), n ? u.attr("transform", `translate(0,${o / 2 + 7})`) : u.attr("transform", `translate(0,${o / 2 + 7})`), e.height;
}, "drawActorTypeBoundary"), Trt = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = n ? e.stopy : e.starty, a = e.x + e.width / 2, s = i + 80, o = t.append("g").lower();
  n || (cr++, o.append("line").attr("id", "actor" + cr).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", e.name), e.actorCnt = cr);
  const l = t.append("g");
  let u = Nc;
  n ? u += ` ${iu}` : u += ` ${nu}`, l.attr("class", u), l.attr("name", e.name);
  const h = Oa();
  h.x = e.x, h.y = i, h.fill = "#eaeaea", h.width = e.width, h.height = e.height, h.class = "actor", h.rx = 3, h.ry = 3, l.append("line").attr("id", "actor-man-torso" + cr).attr("x1", a).attr("y1", i + 25).attr("x2", a).attr("y2", i + 45), l.append("line").attr("id", "actor-man-arms" + cr).attr("x1", a - Pu / 2).attr("y1", i + 33).attr("x2", a + Pu / 2).attr("y2", i + 33), l.append("line").attr("x1", a - Pu / 2).attr("y1", i + 60).attr("x2", a).attr("y2", i + 45), l.append("line").attr("x1", a).attr("y1", i + 45).attr("x2", a + Pu / 2 - 2).attr("y2", i + 60);
  const f = l.append("circle");
  f.attr("cx", e.x + e.width / 2), f.attr("cy", i + 10), f.attr("r", 15), f.attr("width", e.width), f.attr("height", e.height);
  const d = l.node().getBBox();
  return e.height = d.height, Bl(r, dn(e.description))(
    e.description,
    l,
    h.x,
    h.y + 35,
    h.width,
    h.height,
    { class: `actor ${Nc}` },
    r
  ), e.height;
}, "drawActorTypeActor"), Ert = /* @__PURE__ */ w(async function(t, e, r, n) {
  switch (e.type) {
    case "actor":
      return await Trt(t, e, r, n);
    case "participant":
      return await grt(t, e, r, n);
    case "boundary":
      return await wrt(t, e, r, n);
    case "control":
      return await yrt(t, e, r, n);
    case "entity":
      return await brt(t, e, r, n);
    case "database":
      return await xrt(t, e, r, n);
    case "collections":
      return await mrt(t, e, r, n);
    case "queue":
      return await vrt(t, e, r, n);
  }
}, "drawActor"), Srt = /* @__PURE__ */ w(function(t, e, r) {
  const i = t.append("g");
  Ice(i, e), e.name && Bl(r)(
    e.name,
    i,
    e.x,
    e.y + r.boxTextMargin + (e.textMaxHeight || 0) / 2,
    e.width,
    0,
    { class: "text" },
    r
  ), i.lower();
}, "drawBox"), krt = /* @__PURE__ */ w(function(t) {
  return t.append("g");
}, "anchorElement"), Crt = /* @__PURE__ */ w(function(t, e, r, n, i) {
  const a = Oa(), s = e.anchored;
  a.x = e.startx, a.y = e.starty, a.class = "activation" + i % 3, a.width = e.stopx - e.startx, a.height = r - e.starty, H1(s, a);
}, "drawActivation"), _rt = /* @__PURE__ */ w(async function(t, e, r, n) {
  const {
    boxMargin: i,
    boxTextMargin: a,
    labelBoxHeight: s,
    labelBoxWidth: o,
    messageFontFamily: l,
    messageFontSize: u,
    messageFontWeight: h
  } = n, f = t.append("g"), d = /* @__PURE__ */ w(function(m, v, y, b) {
    return f.append("line").attr("x1", m).attr("y1", v).attr("x2", y).attr("y2", b).attr("class", "loopLine");
  }, "drawLoopLine");
  d(e.startx, e.starty, e.stopx, e.starty), d(e.stopx, e.starty, e.stopx, e.stopy), d(e.startx, e.stopy, e.stopx, e.stopy), d(e.startx, e.starty, e.startx, e.stopy), e.sections !== void 0 && e.sections.forEach(function(m) {
    d(e.startx, m.y, e.stopx, m.y).style(
      "stroke-dasharray",
      "3, 3"
    );
  });
  let p = zR();
  p.text = r, p.x = e.startx, p.y = e.starty, p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.width = o || 50, p.height = s || 20, p.textMargin = a, p.class = "labelText", Lce(f, p), p = Mce(), p.text = e.title, p.x = e.startx + o / 2 + (e.stopx - e.startx) / 2, p.y = e.starty + i + a, p.anchor = "middle", p.valign = "middle", p.textMargin = a, p.class = "loopText", p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.wrap = !0;
  let g = dn(p.text) ? await kx(f, p, e) : T0(f, p);
  if (e.sectionTitles !== void 0) {
    for (const [m, v] of Object.entries(e.sectionTitles))
      if (v.message) {
        p.text = v.message, p.x = e.startx + (e.stopx - e.startx) / 2, p.y = e.sections[m].y + i + a, p.class = "loopText", p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.wrap = e.wrap, dn(p.text) ? (e.starty = e.sections[m].y, await kx(f, p, e)) : T0(f, p);
        let y = Math.round(
          g.map((b) => (b._groups || b)[0][0].getBBox().height).reduce((b, x) => b + x)
        );
        e.sections[m].height += y - (i + a);
      }
  }
  return e.height = Math.round(e.stopy - e.starty), f;
}, "drawLoop"), Ice = /* @__PURE__ */ w(function(t, e) {
  Aae(t, e);
}, "drawBackgroundRect"), Art = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, "insertDatabaseIcon"), Lrt = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, "insertComputerIcon"), Rrt = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, "insertClockIcon"), Irt = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 7.9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto-start-reverse").append("path").attr("d", "M -1 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), Mrt = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "filled-head").attr("refX", 15.5).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), Nrt = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, "insertSequenceNumber"), Drt = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 4).attr("refY", 4.5).append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1pt").attr("d", "M 1,2 L 6,7 M 6,2 L 1,7");
}, "insertArrowCrossHead"), Mce = /* @__PURE__ */ w(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: !0,
    valign: void 0
  };
}, "getTextObj"), Ort = /* @__PURE__ */ w(function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, "getNoteRect"), Bl = /* @__PURE__ */ (function() {
  function t(a, s, o, l, u, h, f) {
    const d = s.append("text").attr("x", o + u / 2).attr("y", l + h / 2 + 5).style("text-anchor", "middle").text(a);
    i(d, f);
  }
  w(t, "byText");
  function e(a, s, o, l, u, h, f, d) {
    const { actorFontSize: p, actorFontFamily: g, actorFontWeight: m } = d, [v, y] = Sh(p), b = a.split(at.lineBreakRegex);
    for (let x = 0; x < b.length; x++) {
      const T = x * v - v * (b.length - 1) / 2, E = s.append("text").attr("x", o + u / 2).attr("y", l).style("text-anchor", "middle").style("font-size", y).style("font-weight", m).style("font-family", g);
      E.append("tspan").attr("x", o + u / 2).attr("dy", T).text(b[x]), E.attr("y", l + h / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(E, f);
    }
  }
  w(e, "byTspan");
  function r(a, s, o, l, u, h, f, d) {
    const p = s.append("switch"), m = p.append("foreignObject").attr("x", o).attr("y", l).attr("width", u).attr("height", h).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    m.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(a), e(a, p, o, l, u, h, f, d), i(m, f);
  }
  w(r, "byFo");
  async function n(a, s, o, l, u, h, f, d) {
    const p = await K1(a, mr()), g = s.append("switch"), v = g.append("foreignObject").attr("x", o + u / 2 - p.width / 2).attr("y", l + h / 2 - p.height / 2).attr("width", p.width).attr("height", p.height).append("xhtml:div").style("height", "100%").style("width", "100%");
    v.append("div").style("text-align", "center").style("vertical-align", "middle").html(await Z1(a, mr())), e(a, g, o, l, u, h, f, d), i(v, f);
  }
  w(n, "byKatex");
  function i(a, s) {
    for (const o in s)
      s.hasOwnProperty(o) && a.attr(o, s[o]);
  }
  return w(i, "_setTextAttrs"), function(a, s = !1) {
    return s ? n : a.textPlacement === "fo" ? r : a.textPlacement === "old" ? t : e;
  };
})(), Prt = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h) {
    const f = a.append("text").attr("x", s).attr("y", o).style("text-anchor", "start").text(i);
    n(f, h);
  }
  w(t, "byText");
  function e(i, a, s, o, l, u, h, f) {
    const { actorFontSize: d, actorFontFamily: p, actorFontWeight: g } = f, m = i.split(at.lineBreakRegex);
    for (let v = 0; v < m.length; v++) {
      const y = v * d - d * (m.length - 1) / 2, b = a.append("text").attr("x", s).attr("y", o).style("text-anchor", "start").style("font-size", d).style("font-weight", g).style("font-family", p);
      b.append("tspan").attr("x", s).attr("dy", y).text(m[v]), b.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(b, h);
    }
  }
  w(e, "byTspan");
  function r(i, a, s, o, l, u, h, f) {
    const d = a.append("switch"), g = d.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, s, o, l, u, h, f), n(g, h);
  }
  w(r, "byFo");
  function n(i, a) {
    for (const s in a)
      a.hasOwnProperty(s) && i.attr(s, a[s]);
  }
  return w(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), mn = {
  drawRect: H1,
  drawText: T0,
  drawLabel: Lce,
  drawActor: Ert,
  drawBox: Srt,
  drawPopup: prt,
  anchorElement: krt,
  drawActivation: Crt,
  drawLoop: _rt,
  drawBackgroundRect: Ice,
  insertArrowHead: Irt,
  insertArrowFilledHead: Mrt,
  insertSequenceNumber: Nrt,
  insertArrowCrossHead: Drt,
  insertDatabaseIcon: Art,
  insertComputerIcon: Lrt,
  insertClockIcon: Rrt,
  getTextObj: Mce,
  getNoteRect: Ort,
  fixLifeLineHeights: Rce,
  sanitizeUrl: yh.sanitizeUrl
}, Re = {}, et = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: /* @__PURE__ */ w(function() {
      return Math.max.apply(
        null,
        this.actors.length === 0 ? [0] : this.actors.map((t) => t.height || 0)
      ) + (this.loops.length === 0 ? 0 : this.loops.map((t) => t.height || 0).reduce((t, e) => t + e)) + (this.messages.length === 0 ? 0 : this.messages.map((t) => t.height || 0).reduce((t, e) => t + e)) + (this.notes.length === 0 ? 0 : this.notes.map((t) => t.height || 0).reduce((t, e) => t + e));
    }, "getHeight"),
    clear: /* @__PURE__ */ w(function() {
      this.actors = [], this.boxes = [], this.loops = [], this.messages = [], this.notes = [];
    }, "clear"),
    addBox: /* @__PURE__ */ w(function(t) {
      this.boxes.push(t);
    }, "addBox"),
    addActor: /* @__PURE__ */ w(function(t) {
      this.actors.push(t);
    }, "addActor"),
    addLoop: /* @__PURE__ */ w(function(t) {
      this.loops.push(t);
    }, "addLoop"),
    addMessage: /* @__PURE__ */ w(function(t) {
      this.messages.push(t);
    }, "addMessage"),
    addNote: /* @__PURE__ */ w(function(t) {
      this.notes.push(t);
    }, "addNote"),
    lastActor: /* @__PURE__ */ w(function() {
      return this.actors[this.actors.length - 1];
    }, "lastActor"),
    lastLoop: /* @__PURE__ */ w(function() {
      return this.loops[this.loops.length - 1];
    }, "lastLoop"),
    lastMessage: /* @__PURE__ */ w(function() {
      return this.messages[this.messages.length - 1];
    }, "lastMessage"),
    lastNote: /* @__PURE__ */ w(function() {
      return this.notes[this.notes.length - 1];
    }, "lastNote"),
    actors: [],
    boxes: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: /* @__PURE__ */ w(function() {
    this.sequenceItems = [], this.activations = [], this.models.clear(), this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0, Oce(Te());
  }, "init"),
  updateVal: /* @__PURE__ */ w(function(t, e, r, n) {
    t[e] === void 0 ? t[e] = r : t[e] = n(r, t[e]);
  }, "updateVal"),
  updateBounds: /* @__PURE__ */ w(function(t, e, r, n) {
    const i = this;
    let a = 0;
    function s(o) {
      return /* @__PURE__ */ w(function(u) {
        a++;
        const h = i.sequenceItems.length - a + 1;
        i.updateVal(u, "starty", e - h * Re.boxMargin, Math.min), i.updateVal(u, "stopy", n + h * Re.boxMargin, Math.max), i.updateVal(et.data, "startx", t - h * Re.boxMargin, Math.min), i.updateVal(et.data, "stopx", r + h * Re.boxMargin, Math.max), o !== "activation" && (i.updateVal(u, "startx", t - h * Re.boxMargin, Math.min), i.updateVal(u, "stopx", r + h * Re.boxMargin, Math.max), i.updateVal(et.data, "starty", e - h * Re.boxMargin, Math.min), i.updateVal(et.data, "stopy", n + h * Re.boxMargin, Math.max));
      }, "updateItemBounds");
    }
    w(s, "updateFn"), this.sequenceItems.forEach(s()), this.activations.forEach(s("activation"));
  }, "updateBounds"),
  insert: /* @__PURE__ */ w(function(t, e, r, n) {
    const i = at.getMin(t, r), a = at.getMax(t, r), s = at.getMin(e, n), o = at.getMax(e, n);
    this.updateVal(et.data, "startx", i, Math.min), this.updateVal(et.data, "starty", s, Math.min), this.updateVal(et.data, "stopx", a, Math.max), this.updateVal(et.data, "stopy", o, Math.max), this.updateBounds(i, s, a, o);
  }, "insert"),
  newActivation: /* @__PURE__ */ w(function(t, e, r) {
    const n = r.get(t.from), i = e5(t.from).length || 0, a = n.x + n.width / 2 + (i - 1) * Re.activationWidth / 2;
    this.activations.push({
      startx: a,
      starty: this.verticalPos + 2,
      stopx: a + Re.activationWidth,
      stopy: void 0,
      actor: t.from,
      anchored: mn.anchorElement(e)
    });
  }, "newActivation"),
  endActivation: /* @__PURE__ */ w(function(t) {
    const e = this.activations.map(function(r) {
      return r.actor;
    }).lastIndexOf(t.from);
    return this.activations.splice(e, 1)[0];
  }, "endActivation"),
  createLoop: /* @__PURE__ */ w(function(t = { message: void 0, wrap: !1, width: void 0 }, e) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: t.message,
      wrap: t.wrap,
      width: t.width,
      height: 0,
      fill: e
    };
  }, "createLoop"),
  newLoop: /* @__PURE__ */ w(function(t = { message: void 0, wrap: !1, width: void 0 }, e) {
    this.sequenceItems.push(this.createLoop(t, e));
  }, "newLoop"),
  endLoop: /* @__PURE__ */ w(function() {
    return this.sequenceItems.pop();
  }, "endLoop"),
  isLoopOverlap: /* @__PURE__ */ w(function() {
    return this.sequenceItems.length ? this.sequenceItems[this.sequenceItems.length - 1].overlap : !1;
  }, "isLoopOverlap"),
  addSectionToLoop: /* @__PURE__ */ w(function(t) {
    const e = this.sequenceItems.pop();
    e.sections = e.sections || [], e.sectionTitles = e.sectionTitles || [], e.sections.push({ y: et.getVerticalPos(), height: 0 }), e.sectionTitles.push(t), this.sequenceItems.push(e);
  }, "addSectionToLoop"),
  saveVerticalPos: /* @__PURE__ */ w(function() {
    this.isLoopOverlap() && (this.savedVerticalPos = this.verticalPos);
  }, "saveVerticalPos"),
  resetVerticalPos: /* @__PURE__ */ w(function() {
    this.isLoopOverlap() && (this.verticalPos = this.savedVerticalPos);
  }, "resetVerticalPos"),
  bumpVerticalPos: /* @__PURE__ */ w(function(t) {
    this.verticalPos = this.verticalPos + t, this.data.stopy = at.getMax(this.data.stopy, this.verticalPos);
  }, "bumpVerticalPos"),
  getVerticalPos: /* @__PURE__ */ w(function() {
    return this.verticalPos;
  }, "getVerticalPos"),
  getBounds: /* @__PURE__ */ w(function() {
    return { bounds: this.data, models: this.models };
  }, "getBounds")
}, $rt = /* @__PURE__ */ w(async function(t, e) {
  et.bumpVerticalPos(Re.boxMargin), e.height = Re.boxMargin, e.starty = et.getVerticalPos();
  const r = Oa();
  r.x = e.startx, r.y = e.starty, r.width = e.width || Re.width, r.class = "note";
  const n = t.append("g"), i = mn.drawRect(n, r), a = zR();
  a.x = e.startx, a.y = e.starty, a.width = r.width, a.dy = "1em", a.text = e.message, a.class = "noteText", a.fontFamily = Re.noteFontFamily, a.fontSize = Re.noteFontSize, a.fontWeight = Re.noteFontWeight, a.anchor = Re.noteAlign, a.textMargin = Re.noteMargin, a.valign = "center";
  const s = dn(a.text) ? await kx(n, a) : T0(n, a), o = Math.round(
    s.map((l) => (l._groups || l)[0][0].getBBox().height).reduce((l, u) => l + u)
  );
  i.attr("height", o + 2 * Re.noteMargin), e.height += o + 2 * Re.noteMargin, et.bumpVerticalPos(o + 2 * Re.noteMargin), e.stopy = e.starty + o + 2 * Re.noteMargin, e.stopx = e.startx + r.width, et.insert(e.startx, e.starty, e.stopx, e.stopy), et.models.addNote(e);
}, "drawNote"), ph = /* @__PURE__ */ w((t) => ({
  fontFamily: t.messageFontFamily,
  fontSize: t.messageFontSize,
  fontWeight: t.messageFontWeight
}), "messageFont"), vf = /* @__PURE__ */ w((t) => ({
  fontFamily: t.noteFontFamily,
  fontSize: t.noteFontSize,
  fontWeight: t.noteFontWeight
}), "noteFont"), q8 = /* @__PURE__ */ w((t) => ({
  fontFamily: t.actorFontFamily,
  fontSize: t.actorFontSize,
  fontWeight: t.actorFontWeight
}), "actorFont");
async function Nce(t, e) {
  et.bumpVerticalPos(10);
  const { startx: r, stopx: n, message: i } = e, a = at.splitBreaks(i).length, s = dn(i), o = s ? await K1(i, Te()) : Jt.calculateTextDimensions(i, ph(Re));
  if (!s) {
    const f = o.height / a;
    e.height += f, et.bumpVerticalPos(f);
  }
  let l, u = o.height - 10;
  const h = o.width;
  if (r === n) {
    l = et.getVerticalPos() + u, Re.rightAngles || (u += Re.boxMargin, l = et.getVerticalPos() + u), u += 30;
    const f = at.getMax(h / 2, Re.width / 2);
    et.insert(
      r - f,
      et.getVerticalPos() - 10 + u,
      n + f,
      et.getVerticalPos() + 30 + u
    );
  } else
    u += Re.boxMargin, l = et.getVerticalPos() + u, et.insert(r, l - 10, n, l);
  return et.bumpVerticalPos(u), e.height += u, e.stopy = e.starty + e.height, et.insert(e.fromBounds, e.starty, e.toBounds, e.stopy), l;
}
w(Nce, "boundMessage");
var Brt = /* @__PURE__ */ w(async function(t, e, r, n) {
  const { startx: i, stopx: a, starty: s, message: o, type: l, sequenceIndex: u, sequenceVisible: h } = e, f = Jt.calculateTextDimensions(o, ph(Re)), d = zR();
  d.x = i, d.y = s + 10, d.width = a - i, d.class = "messageText", d.dy = "1em", d.text = o, d.fontFamily = Re.messageFontFamily, d.fontSize = Re.messageFontSize, d.fontWeight = Re.messageFontWeight, d.anchor = Re.messageAlign, d.valign = "center", d.textMargin = Re.wrapPadding, d.tspan = !1, dn(d.text) ? await kx(t, d, { startx: i, stopx: a, starty: r }) : T0(t, d);
  const p = f.width;
  let g;
  i === a ? Re.rightAngles ? g = t.append("path").attr(
    "d",
    `M  ${i},${r} H ${i + at.getMax(Re.width / 2, p / 2)} V ${r + 25} H ${i}`
  ) : g = t.append("path").attr(
    "d",
    "M " + i + "," + r + " C " + (i + 60) + "," + (r - 10) + " " + (i + 60) + "," + (r + 30) + " " + i + "," + (r + 20)
  ) : (g = t.append("line"), g.attr("x1", i), g.attr("y1", r), g.attr("x2", a), g.attr("y2", r)), l === n.db.LINETYPE.DOTTED || l === n.db.LINETYPE.DOTTED_CROSS || l === n.db.LINETYPE.DOTTED_POINT || l === n.db.LINETYPE.DOTTED_OPEN || l === n.db.LINETYPE.BIDIRECTIONAL_DOTTED ? (g.style("stroke-dasharray", "3, 3"), g.attr("class", "messageLine1")) : g.attr("class", "messageLine0");
  let m = "";
  Re.arrowMarkerAbsolute && (m = Bx(!0)), g.attr("stroke-width", 2), g.attr("stroke", "none"), g.style("fill", "none"), (l === n.db.LINETYPE.SOLID || l === n.db.LINETYPE.DOTTED) && g.attr("marker-end", "url(" + m + "#arrowhead)"), (l === n.db.LINETYPE.BIDIRECTIONAL_SOLID || l === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (g.attr("marker-start", "url(" + m + "#arrowhead)"), g.attr("marker-end", "url(" + m + "#arrowhead)")), (l === n.db.LINETYPE.SOLID_POINT || l === n.db.LINETYPE.DOTTED_POINT) && g.attr("marker-end", "url(" + m + "#filled-head)"), (l === n.db.LINETYPE.SOLID_CROSS || l === n.db.LINETYPE.DOTTED_CROSS) && g.attr("marker-end", "url(" + m + "#crosshead)"), (h || Re.showSequenceNumbers) && ((l === n.db.LINETYPE.BIDIRECTIONAL_SOLID || l === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (i < a ? g.attr("x1", i + 12) : g.attr("x1", i + 6)), t.append("line").attr("x1", i).attr("y1", r).attr("x2", i).attr("y2", r).attr("stroke-width", 0).attr("marker-start", "url(" + m + "#sequencenumber)"), t.append("text").attr("x", i).attr("y", r + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(u));
}, "drawMessage"), Frt = /* @__PURE__ */ w(function(t, e, r, n, i, a, s) {
  let o = 0, l = 0, u, h = 0;
  for (const f of n) {
    const d = e.get(f), p = d.box;
    u && u != p && (s || et.models.addBox(u), l += Re.boxMargin + u.margin), p && p != u && (s || (p.x = o + l, p.y = i), l += p.margin), d.width = d.width || Re.width, d.height = at.getMax(d.height || Re.height, Re.height), d.margin = d.margin || Re.actorMargin, h = at.getMax(h, d.height), r.get(d.name) && (l += d.width / 2), d.x = o + l, d.starty = et.getVerticalPos(), et.insert(d.x, i, d.x + d.width, d.height), o += d.width + l, d.box && (d.box.width = o + p.margin - d.box.x), l = d.margin, u = d.box, et.models.addActor(d);
  }
  u && !s && et.models.addBox(u), et.bumpVerticalPos(h);
}, "addActorRenderingData"), G8 = /* @__PURE__ */ w(async function(t, e, r, n) {
  if (n) {
    let i = 0;
    et.bumpVerticalPos(Re.boxMargin * 2);
    for (const a of r) {
      const s = e.get(a);
      s.stopy || (s.stopy = et.getVerticalPos());
      const o = await mn.drawActor(t, s, Re, !0);
      i = at.getMax(i, o);
    }
    et.bumpVerticalPos(i + Re.boxMargin);
  } else
    for (const i of r) {
      const a = e.get(i);
      await mn.drawActor(t, a, Re, !1);
    }
}, "drawActors"), Dce = /* @__PURE__ */ w(function(t, e, r, n) {
  let i = 0, a = 0;
  for (const s of r) {
    const o = e.get(s), l = qrt(o), u = mn.drawPopup(
      t,
      o,
      l,
      Re,
      Re.forceMenus,
      n
    );
    u.height > i && (i = u.height), u.width + o.x > a && (a = u.width + o.x);
  }
  return { maxHeight: i, maxWidth: a };
}, "drawActorsPopup"), Oce = /* @__PURE__ */ w(function(t) {
  bn(Re, t), t.fontFamily && (Re.actorFontFamily = Re.noteFontFamily = Re.messageFontFamily = t.fontFamily), t.fontSize && (Re.actorFontSize = Re.noteFontSize = Re.messageFontSize = t.fontSize), t.fontWeight && (Re.actorFontWeight = Re.noteFontWeight = Re.messageFontWeight = t.fontWeight);
}, "setConf"), e5 = /* @__PURE__ */ w(function(t) {
  return et.activations.filter(function(e) {
    return e.actor === t;
  });
}, "actorActivations"), KW = /* @__PURE__ */ w(function(t, e) {
  const r = e.get(t), n = e5(t), i = n.reduce(
    function(s, o) {
      return at.getMin(s, o.startx);
    },
    r.x + r.width / 2 - 1
  ), a = n.reduce(
    function(s, o) {
      return at.getMax(s, o.stopx);
    },
    r.x + r.width / 2 + 1
  );
  return [i, a];
}, "activationBounds");
function ps(t, e, r, n, i) {
  et.bumpVerticalPos(r);
  let a = n;
  if (e.id && e.message && t[e.id]) {
    const s = t[e.id].width, o = ph(Re);
    e.message = Jt.wrapLabel(`[${e.message}]`, s - 2 * Re.wrapPadding, o), e.width = s, e.wrap = !0;
    const l = Jt.calculateTextDimensions(e.message, o), u = at.getMax(l.height, Re.labelBoxHeight);
    a = n + u, ae.debug(`${u} - ${e.message}`);
  }
  i(e), et.bumpVerticalPos(a);
}
w(ps, "adjustLoopHeightForWrap");
function Pce(t, e, r, n, i, a, s) {
  function o(h, f) {
    h.x < i.get(t.from).x ? (et.insert(
      e.stopx - f,
      e.starty,
      e.startx,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.stopx = e.stopx + f) : (et.insert(
      e.startx,
      e.starty,
      e.stopx + f,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.stopx = e.stopx - f);
  }
  w(o, "receiverAdjustment");
  function l(h, f) {
    h.x < i.get(t.to).x ? (et.insert(
      e.startx - f,
      e.starty,
      e.stopx,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.startx = e.startx + f) : (et.insert(
      e.stopx,
      e.starty,
      e.startx + f,
      e.stopy + h.height / 2 + Re.noteMargin
    ), e.startx = e.startx - f);
  }
  w(l, "senderAdjustment");
  const u = [
    uy.ACTOR,
    uy.CONTROL,
    uy.ENTITY,
    uy.DATABASE
  ];
  if (a.get(t.to) == n) {
    const h = i.get(t.to), f = u.includes(h.type) ? Pu / 2 + 3 : h.width / 2 + 3;
    o(h, f), h.starty = r - h.height / 2, et.bumpVerticalPos(h.height / 2);
  } else if (s.get(t.from) == n) {
    const h = i.get(t.from);
    if (Re.mirrorActors) {
      const f = u.includes(h.type) ? Pu / 2 : h.width / 2;
      l(h, f);
    }
    h.stopy = r - h.height / 2, et.bumpVerticalPos(h.height / 2);
  } else if (s.get(t.to) == n) {
    const h = i.get(t.to);
    if (Re.mirrorActors) {
      const f = u.includes(h.type) ? Pu / 2 + 3 : h.width / 2 + 3;
      o(h, f);
    }
    h.stopy = r - h.height / 2, et.bumpVerticalPos(h.height / 2);
  }
}
w(Pce, "adjustCreatedDestroyedData");
var zrt = /* @__PURE__ */ w(async function(t, e, r, n) {
  const { securityLevel: i, sequence: a } = Te();
  Re = a;
  let s;
  i === "sandbox" && (s = Qe("#i" + e));
  const o = Qe(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body"), l = i === "sandbox" ? s.nodes()[0].contentDocument : document;
  et.init(), ae.debug(n.db);
  const u = i === "sandbox" ? o.select(`[id="${e}"]`) : Qe(`[id="${e}"]`), h = n.db.getActors(), f = n.db.getCreatedActors(), d = n.db.getDestroyedActors(), p = n.db.getBoxes();
  let g = n.db.getActorKeys();
  const m = n.db.getMessages(), v = n.db.getDiagramTitle(), y = n.db.hasAtLeastOneBox(), b = n.db.hasAtLeastOneBoxWithTitle(), x = await $ce(h, m, n);
  if (Re.height = await Bce(h, x, p), mn.insertComputerIcon(u), mn.insertDatabaseIcon(u), mn.insertClockIcon(u), y && (et.bumpVerticalPos(Re.boxMargin), b && et.bumpVerticalPos(p[0].textMaxHeight)), Re.hideUnusedParticipants === !0) {
    const D = /* @__PURE__ */ new Set();
    m.forEach(($) => {
      D.add($.from), D.add($.to);
    }), g = g.filter(($) => D.has($));
  }
  Frt(u, h, f, g, 0, m, !1);
  const T = await Vrt(m, h, x, n);
  mn.insertArrowHead(u), mn.insertArrowCrossHead(u), mn.insertArrowFilledHead(u), mn.insertSequenceNumber(u);
  function E(D, $) {
    const z = et.endActivation(D);
    z.starty + 18 > $ && (z.starty = $ - 6, $ += 12), mn.drawActivation(
      u,
      z,
      $,
      Re,
      e5(D.from).length
    ), et.insert(z.startx, $ - 10, z.stopx, $);
  }
  w(E, "activeEnd");
  let A = 1, S = 1;
  const k = [], _ = [];
  let R = 0;
  for (const D of m) {
    let $, z, B;
    switch (D.type) {
      case n.db.LINETYPE.NOTE:
        et.resetVerticalPos(), z = D.noteModel, await $rt(u, z);
        break;
      case n.db.LINETYPE.ACTIVE_START:
        et.newActivation(D, u, h);
        break;
      case n.db.LINETYPE.ACTIVE_END:
        E(D, et.getVerticalPos());
        break;
      case n.db.LINETYPE.LOOP_START:
        ps(
          T,
          D,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (G) => et.newLoop(G)
        );
        break;
      case n.db.LINETYPE.LOOP_END:
        $ = et.endLoop(), await mn.drawLoop(u, $, "loop", Re), et.bumpVerticalPos($.stopy - et.getVerticalPos()), et.models.addLoop($);
        break;
      case n.db.LINETYPE.RECT_START:
        ps(
          T,
          D,
          Re.boxMargin,
          Re.boxMargin,
          (G) => et.newLoop(void 0, G.message)
        );
        break;
      case n.db.LINETYPE.RECT_END:
        $ = et.endLoop(), _.push($), et.models.addLoop($), et.bumpVerticalPos($.stopy - et.getVerticalPos());
        break;
      case n.db.LINETYPE.OPT_START:
        ps(
          T,
          D,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (G) => et.newLoop(G)
        );
        break;
      case n.db.LINETYPE.OPT_END:
        $ = et.endLoop(), await mn.drawLoop(u, $, "opt", Re), et.bumpVerticalPos($.stopy - et.getVerticalPos()), et.models.addLoop($);
        break;
      case n.db.LINETYPE.ALT_START:
        ps(
          T,
          D,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (G) => et.newLoop(G)
        );
        break;
      case n.db.LINETYPE.ALT_ELSE:
        ps(
          T,
          D,
          Re.boxMargin + Re.boxTextMargin,
          Re.boxMargin,
          (G) => et.addSectionToLoop(G)
        );
        break;
      case n.db.LINETYPE.ALT_END:
        $ = et.endLoop(), await mn.drawLoop(u, $, "alt", Re), et.bumpVerticalPos($.stopy - et.getVerticalPos()), et.models.addLoop($);
        break;
      case n.db.LINETYPE.PAR_START:
      case n.db.LINETYPE.PAR_OVER_START:
        ps(
          T,
          D,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (G) => et.newLoop(G)
        ), et.saveVerticalPos();
        break;
      case n.db.LINETYPE.PAR_AND:
        ps(
          T,
          D,
          Re.boxMargin + Re.boxTextMargin,
          Re.boxMargin,
          (G) => et.addSectionToLoop(G)
        );
        break;
      case n.db.LINETYPE.PAR_END:
        $ = et.endLoop(), await mn.drawLoop(u, $, "par", Re), et.bumpVerticalPos($.stopy - et.getVerticalPos()), et.models.addLoop($);
        break;
      case n.db.LINETYPE.AUTONUMBER:
        A = D.message.start || A, S = D.message.step || S, D.message.visible ? n.db.enableSequenceNumbers() : n.db.disableSequenceNumbers();
        break;
      case n.db.LINETYPE.CRITICAL_START:
        ps(
          T,
          D,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (G) => et.newLoop(G)
        );
        break;
      case n.db.LINETYPE.CRITICAL_OPTION:
        ps(
          T,
          D,
          Re.boxMargin + Re.boxTextMargin,
          Re.boxMargin,
          (G) => et.addSectionToLoop(G)
        );
        break;
      case n.db.LINETYPE.CRITICAL_END:
        $ = et.endLoop(), await mn.drawLoop(u, $, "critical", Re), et.bumpVerticalPos($.stopy - et.getVerticalPos()), et.models.addLoop($);
        break;
      case n.db.LINETYPE.BREAK_START:
        ps(
          T,
          D,
          Re.boxMargin,
          Re.boxMargin + Re.boxTextMargin,
          (G) => et.newLoop(G)
        );
        break;
      case n.db.LINETYPE.BREAK_END:
        $ = et.endLoop(), await mn.drawLoop(u, $, "break", Re), et.bumpVerticalPos($.stopy - et.getVerticalPos()), et.models.addLoop($);
        break;
      default:
        try {
          B = D.msgModel, B.starty = et.getVerticalPos(), B.sequenceIndex = A, B.sequenceVisible = n.db.showSequenceNumbers();
          const G = await Nce(u, B);
          Pce(
            D,
            B,
            G,
            R,
            h,
            f,
            d
          ), k.push({ messageModel: B, lineStartY: G }), et.models.addMessage(B);
        } catch (G) {
          ae.error("error while drawing message", G);
        }
    }
    [
      n.db.LINETYPE.SOLID_OPEN,
      n.db.LINETYPE.DOTTED_OPEN,
      n.db.LINETYPE.SOLID,
      n.db.LINETYPE.DOTTED,
      n.db.LINETYPE.SOLID_CROSS,
      n.db.LINETYPE.DOTTED_CROSS,
      n.db.LINETYPE.SOLID_POINT,
      n.db.LINETYPE.DOTTED_POINT,
      n.db.LINETYPE.BIDIRECTIONAL_SOLID,
      n.db.LINETYPE.BIDIRECTIONAL_DOTTED
    ].includes(D.type) && (A = A + S), R++;
  }
  ae.debug("createdActors", f), ae.debug("destroyedActors", d), await G8(u, h, g, !1);
  for (const D of k)
    await Brt(u, D.messageModel, D.lineStartY, n);
  Re.mirrorActors && await G8(u, h, g, !0), _.forEach((D) => mn.drawBackgroundRect(u, D)), Rce(u, h, g, Re);
  for (const D of et.models.boxes) {
    D.height = et.getVerticalPos() - D.y, et.insert(D.x, D.y, D.x + D.width, D.height);
    const $ = Re.boxMargin * 2;
    D.startx = D.x - $, D.starty = D.y - $ * 0.25, D.stopx = D.startx + D.width + 2 * $, D.stopy = D.starty + D.height + $ * 0.75, D.stroke = "rgb(0,0,0, 0.5)", mn.drawBox(u, D, Re);
  }
  y && et.bumpVerticalPos(Re.boxMargin);
  const L = Dce(u, h, g, l), { bounds: M } = et.getBounds();
  M.startx === void 0 && (M.startx = 0), M.starty === void 0 && (M.starty = 0), M.stopx === void 0 && (M.stopx = 0), M.stopy === void 0 && (M.stopy = 0);
  let P = M.stopy - M.starty;
  P < L.maxHeight && (P = L.maxHeight);
  let C = P + 2 * Re.diagramMarginY;
  Re.mirrorActors && (C = C - Re.boxMargin + Re.bottomMarginAdj);
  let I = M.stopx - M.startx;
  I < L.maxWidth && (I = L.maxWidth);
  const N = I + 2 * Re.diagramMarginX;
  v && u.append("text").text(v).attr("x", (M.stopx - M.startx) / 2 - 2 * Re.diagramMarginX).attr("y", -25), Qi(u, C, N, Re.useMaxWidth);
  const O = v ? 40 : 0;
  u.attr(
    "viewBox",
    M.startx - Re.diagramMarginX + " -" + (Re.diagramMarginY + O) + " " + N + " " + (C + O)
  ), ae.debug("models:", et.models);
}, "draw");
async function $ce(t, e, r) {
  const n = {};
  for (const i of e)
    if (t.get(i.to) && t.get(i.from)) {
      const a = t.get(i.to);
      if (i.placement === r.db.PLACEMENT.LEFTOF && !a.prevActor || i.placement === r.db.PLACEMENT.RIGHTOF && !a.nextActor)
        continue;
      const s = i.placement !== void 0, o = !s, l = s ? vf(Re) : ph(Re), u = i.wrap ? Jt.wrapLabel(i.message, Re.width - 2 * Re.wrapPadding, l) : i.message, f = (dn(u) ? await K1(i.message, Te()) : Jt.calculateTextDimensions(u, l)).width + 2 * Re.wrapPadding;
      o && i.from === a.nextActor ? n[i.to] = at.getMax(
        n[i.to] || 0,
        f
      ) : o && i.from === a.prevActor ? n[i.from] = at.getMax(
        n[i.from] || 0,
        f
      ) : o && i.from === i.to ? (n[i.from] = at.getMax(
        n[i.from] || 0,
        f / 2
      ), n[i.to] = at.getMax(
        n[i.to] || 0,
        f / 2
      )) : i.placement === r.db.PLACEMENT.RIGHTOF ? n[i.from] = at.getMax(
        n[i.from] || 0,
        f
      ) : i.placement === r.db.PLACEMENT.LEFTOF ? n[a.prevActor] = at.getMax(
        n[a.prevActor] || 0,
        f
      ) : i.placement === r.db.PLACEMENT.OVER && (a.prevActor && (n[a.prevActor] = at.getMax(
        n[a.prevActor] || 0,
        f / 2
      )), a.nextActor && (n[i.from] = at.getMax(
        n[i.from] || 0,
        f / 2
      )));
    }
  return ae.debug("maxMessageWidthPerActor:", n), n;
}
w($ce, "getMaxMessageWidthPerActor");
var qrt = /* @__PURE__ */ w(function(t) {
  let e = 0;
  const r = q8(Re);
  for (const n in t.links) {
    const a = Jt.calculateTextDimensions(n, r).width + 2 * Re.wrapPadding + 2 * Re.boxMargin;
    e < a && (e = a);
  }
  return e;
}, "getRequiredPopupWidth");
async function Bce(t, e, r) {
  let n = 0;
  for (const a of t.keys()) {
    const s = t.get(a);
    s.wrap && (s.description = Jt.wrapLabel(
      s.description,
      Re.width - 2 * Re.wrapPadding,
      q8(Re)
    ));
    const o = dn(s.description) ? await K1(s.description, Te()) : Jt.calculateTextDimensions(s.description, q8(Re));
    s.width = s.wrap ? Re.width : at.getMax(Re.width, o.width + 2 * Re.wrapPadding), s.height = s.wrap ? at.getMax(o.height, Re.height) : Re.height, n = at.getMax(n, s.height);
  }
  for (const a in e) {
    const s = t.get(a);
    if (!s)
      continue;
    const o = t.get(s.nextActor);
    if (!o) {
      const f = e[a] + Re.actorMargin - s.width / 2;
      s.margin = at.getMax(f, Re.actorMargin);
      continue;
    }
    const u = e[a] + Re.actorMargin - s.width / 2 - o.width / 2;
    s.margin = at.getMax(u, Re.actorMargin);
  }
  let i = 0;
  return r.forEach((a) => {
    const s = ph(Re);
    let o = a.actorKeys.reduce((f, d) => f += t.get(d).width + (t.get(d).margin || 0), 0);
    const l = Re.boxMargin * 8;
    o += l, o -= 2 * Re.boxTextMargin, a.wrap && (a.name = Jt.wrapLabel(a.name, o - 2 * Re.wrapPadding, s));
    const u = Jt.calculateTextDimensions(a.name, s);
    i = at.getMax(u.height, i);
    const h = at.getMax(o, u.width + 2 * Re.wrapPadding);
    if (a.margin = Re.boxTextMargin, o < h) {
      const f = (h - o) / 2;
      a.margin += f;
    }
  }), r.forEach((a) => a.textMaxHeight = i), at.getMax(n, Re.height);
}
w(Bce, "calculateActorMargins");
var Grt = /* @__PURE__ */ w(async function(t, e, r) {
  const n = e.get(t.from), i = e.get(t.to), a = n.x, s = i.x, o = t.wrap && t.message;
  let l = dn(t.message) ? await K1(t.message, Te()) : Jt.calculateTextDimensions(
    o ? Jt.wrapLabel(t.message, Re.width, vf(Re)) : t.message,
    vf(Re)
  );
  const u = {
    width: o ? Re.width : at.getMax(Re.width, l.width + 2 * Re.noteMargin),
    height: 0,
    startx: n.x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: t.message
  };
  return t.placement === r.db.PLACEMENT.RIGHTOF ? (u.width = o ? at.getMax(Re.width, l.width) : at.getMax(
    n.width / 2 + i.width / 2,
    l.width + 2 * Re.noteMargin
  ), u.startx = a + (n.width + Re.actorMargin) / 2) : t.placement === r.db.PLACEMENT.LEFTOF ? (u.width = o ? at.getMax(Re.width, l.width + 2 * Re.noteMargin) : at.getMax(
    n.width / 2 + i.width / 2,
    l.width + 2 * Re.noteMargin
  ), u.startx = a - u.width + (n.width - Re.actorMargin) / 2) : t.to === t.from ? (l = Jt.calculateTextDimensions(
    o ? Jt.wrapLabel(t.message, at.getMax(Re.width, n.width), vf(Re)) : t.message,
    vf(Re)
  ), u.width = o ? at.getMax(Re.width, n.width) : at.getMax(n.width, Re.width, l.width + 2 * Re.noteMargin), u.startx = a + (n.width - u.width) / 2) : (u.width = Math.abs(a + n.width / 2 - (s + i.width / 2)) + Re.actorMargin, u.startx = a < s ? a + n.width / 2 - Re.actorMargin / 2 : s + i.width / 2 - Re.actorMargin / 2), o && (u.message = Jt.wrapLabel(
    t.message,
    u.width - 2 * Re.wrapPadding,
    vf(Re)
  )), ae.debug(
    `NM:[${u.startx},${u.stopx},${u.starty},${u.stopy}:${u.width},${u.height}=${t.message}]`
  ), u;
}, "buildNoteModel"), Urt = /* @__PURE__ */ w(function(t, e, r) {
  if (![
    r.db.LINETYPE.SOLID_OPEN,
    r.db.LINETYPE.DOTTED_OPEN,
    r.db.LINETYPE.SOLID,
    r.db.LINETYPE.DOTTED,
    r.db.LINETYPE.SOLID_CROSS,
    r.db.LINETYPE.DOTTED_CROSS,
    r.db.LINETYPE.SOLID_POINT,
    r.db.LINETYPE.DOTTED_POINT,
    r.db.LINETYPE.BIDIRECTIONAL_SOLID,
    r.db.LINETYPE.BIDIRECTIONAL_DOTTED
  ].includes(t.type))
    return {};
  const [n, i] = KW(t.from, e), [a, s] = KW(t.to, e), o = n <= a;
  let l = o ? i : n, u = o ? a : s;
  const h = Math.abs(a - s) > 2, f = /* @__PURE__ */ w((m) => o ? -m : m, "adjustValue");
  t.from === t.to ? u = l : (t.activate && !h && (u += f(Re.activationWidth / 2 - 1)), [r.db.LINETYPE.SOLID_OPEN, r.db.LINETYPE.DOTTED_OPEN].includes(t.type) || (u += f(3)), [r.db.LINETYPE.BIDIRECTIONAL_SOLID, r.db.LINETYPE.BIDIRECTIONAL_DOTTED].includes(
    t.type
  ) && (l -= f(3)));
  const d = [n, i, a, s], p = Math.abs(l - u);
  t.wrap && t.message && (t.message = Jt.wrapLabel(
    t.message,
    at.getMax(p + 2 * Re.wrapPadding, Re.width),
    ph(Re)
  ));
  const g = Jt.calculateTextDimensions(t.message, ph(Re));
  return {
    width: at.getMax(
      t.wrap ? 0 : g.width + 2 * Re.wrapPadding,
      p + 2 * Re.wrapPadding,
      Re.width
    ),
    height: 0,
    startx: l,
    stopx: u,
    starty: 0,
    stopy: 0,
    message: t.message,
    type: t.type,
    wrap: t.wrap,
    fromBounds: Math.min.apply(null, d),
    toBounds: Math.max.apply(null, d)
  };
}, "buildMessageModel"), Vrt = /* @__PURE__ */ w(async function(t, e, r, n) {
  const i = {}, a = [];
  let s, o, l;
  for (const u of t) {
    switch (u.type) {
      case n.db.LINETYPE.LOOP_START:
      case n.db.LINETYPE.ALT_START:
      case n.db.LINETYPE.OPT_START:
      case n.db.LINETYPE.PAR_START:
      case n.db.LINETYPE.PAR_OVER_START:
      case n.db.LINETYPE.CRITICAL_START:
      case n.db.LINETYPE.BREAK_START:
        a.push({
          id: u.id,
          msg: u.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;
      case n.db.LINETYPE.ALT_ELSE:
      case n.db.LINETYPE.PAR_AND:
      case n.db.LINETYPE.CRITICAL_OPTION:
        u.message && (s = a.pop(), i[s.id] = s, i[u.id] = s, a.push(s));
        break;
      case n.db.LINETYPE.LOOP_END:
      case n.db.LINETYPE.ALT_END:
      case n.db.LINETYPE.OPT_END:
      case n.db.LINETYPE.PAR_END:
      case n.db.LINETYPE.CRITICAL_END:
      case n.db.LINETYPE.BREAK_END:
        s = a.pop(), i[s.id] = s;
        break;
      case n.db.LINETYPE.ACTIVE_START:
        {
          const f = e.get(u.from ? u.from : u.to.actor), d = e5(u.from ? u.from : u.to.actor).length, p = f.x + f.width / 2 + (d - 1) * Re.activationWidth / 2, g = {
            startx: p,
            stopx: p + Re.activationWidth,
            actor: u.from,
            enabled: !0
          };
          et.activations.push(g);
        }
        break;
      case n.db.LINETYPE.ACTIVE_END:
        {
          const f = et.activations.map((d) => d.actor).lastIndexOf(u.from);
          et.activations.splice(f, 1).splice(0, 1);
        }
        break;
    }
    u.placement !== void 0 ? (o = await Grt(u, e, n), u.noteModel = o, a.forEach((f) => {
      s = f, s.from = at.getMin(s.from, o.startx), s.to = at.getMax(s.to, o.startx + o.width), s.width = at.getMax(s.width, Math.abs(s.from - s.to)) - Re.labelBoxWidth;
    })) : (l = Urt(u, e, n), u.msgModel = l, l.startx && l.stopx && a.length > 0 && a.forEach((f) => {
      if (s = f, l.startx === l.stopx) {
        const d = e.get(u.from), p = e.get(u.to);
        s.from = at.getMin(
          d.x - l.width / 2,
          d.x - d.width / 2,
          s.from
        ), s.to = at.getMax(
          p.x + l.width / 2,
          p.x + d.width / 2,
          s.to
        ), s.width = at.getMax(s.width, Math.abs(s.to - s.from)) - Re.labelBoxWidth;
      } else
        s.from = at.getMin(l.startx, s.from), s.to = at.getMax(l.stopx, s.to), s.width = at.getMax(s.width, l.width) - Re.labelBoxWidth;
    }));
  }
  return et.activations = [], ae.debug("Loop type widths:", i), i;
}, "calculateLoopBounds"), Hrt = {
  bounds: et,
  drawActors: G8,
  drawActorsPopup: Dce,
  setConf: Oce,
  draw: zrt
}, Wrt = {
  parser: ort,
  get db() {
    return new hrt();
  },
  renderer: Hrt,
  styles: drt,
  init: /* @__PURE__ */ w((t) => {
    t.sequence || (t.sequence = {}), t.wrap && (t.sequence.wrap = t.wrap, t_({ sequence: { wrap: t.wrap } }));
  }, "init")
};
const Yrt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Wrt
}, Symbol.toStringTag, { value: "Module" }));
var U8 = (function() {
  var t = /* @__PURE__ */ w(function(Oe, Ce, Ae, $e) {
    for (Ae = Ae || {}, $e = Oe.length; $e--; Ae[Oe[$e]] = Ce) ;
    return Ae;
  }, "o"), e = [1, 18], r = [1, 19], n = [1, 20], i = [1, 41], a = [1, 42], s = [1, 26], o = [1, 24], l = [1, 25], u = [1, 32], h = [1, 33], f = [1, 34], d = [1, 45], p = [1, 35], g = [1, 36], m = [1, 37], v = [1, 38], y = [1, 27], b = [1, 28], x = [1, 29], T = [1, 30], E = [1, 31], A = [1, 44], S = [1, 46], k = [1, 43], _ = [1, 47], R = [1, 9], L = [1, 8, 9], M = [1, 58], P = [1, 59], C = [1, 60], I = [1, 61], N = [1, 62], O = [1, 63], D = [1, 64], $ = [1, 8, 9, 41], z = [1, 76], B = [1, 8, 9, 12, 13, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81], G = [1, 8, 9, 12, 13, 18, 20, 22, 39, 41, 44, 50, 60, 68, 69, 70, 71, 72, 73, 74, 79, 81, 86, 100, 102, 103], W = [13, 60, 86, 100, 102, 103], V = [13, 60, 73, 74, 86, 100, 102, 103], U = [13, 60, 68, 69, 70, 71, 72, 86, 100, 102, 103], Z = [1, 100], K = [1, 117], ce = [1, 113], J = [1, 109], ee = [1, 115], j = [1, 110], X = [1, 111], re = [1, 112], Q = [1, 114], ue = [1, 116], ne = [22, 48, 60, 61, 82, 86, 87, 88, 89, 90], xe = [1, 8, 9, 39, 41, 44], Y = [1, 8, 9, 22], Ne = [1, 145], fe = [1, 8, 9, 61], qe = [1, 8, 9, 22, 48, 60, 61, 82, 86, 87, 88, 89, 90], ze = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, statements: 5, graphConfig: 6, CLASS_DIAGRAM: 7, NEWLINE: 8, EOF: 9, statement: 10, classLabel: 11, SQS: 12, STR: 13, SQE: 14, namespaceName: 15, alphaNumToken: 16, classLiteralName: 17, DOT: 18, className: 19, GENERICTYPE: 20, relationStatement: 21, LABEL: 22, namespaceStatement: 23, classStatement: 24, memberStatement: 25, annotationStatement: 26, clickStatement: 27, styleStatement: 28, cssClassStatement: 29, noteStatement: 30, classDefStatement: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, namespaceIdentifier: 38, STRUCT_START: 39, classStatements: 40, STRUCT_STOP: 41, NAMESPACE: 42, classIdentifier: 43, STYLE_SEPARATOR: 44, members: 45, CLASS: 46, emptyBody: 47, SPACE: 48, ANNOTATION_START: 49, ANNOTATION_END: 50, MEMBER: 51, SEPARATOR: 52, relation: 53, NOTE_FOR: 54, noteText: 55, NOTE: 56, CLASSDEF: 57, classList: 58, stylesOpt: 59, ALPHA: 60, COMMA: 61, direction_tb: 62, direction_bt: 63, direction_rl: 64, direction_lr: 65, relationType: 66, lineType: 67, AGGREGATION: 68, EXTENSION: 69, COMPOSITION: 70, DEPENDENCY: 71, LOLLIPOP: 72, LINE: 73, DOTTED_LINE: 74, CALLBACK: 75, LINK: 76, LINK_TARGET: 77, CLICK: 78, CALLBACK_NAME: 79, CALLBACK_ARGS: 80, HREF: 81, STYLE: 82, CSSCLASS: 83, style: 84, styleComponent: 85, NUM: 86, COLON: 87, UNIT: 88, BRKT: 89, PCT: 90, commentToken: 91, textToken: 92, graphCodeTokens: 93, textNoTagsToken: 94, TAGSTART: 95, TAGEND: 96, "==": 97, "--": 98, DEFAULT: 99, MINUS: 100, keywords: 101, UNICODE_TEXT: 102, BQUOTE_STR: 103, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 7: "CLASS_DIAGRAM", 8: "NEWLINE", 9: "EOF", 12: "SQS", 13: "STR", 14: "SQE", 18: "DOT", 20: "GENERICTYPE", 22: "LABEL", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 39: "STRUCT_START", 41: "STRUCT_STOP", 42: "NAMESPACE", 44: "STYLE_SEPARATOR", 46: "CLASS", 48: "SPACE", 49: "ANNOTATION_START", 50: "ANNOTATION_END", 51: "MEMBER", 52: "SEPARATOR", 54: "NOTE_FOR", 56: "NOTE", 57: "CLASSDEF", 60: "ALPHA", 61: "COMMA", 62: "direction_tb", 63: "direction_bt", 64: "direction_rl", 65: "direction_lr", 68: "AGGREGATION", 69: "EXTENSION", 70: "COMPOSITION", 71: "DEPENDENCY", 72: "LOLLIPOP", 73: "LINE", 74: "DOTTED_LINE", 75: "CALLBACK", 76: "LINK", 77: "LINK_TARGET", 78: "CLICK", 79: "CALLBACK_NAME", 80: "CALLBACK_ARGS", 81: "HREF", 82: "STYLE", 83: "CSSCLASS", 86: "NUM", 87: "COLON", 88: "UNIT", 89: "BRKT", 90: "PCT", 93: "graphCodeTokens", 95: "TAGSTART", 96: "TAGEND", 97: "==", 98: "--", 99: "DEFAULT", 100: "MINUS", 101: "keywords", 102: "UNICODE_TEXT", 103: "BQUOTE_STR" },
    productions_: [0, [3, 1], [3, 1], [4, 1], [6, 4], [5, 1], [5, 2], [5, 3], [11, 3], [15, 1], [15, 1], [15, 3], [15, 2], [19, 1], [19, 3], [19, 1], [19, 2], [19, 2], [19, 2], [10, 1], [10, 2], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [23, 4], [23, 5], [38, 2], [40, 1], [40, 2], [40, 3], [24, 1], [24, 3], [24, 4], [24, 3], [24, 6], [43, 2], [43, 3], [47, 0], [47, 2], [47, 2], [26, 4], [45, 1], [45, 2], [25, 1], [25, 2], [25, 1], [25, 1], [21, 3], [21, 4], [21, 4], [21, 5], [30, 3], [30, 2], [31, 3], [58, 1], [58, 3], [32, 1], [32, 1], [32, 1], [32, 1], [53, 3], [53, 2], [53, 2], [53, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [67, 1], [67, 1], [27, 3], [27, 4], [27, 3], [27, 4], [27, 4], [27, 5], [27, 3], [27, 4], [27, 4], [27, 5], [27, 4], [27, 5], [27, 5], [27, 6], [28, 3], [29, 3], [59, 1], [59, 3], [84, 1], [84, 2], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [91, 1], [91, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [94, 1], [94, 1], [94, 1], [94, 1], [16, 1], [16, 1], [16, 1], [16, 1], [17, 1], [55, 1]],
    performAction: /* @__PURE__ */ w(function(Ce, Ae, $e, me, Ie, te, he) {
      var F = te.length - 1;
      switch (Ie) {
        case 8:
          this.$ = te[F - 1];
          break;
        case 9:
        case 10:
        case 13:
        case 15:
          this.$ = te[F];
          break;
        case 11:
        case 14:
          this.$ = te[F - 2] + "." + te[F];
          break;
        case 12:
        case 16:
          this.$ = te[F - 1] + te[F];
          break;
        case 17:
        case 18:
          this.$ = te[F - 1] + "~" + te[F] + "~";
          break;
        case 19:
          me.addRelation(te[F]);
          break;
        case 20:
          te[F - 1].title = me.cleanupLabel(te[F]), me.addRelation(te[F - 1]);
          break;
        case 31:
          this.$ = te[F].trim(), me.setAccTitle(this.$);
          break;
        case 32:
        case 33:
          this.$ = te[F].trim(), me.setAccDescription(this.$);
          break;
        case 34:
          me.addClassesToNamespace(te[F - 3], te[F - 1]);
          break;
        case 35:
          me.addClassesToNamespace(te[F - 4], te[F - 1]);
          break;
        case 36:
          this.$ = te[F], me.addNamespace(te[F]);
          break;
        case 37:
          this.$ = [te[F]];
          break;
        case 38:
          this.$ = [te[F - 1]];
          break;
        case 39:
          te[F].unshift(te[F - 2]), this.$ = te[F];
          break;
        case 41:
          me.setCssClass(te[F - 2], te[F]);
          break;
        case 42:
          me.addMembers(te[F - 3], te[F - 1]);
          break;
        case 44:
          me.setCssClass(te[F - 5], te[F - 3]), me.addMembers(te[F - 5], te[F - 1]);
          break;
        case 45:
          this.$ = te[F], me.addClass(te[F]);
          break;
        case 46:
          this.$ = te[F - 1], me.addClass(te[F - 1]), me.setClassLabel(te[F - 1], te[F]);
          break;
        case 50:
          me.addAnnotation(te[F], te[F - 2]);
          break;
        case 51:
        case 64:
          this.$ = [te[F]];
          break;
        case 52:
          te[F].push(te[F - 1]), this.$ = te[F];
          break;
        case 53:
          break;
        case 54:
          me.addMember(te[F - 1], me.cleanupLabel(te[F]));
          break;
        case 55:
          break;
        case 56:
          break;
        case 57:
          this.$ = { id1: te[F - 2], id2: te[F], relation: te[F - 1], relationTitle1: "none", relationTitle2: "none" };
          break;
        case 58:
          this.$ = { id1: te[F - 3], id2: te[F], relation: te[F - 1], relationTitle1: te[F - 2], relationTitle2: "none" };
          break;
        case 59:
          this.$ = { id1: te[F - 3], id2: te[F], relation: te[F - 2], relationTitle1: "none", relationTitle2: te[F - 1] };
          break;
        case 60:
          this.$ = { id1: te[F - 4], id2: te[F], relation: te[F - 2], relationTitle1: te[F - 3], relationTitle2: te[F - 1] };
          break;
        case 61:
          me.addNote(te[F], te[F - 1]);
          break;
        case 62:
          me.addNote(te[F]);
          break;
        case 63:
          this.$ = te[F - 2], me.defineClass(te[F - 1], te[F]);
          break;
        case 65:
          this.$ = te[F - 2].concat([te[F]]);
          break;
        case 66:
          me.setDirection("TB");
          break;
        case 67:
          me.setDirection("BT");
          break;
        case 68:
          me.setDirection("RL");
          break;
        case 69:
          me.setDirection("LR");
          break;
        case 70:
          this.$ = { type1: te[F - 2], type2: te[F], lineType: te[F - 1] };
          break;
        case 71:
          this.$ = { type1: "none", type2: te[F], lineType: te[F - 1] };
          break;
        case 72:
          this.$ = { type1: te[F - 1], type2: "none", lineType: te[F] };
          break;
        case 73:
          this.$ = { type1: "none", type2: "none", lineType: te[F] };
          break;
        case 74:
          this.$ = me.relationType.AGGREGATION;
          break;
        case 75:
          this.$ = me.relationType.EXTENSION;
          break;
        case 76:
          this.$ = me.relationType.COMPOSITION;
          break;
        case 77:
          this.$ = me.relationType.DEPENDENCY;
          break;
        case 78:
          this.$ = me.relationType.LOLLIPOP;
          break;
        case 79:
          this.$ = me.lineType.LINE;
          break;
        case 80:
          this.$ = me.lineType.DOTTED_LINE;
          break;
        case 81:
        case 87:
          this.$ = te[F - 2], me.setClickEvent(te[F - 1], te[F]);
          break;
        case 82:
        case 88:
          this.$ = te[F - 3], me.setClickEvent(te[F - 2], te[F - 1]), me.setTooltip(te[F - 2], te[F]);
          break;
        case 83:
          this.$ = te[F - 2], me.setLink(te[F - 1], te[F]);
          break;
        case 84:
          this.$ = te[F - 3], me.setLink(te[F - 2], te[F - 1], te[F]);
          break;
        case 85:
          this.$ = te[F - 3], me.setLink(te[F - 2], te[F - 1]), me.setTooltip(te[F - 2], te[F]);
          break;
        case 86:
          this.$ = te[F - 4], me.setLink(te[F - 3], te[F - 2], te[F]), me.setTooltip(te[F - 3], te[F - 1]);
          break;
        case 89:
          this.$ = te[F - 3], me.setClickEvent(te[F - 2], te[F - 1], te[F]);
          break;
        case 90:
          this.$ = te[F - 4], me.setClickEvent(te[F - 3], te[F - 2], te[F - 1]), me.setTooltip(te[F - 3], te[F]);
          break;
        case 91:
          this.$ = te[F - 3], me.setLink(te[F - 2], te[F]);
          break;
        case 92:
          this.$ = te[F - 4], me.setLink(te[F - 3], te[F - 1], te[F]);
          break;
        case 93:
          this.$ = te[F - 4], me.setLink(te[F - 3], te[F - 1]), me.setTooltip(te[F - 3], te[F]);
          break;
        case 94:
          this.$ = te[F - 5], me.setLink(te[F - 4], te[F - 2], te[F]), me.setTooltip(te[F - 4], te[F - 1]);
          break;
        case 95:
          this.$ = te[F - 2], me.setCssStyle(te[F - 1], te[F]);
          break;
        case 96:
          me.setCssClass(te[F - 1], te[F]);
          break;
        case 97:
          this.$ = [te[F]];
          break;
        case 98:
          te[F - 2].push(te[F]), this.$ = te[F - 2];
          break;
        case 100:
          this.$ = te[F - 1] + te[F];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: [1, 6], 10: 5, 16: 39, 17: 40, 19: 21, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: e, 35: r, 37: n, 38: 22, 42: i, 43: 23, 46: a, 49: s, 51: o, 52: l, 54: u, 56: h, 57: f, 60: d, 62: p, 63: g, 64: m, 65: v, 75: y, 76: b, 78: x, 82: T, 83: E, 86: A, 100: S, 102: k, 103: _ }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, t(R, [2, 5], { 8: [1, 48] }), { 8: [1, 49] }, t(L, [2, 19], { 22: [1, 50] }), t(L, [2, 21]), t(L, [2, 22]), t(L, [2, 23]), t(L, [2, 24]), t(L, [2, 25]), t(L, [2, 26]), t(L, [2, 27]), t(L, [2, 28]), t(L, [2, 29]), t(L, [2, 30]), { 34: [1, 51] }, { 36: [1, 52] }, t(L, [2, 33]), t(L, [2, 53], { 53: 53, 66: 56, 67: 57, 13: [1, 54], 22: [1, 55], 68: M, 69: P, 70: C, 71: I, 72: N, 73: O, 74: D }), { 39: [1, 65] }, t($, [2, 40], { 39: [1, 67], 44: [1, 66] }), t(L, [2, 55]), t(L, [2, 56]), { 16: 68, 60: d, 86: A, 100: S, 102: k }, { 16: 39, 17: 40, 19: 69, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 16: 39, 17: 40, 19: 70, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 16: 39, 17: 40, 19: 71, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 60: [1, 72] }, { 13: [1, 73] }, { 16: 39, 17: 40, 19: 74, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 13: z, 55: 75 }, { 58: 77, 60: [1, 78] }, t(L, [2, 66]), t(L, [2, 67]), t(L, [2, 68]), t(L, [2, 69]), t(B, [2, 13], { 16: 39, 17: 40, 19: 80, 18: [1, 79], 20: [1, 81], 60: d, 86: A, 100: S, 102: k, 103: _ }), t(B, [2, 15], { 20: [1, 82] }), { 15: 83, 16: 84, 17: 85, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 16: 39, 17: 40, 19: 86, 60: d, 86: A, 100: S, 102: k, 103: _ }, t(G, [2, 123]), t(G, [2, 124]), t(G, [2, 125]), t(G, [2, 126]), t([1, 8, 9, 12, 13, 20, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81], [2, 127]), t(R, [2, 6], { 10: 5, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 19: 21, 38: 22, 43: 23, 16: 39, 17: 40, 5: 87, 33: e, 35: r, 37: n, 42: i, 46: a, 49: s, 51: o, 52: l, 54: u, 56: h, 57: f, 60: d, 62: p, 63: g, 64: m, 65: v, 75: y, 76: b, 78: x, 82: T, 83: E, 86: A, 100: S, 102: k, 103: _ }), { 5: 88, 10: 5, 16: 39, 17: 40, 19: 21, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: e, 35: r, 37: n, 38: 22, 42: i, 43: 23, 46: a, 49: s, 51: o, 52: l, 54: u, 56: h, 57: f, 60: d, 62: p, 63: g, 64: m, 65: v, 75: y, 76: b, 78: x, 82: T, 83: E, 86: A, 100: S, 102: k, 103: _ }, t(L, [2, 20]), t(L, [2, 31]), t(L, [2, 32]), { 13: [1, 90], 16: 39, 17: 40, 19: 89, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 53: 91, 66: 56, 67: 57, 68: M, 69: P, 70: C, 71: I, 72: N, 73: O, 74: D }, t(L, [2, 54]), { 67: 92, 73: O, 74: D }, t(W, [2, 73], { 66: 93, 68: M, 69: P, 70: C, 71: I, 72: N }), t(V, [2, 74]), t(V, [2, 75]), t(V, [2, 76]), t(V, [2, 77]), t(V, [2, 78]), t(U, [2, 79]), t(U, [2, 80]), { 8: [1, 95], 24: 96, 40: 94, 43: 23, 46: a }, { 16: 97, 60: d, 86: A, 100: S, 102: k }, { 41: [1, 99], 45: 98, 51: Z }, { 50: [1, 101] }, { 13: [1, 102] }, { 13: [1, 103] }, { 79: [1, 104], 81: [1, 105] }, { 22: K, 48: ce, 59: 106, 60: J, 82: ee, 84: 107, 85: 108, 86: j, 87: X, 88: re, 89: Q, 90: ue }, { 60: [1, 118] }, { 13: z, 55: 119 }, t(L, [2, 62]), t(L, [2, 128]), { 22: K, 48: ce, 59: 120, 60: J, 61: [1, 121], 82: ee, 84: 107, 85: 108, 86: j, 87: X, 88: re, 89: Q, 90: ue }, t(ne, [2, 64]), { 16: 39, 17: 40, 19: 122, 60: d, 86: A, 100: S, 102: k, 103: _ }, t(B, [2, 16]), t(B, [2, 17]), t(B, [2, 18]), { 39: [2, 36] }, { 15: 124, 16: 84, 17: 85, 18: [1, 123], 39: [2, 9], 60: d, 86: A, 100: S, 102: k, 103: _ }, { 39: [2, 10] }, t(xe, [2, 45], { 11: 125, 12: [1, 126] }), t(R, [2, 7]), { 9: [1, 127] }, t(Y, [2, 57]), { 16: 39, 17: 40, 19: 128, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 13: [1, 130], 16: 39, 17: 40, 19: 129, 60: d, 86: A, 100: S, 102: k, 103: _ }, t(W, [2, 72], { 66: 131, 68: M, 69: P, 70: C, 71: I, 72: N }), t(W, [2, 71]), { 41: [1, 132] }, { 24: 96, 40: 133, 43: 23, 46: a }, { 8: [1, 134], 41: [2, 37] }, t($, [2, 41], { 39: [1, 135] }), { 41: [1, 136] }, t($, [2, 43]), { 41: [2, 51], 45: 137, 51: Z }, { 16: 39, 17: 40, 19: 138, 60: d, 86: A, 100: S, 102: k, 103: _ }, t(L, [2, 81], { 13: [1, 139] }), t(L, [2, 83], { 13: [1, 141], 77: [1, 140] }), t(L, [2, 87], { 13: [1, 142], 80: [1, 143] }), { 13: [1, 144] }, t(L, [2, 95], { 61: Ne }), t(fe, [2, 97], { 85: 146, 22: K, 48: ce, 60: J, 82: ee, 86: j, 87: X, 88: re, 89: Q, 90: ue }), t(qe, [2, 99]), t(qe, [2, 101]), t(qe, [2, 102]), t(qe, [2, 103]), t(qe, [2, 104]), t(qe, [2, 105]), t(qe, [2, 106]), t(qe, [2, 107]), t(qe, [2, 108]), t(qe, [2, 109]), t(L, [2, 96]), t(L, [2, 61]), t(L, [2, 63], { 61: Ne }), { 60: [1, 147] }, t(B, [2, 14]), { 15: 148, 16: 84, 17: 85, 60: d, 86: A, 100: S, 102: k, 103: _ }, { 39: [2, 12] }, t(xe, [2, 46]), { 13: [1, 149] }, { 1: [2, 4] }, t(Y, [2, 59]), t(Y, [2, 58]), { 16: 39, 17: 40, 19: 150, 60: d, 86: A, 100: S, 102: k, 103: _ }, t(W, [2, 70]), t(L, [2, 34]), { 41: [1, 151] }, { 24: 96, 40: 152, 41: [2, 38], 43: 23, 46: a }, { 45: 153, 51: Z }, t($, [2, 42]), { 41: [2, 52] }, t(L, [2, 50]), t(L, [2, 82]), t(L, [2, 84]), t(L, [2, 85], { 77: [1, 154] }), t(L, [2, 88]), t(L, [2, 89], { 13: [1, 155] }), t(L, [2, 91], { 13: [1, 157], 77: [1, 156] }), { 22: K, 48: ce, 60: J, 82: ee, 84: 158, 85: 108, 86: j, 87: X, 88: re, 89: Q, 90: ue }, t(qe, [2, 100]), t(ne, [2, 65]), { 39: [2, 11] }, { 14: [1, 159] }, t(Y, [2, 60]), t(L, [2, 35]), { 41: [2, 39] }, { 41: [1, 160] }, t(L, [2, 86]), t(L, [2, 90]), t(L, [2, 92]), t(L, [2, 93], { 77: [1, 161] }), t(fe, [2, 98], { 85: 146, 22: K, 48: ce, 60: J, 82: ee, 86: j, 87: X, 88: re, 89: Q, 90: ue }), t(xe, [2, 8]), t($, [2, 44]), t(L, [2, 94])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 83: [2, 36], 85: [2, 10], 124: [2, 12], 127: [2, 4], 137: [2, 52], 148: [2, 11], 152: [2, 39] },
    parseError: /* @__PURE__ */ w(function(Ce, Ae) {
      if (Ae.recoverable)
        this.trace(Ce);
      else {
        var $e = new Error(Ce);
        throw $e.hash = Ae, $e;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(Ce) {
      var Ae = this, $e = [0], me = [], Ie = [null], te = [], he = this.table, F = "", oe = 0, se = 0, ge = 2, de = 1, we = te.slice.call(arguments, 1), _e = Object.create(this.lexer), Se = { yy: {} };
      for (var Me in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Me) && (Se.yy[Me] = this.yy[Me]);
      _e.setInput(Ce, Se.yy), Se.yy.lexer = _e, Se.yy.parser = this, typeof _e.yylloc > "u" && (_e.yylloc = {});
      var Xe = _e.yylloc;
      te.push(Xe);
      var We = _e.options && _e.options.ranges;
      typeof Se.yy.parseError == "function" ? this.parseError = Se.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Ke(nt) {
        $e.length = $e.length - 2 * nt, Ie.length = Ie.length - nt, te.length = te.length - nt;
      }
      w(Ke, "popStack");
      function Ze() {
        var nt;
        return nt = me.pop() || _e.lex() || de, typeof nt != "number" && (nt instanceof Array && (me = nt, nt = me.pop()), nt = Ae.symbols_[nt] || nt), nt;
      }
      w(Ze, "lex");
      for (var Pe, Ve, ht, st, Ue = {}, Et, He, rt, ct; ; ) {
        if (Ve = $e[$e.length - 1], this.defaultActions[Ve] ? ht = this.defaultActions[Ve] : ((Pe === null || typeof Pe > "u") && (Pe = Ze()), ht = he[Ve] && he[Ve][Pe]), typeof ht > "u" || !ht.length || !ht[0]) {
          var ut = "";
          ct = [];
          for (Et in he[Ve])
            this.terminals_[Et] && Et > ge && ct.push("'" + this.terminals_[Et] + "'");
          _e.showPosition ? ut = "Parse error on line " + (oe + 1) + `:
` + _e.showPosition() + `
Expecting ` + ct.join(", ") + ", got '" + (this.terminals_[Pe] || Pe) + "'" : ut = "Parse error on line " + (oe + 1) + ": Unexpected " + (Pe == de ? "end of input" : "'" + (this.terminals_[Pe] || Pe) + "'"), this.parseError(ut, {
            text: _e.match,
            token: this.terminals_[Pe] || Pe,
            line: _e.yylineno,
            loc: Xe,
            expected: ct
          });
        }
        if (ht[0] instanceof Array && ht.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ve + ", token: " + Pe);
        switch (ht[0]) {
          case 1:
            $e.push(Pe), Ie.push(_e.yytext), te.push(_e.yylloc), $e.push(ht[1]), Pe = null, se = _e.yyleng, F = _e.yytext, oe = _e.yylineno, Xe = _e.yylloc;
            break;
          case 2:
            if (He = this.productions_[ht[1]][1], Ue.$ = Ie[Ie.length - He], Ue._$ = {
              first_line: te[te.length - (He || 1)].first_line,
              last_line: te[te.length - 1].last_line,
              first_column: te[te.length - (He || 1)].first_column,
              last_column: te[te.length - 1].last_column
            }, We && (Ue._$.range = [
              te[te.length - (He || 1)].range[0],
              te[te.length - 1].range[1]
            ]), st = this.performAction.apply(Ue, [
              F,
              se,
              oe,
              Se.yy,
              ht[1],
              Ie,
              te
            ].concat(we)), typeof st < "u")
              return st;
            He && ($e = $e.slice(0, -1 * He * 2), Ie = Ie.slice(0, -1 * He), te = te.slice(0, -1 * He)), $e.push(this.productions_[ht[1]][0]), Ie.push(Ue.$), te.push(Ue._$), rt = he[$e[$e.length - 2]][$e[$e.length - 1]], $e.push(rt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Ge = /* @__PURE__ */ (function() {
    var Oe = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(Ae, $e) {
        if (this.yy.parser)
          this.yy.parser.parseError(Ae, $e);
        else
          throw new Error(Ae);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(Ce, Ae) {
        return this.yy = Ae || this.yy || {}, this._input = Ce, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var Ce = this._input[0];
        this.yytext += Ce, this.yyleng++, this.offset++, this.match += Ce, this.matched += Ce;
        var Ae = Ce.match(/(?:\r\n?|\n).*/g);
        return Ae ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Ce;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(Ce) {
        var Ae = Ce.length, $e = Ce.split(/(?:\r\n?|\n)/g);
        this._input = Ce + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Ae), this.offset -= Ae;
        var me = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), $e.length - 1 && (this.yylineno -= $e.length - 1);
        var Ie = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: $e ? ($e.length === me.length ? this.yylloc.first_column : 0) + me[me.length - $e.length].length - $e[0].length : this.yylloc.first_column - Ae
        }, this.options.ranges && (this.yylloc.range = [Ie[0], Ie[0] + this.yyleng - Ae]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(Ce) {
        this.unput(this.match.slice(Ce));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var Ce = this.matched.substr(0, this.matched.length - this.match.length);
        return (Ce.length > 20 ? "..." : "") + Ce.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var Ce = this.match;
        return Ce.length < 20 && (Ce += this._input.substr(0, 20 - Ce.length)), (Ce.substr(0, 20) + (Ce.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var Ce = this.pastInput(), Ae = new Array(Ce.length + 1).join("-");
        return Ce + this.upcomingInput() + `
` + Ae + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(Ce, Ae) {
        var $e, me, Ie;
        if (this.options.backtrack_lexer && (Ie = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Ie.yylloc.range = this.yylloc.range.slice(0))), me = Ce[0].match(/(?:\r\n?|\n).*/g), me && (this.yylineno += me.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: me ? me[me.length - 1].length - me[me.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Ce[0].length
        }, this.yytext += Ce[0], this.match += Ce[0], this.matches = Ce, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Ce[0].length), this.matched += Ce[0], $e = this.performAction.call(this, this.yy, this, Ae, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), $e)
          return $e;
        if (this._backtrack) {
          for (var te in Ie)
            this[te] = Ie[te];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Ce, Ae, $e, me;
        this._more || (this.yytext = "", this.match = "");
        for (var Ie = this._currentRules(), te = 0; te < Ie.length; te++)
          if ($e = this._input.match(this.rules[Ie[te]]), $e && (!Ae || $e[0].length > Ae[0].length)) {
            if (Ae = $e, me = te, this.options.backtrack_lexer) {
              if (Ce = this.test_match($e, Ie[te]), Ce !== !1)
                return Ce;
              if (this._backtrack) {
                Ae = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Ae ? (Ce = this.test_match(Ae, Ie[me]), Ce !== !1 ? Ce : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var Ae = this.next();
        return Ae || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(Ae) {
        this.conditionStack.push(Ae);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var Ae = this.conditionStack.length - 1;
        return Ae > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(Ae) {
        return Ae = this.conditionStack.length - 1 - Math.abs(Ae || 0), Ae >= 0 ? this.conditionStack[Ae] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(Ae) {
        this.begin(Ae);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ w(function(Ae, $e, me, Ie) {
        switch (me) {
          case 0:
            return 62;
          case 1:
            return 63;
          case 2:
            return 64;
          case 3:
            return 65;
          case 4:
            break;
          case 5:
            break;
          case 6:
            return this.begin("acc_title"), 33;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 35;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 8;
          case 14:
            break;
          case 15:
            return 7;
          case 16:
            return 7;
          case 17:
            return "EDGE_STATE";
          case 18:
            this.begin("callback_name");
            break;
          case 19:
            this.popState();
            break;
          case 20:
            this.popState(), this.begin("callback_args");
            break;
          case 21:
            return 79;
          case 22:
            this.popState();
            break;
          case 23:
            return 80;
          case 24:
            this.popState();
            break;
          case 25:
            return "STR";
          case 26:
            this.begin("string");
            break;
          case 27:
            return 82;
          case 28:
            return 57;
          case 29:
            return this.begin("namespace"), 42;
          case 30:
            return this.popState(), 8;
          case 31:
            break;
          case 32:
            return this.begin("namespace-body"), 39;
          case 33:
            return this.popState(), 41;
          case 34:
            return "EOF_IN_STRUCT";
          case 35:
            return 8;
          case 36:
            break;
          case 37:
            return "EDGE_STATE";
          case 38:
            return this.begin("class"), 46;
          case 39:
            return this.popState(), 8;
          case 40:
            break;
          case 41:
            return this.popState(), this.popState(), 41;
          case 42:
            return this.begin("class-body"), 39;
          case 43:
            return this.popState(), 41;
          case 44:
            return "EOF_IN_STRUCT";
          case 45:
            return "EDGE_STATE";
          case 46:
            return "OPEN_IN_STRUCT";
          case 47:
            break;
          case 48:
            return "MEMBER";
          case 49:
            return 83;
          case 50:
            return 75;
          case 51:
            return 76;
          case 52:
            return 78;
          case 53:
            return 54;
          case 54:
            return 56;
          case 55:
            return 49;
          case 56:
            return 50;
          case 57:
            return 81;
          case 58:
            this.popState();
            break;
          case 59:
            return "GENERICTYPE";
          case 60:
            this.begin("generic");
            break;
          case 61:
            this.popState();
            break;
          case 62:
            return "BQUOTE_STR";
          case 63:
            this.begin("bqstring");
            break;
          case 64:
            return 77;
          case 65:
            return 77;
          case 66:
            return 77;
          case 67:
            return 77;
          case 68:
            return 69;
          case 69:
            return 69;
          case 70:
            return 71;
          case 71:
            return 71;
          case 72:
            return 70;
          case 73:
            return 68;
          case 74:
            return 72;
          case 75:
            return 73;
          case 76:
            return 74;
          case 77:
            return 22;
          case 78:
            return 44;
          case 79:
            return 100;
          case 80:
            return 18;
          case 81:
            return "PLUS";
          case 82:
            return 87;
          case 83:
            return 61;
          case 84:
            return 89;
          case 85:
            return 89;
          case 86:
            return 90;
          case 87:
            return "EQUALS";
          case 88:
            return "EQUALS";
          case 89:
            return 60;
          case 90:
            return 12;
          case 91:
            return 14;
          case 92:
            return "PUNCTUATION";
          case 93:
            return 86;
          case 94:
            return 102;
          case 95:
            return 48;
          case 96:
            return 48;
          case 97:
            return 9;
        }
      }, "anonymous"),
      rules: [/^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:\[\*\])/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:["])/, /^(?:[^"]*)/, /^(?:["])/, /^(?:style\b)/, /^(?:classDef\b)/, /^(?:namespace\b)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:\[\*\])/, /^(?:class\b)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:[}])/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\[\*\])/, /^(?:[{])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:note for\b)/, /^(?:note\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:href\b)/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:~)/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:[`])/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?::)/, /^(?:,)/, /^(?:#)/, /^(?:#)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:\[)/, /^(?:\])/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:\s)/, /^(?:$)/],
      conditions: { "namespace-body": { rules: [26, 33, 34, 35, 36, 37, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, namespace: { rules: [26, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, "class-body": { rules: [26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, class: { rules: [26, 39, 40, 41, 42, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_descr_multiline: { rules: [11, 12, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_descr: { rules: [9, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_title: { rules: [7, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, callback_args: { rules: [22, 23, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, callback_name: { rules: [19, 20, 21, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, href: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, struct: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, generic: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, bqstring: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, string: { rules: [24, 25, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 26, 27, 28, 29, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97], inclusive: !0 } }
    };
    return Oe;
  })();
  ze.lexer = Ge;
  function Ee() {
    this.yy = {};
  }
  return w(Ee, "Parser"), Ee.prototype = ze, ze.Parser = Ee, new Ee();
})();
U8.parser = U8;
var Fce = U8, ZW = ["#", "+", "~", "-", ""], $d, QW = ($d = class {
  constructor(e, r) {
    this.memberType = r, this.visibility = "", this.classifier = "", this.text = "";
    const n = pr(e, Te());
    this.parseMember(n);
  }
  getDisplayDetails() {
    let e = this.visibility + Hl(this.id);
    this.memberType === "method" && (e += `(${Hl(this.parameters.trim())})`, this.returnType && (e += " : " + Hl(this.returnType))), e = e.trim();
    const r = this.parseClassifier();
    return {
      displayText: e,
      cssStyle: r
    };
  }
  parseMember(e) {
    let r = "";
    if (this.memberType === "method") {
      const a = /([#+~-])?(.+)\((.*)\)([\s$*])?(.*)([$*])?/.exec(e);
      if (a) {
        const s = a[1] ? a[1].trim() : "";
        if (ZW.includes(s) && (this.visibility = s), this.id = a[2], this.parameters = a[3] ? a[3].trim() : "", r = a[4] ? a[4].trim() : "", this.returnType = a[5] ? a[5].trim() : "", r === "") {
          const o = this.returnType.substring(this.returnType.length - 1);
          /[$*]/.exec(o) && (r = o, this.returnType = this.returnType.substring(0, this.returnType.length - 1));
        }
      }
    } else {
      const i = e.length, a = e.substring(0, 1), s = e.substring(i - 1);
      ZW.includes(a) && (this.visibility = a), /[$*]/.exec(s) && (r = s), this.id = e.substring(
        this.visibility === "" ? 0 : 1,
        r === "" ? i : i - 1
      );
    }
    this.classifier = r, this.id = this.id.startsWith(" ") ? " " + this.id.trim() : this.id.trim();
    const n = `${this.visibility ? "\\" + this.visibility : ""}${Hl(this.id)}${this.memberType === "method" ? `(${Hl(this.parameters)})${this.returnType ? " : " + Hl(this.returnType) : ""}` : ""}`;
    this.text = n.replaceAll("<", "&lt;").replaceAll(">", "&gt;"), this.text.startsWith("\\&lt;") && (this.text = this.text.replace("\\&lt;", "~"));
  }
  parseClassifier() {
    switch (this.classifier) {
      case "*":
        return "font-style:italic;";
      case "$":
        return "text-decoration:underline;";
      default:
        return "";
    }
  }
}, w($d, "ClassMember"), $d), hy = "classId-", JW = 0, mu = /* @__PURE__ */ w((t) => at.sanitizeText(t, Te()), "sanitizeText"), Bd, zce = (Bd = class {
  constructor() {
    this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.styleClasses = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.functions = [], this.lineType = {
      LINE: 0,
      DOTTED_LINE: 1
    }, this.relationType = {
      AGGREGATION: 0,
      EXTENSION: 1,
      COMPOSITION: 2,
      DEPENDENCY: 3,
      LOLLIPOP: 4
    }, this.setupToolTips = /* @__PURE__ */ w((e) => {
      let r = Qe(".mermaidTooltip");
      (r._groups || r)[0][0] === null && (r = Qe("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), Qe(e).select("svg").selectAll("g.node").on("mouseover", (a) => {
        const s = Qe(a.currentTarget);
        if (s.attr("title") === null)
          return;
        const l = this.getBoundingClientRect();
        r.transition().duration(200).style("opacity", ".9"), r.text(s.attr("title")).style("left", window.scrollX + l.left + (l.right - l.left) / 2 + "px").style("top", window.scrollY + l.top - 14 + document.body.scrollTop + "px"), r.html(r.html().replace(/&lt;br\/&gt;/g, "<br/>")), s.classed("hover", !0);
      }).on("mouseout", (a) => {
        r.transition().duration(500).style("opacity", 0), Qe(a.currentTarget).classed("hover", !1);
      });
    }, "setupToolTips"), this.direction = "TB", this.setAccTitle = Ln, this.getAccTitle = Hn, this.setAccDescription = Wn, this.getAccDescription = Yn, this.setDiagramTitle = ti, this.getDiagramTitle = Mn, this.getConfig = /* @__PURE__ */ w(() => Te().class, "getConfig"), this.functions.push(this.setupToolTips.bind(this)), this.clear(), this.addRelation = this.addRelation.bind(this), this.addClassesToNamespace = this.addClassesToNamespace.bind(this), this.addNamespace = this.addNamespace.bind(this), this.setCssClass = this.setCssClass.bind(this), this.addMembers = this.addMembers.bind(this), this.addClass = this.addClass.bind(this), this.setClassLabel = this.setClassLabel.bind(this), this.addAnnotation = this.addAnnotation.bind(this), this.addMember = this.addMember.bind(this), this.cleanupLabel = this.cleanupLabel.bind(this), this.addNote = this.addNote.bind(this), this.defineClass = this.defineClass.bind(this), this.setDirection = this.setDirection.bind(this), this.setLink = this.setLink.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.clear = this.clear.bind(this), this.setTooltip = this.setTooltip.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setCssStyle = this.setCssStyle.bind(this);
  }
  splitClassNameAndType(e) {
    const r = at.sanitizeText(e, Te());
    let n = "", i = r;
    if (r.indexOf("~") > 0) {
      const a = r.split("~");
      i = mu(a[0]), n = mu(a[1]);
    }
    return { className: i, type: n };
  }
  setClassLabel(e, r) {
    const n = at.sanitizeText(e, Te());
    r && (r = mu(r));
    const { className: i } = this.splitClassNameAndType(n);
    this.classes.get(i).label = r, this.classes.get(i).text = `${r}${this.classes.get(i).type ? `<${this.classes.get(i).type}>` : ""}`;
  }
  /**
   * Function called by parser when a node definition has been found.
   *
   * @param id - ID of the class to add
   * @public
   */
  addClass(e) {
    const r = at.sanitizeText(e, Te()), { className: n, type: i } = this.splitClassNameAndType(r);
    if (this.classes.has(n))
      return;
    const a = at.sanitizeText(n, Te());
    this.classes.set(a, {
      id: a,
      type: i,
      label: a,
      text: `${a}${i ? `&lt;${i}&gt;` : ""}`,
      shape: "classBox",
      cssClasses: "default",
      methods: [],
      members: [],
      annotations: [],
      styles: [],
      domId: hy + a + "-" + JW
    }), JW++;
  }
  addInterface(e, r) {
    const n = {
      id: `interface${this.interfaces.length}`,
      label: e,
      classId: r
    };
    this.interfaces.push(n);
  }
  /**
   * Function to lookup domId from id in the graph definition.
   *
   * @param id - class ID to lookup
   * @public
   */
  lookUpDomId(e) {
    const r = at.sanitizeText(e, Te());
    if (this.classes.has(r))
      return this.classes.get(r).domId;
    throw new Error("Class not found: " + r);
  }
  clear() {
    this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.functions = [], this.functions.push(this.setupToolTips.bind(this)), this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.direction = "TB", In();
  }
  getClass(e) {
    return this.classes.get(e);
  }
  getClasses() {
    return this.classes;
  }
  getRelations() {
    return this.relations;
  }
  getNotes() {
    return this.notes;
  }
  addRelation(e) {
    ae.debug("Adding relation: " + JSON.stringify(e));
    const r = [
      this.relationType.LOLLIPOP,
      this.relationType.AGGREGATION,
      this.relationType.COMPOSITION,
      this.relationType.DEPENDENCY,
      this.relationType.EXTENSION
    ];
    e.relation.type1 === this.relationType.LOLLIPOP && !r.includes(e.relation.type2) ? (this.addClass(e.id2), this.addInterface(e.id1, e.id2), e.id1 = `interface${this.interfaces.length - 1}`) : e.relation.type2 === this.relationType.LOLLIPOP && !r.includes(e.relation.type1) ? (this.addClass(e.id1), this.addInterface(e.id2, e.id1), e.id2 = `interface${this.interfaces.length - 1}`) : (this.addClass(e.id1), this.addClass(e.id2)), e.id1 = this.splitClassNameAndType(e.id1).className, e.id2 = this.splitClassNameAndType(e.id2).className, e.relationTitle1 = at.sanitizeText(
      e.relationTitle1.trim(),
      Te()
    ), e.relationTitle2 = at.sanitizeText(
      e.relationTitle2.trim(),
      Te()
    ), this.relations.push(e);
  }
  /**
   * Adds an annotation to the specified class Annotations mark special properties of the given type
   * (like 'interface' or 'service')
   *
   * @param className - The class name
   * @param annotation - The name of the annotation without any brackets
   * @public
   */
  addAnnotation(e, r) {
    const n = this.splitClassNameAndType(e).className;
    this.classes.get(n).annotations.push(r);
  }
  /**
   * Adds a member to the specified class
   *
   * @param className - The class name
   * @param member - The full name of the member. If the member is enclosed in `<<brackets>>` it is
   *   treated as an annotation If the member is ending with a closing bracket ) it is treated as a
   *   method Otherwise the member will be treated as a normal property
   * @public
   */
  addMember(e, r) {
    this.addClass(e);
    const n = this.splitClassNameAndType(e).className, i = this.classes.get(n);
    if (typeof r == "string") {
      const a = r.trim();
      a.startsWith("<<") && a.endsWith(">>") ? i.annotations.push(mu(a.substring(2, a.length - 2))) : a.indexOf(")") > 0 ? i.methods.push(new QW(a, "method")) : a && i.members.push(new QW(a, "attribute"));
    }
  }
  addMembers(e, r) {
    Array.isArray(r) && (r.reverse(), r.forEach((n) => this.addMember(e, n)));
  }
  addNote(e, r) {
    const n = {
      id: `note${this.notes.length}`,
      class: r,
      text: e
    };
    this.notes.push(n);
  }
  cleanupLabel(e) {
    return e.startsWith(":") && (e = e.substring(1)), mu(e.trim());
  }
  /**
   * Called by parser when assigning cssClass to a class
   *
   * @param ids - Comma separated list of ids
   * @param className - Class to add
   */
  setCssClass(e, r) {
    e.split(",").forEach((n) => {
      let i = n;
      /\d/.exec(n[0]) && (i = hy + i);
      const a = this.classes.get(i);
      a && (a.cssClasses += " " + r);
    });
  }
  defineClass(e, r) {
    for (const n of e) {
      let i = this.styleClasses.get(n);
      i === void 0 && (i = { id: n, styles: [], textStyles: [] }, this.styleClasses.set(n, i)), r && r.forEach((a) => {
        if (/color/.exec(a)) {
          const s = a.replace("fill", "bgFill");
          i.textStyles.push(s);
        }
        i.styles.push(a);
      }), this.classes.forEach((a) => {
        a.cssClasses.includes(n) && a.styles.push(...r.flatMap((s) => s.split(",")));
      });
    }
  }
  /**
   * Called by parser when a tooltip is found, e.g. a clickable element.
   *
   * @param ids - Comma separated list of ids
   * @param tooltip - Tooltip to add
   */
  setTooltip(e, r) {
    e.split(",").forEach((n) => {
      r !== void 0 && (this.classes.get(n).tooltip = mu(r));
    });
  }
  getTooltip(e, r) {
    return r && this.namespaces.has(r) ? this.namespaces.get(r).classes.get(e).tooltip : this.classes.get(e).tooltip;
  }
  /**
   * Called by parser when a link is found. Adds the URL to the vertex data.
   *
   * @param ids - Comma separated list of ids
   * @param linkStr - URL to create a link for
   * @param target - Target of the link, _blank by default as originally defined in the svgDraw.js file
   */
  setLink(e, r, n) {
    const i = Te();
    e.split(",").forEach((a) => {
      let s = a;
      /\d/.exec(a[0]) && (s = hy + s);
      const o = this.classes.get(s);
      o && (o.link = Jt.formatUrl(r, i), i.securityLevel === "sandbox" ? o.linkTarget = "_top" : typeof n == "string" ? o.linkTarget = mu(n) : o.linkTarget = "_blank");
    }), this.setCssClass(e, "clickable");
  }
  /**
   * Called by parser when a click definition is found. Registers an event handler.
   *
   * @param ids - Comma separated list of ids
   * @param functionName - Function to be called on click
   * @param functionArgs - Function args the function should be called with
   */
  setClickEvent(e, r, n) {
    e.split(",").forEach((i) => {
      this.setClickFunc(i, r, n), this.classes.get(i).haveCallback = !0;
    }), this.setCssClass(e, "clickable");
  }
  setClickFunc(e, r, n) {
    const i = at.sanitizeText(e, Te());
    if (Te().securityLevel !== "loose" || r === void 0)
      return;
    const s = i;
    if (this.classes.has(s)) {
      const o = this.lookUpDomId(s);
      let l = [];
      if (typeof n == "string") {
        l = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
        for (let u = 0; u < l.length; u++) {
          let h = l[u].trim();
          h.startsWith('"') && h.endsWith('"') && (h = h.substr(1, h.length - 2)), l[u] = h;
        }
      }
      l.length === 0 && l.push(o), this.functions.push(() => {
        const u = document.querySelector(`[id="${o}"]`);
        u !== null && u.addEventListener(
          "click",
          () => {
            Jt.runFunc(r, ...l);
          },
          !1
        );
      });
    }
  }
  bindFunctions(e) {
    this.functions.forEach((r) => {
      r(e);
    });
  }
  getDirection() {
    return this.direction;
  }
  setDirection(e) {
    this.direction = e;
  }
  /**
   * Function called by parser when a namespace definition has been found.
   *
   * @param id - ID of the namespace to add
   * @public
   */
  addNamespace(e) {
    this.namespaces.has(e) || (this.namespaces.set(e, {
      id: e,
      classes: /* @__PURE__ */ new Map(),
      children: {},
      domId: hy + e + "-" + this.namespaceCounter
    }), this.namespaceCounter++);
  }
  getNamespace(e) {
    return this.namespaces.get(e);
  }
  getNamespaces() {
    return this.namespaces;
  }
  /**
   * Function called by parser when a namespace definition has been found.
   *
   * @param id - ID of the namespace to add
   * @param classNames - IDs of the class to add
   * @public
   */
  addClassesToNamespace(e, r) {
    if (this.namespaces.has(e))
      for (const n of r) {
        const { className: i } = this.splitClassNameAndType(n);
        this.classes.get(i).parent = e, this.namespaces.get(e).classes.set(i, this.classes.get(i));
      }
  }
  setCssStyle(e, r) {
    const n = this.classes.get(e);
    if (!(!r || !n))
      for (const i of r)
        i.includes(",") ? n.styles.push(...i.split(",")) : n.styles.push(i);
  }
  /**
   * Gets the arrow marker for a type index
   *
   * @param type - The type to look for
   * @returns The arrow marker
   */
  getArrowMarker(e) {
    let r;
    switch (e) {
      case 0:
        r = "aggregation";
        break;
      case 1:
        r = "extension";
        break;
      case 2:
        r = "composition";
        break;
      case 3:
        r = "dependency";
        break;
      case 4:
        r = "lollipop";
        break;
      default:
        r = "none";
    }
    return r;
  }
  getData() {
    const e = [], r = [], n = Te();
    for (const a of this.namespaces.keys()) {
      const s = this.namespaces.get(a);
      if (s) {
        const o = {
          id: s.id,
          label: s.id,
          isGroup: !0,
          padding: n.class.padding ?? 16,
          // parent node must be one of [rect, roundedWithTitle, noteGroup, divider]
          shape: "rect",
          cssStyles: ["fill: none", "stroke: black"],
          look: n.look
        };
        e.push(o);
      }
    }
    for (const a of this.classes.keys()) {
      const s = this.classes.get(a);
      if (s) {
        const o = s;
        o.parentId = s.parent, o.look = n.look, e.push(o);
      }
    }
    let i = 0;
    for (const a of this.notes) {
      i++;
      const s = {
        id: a.id,
        label: a.text,
        isGroup: !1,
        shape: "note",
        padding: n.class.padding ?? 6,
        cssStyles: [
          "text-align: left",
          "white-space: nowrap",
          `fill: ${n.themeVariables.noteBkgColor}`,
          `stroke: ${n.themeVariables.noteBorderColor}`
        ],
        look: n.look
      };
      e.push(s);
      const o = this.classes.get(a.class)?.id ?? "";
      if (o) {
        const l = {
          id: `edgeNote${i}`,
          start: a.id,
          end: o,
          type: "normal",
          thickness: "normal",
          classes: "relation",
          arrowTypeStart: "none",
          arrowTypeEnd: "none",
          arrowheadStyle: "",
          labelStyle: [""],
          style: ["fill: none"],
          pattern: "dotted",
          look: n.look
        };
        r.push(l);
      }
    }
    for (const a of this.interfaces) {
      const s = {
        id: a.id,
        label: a.label,
        isGroup: !1,
        shape: "rect",
        cssStyles: ["opacity: 0;"],
        look: n.look
      };
      e.push(s);
    }
    i = 0;
    for (const a of this.relations) {
      i++;
      const s = {
        id: Nf(a.id1, a.id2, {
          prefix: "id",
          counter: i
        }),
        start: a.id1,
        end: a.id2,
        type: "normal",
        label: a.title,
        labelpos: "c",
        thickness: "normal",
        classes: "relation",
        arrowTypeStart: this.getArrowMarker(a.relation.type1),
        arrowTypeEnd: this.getArrowMarker(a.relation.type2),
        startLabelRight: a.relationTitle1 === "none" ? "" : a.relationTitle1,
        endLabelLeft: a.relationTitle2 === "none" ? "" : a.relationTitle2,
        arrowheadStyle: "",
        labelStyle: ["display: inline-block"],
        style: a.style || "",
        pattern: a.relation.lineType == 1 ? "dashed" : "solid",
        look: n.look
      };
      r.push(s);
    }
    return { nodes: e, edges: r, other: {}, config: n, direction: this.getDirection() };
  }
}, w(Bd, "ClassDB"), Bd), Xrt = /* @__PURE__ */ w((t) => `g.classGroup text {
  fill: ${t.nodeBorder || t.classText};
  stroke: none;
  font-family: ${t.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${t.classText};
}
.edgeLabel .label rect {
  fill: ${t.mainBkg};
}
.label text {
  fill: ${t.classText};
}

.labelBkg {
  background: ${t.mainBkg};
}
.edgeLabel .label span {
  background: ${t.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${t.nodeBorder};
  stroke-width: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${t.mainBkg};
  stroke: ${t.nodeBorder};
}

g.classGroup line {
  stroke: ${t.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${t.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${t.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${t.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: transparent !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
  line-height: initial;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${t.textColor};
}
  ${Rm()}
`, "getStyles"), qce = Xrt, jrt = /* @__PURE__ */ w((t, e = "TB") => {
  if (!t.doc)
    return e;
  let r = e;
  for (const n of t.doc)
    n.stmt === "dir" && (r = n.value);
  return r;
}, "getDir"), Krt = /* @__PURE__ */ w(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), Zrt = /* @__PURE__ */ w(async function(t, e, r, n) {
  ae.info("REF0:"), ae.info("Drawing class diagram (v3)", e);
  const { securityLevel: i, state: a, layout: s } = Te(), o = n.db.getData(), l = Y0(e, i);
  o.type = n.type, o.layoutAlgorithm = om(s), o.nodeSpacing = a?.nodeSpacing || 50, o.rankSpacing = a?.rankSpacing || 50, o.markers = ["aggregation", "extension", "composition", "dependency", "lollipop"], o.diagramId = e, await I0(o, l);
  const u = 8;
  Jt.insertTitle(
    l,
    "classDiagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), Oh(l, u, "classDiagram", a?.useMaxWidth ?? !0);
}, "draw"), Gce = {
  getClasses: Krt,
  draw: Zrt,
  getDir: jrt
}, Qrt = {
  parser: Fce,
  get db() {
    return new zce();
  },
  renderer: Gce,
  styles: qce,
  init: /* @__PURE__ */ w((t) => {
    t.class || (t.class = {}), t.class.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const Jrt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Qrt
}, Symbol.toStringTag, { value: "Module" }));
var ent = {
  parser: Fce,
  get db() {
    return new zce();
  },
  renderer: Gce,
  styles: qce,
  init: /* @__PURE__ */ w((t) => {
    t.class || (t.class = {}), t.class.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const tnt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: ent
}, Symbol.toStringTag, { value: "Module" }));
var V8 = (function() {
  var t = /* @__PURE__ */ w(function($, z, B, G) {
    for (B = B || {}, G = $.length; G--; B[$[G]] = z) ;
    return B;
  }, "o"), e = [1, 2], r = [1, 3], n = [1, 4], i = [2, 4], a = [1, 9], s = [1, 11], o = [1, 16], l = [1, 17], u = [1, 18], h = [1, 19], f = [1, 33], d = [1, 20], p = [1, 21], g = [1, 22], m = [1, 23], v = [1, 24], y = [1, 26], b = [1, 27], x = [1, 28], T = [1, 29], E = [1, 30], A = [1, 31], S = [1, 32], k = [1, 35], _ = [1, 36], R = [1, 37], L = [1, 38], M = [1, 34], P = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], C = [1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 39, 40, 41, 45, 48, 51, 52, 53, 54, 57], I = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], N = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NL: 5, SD: 6, document: 7, line: 8, statement: 9, classDefStatement: 10, styleStatement: 11, cssClassStatement: 12, idStatement: 13, DESCR: 14, "-->": 15, HIDE_EMPTY: 16, scale: 17, WIDTH: 18, COMPOSIT_STATE: 19, STRUCT_START: 20, STRUCT_STOP: 21, STATE_DESCR: 22, AS: 23, ID: 24, FORK: 25, JOIN: 26, CHOICE: 27, CONCURRENT: 28, note: 29, notePosition: 30, NOTE_TEXT: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, CLICK: 38, STRING: 39, HREF: 40, classDef: 41, CLASSDEF_ID: 42, CLASSDEF_STYLEOPTS: 43, DEFAULT: 44, style: 45, STYLE_IDS: 46, STYLEDEF_STYLEOPTS: 47, class: 48, CLASSENTITY_IDS: 49, STYLECLASS: 50, direction_tb: 51, direction_bt: 52, direction_rl: 53, direction_lr: 54, eol: 55, ";": 56, EDGE_STATE: 57, STYLE_SEPARATOR: 58, left_of: 59, right_of: 60, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NL", 6: "SD", 14: "DESCR", 15: "-->", 16: "HIDE_EMPTY", 17: "scale", 18: "WIDTH", 19: "COMPOSIT_STATE", 20: "STRUCT_START", 21: "STRUCT_STOP", 22: "STATE_DESCR", 23: "AS", 24: "ID", 25: "FORK", 26: "JOIN", 27: "CHOICE", 28: "CONCURRENT", 29: "note", 31: "NOTE_TEXT", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 38: "CLICK", 39: "STRING", 40: "HREF", 41: "classDef", 42: "CLASSDEF_ID", 43: "CLASSDEF_STYLEOPTS", 44: "DEFAULT", 45: "style", 46: "STYLE_IDS", 47: "STYLEDEF_STYLEOPTS", 48: "class", 49: "CLASSENTITY_IDS", 50: "STYLECLASS", 51: "direction_tb", 52: "direction_bt", 53: "direction_rl", 54: "direction_lr", 56: ";", 57: "EDGE_STATE", 58: "STYLE_SEPARATOR", 59: "left_of", 60: "right_of" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 3], [9, 4], [9, 1], [9, 2], [9, 1], [9, 4], [9, 3], [9, 6], [9, 1], [9, 1], [9, 1], [9, 1], [9, 4], [9, 4], [9, 1], [9, 2], [9, 2], [9, 1], [9, 5], [9, 5], [10, 3], [10, 3], [11, 3], [12, 3], [32, 1], [32, 1], [32, 1], [32, 1], [55, 1], [55, 1], [13, 1], [13, 1], [13, 3], [13, 3], [30, 1], [30, 1]],
    performAction: /* @__PURE__ */ w(function(z, B, G, W, V, U, Z) {
      var K = U.length - 1;
      switch (V) {
        case 3:
          return W.setRootDoc(U[K]), U[K];
        case 4:
          this.$ = [];
          break;
        case 5:
          U[K] != "nl" && (U[K - 1].push(U[K]), this.$ = U[K - 1]);
          break;
        case 6:
        case 7:
          this.$ = U[K];
          break;
        case 8:
          this.$ = "nl";
          break;
        case 12:
          this.$ = U[K];
          break;
        case 13:
          const j = U[K - 1];
          j.description = W.trimColon(U[K]), this.$ = j;
          break;
        case 14:
          this.$ = { stmt: "relation", state1: U[K - 2], state2: U[K] };
          break;
        case 15:
          const X = W.trimColon(U[K]);
          this.$ = { stmt: "relation", state1: U[K - 3], state2: U[K - 1], description: X };
          break;
        case 19:
          this.$ = { stmt: "state", id: U[K - 3], type: "default", description: "", doc: U[K - 1] };
          break;
        case 20:
          var ce = U[K], J = U[K - 2].trim();
          if (U[K].match(":")) {
            var ee = U[K].split(":");
            ce = ee[0], J = [J, ee[1]];
          }
          this.$ = { stmt: "state", id: ce, type: "default", description: J };
          break;
        case 21:
          this.$ = { stmt: "state", id: U[K - 3], type: "default", description: U[K - 5], doc: U[K - 1] };
          break;
        case 22:
          this.$ = { stmt: "state", id: U[K], type: "fork" };
          break;
        case 23:
          this.$ = { stmt: "state", id: U[K], type: "join" };
          break;
        case 24:
          this.$ = { stmt: "state", id: U[K], type: "choice" };
          break;
        case 25:
          this.$ = { stmt: "state", id: W.getDividerId(), type: "divider" };
          break;
        case 26:
          this.$ = { stmt: "state", id: U[K - 1].trim(), note: { position: U[K - 2].trim(), text: U[K].trim() } };
          break;
        case 29:
          this.$ = U[K].trim(), W.setAccTitle(this.$);
          break;
        case 30:
        case 31:
          this.$ = U[K].trim(), W.setAccDescription(this.$);
          break;
        case 32:
          this.$ = {
            stmt: "click",
            id: U[K - 3],
            url: U[K - 2],
            tooltip: U[K - 1]
          };
          break;
        case 33:
          this.$ = {
            stmt: "click",
            id: U[K - 3],
            url: U[K - 1],
            tooltip: ""
          };
          break;
        case 34:
        case 35:
          this.$ = { stmt: "classDef", id: U[K - 1].trim(), classes: U[K].trim() };
          break;
        case 36:
          this.$ = { stmt: "style", id: U[K - 1].trim(), styleClass: U[K].trim() };
          break;
        case 37:
          this.$ = { stmt: "applyClass", id: U[K - 1].trim(), styleClass: U[K].trim() };
          break;
        case 38:
          W.setDirection("TB"), this.$ = { stmt: "dir", value: "TB" };
          break;
        case 39:
          W.setDirection("BT"), this.$ = { stmt: "dir", value: "BT" };
          break;
        case 40:
          W.setDirection("RL"), this.$ = { stmt: "dir", value: "RL" };
          break;
        case 41:
          W.setDirection("LR"), this.$ = { stmt: "dir", value: "LR" };
          break;
        case 44:
        case 45:
          this.$ = { stmt: "state", id: U[K].trim(), type: "default", description: "" };
          break;
        case 46:
          this.$ = { stmt: "state", id: U[K - 2].trim(), classes: [U[K].trim()], type: "default", description: "" };
          break;
        case 47:
          this.$ = { stmt: "state", id: U[K - 2].trim(), classes: [U[K].trim()], type: "default", description: "" };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: e, 5: r, 6: n }, { 1: [3] }, { 3: 5, 4: e, 5: r, 6: n }, { 3: 6, 4: e, 5: r, 6: n }, t([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], i, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: a, 5: s, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 22: h, 24: f, 25: d, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: x, 38: T, 41: E, 45: A, 48: S, 51: k, 52: _, 53: R, 54: L, 57: M }, t(P, [2, 5]), { 9: 39, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 22: h, 24: f, 25: d, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: x, 38: T, 41: E, 45: A, 48: S, 51: k, 52: _, 53: R, 54: L, 57: M }, t(P, [2, 7]), t(P, [2, 8]), t(P, [2, 9]), t(P, [2, 10]), t(P, [2, 11]), t(P, [2, 12], { 14: [1, 40], 15: [1, 41] }), t(P, [2, 16]), { 18: [1, 42] }, t(P, [2, 18], { 20: [1, 43] }), { 23: [1, 44] }, t(P, [2, 22]), t(P, [2, 23]), t(P, [2, 24]), t(P, [2, 25]), { 30: 45, 31: [1, 46], 59: [1, 47], 60: [1, 48] }, t(P, [2, 28]), { 34: [1, 49] }, { 36: [1, 50] }, t(P, [2, 31]), { 13: 51, 24: f, 57: M }, { 42: [1, 52], 44: [1, 53] }, { 46: [1, 54] }, { 49: [1, 55] }, t(C, [2, 44], { 58: [1, 56] }), t(C, [2, 45], { 58: [1, 57] }), t(P, [2, 38]), t(P, [2, 39]), t(P, [2, 40]), t(P, [2, 41]), t(P, [2, 6]), t(P, [2, 13]), { 13: 58, 24: f, 57: M }, t(P, [2, 17]), t(I, i, { 7: 59 }), { 24: [1, 60] }, { 24: [1, 61] }, { 23: [1, 62] }, { 24: [2, 48] }, { 24: [2, 49] }, t(P, [2, 29]), t(P, [2, 30]), { 39: [1, 63], 40: [1, 64] }, { 43: [1, 65] }, { 43: [1, 66] }, { 47: [1, 67] }, { 50: [1, 68] }, { 24: [1, 69] }, { 24: [1, 70] }, t(P, [2, 14], { 14: [1, 71] }), { 4: a, 5: s, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 21: [1, 72], 22: h, 24: f, 25: d, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: x, 38: T, 41: E, 45: A, 48: S, 51: k, 52: _, 53: R, 54: L, 57: M }, t(P, [2, 20], { 20: [1, 73] }), { 31: [1, 74] }, { 24: [1, 75] }, { 39: [1, 76] }, { 39: [1, 77] }, t(P, [2, 34]), t(P, [2, 35]), t(P, [2, 36]), t(P, [2, 37]), t(C, [2, 46]), t(C, [2, 47]), t(P, [2, 15]), t(P, [2, 19]), t(I, i, { 7: 78 }), t(P, [2, 26]), t(P, [2, 27]), { 5: [1, 79] }, { 5: [1, 80] }, { 4: a, 5: s, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: l, 19: u, 21: [1, 81], 22: h, 24: f, 25: d, 26: p, 27: g, 28: m, 29: v, 32: 25, 33: y, 35: b, 37: x, 38: T, 41: E, 45: A, 48: S, 51: k, 52: _, 53: R, 54: L, 57: M }, t(P, [2, 32]), t(P, [2, 33]), t(P, [2, 21])],
    defaultActions: { 5: [2, 1], 6: [2, 2], 47: [2, 48], 48: [2, 49] },
    parseError: /* @__PURE__ */ w(function(z, B) {
      if (B.recoverable)
        this.trace(z);
      else {
        var G = new Error(z);
        throw G.hash = B, G;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(z) {
      var B = this, G = [0], W = [], V = [null], U = [], Z = this.table, K = "", ce = 0, J = 0, ee = 2, j = 1, X = U.slice.call(arguments, 1), re = Object.create(this.lexer), Q = { yy: {} };
      for (var ue in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ue) && (Q.yy[ue] = this.yy[ue]);
      re.setInput(z, Q.yy), Q.yy.lexer = re, Q.yy.parser = this, typeof re.yylloc > "u" && (re.yylloc = {});
      var ne = re.yylloc;
      U.push(ne);
      var xe = re.options && re.options.ranges;
      typeof Q.yy.parseError == "function" ? this.parseError = Q.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Y(Ie) {
        G.length = G.length - 2 * Ie, V.length = V.length - Ie, U.length = U.length - Ie;
      }
      w(Y, "popStack");
      function Ne() {
        var Ie;
        return Ie = W.pop() || re.lex() || j, typeof Ie != "number" && (Ie instanceof Array && (W = Ie, Ie = W.pop()), Ie = B.symbols_[Ie] || Ie), Ie;
      }
      w(Ne, "lex");
      for (var fe, qe, ze, Ge, Ee = {}, Oe, Ce, Ae, $e; ; ) {
        if (qe = G[G.length - 1], this.defaultActions[qe] ? ze = this.defaultActions[qe] : ((fe === null || typeof fe > "u") && (fe = Ne()), ze = Z[qe] && Z[qe][fe]), typeof ze > "u" || !ze.length || !ze[0]) {
          var me = "";
          $e = [];
          for (Oe in Z[qe])
            this.terminals_[Oe] && Oe > ee && $e.push("'" + this.terminals_[Oe] + "'");
          re.showPosition ? me = "Parse error on line " + (ce + 1) + `:
` + re.showPosition() + `
Expecting ` + $e.join(", ") + ", got '" + (this.terminals_[fe] || fe) + "'" : me = "Parse error on line " + (ce + 1) + ": Unexpected " + (fe == j ? "end of input" : "'" + (this.terminals_[fe] || fe) + "'"), this.parseError(me, {
            text: re.match,
            token: this.terminals_[fe] || fe,
            line: re.yylineno,
            loc: ne,
            expected: $e
          });
        }
        if (ze[0] instanceof Array && ze.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + qe + ", token: " + fe);
        switch (ze[0]) {
          case 1:
            G.push(fe), V.push(re.yytext), U.push(re.yylloc), G.push(ze[1]), fe = null, J = re.yyleng, K = re.yytext, ce = re.yylineno, ne = re.yylloc;
            break;
          case 2:
            if (Ce = this.productions_[ze[1]][1], Ee.$ = V[V.length - Ce], Ee._$ = {
              first_line: U[U.length - (Ce || 1)].first_line,
              last_line: U[U.length - 1].last_line,
              first_column: U[U.length - (Ce || 1)].first_column,
              last_column: U[U.length - 1].last_column
            }, xe && (Ee._$.range = [
              U[U.length - (Ce || 1)].range[0],
              U[U.length - 1].range[1]
            ]), Ge = this.performAction.apply(Ee, [
              K,
              J,
              ce,
              Q.yy,
              ze[1],
              V,
              U
            ].concat(X)), typeof Ge < "u")
              return Ge;
            Ce && (G = G.slice(0, -1 * Ce * 2), V = V.slice(0, -1 * Ce), U = U.slice(0, -1 * Ce)), G.push(this.productions_[ze[1]][0]), V.push(Ee.$), U.push(Ee._$), Ae = Z[G[G.length - 2]][G[G.length - 1]], G.push(Ae);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, O = /* @__PURE__ */ (function() {
    var $ = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(B, G) {
        if (this.yy.parser)
          this.yy.parser.parseError(B, G);
        else
          throw new Error(B);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(z, B) {
        return this.yy = B || this.yy || {}, this._input = z, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var z = this._input[0];
        this.yytext += z, this.yyleng++, this.offset++, this.match += z, this.matched += z;
        var B = z.match(/(?:\r\n?|\n).*/g);
        return B ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), z;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(z) {
        var B = z.length, G = z.split(/(?:\r\n?|\n)/g);
        this._input = z + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - B), this.offset -= B;
        var W = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), G.length - 1 && (this.yylineno -= G.length - 1);
        var V = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: G ? (G.length === W.length ? this.yylloc.first_column : 0) + W[W.length - G.length].length - G[0].length : this.yylloc.first_column - B
        }, this.options.ranges && (this.yylloc.range = [V[0], V[0] + this.yyleng - B]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(z) {
        this.unput(this.match.slice(z));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var z = this.matched.substr(0, this.matched.length - this.match.length);
        return (z.length > 20 ? "..." : "") + z.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var z = this.match;
        return z.length < 20 && (z += this._input.substr(0, 20 - z.length)), (z.substr(0, 20) + (z.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var z = this.pastInput(), B = new Array(z.length + 1).join("-");
        return z + this.upcomingInput() + `
` + B + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(z, B) {
        var G, W, V;
        if (this.options.backtrack_lexer && (V = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (V.yylloc.range = this.yylloc.range.slice(0))), W = z[0].match(/(?:\r\n?|\n).*/g), W && (this.yylineno += W.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: W ? W[W.length - 1].length - W[W.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + z[0].length
        }, this.yytext += z[0], this.match += z[0], this.matches = z, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(z[0].length), this.matched += z[0], G = this.performAction.call(this, this.yy, this, B, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), G)
          return G;
        if (this._backtrack) {
          for (var U in V)
            this[U] = V[U];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var z, B, G, W;
        this._more || (this.yytext = "", this.match = "");
        for (var V = this._currentRules(), U = 0; U < V.length; U++)
          if (G = this._input.match(this.rules[V[U]]), G && (!B || G[0].length > B[0].length)) {
            if (B = G, W = U, this.options.backtrack_lexer) {
              if (z = this.test_match(G, V[U]), z !== !1)
                return z;
              if (this._backtrack) {
                B = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return B ? (z = this.test_match(B, V[W]), z !== !1 ? z : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var B = this.next();
        return B || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(B) {
        this.conditionStack.push(B);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var B = this.conditionStack.length - 1;
        return B > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(B) {
        return B = this.conditionStack.length - 1 - Math.abs(B || 0), B >= 0 ? this.conditionStack[B] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(B) {
        this.begin(B);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(B, G, W, V) {
        switch (W) {
          case 0:
            return 38;
          case 1:
            return 40;
          case 2:
            return 39;
          case 3:
            return 44;
          case 4:
            return 51;
          case 5:
            return 52;
          case 6:
            return 53;
          case 7:
            return 54;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return 5;
          case 11:
            break;
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return this.pushState("SCALE"), 17;
          case 16:
            return 18;
          case 17:
            this.popState();
            break;
          case 18:
            return this.begin("acc_title"), 33;
          case 19:
            return this.popState(), "acc_title_value";
          case 20:
            return this.begin("acc_descr"), 35;
          case 21:
            return this.popState(), "acc_descr_value";
          case 22:
            this.begin("acc_descr_multiline");
            break;
          case 23:
            this.popState();
            break;
          case 24:
            return "acc_descr_multiline_value";
          case 25:
            return this.pushState("CLASSDEF"), 41;
          case 26:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 27:
            return this.popState(), this.pushState("CLASSDEFID"), 42;
          case 28:
            return this.popState(), 43;
          case 29:
            return this.pushState("CLASS"), 48;
          case 30:
            return this.popState(), this.pushState("CLASS_STYLE"), 49;
          case 31:
            return this.popState(), 50;
          case 32:
            return this.pushState("STYLE"), 45;
          case 33:
            return this.popState(), this.pushState("STYLEDEF_STYLES"), 46;
          case 34:
            return this.popState(), 47;
          case 35:
            return this.pushState("SCALE"), 17;
          case 36:
            return 18;
          case 37:
            this.popState();
            break;
          case 38:
            this.pushState("STATE");
            break;
          case 39:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 25;
          case 40:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 26;
          case 41:
            return this.popState(), G.yytext = G.yytext.slice(0, -10).trim(), 27;
          case 42:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 25;
          case 43:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 26;
          case 44:
            return this.popState(), G.yytext = G.yytext.slice(0, -10).trim(), 27;
          case 45:
            return 51;
          case 46:
            return 52;
          case 47:
            return 53;
          case 48:
            return 54;
          case 49:
            this.pushState("STATE_STRING");
            break;
          case 50:
            return this.pushState("STATE_ID"), "AS";
          case 51:
            return this.popState(), "ID";
          case 52:
            this.popState();
            break;
          case 53:
            return "STATE_DESCR";
          case 54:
            return 19;
          case 55:
            this.popState();
            break;
          case 56:
            return this.popState(), this.pushState("struct"), 20;
          case 57:
            break;
          case 58:
            return this.popState(), 21;
          case 59:
            break;
          case 60:
            return this.begin("NOTE"), 29;
          case 61:
            return this.popState(), this.pushState("NOTE_ID"), 59;
          case 62:
            return this.popState(), this.pushState("NOTE_ID"), 60;
          case 63:
            this.popState(), this.pushState("FLOATING_NOTE");
            break;
          case 64:
            return this.popState(), this.pushState("FLOATING_NOTE_ID"), "AS";
          case 65:
            break;
          case 66:
            return "NOTE_TEXT";
          case 67:
            return this.popState(), "ID";
          case 68:
            return this.popState(), this.pushState("NOTE_TEXT"), 24;
          case 69:
            return this.popState(), G.yytext = G.yytext.substr(2).trim(), 31;
          case 70:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 31;
          case 71:
            return 6;
          case 72:
            return 6;
          case 73:
            return 16;
          case 74:
            return 57;
          case 75:
            return 24;
          case 76:
            return G.yytext = G.yytext.trim(), 14;
          case 77:
            return 15;
          case 78:
            return 28;
          case 79:
            return 58;
          case 80:
            return 5;
          case 81:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:click\b)/i, /^(?:href\b)/i, /^(?:"[^"]*")/i, /^(?:default\b)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:classDef\s+)/i, /^(?:DEFAULT\s+)/i, /^(?:\w+\s+)/i, /^(?:[^\n]*)/i, /^(?:class\s+)/i, /^(?:(\w+)+((,\s*\w+)*))/i, /^(?:[^\n]*)/i, /^(?:style\s+)/i, /^(?:[\w,]+\s+)/i, /^(?:[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?::::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { LINE: { rules: [12, 13], inclusive: !1 }, struct: { rules: [12, 13, 25, 29, 32, 38, 45, 46, 47, 48, 57, 58, 59, 60, 74, 75, 76, 77, 78], inclusive: !1 }, FLOATING_NOTE_ID: { rules: [67], inclusive: !1 }, FLOATING_NOTE: { rules: [64, 65, 66], inclusive: !1 }, NOTE_TEXT: { rules: [69, 70], inclusive: !1 }, NOTE_ID: { rules: [68], inclusive: !1 }, NOTE: { rules: [61, 62, 63], inclusive: !1 }, STYLEDEF_STYLEOPTS: { rules: [], inclusive: !1 }, STYLEDEF_STYLES: { rules: [34], inclusive: !1 }, STYLE_IDS: { rules: [], inclusive: !1 }, STYLE: { rules: [33], inclusive: !1 }, CLASS_STYLE: { rules: [31], inclusive: !1 }, CLASS: { rules: [30], inclusive: !1 }, CLASSDEFID: { rules: [28], inclusive: !1 }, CLASSDEF: { rules: [26, 27], inclusive: !1 }, acc_descr_multiline: { rules: [23, 24], inclusive: !1 }, acc_descr: { rules: [21], inclusive: !1 }, acc_title: { rules: [19], inclusive: !1 }, SCALE: { rules: [16, 17, 36, 37], inclusive: !1 }, ALIAS: { rules: [], inclusive: !1 }, STATE_ID: { rules: [51], inclusive: !1 }, STATE_STRING: { rules: [52, 53], inclusive: !1 }, FORK_STATE: { rules: [], inclusive: !1 }, STATE: { rules: [12, 13, 39, 40, 41, 42, 43, 44, 49, 50, 54, 55, 56], inclusive: !1 }, ID: { rules: [12, 13], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 18, 20, 22, 25, 29, 32, 35, 38, 56, 60, 71, 72, 73, 74, 75, 76, 77, 79, 80, 81], inclusive: !0 } }
    };
    return $;
  })();
  N.lexer = O;
  function D() {
    this.yy = {};
  }
  return w(D, "Parser"), D.prototype = N, N.Parser = D, new D();
})();
V8.parser = V8;
var Uce = V8, rnt = "TB", Vce = "TB", eY = "dir", yf = "state", uf = "root", H8 = "relation", nnt = "classDef", int = "style", ant = "applyClass", Xg = "default", Hce = "divider", Wce = "fill:none", Yce = "fill: #333", Xce = "c", jce = "text", Kce = "normal", z7 = "rect", q7 = "rectWithTitle", snt = "stateStart", ont = "stateEnd", tY = "divider", rY = "roundedWithTitle", lnt = "note", cnt = "noteGroup", Xm = "statediagram", unt = "state", hnt = `${Xm}-${unt}`, Zce = "transition", fnt = "note", dnt = "note-edge", pnt = `${Zce} ${dnt}`, gnt = `${Xm}-${fnt}`, mnt = "cluster", vnt = `${Xm}-${mnt}`, ynt = "cluster-alt", bnt = `${Xm}-${ynt}`, Qce = "parent", Jce = "note", xnt = "state", oM = "----", wnt = `${oM}${Jce}`, nY = `${oM}${Qce}`, eue = /* @__PURE__ */ w((t, e = Vce) => {
  if (!t.doc)
    return e;
  let r = e;
  for (const n of t.doc)
    n.stmt === "dir" && (r = n.value);
  return r;
}, "getDir"), Tnt = /* @__PURE__ */ w(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), Ent = /* @__PURE__ */ w(async function(t, e, r, n) {
  ae.info("REF0:"), ae.info("Drawing state diagram (v2)", e);
  const { securityLevel: i, state: a, layout: s } = Te();
  n.db.extract(n.db.getRootDocV2());
  const o = n.db.getData(), l = Y0(e, i);
  o.type = n.type, o.layoutAlgorithm = s, o.nodeSpacing = a?.nodeSpacing || 50, o.rankSpacing = a?.rankSpacing || 50, o.markers = ["barb"], o.diagramId = e, await I0(o, l);
  const u = 8;
  try {
    (typeof n.db.getLinks == "function" ? n.db.getLinks() : /* @__PURE__ */ new Map()).forEach((f, d) => {
      const p = typeof d == "string" ? d : typeof d?.id == "string" ? d.id : "";
      if (!p) {
        ae.warn("\u26A0\uFE0F Invalid or missing stateId from key:", JSON.stringify(d));
        return;
      }
      const g = l.node()?.querySelectorAll("g");
      let m;
      if (g?.forEach((x) => {
        x.textContent?.trim() === p && (m = x);
      }), !m) {
        ae.warn("\u26A0\uFE0F Could not find node matching text:", p);
        return;
      }
      const v = m.parentNode;
      if (!v) {
        ae.warn("\u26A0\uFE0F Node has no parent, cannot wrap:", p);
        return;
      }
      const y = document.createElementNS("http://www.w3.org/2000/svg", "a"), b = f.url.replace(/^"+|"+$/g, "");
      if (y.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", b), y.setAttribute("target", "_blank"), f.tooltip) {
        const x = f.tooltip.replace(/^"+|"+$/g, "");
        y.setAttribute("title", x);
      }
      v.replaceChild(y, m), y.appendChild(m), ae.info("\u{1F517} Wrapped node in <a> tag for:", p, f.url);
    });
  } catch (h) {
    ae.error("\u274C Error injecting clickable links:", h);
  }
  Jt.insertTitle(
    l,
    "statediagramTitleText",
    a?.titleTopMargin ?? 25,
    n.db.getDiagramTitle()
  ), Oh(l, u, Xm, a?.useMaxWidth ?? !0);
}, "draw"), Snt = {
  getClasses: Tnt,
  draw: Ent,
  getDir: eue
}, y2 = /* @__PURE__ */ new Map(), Kl = 0;
function b2(t = "", e = 0, r = "", n = oM) {
  const i = r !== null && r.length > 0 ? `${n}${r}` : "";
  return `${xnt}-${t}${i}-${e}`;
}
w(b2, "stateDomId");
var knt = /* @__PURE__ */ w((t, e, r, n, i, a, s, o) => {
  ae.trace("items", e), e.forEach((l) => {
    switch (l.stmt) {
      case yf:
        Rg(t, l, r, n, i, a, s, o);
        break;
      case Xg:
        Rg(t, l, r, n, i, a, s, o);
        break;
      case H8:
        {
          Rg(
            t,
            l.state1,
            r,
            n,
            i,
            a,
            s,
            o
          ), Rg(
            t,
            l.state2,
            r,
            n,
            i,
            a,
            s,
            o
          );
          const u = {
            id: "edge" + Kl,
            start: l.state1.id,
            end: l.state2.id,
            arrowhead: "normal",
            arrowTypeEnd: "arrow_barb",
            style: Wce,
            labelStyle: "",
            label: at.sanitizeText(l.description ?? "", Te()),
            arrowheadStyle: Yce,
            labelpos: Xce,
            labelType: jce,
            thickness: Kce,
            classes: Zce,
            look: s
          };
          i.push(u), Kl++;
        }
        break;
    }
  });
}, "setupDoc"), iY = /* @__PURE__ */ w((t, e = Vce) => {
  let r = e;
  if (t.doc)
    for (const n of t.doc)
      n.stmt === "dir" && (r = n.value);
  return r;
}, "getDir");
function Lg(t, e, r) {
  if (!e.id || e.id === "</join></fork>" || e.id === "</choice>")
    return;
  e.cssClasses && (Array.isArray(e.cssCompiledStyles) || (e.cssCompiledStyles = []), e.cssClasses.split(" ").forEach((i) => {
    const a = r.get(i);
    a && (e.cssCompiledStyles = [...e.cssCompiledStyles ?? [], ...a.styles]);
  }));
  const n = t.find((i) => i.id === e.id);
  n ? Object.assign(n, e) : t.push(e);
}
w(Lg, "insertOrUpdateNode");
function tue(t) {
  return t?.classes?.join(" ") ?? "";
}
w(tue, "getClassesFromDbInfo");
function rue(t) {
  return t?.styles ?? [];
}
w(rue, "getStylesFromDbInfo");
var Rg = /* @__PURE__ */ w((t, e, r, n, i, a, s, o) => {
  const l = e.id, u = r.get(l), h = tue(u), f = rue(u), d = Te();
  if (ae.info("dataFetcher parsedItem", e, u, f), l !== "root") {
    let p = z7;
    e.start === !0 ? p = snt : e.start === !1 && (p = ont), e.type !== Xg && (p = e.type), y2.get(l) || y2.set(l, {
      id: l,
      shape: p,
      description: at.sanitizeText(l, d),
      cssClasses: `${h} ${hnt}`,
      cssStyles: f
    });
    const g = y2.get(l);
    e.description && (Array.isArray(g.description) ? (g.shape = q7, g.description.push(e.description)) : g.description?.length && g.description.length > 0 ? (g.shape = q7, g.description === l ? g.description = [e.description] : g.description = [g.description, e.description]) : (g.shape = z7, g.description = e.description), g.description = at.sanitizeTextOrArray(g.description, d)), g.description?.length === 1 && g.shape === q7 && (g.type === "group" ? g.shape = rY : g.shape = z7), !g.type && e.doc && (ae.info("Setting cluster for XCX", l, iY(e)), g.type = "group", g.isGroup = !0, g.dir = iY(e), g.shape = e.type === Hce ? tY : rY, g.cssClasses = `${g.cssClasses} ${vnt} ${a ? bnt : ""}`);
    const m = {
      labelStyle: "",
      shape: g.shape,
      label: g.description,
      cssClasses: g.cssClasses,
      cssCompiledStyles: [],
      cssStyles: g.cssStyles,
      id: l,
      dir: g.dir,
      domId: b2(l, Kl),
      type: g.type,
      isGroup: g.type === "group",
      padding: 8,
      rx: 10,
      ry: 10,
      look: s
    };
    if (m.shape === tY && (m.label = ""), t && t.id !== "root" && (ae.trace("Setting node ", l, " to be child of its parent ", t.id), m.parentId = t.id), m.centerLabel = !0, e.note) {
      const v = {
        labelStyle: "",
        shape: lnt,
        label: e.note.text,
        cssClasses: gnt,
        // useHtmlLabels: false,
        cssStyles: [],
        cssCompiledStyles: [],
        id: l + wnt + "-" + Kl,
        domId: b2(l, Kl, Jce),
        type: g.type,
        isGroup: g.type === "group",
        padding: d.flowchart?.padding,
        look: s,
        position: e.note.position
      }, y = l + nY, b = {
        labelStyle: "",
        shape: cnt,
        label: e.note.text,
        cssClasses: g.cssClasses,
        cssStyles: [],
        id: l + nY,
        domId: b2(l, Kl, Qce),
        type: "group",
        isGroup: !0,
        padding: 16,
        //getConfig().flowchart.padding
        look: s,
        position: e.note.position
      };
      Kl++, b.id = y, v.parentId = y, Lg(n, b, o), Lg(n, v, o), Lg(n, m, o);
      let x = l, T = v.id;
      e.note.position === "left of" && (x = v.id, T = l), i.push({
        id: x + "-" + T,
        start: x,
        end: T,
        arrowhead: "none",
        arrowTypeEnd: "",
        style: Wce,
        labelStyle: "",
        classes: pnt,
        arrowheadStyle: Yce,
        labelpos: Xce,
        labelType: jce,
        thickness: Kce,
        look: s
      });
    } else
      Lg(n, m, o);
  }
  e.doc && (ae.trace("Adding nodes children "), knt(e, e.doc, r, n, i, !a, s, o));
}, "dataFetcher"), Cnt = /* @__PURE__ */ w(() => {
  y2.clear(), Kl = 0;
}, "reset"), $i = {
  START_NODE: "[*]",
  START_TYPE: "start",
  END_NODE: "[*]",
  END_TYPE: "end",
  COLOR_KEYWORD: "color",
  FILL_KEYWORD: "fill",
  BG_FILL: "bgFill",
  STYLECLASS_SEP: ","
}, aY = /* @__PURE__ */ w(() => /* @__PURE__ */ new Map(), "newClassesList"), sY = /* @__PURE__ */ w(() => ({
  relations: [],
  states: /* @__PURE__ */ new Map(),
  documents: {}
}), "newDoc"), fy = /* @__PURE__ */ w((t) => JSON.parse(JSON.stringify(t)), "clone"), zu, Cu = (zu = class {
  constructor(e) {
    this.version = e, this.nodes = [], this.edges = [], this.rootDoc = [], this.classes = aY(), this.documents = { root: sY() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.dividerCnt = 0, this.links = /* @__PURE__ */ new Map(), this.getAccTitle = Hn, this.setAccTitle = Ln, this.getAccDescription = Yn, this.setAccDescription = Wn, this.setDiagramTitle = ti, this.getDiagramTitle = Mn, this.clear(), this.setRootDoc = this.setRootDoc.bind(this), this.getDividerId = this.getDividerId.bind(this), this.setDirection = this.setDirection.bind(this), this.trimColon = this.trimColon.bind(this);
  }
  /**
   * Convert all of the statements (stmts) that were parsed into states and relationships.
   * This is done because a state diagram may have nested sections,
   * where each section is a 'document' and has its own set of statements.
   * Ex: the section within a fork has its own statements, and incoming and outgoing statements
   * refer to the fork as a whole (document).
   * See the parser grammar:  the definition of a document is a document then a 'line', where a line can be a statement.
   * This will push the statement into the list of statements for the current document.
   */
  extract(e) {
    this.clear(!0);
    for (const i of Array.isArray(e) ? e : e.doc)
      switch (i.stmt) {
        case yf:
          this.addState(i.id.trim(), i.type, i.doc, i.description, i.note);
          break;
        case H8:
          this.addRelation(i.state1, i.state2, i.description);
          break;
        case nnt:
          this.addStyleClass(i.id.trim(), i.classes);
          break;
        case int:
          this.handleStyleDef(i);
          break;
        case ant:
          this.setCssClass(i.id.trim(), i.styleClass);
          break;
        case "click":
          this.addLink(i.id, i.url, i.tooltip);
          break;
      }
    const r = this.getStates(), n = Te();
    Cnt(), Rg(
      void 0,
      this.getRootDocV2(),
      r,
      this.nodes,
      this.edges,
      !0,
      n.look,
      this.classes
    );
    for (const i of this.nodes)
      if (Array.isArray(i.label)) {
        if (i.description = i.label.slice(1), i.isGroup && i.description.length > 0)
          throw new Error(
            `Group nodes can only have label. Remove the additional description for node [${i.id}]`
          );
        i.label = i.label[0];
      }
  }
  handleStyleDef(e) {
    const r = e.id.trim().split(","), n = e.styleClass.split(",");
    for (const i of r) {
      let a = this.getState(i);
      if (!a) {
        const s = i.trim();
        this.addState(s), a = this.getState(s);
      }
      a && (a.styles = n.map((s) => s.replace(/;/g, "")?.trim()));
    }
  }
  setRootDoc(e) {
    ae.info("Setting root doc", e), this.rootDoc = e, this.version === 1 ? this.extract(e) : this.extract(this.getRootDocV2());
  }
  docTranslator(e, r, n) {
    if (r.stmt === H8) {
      this.docTranslator(e, r.state1, !0), this.docTranslator(e, r.state2, !1);
      return;
    }
    if (r.stmt === yf && (r.id === $i.START_NODE ? (r.id = e.id + (n ? "_start" : "_end"), r.start = n) : r.id = r.id.trim()), r.stmt !== uf && r.stmt !== yf || !r.doc)
      return;
    const i = [];
    let a = [];
    for (const s of r.doc)
      if (s.type === Hce) {
        const o = fy(s);
        o.doc = fy(a), i.push(o), a = [];
      } else
        a.push(s);
    if (i.length > 0 && a.length > 0) {
      const s = {
        stmt: yf,
        id: RZ(),
        type: "divider",
        doc: fy(a)
      };
      i.push(fy(s)), r.doc = i;
    }
    r.doc.forEach((s) => this.docTranslator(r, s, !0));
  }
  getRootDocV2() {
    return this.docTranslator(
      { id: uf, stmt: uf },
      { id: uf, stmt: uf, doc: this.rootDoc },
      !0
    ), { id: uf, doc: this.rootDoc };
  }
  /**
   * Function called by parser when a node definition has been found.
   *
   * @param descr - description for the state. Can be a string or a list or strings
   * @param classes - class styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 class, convert it to an array of that 1 class.
   * @param styles - styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 style, convert it to an array of that 1 style.
   * @param textStyles - text styles to apply to this state. Can be a string (1 text test) or an array of text styles. If it's just 1 text style, convert it to an array of that 1 text style.
   */
  addState(e, r = Xg, n = void 0, i = void 0, a = void 0, s = void 0, o = void 0, l = void 0) {
    const u = e?.trim();
    if (!this.currentDocument.states.has(u))
      ae.info("Adding state ", u, i), this.currentDocument.states.set(u, {
        stmt: yf,
        id: u,
        descriptions: [],
        type: r,
        doc: n,
        note: a,
        classes: [],
        styles: [],
        textStyles: []
      });
    else {
      const h = this.currentDocument.states.get(u);
      if (!h)
        throw new Error(`State not found: ${u}`);
      h.doc || (h.doc = n), h.type || (h.type = r);
    }
    if (i && (ae.info("Setting state description", u, i), (Array.isArray(i) ? i : [i]).forEach((f) => this.addDescription(u, f.trim()))), a) {
      const h = this.currentDocument.states.get(u);
      if (!h)
        throw new Error(`State not found: ${u}`);
      h.note = a, h.note.text = at.sanitizeText(h.note.text, Te());
    }
    s && (ae.info("Setting state classes", u, s), (Array.isArray(s) ? s : [s]).forEach((f) => this.setCssClass(u, f.trim()))), o && (ae.info("Setting state styles", u, o), (Array.isArray(o) ? o : [o]).forEach((f) => this.setStyle(u, f.trim()))), l && (ae.info("Setting state styles", u, o), (Array.isArray(l) ? l : [l]).forEach((f) => this.setTextStyle(u, f.trim())));
  }
  clear(e) {
    this.nodes = [], this.edges = [], this.documents = { root: sY() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.classes = aY(), e || (this.links = /* @__PURE__ */ new Map(), In());
  }
  getState(e) {
    return this.currentDocument.states.get(e);
  }
  getStates() {
    return this.currentDocument.states;
  }
  logDocuments() {
    ae.info("Documents = ", this.documents);
  }
  getRelations() {
    return this.currentDocument.relations;
  }
  /**
   * Adds a clickable link to a state.
   */
  addLink(e, r, n) {
    this.links.set(e, { url: r, tooltip: n }), ae.warn("Adding link", e, r, n);
  }
  /**
   * Get all registered links.
   */
  getLinks() {
    return this.links;
  }
  /**
   * If the id is a start node ( [*] ), then return a new id constructed from
   * the start node name and the current start node count.
   * else return the given id
   */
  startIdIfNeeded(e = "") {
    return e === $i.START_NODE ? (this.startEndCount++, `${$i.START_TYPE}${this.startEndCount}`) : e;
  }
  /**
   * If the id is a start node ( [*] ), then return the start type ('start')
   * else return the given type
   */
  startTypeIfNeeded(e = "", r = Xg) {
    return e === $i.START_NODE ? $i.START_TYPE : r;
  }
  /**
   * If the id is an end node ( [*] ), then return a new id constructed from
   * the end node name and the current start_end node count.
   * else return the given id
   */
  endIdIfNeeded(e = "") {
    return e === $i.END_NODE ? (this.startEndCount++, `${$i.END_TYPE}${this.startEndCount}`) : e;
  }
  /**
   * If the id is an end node ( [*] ), then return the end type
   * else return the given type
   *
   */
  endTypeIfNeeded(e = "", r = Xg) {
    return e === $i.END_NODE ? $i.END_TYPE : r;
  }
  addRelationObjs(e, r, n = "") {
    const i = this.startIdIfNeeded(e.id.trim()), a = this.startTypeIfNeeded(e.id.trim(), e.type), s = this.startIdIfNeeded(r.id.trim()), o = this.startTypeIfNeeded(r.id.trim(), r.type);
    this.addState(
      i,
      a,
      e.doc,
      e.description,
      e.note,
      e.classes,
      e.styles,
      e.textStyles
    ), this.addState(
      s,
      o,
      r.doc,
      r.description,
      r.note,
      r.classes,
      r.styles,
      r.textStyles
    ), this.currentDocument.relations.push({
      id1: i,
      id2: s,
      relationTitle: at.sanitizeText(n, Te())
    });
  }
  /**
   * Add a relation between two items.  The items may be full objects or just the string id of a state.
   */
  addRelation(e, r, n) {
    if (typeof e == "object" && typeof r == "object")
      this.addRelationObjs(e, r, n);
    else if (typeof e == "string" && typeof r == "string") {
      const i = this.startIdIfNeeded(e.trim()), a = this.startTypeIfNeeded(e), s = this.endIdIfNeeded(r.trim()), o = this.endTypeIfNeeded(r);
      this.addState(i, a), this.addState(s, o), this.currentDocument.relations.push({
        id1: i,
        id2: s,
        relationTitle: n ? at.sanitizeText(n, Te()) : void 0
      });
    }
  }
  addDescription(e, r) {
    const n = this.currentDocument.states.get(e), i = r.startsWith(":") ? r.replace(":", "").trim() : r;
    n?.descriptions?.push(at.sanitizeText(i, Te()));
  }
  cleanupLabel(e) {
    return e.startsWith(":") ? e.slice(2).trim() : e.trim();
  }
  getDividerId() {
    return this.dividerCnt++, `divider-id-${this.dividerCnt}`;
  }
  /**
   * Called when the parser comes across a (style) class definition
   * @example classDef my-style fill:#f96;
   *
   * @param id - the id of this (style) class
   * @param styleAttributes - the string with 1 or more style attributes (each separated by a comma)
   */
  addStyleClass(e, r = "") {
    this.classes.has(e) || this.classes.set(e, { id: e, styles: [], textStyles: [] });
    const n = this.classes.get(e);
    r && n && r.split($i.STYLECLASS_SEP).forEach((i) => {
      const a = i.replace(/([^;]*);/, "$1").trim();
      if (RegExp($i.COLOR_KEYWORD).exec(i)) {
        const o = a.replace($i.FILL_KEYWORD, $i.BG_FILL).replace($i.COLOR_KEYWORD, $i.FILL_KEYWORD);
        n.textStyles.push(o);
      }
      n.styles.push(a);
    });
  }
  getClasses() {
    return this.classes;
  }
  /**
   * Add a (style) class or css class to a state with the given id.
   * If the state isn't already in the list of known states, add it.
   * Might be called by parser when a style class or CSS class should be applied to a state
   *
   * @param itemIds - The id or a list of ids of the item(s) to apply the css class to
   * @param cssClassName - CSS class name
   */
  setCssClass(e, r) {
    e.split(",").forEach((n) => {
      let i = this.getState(n);
      if (!i) {
        const a = n.trim();
        this.addState(a), i = this.getState(a);
      }
      i?.classes?.push(r);
    });
  }
  /**
   * Add a style to a state with the given id.
   * @example style stateId fill:#f9f,stroke:#333,stroke-width:4px
   *   where 'style' is the keyword
   *   stateId is the id of a state
   *   the rest of the string is the styleText (all of the attributes to be applied to the state)
   *
   * @param itemId - The id of item to apply the style to
   * @param styleText - the text of the attributes for the style
   */
  setStyle(e, r) {
    this.getState(e)?.styles?.push(r);
  }
  /**
   * Add a text style to a state with the given id
   *
   * @param itemId - The id of item to apply the css class to
   * @param cssClassName - CSS class name
   */
  setTextStyle(e, r) {
    this.getState(e)?.textStyles?.push(r);
  }
  /**
   * Finds the direction statement in the root document.
   * @returns the direction statement if present
   */
  getDirectionStatement() {
    return this.rootDoc.find((e) => e.stmt === eY);
  }
  getDirection() {
    return this.getDirectionStatement()?.value ?? rnt;
  }
  setDirection(e) {
    const r = this.getDirectionStatement();
    r ? r.value = e : this.rootDoc.unshift({ stmt: eY, value: e });
  }
  trimColon(e) {
    return e.startsWith(":") ? e.slice(1).trim() : e.trim();
  }
  getData() {
    const e = Te();
    return {
      nodes: this.nodes,
      edges: this.edges,
      other: {},
      config: e,
      direction: eue(this.getRootDocV2())
    };
  }
  getConfig() {
    return Te().state;
  }
}, w(zu, "StateDB"), zu.relationType = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
}, zu), _nt = /* @__PURE__ */ w((t) => `
defs #statediagram-barbEnd {
    fill: ${t.transitionColor};
    stroke: ${t.transitionColor};
  }
g.stateGroup text {
  fill: ${t.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${t.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${t.stateLabelColor};
}

g.stateGroup rect {
  fill: ${t.mainBkg};
  stroke: ${t.nodeBorder};
}

g.stateGroup line {
  stroke: ${t.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${t.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${t.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${t.noteBorderColor};
  fill: ${t.noteBkgColor};

  text {
    fill: ${t.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${t.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${t.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel {
  background-color: ${t.edgeLabelBackground};
  p {
    background-color: ${t.edgeLabelBackground};
  }
  rect {
    opacity: 0.5;
    background-color: ${t.edgeLabelBackground};
    fill: ${t.edgeLabelBackground};
  }
  text-align: center;
}
.edgeLabel .label text {
  fill: ${t.transitionLabelColor || t.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${t.transitionLabelColor || t.tertiaryTextColor};
}

.stateLabel text {
  fill: ${t.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${t.specialStateColor};
  stroke: ${t.specialStateColor};
}

.node .fork-join {
  fill: ${t.specialStateColor};
  stroke: ${t.specialStateColor};
}

.node circle.state-end {
  fill: ${t.innerEndBackground};
  stroke: ${t.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${t.compositeBackground || t.background};
  // stroke: ${t.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${t.stateBkg || t.mainBkg};
  stroke: ${t.stateBorder || t.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${t.mainBkg};
  stroke: ${t.stateBorder || t.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${t.lineColor};
}

.statediagram-cluster rect {
  fill: ${t.compositeTitleBackground};
  stroke: ${t.stateBorder || t.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${t.stateLabelColor};
  // line-height: 1;
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${t.stateBorder || t.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${t.compositeBackground || t.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${t.altBackground ? t.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${t.altBackground ? t.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${t.noteBkgColor};
  stroke: ${t.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${t.noteBkgColor};
  stroke: ${t.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${t.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${t.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${t.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${t.lineColor};
  stroke: ${t.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${t.textColor};
}
`, "getStyles"), nue = _nt, Ant = /* @__PURE__ */ w((t) => t.append("circle").attr("class", "start-state").attr("r", Te().state.sizeUnit).attr("cx", Te().state.padding + Te().state.sizeUnit).attr("cy", Te().state.padding + Te().state.sizeUnit), "drawStartState"), Lnt = /* @__PURE__ */ w((t) => t.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", Te().state.textHeight).attr("class", "divider").attr("x2", Te().state.textHeight * 2).attr("y1", 0).attr("y2", 0), "drawDivider"), Rnt = /* @__PURE__ */ w((t, e) => {
  const r = t.append("text").attr("x", 2 * Te().state.padding).attr("y", Te().state.textHeight + 2 * Te().state.padding).attr("font-size", Te().state.fontSize).attr("class", "state-title").text(e.id), n = r.node().getBBox();
  return t.insert("rect", ":first-child").attr("x", Te().state.padding).attr("y", Te().state.padding).attr("width", n.width + 2 * Te().state.padding).attr("height", n.height + 2 * Te().state.padding).attr("rx", Te().state.radius), r;
}, "drawSimpleState"), Int = /* @__PURE__ */ w((t, e) => {
  const r = /* @__PURE__ */ w(function(d, p, g) {
    const m = d.append("tspan").attr("x", 2 * Te().state.padding).text(p);
    g || m.attr("dy", Te().state.textHeight);
  }, "addTspan"), i = t.append("text").attr("x", 2 * Te().state.padding).attr("y", Te().state.textHeight + 1.3 * Te().state.padding).attr("font-size", Te().state.fontSize).attr("class", "state-title").text(e.descriptions[0]).node().getBBox(), a = i.height, s = t.append("text").attr("x", Te().state.padding).attr(
    "y",
    a + Te().state.padding * 0.4 + Te().state.dividerMargin + Te().state.textHeight
  ).attr("class", "state-description");
  let o = !0, l = !0;
  e.descriptions.forEach(function(d) {
    o || (r(s, d, l), l = !1), o = !1;
  });
  const u = t.append("line").attr("x1", Te().state.padding).attr("y1", Te().state.padding + a + Te().state.dividerMargin / 2).attr("y2", Te().state.padding + a + Te().state.dividerMargin / 2).attr("class", "descr-divider"), h = s.node().getBBox(), f = Math.max(h.width, i.width);
  return u.attr("x2", f + 3 * Te().state.padding), t.insert("rect", ":first-child").attr("x", Te().state.padding).attr("y", Te().state.padding).attr("width", f + 2 * Te().state.padding).attr("height", h.height + a + 2 * Te().state.padding).attr("rx", Te().state.radius), t;
}, "drawDescrState"), Mnt = /* @__PURE__ */ w((t, e, r) => {
  const n = Te().state.padding, i = 2 * Te().state.padding, a = t.node().getBBox(), s = a.width, o = a.x, l = t.append("text").attr("x", 0).attr("y", Te().state.titleShift).attr("font-size", Te().state.fontSize).attr("class", "state-title").text(e.id), h = l.node().getBBox().width + i;
  let f = Math.max(h, s);
  f === s && (f = f + i);
  let d;
  const p = t.node().getBBox();
  e.doc, d = o - n, h > s && (d = (s - f) / 2 + n), Math.abs(o - p.x) < n && h > s && (d = o - (h - s) / 2);
  const g = 1 - Te().state.textHeight;
  return t.insert("rect", ":first-child").attr("x", d).attr("y", g).attr("class", r ? "alt-composit" : "composit").attr("width", f).attr(
    "height",
    p.height + Te().state.textHeight + Te().state.titleShift + 1
  ).attr("rx", "0"), l.attr("x", d + n), h <= s && l.attr("x", o + (f - i) / 2 - h / 2 + n), t.insert("rect", ":first-child").attr("x", d).attr(
    "y",
    Te().state.titleShift - Te().state.textHeight - Te().state.padding
  ).attr("width", f).attr("height", Te().state.textHeight * 3).attr("rx", Te().state.radius), t.insert("rect", ":first-child").attr("x", d).attr(
    "y",
    Te().state.titleShift - Te().state.textHeight - Te().state.padding
  ).attr("width", f).attr("height", p.height + 3 + 2 * Te().state.textHeight).attr("rx", Te().state.radius), t;
}, "addTitleAndBox"), Nnt = /* @__PURE__ */ w((t) => (t.append("circle").attr("class", "end-state-outer").attr("r", Te().state.sizeUnit + Te().state.miniPadding).attr(
  "cx",
  Te().state.padding + Te().state.sizeUnit + Te().state.miniPadding
).attr(
  "cy",
  Te().state.padding + Te().state.sizeUnit + Te().state.miniPadding
), t.append("circle").attr("class", "end-state-inner").attr("r", Te().state.sizeUnit).attr("cx", Te().state.padding + Te().state.sizeUnit + 2).attr("cy", Te().state.padding + Te().state.sizeUnit + 2)), "drawEndState"), Dnt = /* @__PURE__ */ w((t, e) => {
  let r = Te().state.forkWidth, n = Te().state.forkHeight;
  if (e.parentId) {
    let i = r;
    r = n, n = i;
  }
  return t.append("rect").style("stroke", "black").style("fill", "black").attr("width", r).attr("height", n).attr("x", Te().state.padding).attr("y", Te().state.padding);
}, "drawForkJoinState"), Ont = /* @__PURE__ */ w((t, e, r, n) => {
  let i = 0;
  const a = n.append("text");
  a.style("text-anchor", "start"), a.attr("class", "noteText");
  let s = t.replace(/\r\n/g, "<br/>");
  s = s.replace(/\n/g, "<br/>");
  const o = s.split(at.lineBreakRegex);
  let l = 1.25 * Te().state.noteMargin;
  for (const u of o) {
    const h = u.trim();
    if (h.length > 0) {
      const f = a.append("tspan");
      if (f.text(h), l === 0) {
        const d = f.node().getBBox();
        l += d.height;
      }
      i += l, f.attr("x", e + Te().state.noteMargin), f.attr("y", r + i + 1.25 * Te().state.noteMargin);
    }
  }
  return { textWidth: a.node().getBBox().width, textHeight: i };
}, "_drawLongText"), Pnt = /* @__PURE__ */ w((t, e) => {
  e.attr("class", "state-note");
  const r = e.append("rect").attr("x", 0).attr("y", Te().state.padding), n = e.append("g"), { textWidth: i, textHeight: a } = Ont(t, 0, 0, n);
  return r.attr("height", a + 2 * Te().state.noteMargin), r.attr("width", i + Te().state.noteMargin * 2), r;
}, "drawNote"), oY = /* @__PURE__ */ w(function(t, e) {
  const r = e.id, n = {
    id: r,
    label: e.id,
    width: 0,
    height: 0
  }, i = t.append("g").attr("id", r).attr("class", "stateGroup");
  e.type === "start" && Ant(i), e.type === "end" && Nnt(i), (e.type === "fork" || e.type === "join") && Dnt(i, e), e.type === "note" && Pnt(e.note.text, i), e.type === "divider" && Lnt(i), e.type === "default" && e.descriptions.length === 0 && Rnt(i, e), e.type === "default" && e.descriptions.length > 0 && Int(i, e);
  const a = i.node().getBBox();
  return n.width = a.width + 2 * Te().state.padding, n.height = a.height + 2 * Te().state.padding, n;
}, "drawState"), lY = 0, $nt = /* @__PURE__ */ w(function(t, e, r) {
  const n = /* @__PURE__ */ w(function(l) {
    switch (l) {
      case Cu.relationType.AGGREGATION:
        return "aggregation";
      case Cu.relationType.EXTENSION:
        return "extension";
      case Cu.relationType.COMPOSITION:
        return "composition";
      case Cu.relationType.DEPENDENCY:
        return "dependency";
    }
  }, "getRelationType");
  e.points = e.points.filter((l) => !Number.isNaN(l.y));
  const i = e.points, a = i1().x(function(l) {
    return l.x;
  }).y(function(l) {
    return l.y;
  }).curve(Mf), s = t.append("path").attr("d", a(i)).attr("id", "edge" + lY).attr("class", "transition");
  let o = "";
  if (Te().state.arrowMarkerAbsolute && (o = Bx(!0)), s.attr(
    "marker-end",
    "url(" + o + "#" + n(Cu.relationType.DEPENDENCY) + "End)"
  ), r.title !== void 0) {
    const l = t.append("g").attr("class", "stateLabel"), { x: u, y: h } = Jt.calcLabelPosition(e.points), f = at.getRows(r.title);
    let d = 0;
    const p = [];
    let g = 0, m = 0;
    for (let b = 0; b <= f.length; b++) {
      const x = l.append("text").attr("text-anchor", "middle").text(f[b]).attr("x", u).attr("y", h + d), T = x.node().getBBox();
      g = Math.max(g, T.width), m = Math.min(m, T.x), ae.info(T.x, u, h + d), d === 0 && (d = x.node().getBBox().height, ae.info("Title height", d, h)), p.push(x);
    }
    let v = d * f.length;
    if (f.length > 1) {
      const b = (f.length - 1) * d * 0.5;
      p.forEach((x, T) => x.attr("y", h + T * d - b)), v = d * f.length;
    }
    const y = l.node().getBBox();
    l.insert("rect", ":first-child").attr("class", "box").attr("x", u - g / 2 - Te().state.padding / 2).attr("y", h - v / 2 - Te().state.padding / 2 - 3.5).attr("width", g + Te().state.padding).attr("height", v + Te().state.padding), ae.info(y);
  }
  lY++;
}, "drawEdge"), Sa, G7 = {}, Bnt = /* @__PURE__ */ w(function() {
}, "setConf"), Fnt = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "insertMarkers"), znt = /* @__PURE__ */ w(function(t, e, r, n) {
  Sa = Te().state;
  const i = Te().securityLevel;
  let a;
  i === "sandbox" && (a = Qe("#i" + e));
  const s = Qe(i === "sandbox" ? a.nodes()[0].contentDocument.body : "body"), o = i === "sandbox" ? a.nodes()[0].contentDocument : document;
  ae.debug("Rendering diagram " + t);
  const l = s.select(`[id='${e}']`);
  Fnt(l);
  const u = n.db.getRootDoc();
  iue(u, l, void 0, !1, s, o, n);
  const h = Sa.padding, f = l.node().getBBox(), d = f.width + h * 2, p = f.height + h * 2, g = d * 1.75;
  Qi(l, p, g, Sa.useMaxWidth), l.attr(
    "viewBox",
    `${f.x - Sa.padding}  ${f.y - Sa.padding} ` + d + " " + p
  );
}, "draw"), qnt = /* @__PURE__ */ w((t) => t ? t.length * Sa.fontSizeFactor : 1, "getLabelWidth"), iue = /* @__PURE__ */ w((t, e, r, n, i, a, s) => {
  const o = new ma({
    compound: !0,
    multigraph: !0
  });
  let l, u = !0;
  for (l = 0; l < t.length; l++)
    if (t[l].stmt === "relation") {
      u = !1;
      break;
    }
  r ? o.setGraph({
    rankdir: "LR",
    multigraph: !0,
    compound: !0,
    // acyclicer: 'greedy',
    ranker: "tight-tree",
    ranksep: u ? 1 : Sa.edgeLengthFactor,
    nodeSep: u ? 1 : 50,
    isMultiGraph: !0
    // ranksep: 5,
    // nodesep: 1
  }) : o.setGraph({
    rankdir: "TB",
    multigraph: !0,
    compound: !0,
    // isCompound: true,
    // acyclicer: 'greedy',
    // ranker: 'longest-path'
    ranksep: u ? 1 : Sa.edgeLengthFactor,
    nodeSep: u ? 1 : 50,
    ranker: "tight-tree",
    // ranker: 'network-simplex'
    isMultiGraph: !0
  }), o.setDefaultEdgeLabel(function() {
    return {};
  });
  const h = s.db.getStates(), f = s.db.getRelations(), d = Object.keys(h);
  for (const y of d) {
    const b = h[y];
    r && (b.parentId = r);
    let x;
    if (b.doc) {
      let T = e.append("g").attr("id", b.id).attr("class", "stateGroup");
      x = iue(b.doc, T, b.id, !n, i, a, s);
      {
        T = Mnt(T, b, n);
        let E = T.node().getBBox();
        x.width = E.width, x.height = E.height + Sa.padding / 2, G7[b.id] = { y: Sa.compositTitleSize };
      }
    } else
      x = oY(e, b, o);
    if (b.note) {
      const T = {
        descriptions: [],
        id: b.id + "-note",
        note: b.note,
        type: "note"
      }, E = oY(e, T, o);
      b.note.position === "left of" ? (o.setNode(x.id + "-note", E), o.setNode(x.id, x)) : (o.setNode(x.id, x), o.setNode(x.id + "-note", E)), o.setParent(x.id, x.id + "-group"), o.setParent(x.id + "-note", x.id + "-group");
    } else
      o.setNode(x.id, x);
  }
  ae.debug("Count=", o.nodeCount(), o);
  let p = 0;
  f.forEach(function(y) {
    p++, ae.debug("Setting edge", y), o.setEdge(
      y.id1,
      y.id2,
      {
        relation: y,
        width: qnt(y.title),
        height: Sa.labelHeight * at.getRows(y.title).length,
        labelpos: "c"
      },
      "id" + p
    );
  }), Ene(o), ae.debug("Graph after layout", o.nodes());
  const g = e.node();
  o.nodes().forEach(function(y) {
    y !== void 0 && o.node(y) !== void 0 ? (ae.warn("Node " + y + ": " + JSON.stringify(o.node(y))), i.select("#" + g.id + " #" + y).attr(
      "transform",
      "translate(" + (o.node(y).x - o.node(y).width / 2) + "," + (o.node(y).y + (G7[y] ? G7[y].y : 0) - o.node(y).height / 2) + " )"
    ), i.select("#" + g.id + " #" + y).attr("data-x-shift", o.node(y).x - o.node(y).width / 2), a.querySelectorAll("#" + g.id + " #" + y + " .divider").forEach((x) => {
      const T = x.parentElement;
      let E = 0, A = 0;
      T && (T.parentElement && (E = T.parentElement.getBBox().width), A = parseInt(T.getAttribute("data-x-shift"), 10), Number.isNaN(A) && (A = 0)), x.setAttribute("x1", 0 - A + 8), x.setAttribute("x2", E - A - 8);
    })) : ae.debug("No Node " + y + ": " + JSON.stringify(o.node(y)));
  });
  let m = g.getBBox();
  o.edges().forEach(function(y) {
    y !== void 0 && o.edge(y) !== void 0 && (ae.debug("Edge " + y.v + " -> " + y.w + ": " + JSON.stringify(o.edge(y))), $nt(e, o.edge(y), o.edge(y).relation));
  }), m = g.getBBox();
  const v = {
    id: r || "root",
    label: r || "root",
    width: 0,
    height: 0
  };
  return v.width = m.width + 2 * Sa.padding, v.height = m.height + 2 * Sa.padding, ae.debug("Doc rendered", v, o), v;
}, "renderDoc"), Gnt = {
  setConf: Bnt,
  draw: znt
}, Unt = {
  parser: Uce,
  get db() {
    return new Cu(1);
  },
  renderer: Gnt,
  styles: nue,
  init: /* @__PURE__ */ w((t) => {
    t.state || (t.state = {}), t.state.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const Vnt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Unt
}, Symbol.toStringTag, { value: "Module" }));
var Hnt = {
  parser: Uce,
  get db() {
    return new Cu(2);
  },
  renderer: Snt,
  styles: nue,
  init: /* @__PURE__ */ w((t) => {
    t.state || (t.state = {}), t.state.arrowMarkerAbsolute = t.arrowMarkerAbsolute;
  }, "init")
};
const Wnt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Hnt
}, Symbol.toStringTag, { value: "Module" }));
var W8 = (function() {
  var t = /* @__PURE__ */ w(function(f, d, p, g) {
    for (p = p || {}, g = f.length; g--; p[f[g]] = d) ;
    return p;
  }, "o"), e = [6, 8, 10, 11, 12, 14, 16, 17, 18], r = [1, 9], n = [1, 10], i = [1, 11], a = [1, 12], s = [1, 13], o = [1, 14], l = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, journey: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, title: 11, acc_title: 12, acc_title_value: 13, acc_descr: 14, acc_descr_value: 15, acc_descr_multiline_value: 16, section: 17, taskName: 18, taskData: 19, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "journey", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 11: "title", 12: "acc_title", 13: "acc_title_value", 14: "acc_descr", 15: "acc_descr_value", 16: "acc_descr_multiline_value", 17: "section", 18: "taskName", 19: "taskData" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 2]],
    performAction: /* @__PURE__ */ w(function(d, p, g, m, v, y, b) {
      var x = y.length - 1;
      switch (v) {
        case 1:
          return y[x - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          y[x - 1].push(y[x]), this.$ = y[x - 1];
          break;
        case 4:
        case 5:
          this.$ = y[x];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          m.setDiagramTitle(y[x].substr(6)), this.$ = y[x].substr(6);
          break;
        case 9:
          this.$ = y[x].trim(), m.setAccTitle(this.$);
          break;
        case 10:
        case 11:
          this.$ = y[x].trim(), m.setAccDescription(this.$);
          break;
        case 12:
          m.addSection(y[x].substr(8)), this.$ = y[x].substr(8);
          break;
        case 13:
          m.addTask(y[x - 1], y[x]), this.$ = "task";
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: r, 12: n, 14: i, 16: a, 17: s, 18: o }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 15, 11: r, 12: n, 14: i, 16: a, 17: s, 18: o }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 8]), { 13: [1, 16] }, { 15: [1, 17] }, t(e, [2, 11]), t(e, [2, 12]), { 19: [1, 18] }, t(e, [2, 4]), t(e, [2, 9]), t(e, [2, 10]), t(e, [2, 13])],
    defaultActions: {},
    parseError: /* @__PURE__ */ w(function(d, p) {
      if (p.recoverable)
        this.trace(d);
      else {
        var g = new Error(d);
        throw g.hash = p, g;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(d) {
      var p = this, g = [0], m = [], v = [null], y = [], b = this.table, x = "", T = 0, E = 0, A = 2, S = 1, k = y.slice.call(arguments, 1), _ = Object.create(this.lexer), R = { yy: {} };
      for (var L in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, L) && (R.yy[L] = this.yy[L]);
      _.setInput(d, R.yy), R.yy.lexer = _, R.yy.parser = this, typeof _.yylloc > "u" && (_.yylloc = {});
      var M = _.yylloc;
      y.push(M);
      var P = _.options && _.options.ranges;
      typeof R.yy.parseError == "function" ? this.parseError = R.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function C(Z) {
        g.length = g.length - 2 * Z, v.length = v.length - Z, y.length = y.length - Z;
      }
      w(C, "popStack");
      function I() {
        var Z;
        return Z = m.pop() || _.lex() || S, typeof Z != "number" && (Z instanceof Array && (m = Z, Z = m.pop()), Z = p.symbols_[Z] || Z), Z;
      }
      w(I, "lex");
      for (var N, O, D, $, z = {}, B, G, W, V; ; ) {
        if (O = g[g.length - 1], this.defaultActions[O] ? D = this.defaultActions[O] : ((N === null || typeof N > "u") && (N = I()), D = b[O] && b[O][N]), typeof D > "u" || !D.length || !D[0]) {
          var U = "";
          V = [];
          for (B in b[O])
            this.terminals_[B] && B > A && V.push("'" + this.terminals_[B] + "'");
          _.showPosition ? U = "Parse error on line " + (T + 1) + `:
` + _.showPosition() + `
Expecting ` + V.join(", ") + ", got '" + (this.terminals_[N] || N) + "'" : U = "Parse error on line " + (T + 1) + ": Unexpected " + (N == S ? "end of input" : "'" + (this.terminals_[N] || N) + "'"), this.parseError(U, {
            text: _.match,
            token: this.terminals_[N] || N,
            line: _.yylineno,
            loc: M,
            expected: V
          });
        }
        if (D[0] instanceof Array && D.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + O + ", token: " + N);
        switch (D[0]) {
          case 1:
            g.push(N), v.push(_.yytext), y.push(_.yylloc), g.push(D[1]), N = null, E = _.yyleng, x = _.yytext, T = _.yylineno, M = _.yylloc;
            break;
          case 2:
            if (G = this.productions_[D[1]][1], z.$ = v[v.length - G], z._$ = {
              first_line: y[y.length - (G || 1)].first_line,
              last_line: y[y.length - 1].last_line,
              first_column: y[y.length - (G || 1)].first_column,
              last_column: y[y.length - 1].last_column
            }, P && (z._$.range = [
              y[y.length - (G || 1)].range[0],
              y[y.length - 1].range[1]
            ]), $ = this.performAction.apply(z, [
              x,
              E,
              T,
              R.yy,
              D[1],
              v,
              y
            ].concat(k)), typeof $ < "u")
              return $;
            G && (g = g.slice(0, -1 * G * 2), v = v.slice(0, -1 * G), y = y.slice(0, -1 * G)), g.push(this.productions_[D[1]][0]), v.push(z.$), y.push(z._$), W = b[g[g.length - 2]][g[g.length - 1]], g.push(W);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, u = /* @__PURE__ */ (function() {
    var f = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(p, g) {
        if (this.yy.parser)
          this.yy.parser.parseError(p, g);
        else
          throw new Error(p);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(d, p) {
        return this.yy = p || this.yy || {}, this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var d = this._input[0];
        this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
        var p = d.match(/(?:\r\n?|\n).*/g);
        return p ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(d) {
        var p = d.length, g = d.split(/(?:\r\n?|\n)/g);
        this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - p), this.offset -= p;
        var m = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), g.length - 1 && (this.yylineno -= g.length - 1);
        var v = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: g ? (g.length === m.length ? this.yylloc.first_column : 0) + m[m.length - g.length].length - g[0].length : this.yylloc.first_column - p
        }, this.options.ranges && (this.yylloc.range = [v[0], v[0] + this.yyleng - p]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(d) {
        this.unput(this.match.slice(d));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var d = this.matched.substr(0, this.matched.length - this.match.length);
        return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var d = this.match;
        return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var d = this.pastInput(), p = new Array(d.length + 1).join("-");
        return d + this.upcomingInput() + `
` + p + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(d, p) {
        var g, m, v;
        if (this.options.backtrack_lexer && (v = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (v.yylloc.range = this.yylloc.range.slice(0))), m = d[0].match(/(?:\r\n?|\n).*/g), m && (this.yylineno += m.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: m ? m[m.length - 1].length - m[m.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
        }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], g = this.performAction.call(this, this.yy, this, p, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), g)
          return g;
        if (this._backtrack) {
          for (var y in v)
            this[y] = v[y];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var d, p, g, m;
        this._more || (this.yytext = "", this.match = "");
        for (var v = this._currentRules(), y = 0; y < v.length; y++)
          if (g = this._input.match(this.rules[v[y]]), g && (!p || g[0].length > p[0].length)) {
            if (p = g, m = y, this.options.backtrack_lexer) {
              if (d = this.test_match(g, v[y]), d !== !1)
                return d;
              if (this._backtrack) {
                p = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return p ? (d = this.test_match(p, v[m]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var p = this.next();
        return p || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(p) {
        this.conditionStack.push(p);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var p = this.conditionStack.length - 1;
        return p > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(p) {
        return p = this.conditionStack.length - 1 - Math.abs(p || 0), p >= 0 ? this.conditionStack[p] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(p) {
        this.begin(p);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(p, g, m, v) {
        switch (m) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 10;
          case 3:
            break;
          case 4:
            break;
          case 5:
            return 4;
          case 6:
            return 11;
          case 7:
            return this.begin("acc_title"), 12;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 14;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 17;
          case 15:
            return 18;
          case 16:
            return 19;
          case 17:
            return ":";
          case 18:
            return 6;
          case 19:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19], inclusive: !0 } }
    };
    return f;
  })();
  l.lexer = u;
  function h() {
    this.yy = {};
  }
  return w(h, "Parser"), h.prototype = l, l.Parser = h, new h();
})();
W8.parser = W8;
var Ynt = W8, E0 = "", lM = [], W1 = [], Y1 = [], Xnt = /* @__PURE__ */ w(function() {
  lM.length = 0, W1.length = 0, E0 = "", Y1.length = 0, In();
}, "clear"), jnt = /* @__PURE__ */ w(function(t) {
  E0 = t, lM.push(t);
}, "addSection"), Knt = /* @__PURE__ */ w(function() {
  return lM;
}, "getSections"), Znt = /* @__PURE__ */ w(function() {
  let t = cY();
  const e = 100;
  let r = 0;
  for (; !t && r < e; )
    t = cY(), r++;
  return W1.push(...Y1), W1;
}, "getTasks"), Qnt = /* @__PURE__ */ w(function() {
  const t = [];
  return W1.forEach((r) => {
    r.people && t.push(...r.people);
  }), [...new Set(t)].sort();
}, "updateActors"), Jnt = /* @__PURE__ */ w(function(t, e) {
  const r = e.substr(1).split(":");
  let n = 0, i = [];
  r.length === 1 ? (n = Number(r[0]), i = []) : (n = Number(r[0]), i = r[1].split(","));
  const a = i.map((o) => o.trim()), s = {
    section: E0,
    type: E0,
    people: a,
    task: t,
    score: n
  };
  Y1.push(s);
}, "addTask"), eit = /* @__PURE__ */ w(function(t) {
  const e = {
    section: E0,
    type: E0,
    description: t,
    task: t,
    classes: []
  };
  W1.push(e);
}, "addTaskOrg"), cY = /* @__PURE__ */ w(function() {
  const t = /* @__PURE__ */ w(function(r) {
    return Y1[r].processed;
  }, "compileTask");
  let e = !0;
  for (const [r, n] of Y1.entries())
    t(r), e = e && n.processed;
  return e;
}, "compileTasks"), tit = /* @__PURE__ */ w(function() {
  return Qnt();
}, "getActors"), uY = {
  getConfig: /* @__PURE__ */ w(() => Te().journey, "getConfig"),
  clear: Xnt,
  setDiagramTitle: ti,
  getDiagramTitle: Mn,
  setAccTitle: Ln,
  getAccTitle: Hn,
  setAccDescription: Wn,
  getAccDescription: Yn,
  addSection: jnt,
  getSections: Knt,
  getTasks: Znt,
  addTask: Jnt,
  addTaskOrg: eit,
  getActors: tit
}, rit = /* @__PURE__ */ w((t) => `.label {
    font-family: ${t.fontFamily};
    color: ${t.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${t.textColor}
  }

  .legend {
    fill: ${t.textColor};
    font-family: ${t.fontFamily};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${t.textColor}
  }

  .face {
    ${t.faceColor ? `fill: ${t.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${t.fontFamily};
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${t.fillType0 ? `fill: ${t.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${t.fillType0 ? `fill: ${t.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${t.fillType0 ? `fill: ${t.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${t.fillType0 ? `fill: ${t.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${t.fillType0 ? `fill: ${t.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${t.fillType0 ? `fill: ${t.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${t.fillType0 ? `fill: ${t.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${t.fillType0 ? `fill: ${t.fillType7}` : ""};
  }

  .actor-0 {
    ${t.actor0 ? `fill: ${t.actor0}` : ""};
  }
  .actor-1 {
    ${t.actor1 ? `fill: ${t.actor1}` : ""};
  }
  .actor-2 {
    ${t.actor2 ? `fill: ${t.actor2}` : ""};
  }
  .actor-3 {
    ${t.actor3 ? `fill: ${t.actor3}` : ""};
  }
  .actor-4 {
    ${t.actor4 ? `fill: ${t.actor4}` : ""};
  }
  .actor-5 {
    ${t.actor5 ? `fill: ${t.actor5}` : ""};
  }
  ${Rm()}
`, "getStyles"), nit = rit, cM = /* @__PURE__ */ w(function(t, e) {
  return h3(t, e);
}, "drawRect"), iit = /* @__PURE__ */ w(function(t, e) {
  const n = t.append("circle").attr("cx", e.cx).attr("cy", e.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = t.append("g");
  i.append("circle").attr("cx", e.cx - 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", e.cx + 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function a(l) {
    const u = Jd().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 2) + ")");
  }
  w(a, "smile");
  function s(l) {
    const u = Jd().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 7) + ")");
  }
  w(s, "sad");
  function o(l) {
    l.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", e.cx - 5).attr("y1", e.cy + 7).attr("x2", e.cx + 5).attr("y2", e.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return w(o, "ambivalent"), e.score > 3 ? a(i) : e.score < 3 ? s(i) : o(i), n;
}, "drawFace"), aue = /* @__PURE__ */ w(function(t, e) {
  const r = t.append("circle");
  return r.attr("cx", e.cx), r.attr("cy", e.cy), r.attr("class", "actor-" + e.pos), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("r", e.r), r.class !== void 0 && r.attr("class", r.class), e.title !== void 0 && r.append("title").text(e.title), r;
}, "drawCircle"), sue = /* @__PURE__ */ w(function(t, e) {
  return POe(t, e);
}, "drawText"), ait = /* @__PURE__ */ w(function(t, e) {
  function r(i, a, s, o, l) {
    return i + "," + a + " " + (i + s) + "," + a + " " + (i + s) + "," + (a + o - l) + " " + (i + s - l * 1.2) + "," + (a + o) + " " + i + "," + (a + o);
  }
  w(r, "genPoints");
  const n = t.append("polygon");
  n.attr("points", r(e.x, e.y, 50, 20, 7)), n.attr("class", "labelBox"), e.y = e.y + e.labelMargin, e.x = e.x + 0.5 * e.labelMargin, sue(t, e);
}, "drawLabel"), sit = /* @__PURE__ */ w(function(t, e, r) {
  const n = t.append("g"), i = Oa();
  i.x = e.x, i.y = e.y, i.fill = e.fill, i.width = r.width * e.taskCount + // width of the tasks
  r.diagramMarginX * (e.taskCount - 1), i.height = r.height, i.class = "journey-section section-type-" + e.num, i.rx = 3, i.ry = 3, cM(n, i), oue(r)(
    e.text,
    n,
    i.x,
    i.y,
    i.width,
    i.height,
    { class: "journey-section section-type-" + e.num },
    r,
    e.colour
  );
}, "drawSection"), hY = -1, oit = /* @__PURE__ */ w(function(t, e, r) {
  const n = e.x + r.width / 2, i = t.append("g");
  hY++, i.append("line").attr("id", "task" + hY).attr("x1", n).attr("y1", e.y).attr("x2", n).attr("y2", 450).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), iit(i, {
    cx: n,
    cy: 300 + (5 - e.score) * 30,
    score: e.score
  });
  const s = Oa();
  s.x = e.x, s.y = e.y, s.fill = e.fill, s.width = r.width, s.height = r.height, s.class = "task task-type-" + e.num, s.rx = 3, s.ry = 3, cM(i, s);
  let o = e.x + 14;
  e.people.forEach((l) => {
    const u = e.actors[l].color, h = {
      cx: o,
      cy: e.y,
      r: 7,
      fill: u,
      stroke: "#000",
      title: l,
      pos: e.actors[l].position
    };
    aue(i, h), o += 10;
  }), oue(r)(
    e.task,
    i,
    s.x,
    s.y,
    s.width,
    s.height,
    { class: "task" },
    r,
    e.colour
  );
}, "drawTask"), lit = /* @__PURE__ */ w(function(t, e) {
  Aae(t, e);
}, "drawBackgroundRect"), oue = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h, f) {
    const d = a.append("text").attr("x", s + l / 2).attr("y", o + u / 2 + 5).style("font-color", f).style("text-anchor", "middle").text(i);
    n(d, h);
  }
  w(t, "byText");
  function e(i, a, s, o, l, u, h, f, d) {
    const { taskFontSize: p, taskFontFamily: g } = f, m = i.split(/<br\s*\/?>/gi);
    for (let v = 0; v < m.length; v++) {
      const y = v * p - p * (m.length - 1) / 2, b = a.append("text").attr("x", s + l / 2).attr("y", o).attr("fill", d).style("text-anchor", "middle").style("font-size", p).style("font-family", g);
      b.append("tspan").attr("x", s + l / 2).attr("dy", y).text(m[v]), b.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(b, h);
    }
  }
  w(e, "byTspan");
  function r(i, a, s, o, l, u, h, f) {
    const d = a.append("switch"), g = d.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, s, o, l, u, h, f), n(g, h);
  }
  w(r, "byFo");
  function n(i, a) {
    for (const s in a)
      s in a && i.attr(s, a[s]);
  }
  return w(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), cit = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, "initGraphics"), X1 = {
  drawRect: cM,
  drawCircle: aue,
  drawSection: sit,
  drawText: sue,
  drawLabel: ait,
  drawTask: oit,
  drawBackgroundRect: lit,
  initGraphics: cit
}, uit = /* @__PURE__ */ w(function(t) {
  Object.keys(t).forEach(function(r) {
    ms[r] = t[r];
  });
}, "setConf"), rl = {}, x2 = 0;
function lue(t) {
  const e = Te().journey, r = e.maxLabelWidth;
  x2 = 0;
  let n = 60;
  Object.keys(rl).forEach((i) => {
    const a = rl[i].color, s = {
      cx: 20,
      cy: n,
      r: 7,
      fill: a,
      stroke: "#000",
      pos: rl[i].position
    };
    X1.drawCircle(t, s);
    let o = t.append("text").attr("visibility", "hidden").text(i);
    const l = o.node().getBoundingClientRect().width;
    o.remove();
    let u = [];
    if (l <= r)
      u = [i];
    else {
      const h = i.split(" ");
      let f = "";
      o = t.append("text").attr("visibility", "hidden"), h.forEach((d) => {
        const p = f ? `${f} ${d}` : d;
        if (o.text(p), o.node().getBoundingClientRect().width > r) {
          if (f && u.push(f), f = d, o.text(d), o.node().getBoundingClientRect().width > r) {
            let m = "";
            for (const v of d)
              m += v, o.text(m + "-"), o.node().getBoundingClientRect().width > r && (u.push(m.slice(0, -1) + "-"), m = v);
            f = m;
          }
        } else
          f = p;
      }), f && u.push(f), o.remove();
    }
    u.forEach((h, f) => {
      const d = {
        x: 40,
        y: n + 7 + f * 20,
        fill: "#666",
        text: h,
        textMargin: e.boxTextMargin ?? 5
      }, g = X1.drawText(t, d).node().getBoundingClientRect().width;
      g > x2 && g > e.leftMargin - g && (x2 = g);
    }), n += Math.max(20, u.length * 20);
  });
}
w(lue, "drawActorLegend");
var ms = Te().journey, Xl = 0, hit = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = Te(), a = i.journey.titleColor, s = i.journey.titleFontSize, o = i.journey.titleFontFamily, l = i.securityLevel;
  let u;
  l === "sandbox" && (u = Qe("#i" + e));
  const h = Qe(l === "sandbox" ? u.nodes()[0].contentDocument.body : "body");
  Ua.init();
  const f = h.select("#" + e);
  X1.initGraphics(f);
  const d = n.db.getTasks(), p = n.db.getDiagramTitle(), g = n.db.getActors();
  for (const T in rl)
    delete rl[T];
  let m = 0;
  g.forEach((T) => {
    rl[T] = {
      color: ms.actorColours[m % ms.actorColours.length],
      position: m
    }, m++;
  }), lue(f), Xl = ms.leftMargin + x2, Ua.insert(0, 0, Xl, Object.keys(rl).length * 50), fit(f, d, 0);
  const v = Ua.getBounds();
  p && f.append("text").text(p).attr("x", Xl).attr("font-size", s).attr("font-weight", "bold").attr("y", 25).attr("fill", a).attr("font-family", o);
  const y = v.stopy - v.starty + 2 * ms.diagramMarginY, b = Xl + v.stopx + 2 * ms.diagramMarginX;
  Qi(f, y, b, ms.useMaxWidth), f.append("line").attr("x1", Xl).attr("y1", ms.height * 4).attr("x2", b - Xl - 4).attr("y2", ms.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
  const x = p ? 70 : 0;
  f.attr("viewBox", `${v.startx} -25 ${b} ${y + x}`), f.attr("preserveAspectRatio", "xMinYMin meet"), f.attr("height", y + x + 25);
}, "draw"), Ua = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  init: /* @__PURE__ */ w(function() {
    this.sequenceItems = [], this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0;
  }, "init"),
  updateVal: /* @__PURE__ */ w(function(t, e, r, n) {
    t[e] === void 0 ? t[e] = r : t[e] = n(r, t[e]);
  }, "updateVal"),
  updateBounds: /* @__PURE__ */ w(function(t, e, r, n) {
    const i = Te().journey, a = this;
    let s = 0;
    function o(l) {
      return /* @__PURE__ */ w(function(h) {
        s++;
        const f = a.sequenceItems.length - s + 1;
        a.updateVal(h, "starty", e - f * i.boxMargin, Math.min), a.updateVal(h, "stopy", n + f * i.boxMargin, Math.max), a.updateVal(Ua.data, "startx", t - f * i.boxMargin, Math.min), a.updateVal(Ua.data, "stopx", r + f * i.boxMargin, Math.max), l !== "activation" && (a.updateVal(h, "startx", t - f * i.boxMargin, Math.min), a.updateVal(h, "stopx", r + f * i.boxMargin, Math.max), a.updateVal(Ua.data, "starty", e - f * i.boxMargin, Math.min), a.updateVal(Ua.data, "stopy", n + f * i.boxMargin, Math.max));
      }, "updateItemBounds");
    }
    w(o, "updateFn"), this.sequenceItems.forEach(o());
  }, "updateBounds"),
  insert: /* @__PURE__ */ w(function(t, e, r, n) {
    const i = Math.min(t, r), a = Math.max(t, r), s = Math.min(e, n), o = Math.max(e, n);
    this.updateVal(Ua.data, "startx", i, Math.min), this.updateVal(Ua.data, "starty", s, Math.min), this.updateVal(Ua.data, "stopx", a, Math.max), this.updateVal(Ua.data, "stopy", o, Math.max), this.updateBounds(i, s, a, o);
  }, "insert"),
  bumpVerticalPos: /* @__PURE__ */ w(function(t) {
    this.verticalPos = this.verticalPos + t, this.data.stopy = this.verticalPos;
  }, "bumpVerticalPos"),
  getVerticalPos: /* @__PURE__ */ w(function() {
    return this.verticalPos;
  }, "getVerticalPos"),
  getBounds: /* @__PURE__ */ w(function() {
    return this.data;
  }, "getBounds")
}, U7 = ms.sectionFills, fY = ms.sectionColours, fit = /* @__PURE__ */ w(function(t, e, r) {
  const n = Te().journey;
  let i = "";
  const a = n.height * 2 + n.diagramMarginY, s = r + a;
  let o = 0, l = "#CCC", u = "black", h = 0;
  for (const [f, d] of e.entries()) {
    if (i !== d.section) {
      l = U7[o % U7.length], h = o % U7.length, u = fY[o % fY.length];
      let g = 0;
      const m = d.section;
      for (let y = f; y < e.length && e[y].section == m; y++)
        g = g + 1;
      const v = {
        x: f * n.taskMargin + f * n.width + Xl,
        y: 50,
        text: d.section,
        fill: l,
        num: h,
        colour: u,
        taskCount: g
      };
      X1.drawSection(t, v, n), i = d.section, o++;
    }
    const p = d.people.reduce((g, m) => (rl[m] && (g[m] = rl[m]), g), {});
    d.x = f * n.taskMargin + f * n.width + Xl, d.y = s, d.width = n.diagramMarginX, d.height = n.diagramMarginY, d.colour = u, d.fill = l, d.num = h, d.actors = p, X1.drawTask(t, d, n), Ua.insert(d.x, d.y, d.x + d.width + n.taskMargin, 450);
  }
}, "drawTasks"), dY = {
  setConf: uit,
  draw: hit
}, dit = {
  parser: Ynt,
  db: uY,
  renderer: dY,
  styles: nit,
  init: /* @__PURE__ */ w((t) => {
    dY.setConf(t.journey), uY.clear();
  }, "init")
};
const pit = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: dit
}, Symbol.toStringTag, { value: "Module" }));
var Y8 = (function() {
  var t = /* @__PURE__ */ w(function(d, p, g, m) {
    for (g = g || {}, m = d.length; m--; g[d[m]] = p) ;
    return g;
  }, "o"), e = [6, 8, 10, 11, 12, 14, 16, 17, 20, 21], r = [1, 9], n = [1, 10], i = [1, 11], a = [1, 12], s = [1, 13], o = [1, 16], l = [1, 17], u = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, timeline: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, title: 11, acc_title: 12, acc_title_value: 13, acc_descr: 14, acc_descr_value: 15, acc_descr_multiline_value: 16, section: 17, period_statement: 18, event_statement: 19, period: 20, event: 21, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "timeline", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 11: "title", 12: "acc_title", 13: "acc_title_value", 14: "acc_descr", 15: "acc_descr_value", 16: "acc_descr_multiline_value", 17: "section", 20: "period", 21: "event" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 1], [18, 1], [19, 1]],
    performAction: /* @__PURE__ */ w(function(p, g, m, v, y, b, x) {
      var T = b.length - 1;
      switch (y) {
        case 1:
          return b[T - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          b[T - 1].push(b[T]), this.$ = b[T - 1];
          break;
        case 4:
        case 5:
          this.$ = b[T];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          v.getCommonDb().setDiagramTitle(b[T].substr(6)), this.$ = b[T].substr(6);
          break;
        case 9:
          this.$ = b[T].trim(), v.getCommonDb().setAccTitle(this.$);
          break;
        case 10:
        case 11:
          this.$ = b[T].trim(), v.getCommonDb().setAccDescription(this.$);
          break;
        case 12:
          v.addSection(b[T].substr(8)), this.$ = b[T].substr(8);
          break;
        case 15:
          v.addTask(b[T], 0, ""), this.$ = b[T];
          break;
        case 16:
          v.addEvent(b[T].substr(2)), this.$ = b[T];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: r, 12: n, 14: i, 16: a, 17: s, 18: 14, 19: 15, 20: o, 21: l }, t(e, [2, 7], { 1: [2, 1] }), t(e, [2, 3]), { 9: 18, 11: r, 12: n, 14: i, 16: a, 17: s, 18: 14, 19: 15, 20: o, 21: l }, t(e, [2, 5]), t(e, [2, 6]), t(e, [2, 8]), { 13: [1, 19] }, { 15: [1, 20] }, t(e, [2, 11]), t(e, [2, 12]), t(e, [2, 13]), t(e, [2, 14]), t(e, [2, 15]), t(e, [2, 16]), t(e, [2, 4]), t(e, [2, 9]), t(e, [2, 10])],
    defaultActions: {},
    parseError: /* @__PURE__ */ w(function(p, g) {
      if (g.recoverable)
        this.trace(p);
      else {
        var m = new Error(p);
        throw m.hash = g, m;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(p) {
      var g = this, m = [0], v = [], y = [null], b = [], x = this.table, T = "", E = 0, A = 0, S = 2, k = 1, _ = b.slice.call(arguments, 1), R = Object.create(this.lexer), L = { yy: {} };
      for (var M in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, M) && (L.yy[M] = this.yy[M]);
      R.setInput(p, L.yy), L.yy.lexer = R, L.yy.parser = this, typeof R.yylloc > "u" && (R.yylloc = {});
      var P = R.yylloc;
      b.push(P);
      var C = R.options && R.options.ranges;
      typeof L.yy.parseError == "function" ? this.parseError = L.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function I(K) {
        m.length = m.length - 2 * K, y.length = y.length - K, b.length = b.length - K;
      }
      w(I, "popStack");
      function N() {
        var K;
        return K = v.pop() || R.lex() || k, typeof K != "number" && (K instanceof Array && (v = K, K = v.pop()), K = g.symbols_[K] || K), K;
      }
      w(N, "lex");
      for (var O, D, $, z, B = {}, G, W, V, U; ; ) {
        if (D = m[m.length - 1], this.defaultActions[D] ? $ = this.defaultActions[D] : ((O === null || typeof O > "u") && (O = N()), $ = x[D] && x[D][O]), typeof $ > "u" || !$.length || !$[0]) {
          var Z = "";
          U = [];
          for (G in x[D])
            this.terminals_[G] && G > S && U.push("'" + this.terminals_[G] + "'");
          R.showPosition ? Z = "Parse error on line " + (E + 1) + `:
` + R.showPosition() + `
Expecting ` + U.join(", ") + ", got '" + (this.terminals_[O] || O) + "'" : Z = "Parse error on line " + (E + 1) + ": Unexpected " + (O == k ? "end of input" : "'" + (this.terminals_[O] || O) + "'"), this.parseError(Z, {
            text: R.match,
            token: this.terminals_[O] || O,
            line: R.yylineno,
            loc: P,
            expected: U
          });
        }
        if ($[0] instanceof Array && $.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + D + ", token: " + O);
        switch ($[0]) {
          case 1:
            m.push(O), y.push(R.yytext), b.push(R.yylloc), m.push($[1]), O = null, A = R.yyleng, T = R.yytext, E = R.yylineno, P = R.yylloc;
            break;
          case 2:
            if (W = this.productions_[$[1]][1], B.$ = y[y.length - W], B._$ = {
              first_line: b[b.length - (W || 1)].first_line,
              last_line: b[b.length - 1].last_line,
              first_column: b[b.length - (W || 1)].first_column,
              last_column: b[b.length - 1].last_column
            }, C && (B._$.range = [
              b[b.length - (W || 1)].range[0],
              b[b.length - 1].range[1]
            ]), z = this.performAction.apply(B, [
              T,
              A,
              E,
              L.yy,
              $[1],
              y,
              b
            ].concat(_)), typeof z < "u")
              return z;
            W && (m = m.slice(0, -1 * W * 2), y = y.slice(0, -1 * W), b = b.slice(0, -1 * W)), m.push(this.productions_[$[1]][0]), y.push(B.$), b.push(B._$), V = x[m[m.length - 2]][m[m.length - 1]], m.push(V);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, h = /* @__PURE__ */ (function() {
    var d = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(g, m) {
        if (this.yy.parser)
          this.yy.parser.parseError(g, m);
        else
          throw new Error(g);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(p, g) {
        return this.yy = g || this.yy || {}, this._input = p, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var p = this._input[0];
        this.yytext += p, this.yyleng++, this.offset++, this.match += p, this.matched += p;
        var g = p.match(/(?:\r\n?|\n).*/g);
        return g ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), p;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(p) {
        var g = p.length, m = p.split(/(?:\r\n?|\n)/g);
        this._input = p + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - g), this.offset -= g;
        var v = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
        var y = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: m ? (m.length === v.length ? this.yylloc.first_column : 0) + v[v.length - m.length].length - m[0].length : this.yylloc.first_column - g
        }, this.options.ranges && (this.yylloc.range = [y[0], y[0] + this.yyleng - g]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(p) {
        this.unput(this.match.slice(p));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var p = this.matched.substr(0, this.matched.length - this.match.length);
        return (p.length > 20 ? "..." : "") + p.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var p = this.match;
        return p.length < 20 && (p += this._input.substr(0, 20 - p.length)), (p.substr(0, 20) + (p.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var p = this.pastInput(), g = new Array(p.length + 1).join("-");
        return p + this.upcomingInput() + `
` + g + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(p, g) {
        var m, v, y;
        if (this.options.backtrack_lexer && (y = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (y.yylloc.range = this.yylloc.range.slice(0))), v = p[0].match(/(?:\r\n?|\n).*/g), v && (this.yylineno += v.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: v ? v[v.length - 1].length - v[v.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + p[0].length
        }, this.yytext += p[0], this.match += p[0], this.matches = p, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(p[0].length), this.matched += p[0], m = this.performAction.call(this, this.yy, this, g, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
          return m;
        if (this._backtrack) {
          for (var b in y)
            this[b] = y[b];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var p, g, m, v;
        this._more || (this.yytext = "", this.match = "");
        for (var y = this._currentRules(), b = 0; b < y.length; b++)
          if (m = this._input.match(this.rules[y[b]]), m && (!g || m[0].length > g[0].length)) {
            if (g = m, v = b, this.options.backtrack_lexer) {
              if (p = this.test_match(m, y[b]), p !== !1)
                return p;
              if (this._backtrack) {
                g = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return g ? (p = this.test_match(g, y[v]), p !== !1 ? p : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var g = this.next();
        return g || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(g) {
        this.conditionStack.push(g);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var g = this.conditionStack.length - 1;
        return g > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(g) {
        return g = this.conditionStack.length - 1 - Math.abs(g || 0), g >= 0 ? this.conditionStack[g] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(g) {
        this.begin(g);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(g, m, v, y) {
        switch (v) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 10;
          case 3:
            break;
          case 4:
            break;
          case 5:
            return 4;
          case 6:
            return 11;
          case 7:
            return this.begin("acc_title"), 12;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 14;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 17;
          case 15:
            return 21;
          case 16:
            return 20;
          case 17:
            return 6;
          case 18:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:timeline\b)/i, /^(?:title\s[^\n]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^:\n]+)/i, /^(?::\s(?:[^:\n]|:(?!\s))+)/i, /^(?:[^#:\n]+)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18], inclusive: !0 } }
    };
    return d;
  })();
  u.lexer = h;
  function f() {
    this.yy = {};
  }
  return w(f, "Parser"), f.prototype = u, u.Parser = f, new f();
})();
Y8.parser = Y8;
var git = Y8, cue = {};
Mx(cue, {
  addEvent: () => vue,
  addSection: () => due,
  addTask: () => mue,
  addTaskOrg: () => yue,
  clear: () => fue,
  default: () => mit,
  getCommonDb: () => hue,
  getSections: () => pue,
  getTasks: () => gue
});
var S0 = "", uue = 0, uM = [], Cx = [], k0 = [], hue = /* @__PURE__ */ w(() => u9, "getCommonDb"), fue = /* @__PURE__ */ w(function() {
  uM.length = 0, Cx.length = 0, S0 = "", k0.length = 0, In();
}, "clear"), due = /* @__PURE__ */ w(function(t) {
  S0 = t, uM.push(t);
}, "addSection"), pue = /* @__PURE__ */ w(function() {
  return uM;
}, "getSections"), gue = /* @__PURE__ */ w(function() {
  let t = pY();
  const e = 100;
  let r = 0;
  for (; !t && r < e; )
    t = pY(), r++;
  return Cx.push(...k0), Cx;
}, "getTasks"), mue = /* @__PURE__ */ w(function(t, e, r) {
  const n = {
    id: uue++,
    section: S0,
    type: S0,
    task: t,
    score: e || 0,
    //if event is defined, then add it the events array
    events: r ? [r] : []
  };
  k0.push(n);
}, "addTask"), vue = /* @__PURE__ */ w(function(t) {
  k0.find((r) => r.id === uue - 1).events.push(t);
}, "addEvent"), yue = /* @__PURE__ */ w(function(t) {
  const e = {
    section: S0,
    type: S0,
    description: t,
    task: t,
    classes: []
  };
  Cx.push(e);
}, "addTaskOrg"), pY = /* @__PURE__ */ w(function() {
  const t = /* @__PURE__ */ w(function(r) {
    return k0[r].processed;
  }, "compileTask");
  let e = !0;
  for (const [r, n] of k0.entries())
    t(r), e = e && n.processed;
  return e;
}, "compileTasks"), mit = {
  clear: fue,
  getCommonDb: hue,
  addSection: due,
  getSections: pue,
  getTasks: gue,
  addTask: mue,
  addTaskOrg: yue,
  addEvent: vue
}, vit = 12, t5 = /* @__PURE__ */ w(function(t, e) {
  const r = t.append("rect");
  return r.attr("x", e.x), r.attr("y", e.y), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("width", e.width), r.attr("height", e.height), r.attr("rx", e.rx), r.attr("ry", e.ry), e.class !== void 0 && r.attr("class", e.class), r;
}, "drawRect"), yit = /* @__PURE__ */ w(function(t, e) {
  const n = t.append("circle").attr("cx", e.cx).attr("cy", e.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = t.append("g");
  i.append("circle").attr("cx", e.cx - 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", e.cx + 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function a(l) {
    const u = Jd().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 2) + ")");
  }
  w(a, "smile");
  function s(l) {
    const u = Jd().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 7) + ")");
  }
  w(s, "sad");
  function o(l) {
    l.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", e.cx - 5).attr("y1", e.cy + 7).attr("x2", e.cx + 5).attr("y2", e.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return w(o, "ambivalent"), e.score > 3 ? a(i) : e.score < 3 ? s(i) : o(i), n;
}, "drawFace"), bit = /* @__PURE__ */ w(function(t, e) {
  const r = t.append("circle");
  return r.attr("cx", e.cx), r.attr("cy", e.cy), r.attr("class", "actor-" + e.pos), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("r", e.r), r.class !== void 0 && r.attr("class", r.class), e.title !== void 0 && r.append("title").text(e.title), r;
}, "drawCircle"), bue = /* @__PURE__ */ w(function(t, e) {
  const r = e.text.replace(/<br\s*\/?>/gi, " "), n = t.append("text");
  n.attr("x", e.x), n.attr("y", e.y), n.attr("class", "legend"), n.style("text-anchor", e.anchor), e.class !== void 0 && n.attr("class", e.class);
  const i = n.append("tspan");
  return i.attr("x", e.x + e.textMargin * 2), i.text(r), n;
}, "drawText"), xit = /* @__PURE__ */ w(function(t, e) {
  function r(i, a, s, o, l) {
    return i + "," + a + " " + (i + s) + "," + a + " " + (i + s) + "," + (a + o - l) + " " + (i + s - l * 1.2) + "," + (a + o) + " " + i + "," + (a + o);
  }
  w(r, "genPoints");
  const n = t.append("polygon");
  n.attr("points", r(e.x, e.y, 50, 20, 7)), n.attr("class", "labelBox"), e.y = e.y + e.labelMargin, e.x = e.x + 0.5 * e.labelMargin, bue(t, e);
}, "drawLabel"), wit = /* @__PURE__ */ w(function(t, e, r) {
  const n = t.append("g"), i = hM();
  i.x = e.x, i.y = e.y, i.fill = e.fill, i.width = r.width, i.height = r.height, i.class = "journey-section section-type-" + e.num, i.rx = 3, i.ry = 3, t5(n, i), xue(r)(
    e.text,
    n,
    i.x,
    i.y,
    i.width,
    i.height,
    { class: "journey-section section-type-" + e.num },
    r,
    e.colour
  );
}, "drawSection"), gY = -1, Tit = /* @__PURE__ */ w(function(t, e, r) {
  const n = e.x + r.width / 2, i = t.append("g");
  gY++, i.append("line").attr("id", "task" + gY).attr("x1", n).attr("y1", e.y).attr("x2", n).attr("y2", 450).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), yit(i, {
    cx: n,
    cy: 300 + (5 - e.score) * 30,
    score: e.score
  });
  const s = hM();
  s.x = e.x, s.y = e.y, s.fill = e.fill, s.width = r.width, s.height = r.height, s.class = "task task-type-" + e.num, s.rx = 3, s.ry = 3, t5(i, s), xue(r)(
    e.task,
    i,
    s.x,
    s.y,
    s.width,
    s.height,
    { class: "task" },
    r,
    e.colour
  );
}, "drawTask"), Eit = /* @__PURE__ */ w(function(t, e) {
  t5(t, {
    x: e.startx,
    y: e.starty,
    width: e.stopx - e.startx,
    height: e.stopy - e.starty,
    fill: e.fill,
    class: "rect"
  }).lower();
}, "drawBackgroundRect"), Sit = /* @__PURE__ */ w(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    "text-anchor": "start",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
}, "getTextObj"), hM = /* @__PURE__ */ w(function() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, "getNoteRect"), xue = /* @__PURE__ */ (function() {
  function t(i, a, s, o, l, u, h, f) {
    const d = a.append("text").attr("x", s + l / 2).attr("y", o + u / 2 + 5).style("font-color", f).style("text-anchor", "middle").text(i);
    n(d, h);
  }
  w(t, "byText");
  function e(i, a, s, o, l, u, h, f, d) {
    const { taskFontSize: p, taskFontFamily: g } = f, m = i.split(/<br\s*\/?>/gi);
    for (let v = 0; v < m.length; v++) {
      const y = v * p - p * (m.length - 1) / 2, b = a.append("text").attr("x", s + l / 2).attr("y", o).attr("fill", d).style("text-anchor", "middle").style("font-size", p).style("font-family", g);
      b.append("tspan").attr("x", s + l / 2).attr("dy", y).text(m[v]), b.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(b, h);
    }
  }
  w(e, "byTspan");
  function r(i, a, s, o, l, u, h, f) {
    const d = a.append("switch"), g = d.append("foreignObject").attr("x", s).attr("y", o).attr("width", l).attr("height", u).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    g.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, s, o, l, u, h, f), n(g, h);
  }
  w(r, "byFo");
  function n(i, a) {
    for (const s in a)
      s in a && i.attr(s, a[s]);
  }
  return w(n, "_setTextAttrs"), function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
})(), kit = /* @__PURE__ */ w(function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, "initGraphics");
function fM(t, e) {
  t.each(function() {
    var r = Qe(this), n = r.text().split(/(\s+|<br>)/).reverse(), i, a = [], s = 1.1, o = r.attr("y"), l = parseFloat(r.attr("dy")), u = r.text(null).append("tspan").attr("x", 0).attr("y", o).attr("dy", l + "em");
    for (let h = 0; h < n.length; h++)
      i = n[n.length - 1 - h], a.push(i), u.text(a.join(" ").trim()), (u.node().getComputedTextLength() > e || i === "<br>") && (a.pop(), u.text(a.join(" ").trim()), i === "<br>" ? a = [""] : a = [i], u = r.append("tspan").attr("x", 0).attr("y", o).attr("dy", s + "em").text(i));
  });
}
w(fM, "wrap");
var Cit = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = r % vit - 1, a = t.append("g");
  e.section = i, a.attr(
    "class",
    (e.class ? e.class + " " : "") + "timeline-node " + ("section-" + i)
  );
  const s = a.append("g"), o = a.append("g"), u = o.append("text").text(e.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(fM, e.width).node().getBBox(), h = n.fontSize?.replace ? n.fontSize.replace("px", "") : n.fontSize;
  return e.height = u.height + h * 1.1 * 0.5 + e.padding, e.height = Math.max(e.height, e.maxHeight), e.width = e.width + 2 * e.padding, o.attr("transform", "translate(" + e.width / 2 + ", " + e.padding / 2 + ")"), Ait(s, e, i, n), e;
}, "drawNode"), _it = /* @__PURE__ */ w(function(t, e, r) {
  const n = t.append("g"), a = n.append("text").text(e.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(fM, e.width).node().getBBox(), s = r.fontSize?.replace ? r.fontSize.replace("px", "") : r.fontSize;
  return n.remove(), a.height + s * 1.1 * 0.5 + e.padding;
}, "getVirtualNodeHeight"), Ait = /* @__PURE__ */ w(function(t, e, r) {
  t.append("path").attr("id", "node-" + e.id).attr("class", "node-bkg node-" + e.type).attr(
    "d",
    `M0 ${e.height - 5} v${-e.height + 10} q0,-5 5,-5 h${e.width - 10} q5,0 5,5 v${e.height - 5} H0 Z`
  ), t.append("line").attr("class", "node-line-" + r).attr("x1", 0).attr("y1", e.height).attr("x2", e.width).attr("y2", e.height);
}, "defaultBkg"), _u = {
  drawRect: t5,
  drawCircle: bit,
  drawSection: wit,
  drawText: bue,
  drawLabel: xit,
  drawTask: Tit,
  drawBackgroundRect: Eit,
  getTextObj: Sit,
  getNoteRect: hM,
  initGraphics: kit,
  drawNode: Cit,
  getVirtualNodeHeight: _it
}, Lit = /* @__PURE__ */ w(function(t, e, r, n) {
  const i = Te(), a = i.timeline?.leftMargin ?? 50;
  ae.debug("timeline", n.db);
  const s = i.securityLevel;
  let o;
  s === "sandbox" && (o = Qe("#i" + e));
  const u = Qe(s === "sandbox" ? o.nodes()[0].contentDocument.body : "body").select("#" + e);
  u.append("g");
  const h = n.db.getTasks(), f = n.db.getCommonDb().getDiagramTitle();
  ae.debug("task", h), _u.initGraphics(u);
  const d = n.db.getSections();
  ae.debug("sections", d);
  let p = 0, g = 0, m = 0, v = 0, y = 50 + a, b = 50;
  v = 50;
  let x = 0, T = !0;
  d.forEach(function(_) {
    const R = {
      number: x,
      descr: _,
      section: x,
      width: 150,
      padding: 20,
      maxHeight: p
    }, L = _u.getVirtualNodeHeight(u, R, i);
    ae.debug("sectionHeight before draw", L), p = Math.max(p, L + 20);
  });
  let E = 0, A = 0;
  ae.debug("tasks.length", h.length);
  for (const [_, R] of h.entries()) {
    const L = {
      number: _,
      descr: R,
      section: R.section,
      width: 150,
      padding: 20,
      maxHeight: g
    }, M = _u.getVirtualNodeHeight(u, L, i);
    ae.debug("taskHeight before draw", M), g = Math.max(g, M + 20), E = Math.max(E, R.events.length);
    let P = 0;
    for (const C of R.events) {
      const I = {
        descr: C,
        section: R.section,
        number: R.section,
        width: 150,
        padding: 20,
        maxHeight: 50
      };
      P += _u.getVirtualNodeHeight(u, I, i);
    }
    R.events.length > 0 && (P += (R.events.length - 1) * 10), A = Math.max(A, P);
  }
  ae.debug("maxSectionHeight before draw", p), ae.debug("maxTaskHeight before draw", g), d && d.length > 0 ? d.forEach((_) => {
    const R = h.filter((C) => C.section === _), L = {
      number: x,
      descr: _,
      section: x,
      width: 200 * Math.max(R.length, 1) - 50,
      padding: 20,
      maxHeight: p
    };
    ae.debug("sectionNode", L);
    const M = u.append("g"), P = _u.drawNode(M, L, x, i);
    ae.debug("sectionNode output", P), M.attr("transform", `translate(${y}, ${v})`), b += p + 50, R.length > 0 && mY(
      u,
      R,
      x,
      y,
      b,
      g,
      i,
      E,
      A,
      p,
      !1
    ), y += 200 * Math.max(R.length, 1), b = v, x++;
  }) : (T = !1, mY(
    u,
    h,
    x,
    y,
    b,
    g,
    i,
    E,
    A,
    p,
    !0
  ));
  const S = u.node().getBBox();
  ae.debug("bounds", S), f && u.append("text").text(f).attr("x", S.width / 2 - a).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 20), m = T ? p + g + 150 : g + 100, u.append("g").attr("class", "lineWrapper").append("line").attr("x1", a).attr("y1", m).attr("x2", S.width + 3 * a).attr("y2", m).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)"), Q1(
    void 0,
    u,
    i.timeline?.padding ?? 50,
    i.timeline?.useMaxWidth ?? !1
  );
}, "draw"), mY = /* @__PURE__ */ w(function(t, e, r, n, i, a, s, o, l, u, h) {
  for (const f of e) {
    const d = {
      descr: f.task,
      section: r,
      number: r,
      width: 150,
      padding: 20,
      maxHeight: a
    };
    ae.debug("taskNode", d);
    const p = t.append("g").attr("class", "taskWrapper"), m = _u.drawNode(p, d, r, s).height;
    if (ae.debug("taskHeight after draw", m), p.attr("transform", `translate(${n}, ${i})`), a = Math.max(a, m), f.events) {
      const v = t.append("g").attr("class", "lineWrapper");
      let y = a;
      i += 100, y = y + Rit(t, f.events, r, n, i, s), i -= 100, v.append("line").attr("x1", n + 190 / 2).attr("y1", i + a).attr("x2", n + 190 / 2).attr("y2", i + a + 100 + l + 100).attr("stroke-width", 2).attr("stroke", "black").attr("marker-end", "url(#arrowhead)").attr("stroke-dasharray", "5,5");
    }
    n = n + 200, h && !s.timeline?.disableMulticolor && r++;
  }
  i = i - 10;
}, "drawTasks"), Rit = /* @__PURE__ */ w(function(t, e, r, n, i, a) {
  let s = 0;
  const o = i;
  i = i + 100;
  for (const l of e) {
    const u = {
      descr: l,
      section: r,
      number: r,
      width: 150,
      padding: 20,
      maxHeight: 50
    };
    ae.debug("eventNode", u);
    const h = t.append("g").attr("class", "eventWrapper"), d = _u.drawNode(h, u, r, a).height;
    s = s + d, h.attr("transform", `translate(${n}, ${i})`), i = i + 10 + d;
  }
  return i = o, s;
}, "drawEvents"), Iit = {
  setConf: /* @__PURE__ */ w(() => {
  }, "setConf"),
  draw: Lit
}, Mit = /* @__PURE__ */ w((t) => {
  let e = "";
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++)
    t["lineColor" + r] = t["lineColor" + r] || t["cScaleInv" + r], Pc(t["lineColor" + r]) ? t["lineColor" + r] = _t(t["lineColor" + r], 20) : t["lineColor" + r] = Nt(t["lineColor" + r], 20);
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++) {
    const n = "" + (17 - 3 * r);
    e += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} path  {
      fill: ${t["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${t["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${t["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${t["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${n};
    }
    .section-${r - 1} line {
      stroke: ${t["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .lineWrapper line{
      stroke: ${t["cScaleLabel" + r]} ;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
  }
  return e;
}, "genSections"), Nit = /* @__PURE__ */ w((t) => `
  .edge {
    stroke-width: 3;
  }
  ${Mit(t)}
  .section-root rect, .section-root path, .section-root circle  {
    fill: ${t.git0};
  }
  .section-root text {
    fill: ${t.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .eventWrapper  {
   filter: brightness(120%);
  }
`, "getStyles"), Dit = Nit, Oit = {
  db: cue,
  renderer: Iit,
  parser: git,
  styles: Dit
};
const Pit = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Oit
}, Symbol.toStringTag, { value: "Module" })), oi = [];
for (let t = 0; t < 256; ++t)
  oi.push((t + 256).toString(16).slice(1));
function $it(t, e = 0) {
  return (oi[t[e + 0]] + oi[t[e + 1]] + oi[t[e + 2]] + oi[t[e + 3]] + "-" + oi[t[e + 4]] + oi[t[e + 5]] + "-" + oi[t[e + 6]] + oi[t[e + 7]] + "-" + oi[t[e + 8]] + oi[t[e + 9]] + "-" + oi[t[e + 10]] + oi[t[e + 11]] + oi[t[e + 12]] + oi[t[e + 13]] + oi[t[e + 14]] + oi[t[e + 15]]).toLowerCase();
}
let V7;
const Bit = new Uint8Array(16);
function Fit() {
  if (!V7) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    V7 = crypto.getRandomValues.bind(crypto);
  }
  return V7(Bit);
}
const zit = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vY = { randomUUID: zit };
function qit(t, e, r) {
  if (vY.randomUUID && !t)
    return vY.randomUUID();
  t = t || {};
  const n = t.random ?? t.rng?.() ?? Fit();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, $it(n);
}
var X8 = (function() {
  var t = /* @__PURE__ */ w(function(T, E, A, S) {
    for (A = A || {}, S = T.length; S--; A[T[S]] = E) ;
    return A;
  }, "o"), e = [1, 4], r = [1, 13], n = [1, 12], i = [1, 15], a = [1, 16], s = [1, 20], o = [1, 19], l = [6, 7, 8], u = [1, 26], h = [1, 24], f = [1, 25], d = [6, 7, 11], p = [1, 6, 13, 15, 16, 19, 22], g = [1, 33], m = [1, 34], v = [1, 6, 7, 11, 13, 15, 16, 19, 22], y = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mindMap: 4, spaceLines: 5, SPACELINE: 6, NL: 7, MINDMAP: 8, document: 9, stop: 10, EOF: 11, statement: 12, SPACELIST: 13, node: 14, ICON: 15, CLASS: 16, nodeWithId: 17, nodeWithoutId: 18, NODE_DSTART: 19, NODE_DESCR: 20, NODE_DEND: 21, NODE_ID: 22, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "SPACELINE", 7: "NL", 8: "MINDMAP", 11: "EOF", 13: "SPACELIST", 15: "ICON", 16: "CLASS", 19: "NODE_DSTART", 20: "NODE_DESCR", 21: "NODE_DEND", 22: "NODE_ID" },
    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 2], [12, 2], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [18, 3], [17, 1], [17, 4]],
    performAction: /* @__PURE__ */ w(function(E, A, S, k, _, R, L) {
      var M = R.length - 1;
      switch (_) {
        case 6:
        case 7:
          return k;
        case 8:
          k.getLogger().trace("Stop NL ");
          break;
        case 9:
          k.getLogger().trace("Stop EOF ");
          break;
        case 11:
          k.getLogger().trace("Stop NL2 ");
          break;
        case 12:
          k.getLogger().trace("Stop EOF2 ");
          break;
        case 15:
          k.getLogger().info("Node: ", R[M].id), k.addNode(R[M - 1].length, R[M].id, R[M].descr, R[M].type);
          break;
        case 16:
          k.getLogger().trace("Icon: ", R[M]), k.decorateNode({ icon: R[M] });
          break;
        case 17:
        case 21:
          k.decorateNode({ class: R[M] });
          break;
        case 18:
          k.getLogger().trace("SPACELIST");
          break;
        case 19:
          k.getLogger().trace("Node: ", R[M].id), k.addNode(0, R[M].id, R[M].descr, R[M].type);
          break;
        case 20:
          k.decorateNode({ icon: R[M] });
          break;
        case 25:
          k.getLogger().trace("node found ..", R[M - 2]), this.$ = { id: R[M - 1], descr: R[M - 1], type: k.getType(R[M - 2], R[M]) };
          break;
        case 26:
          this.$ = { id: R[M], descr: R[M], type: k.nodeType.DEFAULT };
          break;
        case 27:
          k.getLogger().trace("node found ..", R[M - 3]), this.$ = { id: R[M - 3], descr: R[M - 1], type: k.getType(R[M - 2], R[M]) };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: e }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: e }, { 6: r, 7: [1, 10], 9: 9, 12: 11, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, t(l, [2, 3]), { 1: [2, 2] }, t(l, [2, 4]), t(l, [2, 5]), { 1: [2, 6], 6: r, 12: 21, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, { 6: r, 9: 22, 12: 11, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, { 6: u, 7: h, 10: 23, 11: f }, t(d, [2, 22], { 17: 17, 18: 18, 14: 27, 15: [1, 28], 16: [1, 29], 19: s, 22: o }), t(d, [2, 18]), t(d, [2, 19]), t(d, [2, 20]), t(d, [2, 21]), t(d, [2, 23]), t(d, [2, 24]), t(d, [2, 26], { 19: [1, 30] }), { 20: [1, 31] }, { 6: u, 7: h, 10: 32, 11: f }, { 1: [2, 7], 6: r, 12: 21, 13: n, 14: 14, 15: i, 16: a, 17: 17, 18: 18, 19: s, 22: o }, t(p, [2, 14], { 7: g, 11: m }), t(v, [2, 8]), t(v, [2, 9]), t(v, [2, 10]), t(d, [2, 15]), t(d, [2, 16]), t(d, [2, 17]), { 20: [1, 35] }, { 21: [1, 36] }, t(p, [2, 13], { 7: g, 11: m }), t(v, [2, 11]), t(v, [2, 12]), { 21: [1, 37] }, t(d, [2, 25]), t(d, [2, 27])],
    defaultActions: { 2: [2, 1], 6: [2, 2] },
    parseError: /* @__PURE__ */ w(function(E, A) {
      if (A.recoverable)
        this.trace(E);
      else {
        var S = new Error(E);
        throw S.hash = A, S;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(E) {
      var A = this, S = [0], k = [], _ = [null], R = [], L = this.table, M = "", P = 0, C = 0, I = 2, N = 1, O = R.slice.call(arguments, 1), D = Object.create(this.lexer), $ = { yy: {} };
      for (var z in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, z) && ($.yy[z] = this.yy[z]);
      D.setInput(E, $.yy), $.yy.lexer = D, $.yy.parser = this, typeof D.yylloc > "u" && (D.yylloc = {});
      var B = D.yylloc;
      R.push(B);
      var G = D.options && D.options.ranges;
      typeof $.yy.parseError == "function" ? this.parseError = $.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function W(ue) {
        S.length = S.length - 2 * ue, _.length = _.length - ue, R.length = R.length - ue;
      }
      w(W, "popStack");
      function V() {
        var ue;
        return ue = k.pop() || D.lex() || N, typeof ue != "number" && (ue instanceof Array && (k = ue, ue = k.pop()), ue = A.symbols_[ue] || ue), ue;
      }
      w(V, "lex");
      for (var U, Z, K, ce, J = {}, ee, j, X, re; ; ) {
        if (Z = S[S.length - 1], this.defaultActions[Z] ? K = this.defaultActions[Z] : ((U === null || typeof U > "u") && (U = V()), K = L[Z] && L[Z][U]), typeof K > "u" || !K.length || !K[0]) {
          var Q = "";
          re = [];
          for (ee in L[Z])
            this.terminals_[ee] && ee > I && re.push("'" + this.terminals_[ee] + "'");
          D.showPosition ? Q = "Parse error on line " + (P + 1) + `:
` + D.showPosition() + `
Expecting ` + re.join(", ") + ", got '" + (this.terminals_[U] || U) + "'" : Q = "Parse error on line " + (P + 1) + ": Unexpected " + (U == N ? "end of input" : "'" + (this.terminals_[U] || U) + "'"), this.parseError(Q, {
            text: D.match,
            token: this.terminals_[U] || U,
            line: D.yylineno,
            loc: B,
            expected: re
          });
        }
        if (K[0] instanceof Array && K.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Z + ", token: " + U);
        switch (K[0]) {
          case 1:
            S.push(U), _.push(D.yytext), R.push(D.yylloc), S.push(K[1]), U = null, C = D.yyleng, M = D.yytext, P = D.yylineno, B = D.yylloc;
            break;
          case 2:
            if (j = this.productions_[K[1]][1], J.$ = _[_.length - j], J._$ = {
              first_line: R[R.length - (j || 1)].first_line,
              last_line: R[R.length - 1].last_line,
              first_column: R[R.length - (j || 1)].first_column,
              last_column: R[R.length - 1].last_column
            }, G && (J._$.range = [
              R[R.length - (j || 1)].range[0],
              R[R.length - 1].range[1]
            ]), ce = this.performAction.apply(J, [
              M,
              C,
              P,
              $.yy,
              K[1],
              _,
              R
            ].concat(O)), typeof ce < "u")
              return ce;
            j && (S = S.slice(0, -1 * j * 2), _ = _.slice(0, -1 * j), R = R.slice(0, -1 * j)), S.push(this.productions_[K[1]][0]), _.push(J.$), R.push(J._$), X = L[S[S.length - 2]][S[S.length - 1]], S.push(X);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, b = /* @__PURE__ */ (function() {
    var T = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(A, S) {
        if (this.yy.parser)
          this.yy.parser.parseError(A, S);
        else
          throw new Error(A);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(E, A) {
        return this.yy = A || this.yy || {}, this._input = E, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var E = this._input[0];
        this.yytext += E, this.yyleng++, this.offset++, this.match += E, this.matched += E;
        var A = E.match(/(?:\r\n?|\n).*/g);
        return A ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), E;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(E) {
        var A = E.length, S = E.split(/(?:\r\n?|\n)/g);
        this._input = E + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - A), this.offset -= A;
        var k = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), S.length - 1 && (this.yylineno -= S.length - 1);
        var _ = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: S ? (S.length === k.length ? this.yylloc.first_column : 0) + k[k.length - S.length].length - S[0].length : this.yylloc.first_column - A
        }, this.options.ranges && (this.yylloc.range = [_[0], _[0] + this.yyleng - A]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(E) {
        this.unput(this.match.slice(E));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var E = this.matched.substr(0, this.matched.length - this.match.length);
        return (E.length > 20 ? "..." : "") + E.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var E = this.match;
        return E.length < 20 && (E += this._input.substr(0, 20 - E.length)), (E.substr(0, 20) + (E.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var E = this.pastInput(), A = new Array(E.length + 1).join("-");
        return E + this.upcomingInput() + `
` + A + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(E, A) {
        var S, k, _;
        if (this.options.backtrack_lexer && (_ = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (_.yylloc.range = this.yylloc.range.slice(0))), k = E[0].match(/(?:\r\n?|\n).*/g), k && (this.yylineno += k.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: k ? k[k.length - 1].length - k[k.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + E[0].length
        }, this.yytext += E[0], this.match += E[0], this.matches = E, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(E[0].length), this.matched += E[0], S = this.performAction.call(this, this.yy, this, A, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), S)
          return S;
        if (this._backtrack) {
          for (var R in _)
            this[R] = _[R];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var E, A, S, k;
        this._more || (this.yytext = "", this.match = "");
        for (var _ = this._currentRules(), R = 0; R < _.length; R++)
          if (S = this._input.match(this.rules[_[R]]), S && (!A || S[0].length > A[0].length)) {
            if (A = S, k = R, this.options.backtrack_lexer) {
              if (E = this.test_match(S, _[R]), E !== !1)
                return E;
              if (this._backtrack) {
                A = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return A ? (E = this.test_match(A, _[k]), E !== !1 ? E : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var A = this.next();
        return A || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(A) {
        this.conditionStack.push(A);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var A = this.conditionStack.length - 1;
        return A > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(A) {
        return A = this.conditionStack.length - 1 - Math.abs(A || 0), A >= 0 ? this.conditionStack[A] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(A) {
        this.begin(A);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(A, S, k, _) {
        switch (k) {
          case 0:
            return A.getLogger().trace("Found comment", S.yytext), 6;
          case 1:
            return 8;
          case 2:
            this.begin("CLASS");
            break;
          case 3:
            return this.popState(), 16;
          case 4:
            this.popState();
            break;
          case 5:
            A.getLogger().trace("Begin icon"), this.begin("ICON");
            break;
          case 6:
            return A.getLogger().trace("SPACELINE"), 6;
          case 7:
            return 7;
          case 8:
            return 15;
          case 9:
            A.getLogger().trace("end icon"), this.popState();
            break;
          case 10:
            return A.getLogger().trace("Exploding node"), this.begin("NODE"), 19;
          case 11:
            return A.getLogger().trace("Cloud"), this.begin("NODE"), 19;
          case 12:
            return A.getLogger().trace("Explosion Bang"), this.begin("NODE"), 19;
          case 13:
            return A.getLogger().trace("Cloud Bang"), this.begin("NODE"), 19;
          case 14:
            return this.begin("NODE"), 19;
          case 15:
            return this.begin("NODE"), 19;
          case 16:
            return this.begin("NODE"), 19;
          case 17:
            return this.begin("NODE"), 19;
          case 18:
            return 13;
          case 19:
            return 22;
          case 20:
            return 11;
          case 21:
            this.begin("NSTR2");
            break;
          case 22:
            return "NODE_DESCR";
          case 23:
            this.popState();
            break;
          case 24:
            A.getLogger().trace("Starting NSTR"), this.begin("NSTR");
            break;
          case 25:
            return A.getLogger().trace("description:", S.yytext), "NODE_DESCR";
          case 26:
            this.popState();
            break;
          case 27:
            return this.popState(), A.getLogger().trace("node end ))"), "NODE_DEND";
          case 28:
            return this.popState(), A.getLogger().trace("node end )"), "NODE_DEND";
          case 29:
            return this.popState(), A.getLogger().trace("node end ...", S.yytext), "NODE_DEND";
          case 30:
            return this.popState(), A.getLogger().trace("node end (("), "NODE_DEND";
          case 31:
            return this.popState(), A.getLogger().trace("node end (-"), "NODE_DEND";
          case 32:
            return this.popState(), A.getLogger().trace("node end (-"), "NODE_DEND";
          case 33:
            return this.popState(), A.getLogger().trace("node end (("), "NODE_DEND";
          case 34:
            return this.popState(), A.getLogger().trace("node end (("), "NODE_DEND";
          case 35:
            return A.getLogger().trace("Long description:", S.yytext), 20;
          case 36:
            return A.getLogger().trace("Long description:", S.yytext), 20;
        }
      }, "anonymous"),
      rules: [/^(?:\s*%%.*)/i, /^(?:mindmap\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\n)/i, /^(?:::icon\()/i, /^(?:[\s]+[\n])/i, /^(?:[\n]+)/i, /^(?:[^\)]+)/i, /^(?:\))/i, /^(?:-\))/i, /^(?:\(-)/i, /^(?:\)\))/i, /^(?:\))/i, /^(?:\(\()/i, /^(?:\{\{)/i, /^(?:\()/i, /^(?:\[)/i, /^(?:[\s]+)/i, /^(?:[^\(\[\n\)\{\}]+)/i, /^(?:$)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:[^"]+)/i, /^(?:["])/i, /^(?:[\)]\))/i, /^(?:[\)])/i, /^(?:[\]])/i, /^(?:\}\})/i, /^(?:\(-)/i, /^(?:-\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:[^\)\]\(\}]+)/i, /^(?:.+(?!\(\())/i],
      conditions: { CLASS: { rules: [3, 4], inclusive: !1 }, ICON: { rules: [8, 9], inclusive: !1 }, NSTR2: { rules: [22, 23], inclusive: !1 }, NSTR: { rules: [25, 26], inclusive: !1 }, NODE: { rules: [21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], inclusive: !0 } }
    };
    return T;
  })();
  y.lexer = b;
  function x() {
    this.yy = {};
  }
  return w(x, "Parser"), x.prototype = y, y.Parser = x, new x();
})();
X8.parser = X8;
var Git = X8, qo = {
  DEFAULT: 0,
  NO_BORDER: 0,
  ROUNDED_RECT: 1,
  RECT: 2,
  CIRCLE: 3,
  CLOUD: 4,
  BANG: 5,
  HEXAGON: 6
}, Fd, Uit = (Fd = class {
  constructor() {
    this.nodes = [], this.count = 0, this.elements = {}, this.getLogger = this.getLogger.bind(this), this.nodeType = qo, this.clear(), this.getType = this.getType.bind(this), this.getElementById = this.getElementById.bind(this), this.getParent = this.getParent.bind(this), this.getMindmap = this.getMindmap.bind(this), this.addNode = this.addNode.bind(this), this.decorateNode = this.decorateNode.bind(this);
  }
  clear() {
    this.nodes = [], this.count = 0, this.elements = {}, this.baseLevel = void 0;
  }
  getParent(e) {
    for (let r = this.nodes.length - 1; r >= 0; r--)
      if (this.nodes[r].level < e)
        return this.nodes[r];
    return null;
  }
  getMindmap() {
    return this.nodes.length > 0 ? this.nodes[0] : null;
  }
  addNode(e, r, n, i) {
    ae.info("addNode", e, r, n, i);
    let a = !1;
    this.nodes.length === 0 ? (this.baseLevel = e, e = 0, a = !0) : this.baseLevel !== void 0 && (e = e - this.baseLevel, a = !1);
    const s = Te();
    let o = s.mindmap?.padding ?? fr.mindmap.padding;
    switch (i) {
      case this.nodeType.ROUNDED_RECT:
      case this.nodeType.RECT:
      case this.nodeType.HEXAGON:
        o *= 2;
        break;
    }
    const l = {
      id: this.count++,
      nodeId: pr(r, s),
      level: e,
      descr: pr(n, s),
      type: i,
      children: [],
      width: s.mindmap?.maxNodeWidth ?? fr.mindmap.maxNodeWidth,
      padding: o,
      isRoot: a
    }, u = this.getParent(e);
    if (u)
      u.children.push(l), this.nodes.push(l);
    else if (a)
      this.nodes.push(l);
    else
      throw new Error(
        `There can be only one root. No parent could be found for ("${l.descr}")`
      );
  }
  getType(e, r) {
    switch (ae.debug("In get type", e, r), e) {
      case "[":
        return this.nodeType.RECT;
      case "(":
        return r === ")" ? this.nodeType.ROUNDED_RECT : this.nodeType.CLOUD;
      case "((":
        return this.nodeType.CIRCLE;
      case ")":
        return this.nodeType.CLOUD;
      case "))":
        return this.nodeType.BANG;
      case "{{":
        return this.nodeType.HEXAGON;
      default:
        return this.nodeType.DEFAULT;
    }
  }
  setElementForId(e, r) {
    this.elements[e] = r;
  }
  getElementById(e) {
    return this.elements[e];
  }
  decorateNode(e) {
    if (!e)
      return;
    const r = Te(), n = this.nodes[this.nodes.length - 1];
    e.icon && (n.icon = pr(e.icon, r)), e.class && (n.class = pr(e.class, r));
  }
  type2Str(e) {
    switch (e) {
      case this.nodeType.DEFAULT:
        return "no-border";
      case this.nodeType.RECT:
        return "rect";
      case this.nodeType.ROUNDED_RECT:
        return "rounded-rect";
      case this.nodeType.CIRCLE:
        return "circle";
      case this.nodeType.CLOUD:
        return "cloud";
      case this.nodeType.BANG:
        return "bang";
      case this.nodeType.HEXAGON:
        return "hexgon";
      // cspell: disable-line
      default:
        return "no-border";
    }
  }
  /**
   * Assign section numbers to nodes based on their position relative to root
   * @param node - The mindmap node to process
   * @param sectionNumber - The section number to assign (undefined for root)
   */
  assignSections(e, r) {
    if (e.level === 0 ? e.section = void 0 : e.section = r, e.children)
      for (const [n, i] of e.children.entries()) {
        const a = e.level === 0 ? n : r;
        this.assignSections(i, a);
      }
  }
  /**
   * Convert mindmap tree structure to flat array of nodes
   * @param node - The mindmap node to process
   * @param processedNodes - Array to collect processed nodes
   */
  flattenNodes(e, r) {
    const n = ["mindmap-node"];
    e.isRoot === !0 ? n.push("section-root", "section--1") : e.section !== void 0 && n.push(`section-${e.section}`), e.class && n.push(e.class);
    const i = n.join(" "), a = /* @__PURE__ */ w((o) => {
      switch (o) {
        case qo.CIRCLE:
          return "mindmapCircle";
        case qo.RECT:
          return "rect";
        case qo.ROUNDED_RECT:
          return "rounded";
        case qo.CLOUD:
          return "cloud";
        case qo.BANG:
          return "bang";
        case qo.HEXAGON:
          return "hexagon";
        case qo.DEFAULT:
          return "defaultMindmapNode";
        case qo.NO_BORDER:
        default:
          return "rect";
      }
    }, "getShapeFromType"), s = {
      id: e.id.toString(),
      domId: "node_" + e.id.toString(),
      label: e.descr,
      isGroup: !1,
      shape: a(e.type),
      width: e.width,
      height: e.height ?? 0,
      padding: e.padding,
      cssClasses: i,
      cssStyles: [],
      look: "default",
      icon: e.icon,
      x: e.x,
      y: e.y,
      // Mindmap-specific properties
      level: e.level,
      nodeId: e.nodeId,
      type: e.type,
      section: e.section
    };
    if (r.push(s), e.children)
      for (const o of e.children)
        this.flattenNodes(o, r);
  }
  /**
   * Generate edges from parent-child relationships in mindmap tree
   * @param node - The mindmap node to process
   * @param edges - Array to collect edges
   */
  generateEdges(e, r) {
    if (e.children)
      for (const n of e.children) {
        let i = "edge";
        n.section !== void 0 && (i += ` section-edge-${n.section}`);
        const a = e.level + 1;
        i += ` edge-depth-${a}`;
        const s = {
          id: `edge_${e.id}_${n.id}`,
          start: e.id.toString(),
          end: n.id.toString(),
          type: "normal",
          curve: "basis",
          thickness: "normal",
          look: "default",
          classes: i,
          // Store mindmap-specific data
          depth: e.level,
          section: n.section
        };
        r.push(s), this.generateEdges(n, r);
      }
  }
  /**
   * Get structured data for layout algorithms
   * Following the pattern established by ER diagrams
   * @returns Structured data containing nodes, edges, and config
   */
  getData() {
    const e = this.getMindmap(), r = Te(), i = ffe().layout !== void 0, a = r;
    if (i || (a.layout = "cose-bilkent"), !e)
      return {
        nodes: [],
        edges: [],
        config: a
      };
    ae.debug("getData: mindmapRoot", e, r), this.assignSections(e);
    const s = [], o = [];
    this.flattenNodes(e, s), this.generateEdges(e, o), ae.debug(
      `getData: processed ${s.length} nodes and ${o.length} edges`
    );
    const l = /* @__PURE__ */ new Map();
    for (const u of s)
      l.set(u.id, {
        shape: u.shape,
        width: u.width,
        height: u.height,
        padding: u.padding
      });
    return {
      nodes: s,
      edges: o,
      config: a,
      // Store the root node for mindmap-specific layout algorithms
      rootNode: e,
      // Properties required by dagre layout algorithm
      markers: ["point"],
      // Mindmaps don't use markers
      direction: "TB",
      // Top-to-bottom direction for mindmaps
      nodeSpacing: 50,
      // Default spacing between nodes
      rankSpacing: 50,
      // Default spacing between ranks
      // Add shapes for ELK compatibility
      shapes: Object.fromEntries(l),
      // Additional properties that layout algorithms might expect
      type: "mindmap",
      diagramId: "mindmap-" + qit()
    };
  }
  // Expose logger to grammar
  getLogger() {
    return ae;
  }
}, w(Fd, "MindmapDB"), Fd), Vit = /* @__PURE__ */ w(async (t, e, r, n) => {
  ae.debug(`Rendering mindmap diagram
` + t);
  const i = n.db, a = i.getData(), s = Y0(e, a.config.securityLevel);
  a.type = n.type, a.layoutAlgorithm = om(a.config.layout, {
    fallback: "cose-bilkent"
  }), a.diagramId = e, i.getMindmap() && (a.nodes.forEach((l) => {
    l.shape === "rounded" ? (l.radius = 15, l.taper = 15, l.stroke = "none", l.width = 0, l.padding = 15) : l.shape === "circle" ? l.padding = 10 : l.shape === "rect" && (l.width = 0, l.padding = 10);
  }), await I0(a, s), Oh(
    s,
    a.config.mindmap?.padding ?? fr.mindmap.padding,
    "mindmapDiagram",
    a.config.mindmap?.useMaxWidth ?? fr.mindmap.useMaxWidth
  ));
}, "draw"), Hit = {
  draw: Vit
}, Wit = /* @__PURE__ */ w((t) => {
  let e = "";
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++)
    t["lineColor" + r] = t["lineColor" + r] || t["cScaleInv" + r], Pc(t["lineColor" + r]) ? t["lineColor" + r] = _t(t["lineColor" + r], 20) : t["lineColor" + r] = Nt(t["lineColor" + r], 20);
  for (let r = 0; r < t.THEME_COLOR_LIMIT; r++) {
    const n = "" + (17 - 3 * r);
    e += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} polygon, .section-${r - 1} path  {
      fill: ${t["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${t["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${t["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${t["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${n};
    }
    .section-${r - 1} line {
      stroke: ${t["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
  }
  return e;
}, "genSections"), Yit = /* @__PURE__ */ w((t) => `
  .edge {
    stroke-width: 3;
  }
  ${Wit(t)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${t.git0};
  }
  .section-root text {
    fill: ${t.gitBranchLabel0};
  }
  .section-root span {
    color: ${t.gitBranchLabel0};
  }
  .section-2 span {
    color: ${t.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .mindmap-node-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
`, "getStyles"), Xit = Yit, jit = {
  get db() {
    return new Uit();
  },
  renderer: Hit,
  parser: Git,
  styles: Xit
};
const Kit = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: jit
}, Symbol.toStringTag, { value: "Module" }));
var j8 = (function() {
  var t = /* @__PURE__ */ w(function(S, k, _, R) {
    for (_ = _ || {}, R = S.length; R--; _[S[R]] = k) ;
    return _;
  }, "o"), e = [1, 4], r = [1, 13], n = [1, 12], i = [1, 15], a = [1, 16], s = [1, 20], o = [1, 19], l = [6, 7, 8], u = [1, 26], h = [1, 24], f = [1, 25], d = [6, 7, 11], p = [1, 31], g = [6, 7, 11, 24], m = [1, 6, 13, 16, 17, 20, 23], v = [1, 35], y = [1, 36], b = [1, 6, 7, 11, 13, 16, 17, 20, 23], x = [1, 38], T = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mindMap: 4, spaceLines: 5, SPACELINE: 6, NL: 7, KANBAN: 8, document: 9, stop: 10, EOF: 11, statement: 12, SPACELIST: 13, node: 14, shapeData: 15, ICON: 16, CLASS: 17, nodeWithId: 18, nodeWithoutId: 19, NODE_DSTART: 20, NODE_DESCR: 21, NODE_DEND: 22, NODE_ID: 23, SHAPE_DATA: 24, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "SPACELINE", 7: "NL", 8: "KANBAN", 11: "EOF", 13: "SPACELIST", 16: "ICON", 17: "CLASS", 20: "NODE_DSTART", 21: "NODE_DESCR", 22: "NODE_DEND", 23: "NODE_ID", 24: "SHAPE_DATA" },
    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 3], [12, 2], [12, 2], [12, 2], [12, 1], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [19, 3], [18, 1], [18, 4], [15, 2], [15, 1]],
    performAction: /* @__PURE__ */ w(function(k, _, R, L, M, P, C) {
      var I = P.length - 1;
      switch (M) {
        case 6:
        case 7:
          return L;
        case 8:
          L.getLogger().trace("Stop NL ");
          break;
        case 9:
          L.getLogger().trace("Stop EOF ");
          break;
        case 11:
          L.getLogger().trace("Stop NL2 ");
          break;
        case 12:
          L.getLogger().trace("Stop EOF2 ");
          break;
        case 15:
          L.getLogger().info("Node: ", P[I - 1].id), L.addNode(P[I - 2].length, P[I - 1].id, P[I - 1].descr, P[I - 1].type, P[I]);
          break;
        case 16:
          L.getLogger().info("Node: ", P[I].id), L.addNode(P[I - 1].length, P[I].id, P[I].descr, P[I].type);
          break;
        case 17:
          L.getLogger().trace("Icon: ", P[I]), L.decorateNode({ icon: P[I] });
          break;
        case 18:
        case 23:
          L.decorateNode({ class: P[I] });
          break;
        case 19:
          L.getLogger().trace("SPACELIST");
          break;
        case 20:
          L.getLogger().trace("Node: ", P[I - 1].id), L.addNode(0, P[I - 1].id, P[I - 1].descr, P[I - 1].type, P[I]);
          break;
        case 21:
          L.getLogger().trace("Node: ", P[I].id), L.addNode(0, P[I].id, P[I].descr, P[I].type);
          break;
        case 22:
          L.decorateNode({ icon: P[I] });
          break;
        case 27:
          L.getLogger().trace("node found ..", P[I - 2]), this.$ = { id: P[I - 1], descr: P[I - 1], type: L.getType(P[I - 2], P[I]) };
          break;
        case 28:
          this.$ = { id: P[I], descr: P[I], type: 0 };
          break;
        case 29:
          L.getLogger().trace("node found ..", P[I - 3]), this.$ = { id: P[I - 3], descr: P[I - 1], type: L.getType(P[I - 2], P[I]) };
          break;
        case 30:
          this.$ = P[I - 1] + P[I];
          break;
        case 31:
          this.$ = P[I];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: e }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: e }, { 6: r, 7: [1, 10], 9: 9, 12: 11, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, t(l, [2, 3]), { 1: [2, 2] }, t(l, [2, 4]), t(l, [2, 5]), { 1: [2, 6], 6: r, 12: 21, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, { 6: r, 9: 22, 12: 11, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, { 6: u, 7: h, 10: 23, 11: f }, t(d, [2, 24], { 18: 17, 19: 18, 14: 27, 16: [1, 28], 17: [1, 29], 20: s, 23: o }), t(d, [2, 19]), t(d, [2, 21], { 15: 30, 24: p }), t(d, [2, 22]), t(d, [2, 23]), t(g, [2, 25]), t(g, [2, 26]), t(g, [2, 28], { 20: [1, 32] }), { 21: [1, 33] }, { 6: u, 7: h, 10: 34, 11: f }, { 1: [2, 7], 6: r, 12: 21, 13: n, 14: 14, 16: i, 17: a, 18: 17, 19: 18, 20: s, 23: o }, t(m, [2, 14], { 7: v, 11: y }), t(b, [2, 8]), t(b, [2, 9]), t(b, [2, 10]), t(d, [2, 16], { 15: 37, 24: p }), t(d, [2, 17]), t(d, [2, 18]), t(d, [2, 20], { 24: x }), t(g, [2, 31]), { 21: [1, 39] }, { 22: [1, 40] }, t(m, [2, 13], { 7: v, 11: y }), t(b, [2, 11]), t(b, [2, 12]), t(d, [2, 15], { 24: x }), t(g, [2, 30]), { 22: [1, 41] }, t(g, [2, 27]), t(g, [2, 29])],
    defaultActions: { 2: [2, 1], 6: [2, 2] },
    parseError: /* @__PURE__ */ w(function(k, _) {
      if (_.recoverable)
        this.trace(k);
      else {
        var R = new Error(k);
        throw R.hash = _, R;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(k) {
      var _ = this, R = [0], L = [], M = [null], P = [], C = this.table, I = "", N = 0, O = 0, D = 2, $ = 1, z = P.slice.call(arguments, 1), B = Object.create(this.lexer), G = { yy: {} };
      for (var W in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, W) && (G.yy[W] = this.yy[W]);
      B.setInput(k, G.yy), G.yy.lexer = B, G.yy.parser = this, typeof B.yylloc > "u" && (B.yylloc = {});
      var V = B.yylloc;
      P.push(V);
      var U = B.options && B.options.ranges;
      typeof G.yy.parseError == "function" ? this.parseError = G.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Z(Y) {
        R.length = R.length - 2 * Y, M.length = M.length - Y, P.length = P.length - Y;
      }
      w(Z, "popStack");
      function K() {
        var Y;
        return Y = L.pop() || B.lex() || $, typeof Y != "number" && (Y instanceof Array && (L = Y, Y = L.pop()), Y = _.symbols_[Y] || Y), Y;
      }
      w(K, "lex");
      for (var ce, J, ee, j, X = {}, re, Q, ue, ne; ; ) {
        if (J = R[R.length - 1], this.defaultActions[J] ? ee = this.defaultActions[J] : ((ce === null || typeof ce > "u") && (ce = K()), ee = C[J] && C[J][ce]), typeof ee > "u" || !ee.length || !ee[0]) {
          var xe = "";
          ne = [];
          for (re in C[J])
            this.terminals_[re] && re > D && ne.push("'" + this.terminals_[re] + "'");
          B.showPosition ? xe = "Parse error on line " + (N + 1) + `:
` + B.showPosition() + `
Expecting ` + ne.join(", ") + ", got '" + (this.terminals_[ce] || ce) + "'" : xe = "Parse error on line " + (N + 1) + ": Unexpected " + (ce == $ ? "end of input" : "'" + (this.terminals_[ce] || ce) + "'"), this.parseError(xe, {
            text: B.match,
            token: this.terminals_[ce] || ce,
            line: B.yylineno,
            loc: V,
            expected: ne
          });
        }
        if (ee[0] instanceof Array && ee.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + J + ", token: " + ce);
        switch (ee[0]) {
          case 1:
            R.push(ce), M.push(B.yytext), P.push(B.yylloc), R.push(ee[1]), ce = null, O = B.yyleng, I = B.yytext, N = B.yylineno, V = B.yylloc;
            break;
          case 2:
            if (Q = this.productions_[ee[1]][1], X.$ = M[M.length - Q], X._$ = {
              first_line: P[P.length - (Q || 1)].first_line,
              last_line: P[P.length - 1].last_line,
              first_column: P[P.length - (Q || 1)].first_column,
              last_column: P[P.length - 1].last_column
            }, U && (X._$.range = [
              P[P.length - (Q || 1)].range[0],
              P[P.length - 1].range[1]
            ]), j = this.performAction.apply(X, [
              I,
              O,
              N,
              G.yy,
              ee[1],
              M,
              P
            ].concat(z)), typeof j < "u")
              return j;
            Q && (R = R.slice(0, -1 * Q * 2), M = M.slice(0, -1 * Q), P = P.slice(0, -1 * Q)), R.push(this.productions_[ee[1]][0]), M.push(X.$), P.push(X._$), ue = C[R[R.length - 2]][R[R.length - 1]], R.push(ue);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, E = /* @__PURE__ */ (function() {
    var S = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(_, R) {
        if (this.yy.parser)
          this.yy.parser.parseError(_, R);
        else
          throw new Error(_);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(k, _) {
        return this.yy = _ || this.yy || {}, this._input = k, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var k = this._input[0];
        this.yytext += k, this.yyleng++, this.offset++, this.match += k, this.matched += k;
        var _ = k.match(/(?:\r\n?|\n).*/g);
        return _ ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), k;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(k) {
        var _ = k.length, R = k.split(/(?:\r\n?|\n)/g);
        this._input = k + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - _), this.offset -= _;
        var L = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), R.length - 1 && (this.yylineno -= R.length - 1);
        var M = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: R ? (R.length === L.length ? this.yylloc.first_column : 0) + L[L.length - R.length].length - R[0].length : this.yylloc.first_column - _
        }, this.options.ranges && (this.yylloc.range = [M[0], M[0] + this.yyleng - _]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(k) {
        this.unput(this.match.slice(k));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var k = this.matched.substr(0, this.matched.length - this.match.length);
        return (k.length > 20 ? "..." : "") + k.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var k = this.match;
        return k.length < 20 && (k += this._input.substr(0, 20 - k.length)), (k.substr(0, 20) + (k.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var k = this.pastInput(), _ = new Array(k.length + 1).join("-");
        return k + this.upcomingInput() + `
` + _ + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(k, _) {
        var R, L, M;
        if (this.options.backtrack_lexer && (M = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (M.yylloc.range = this.yylloc.range.slice(0))), L = k[0].match(/(?:\r\n?|\n).*/g), L && (this.yylineno += L.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: L ? L[L.length - 1].length - L[L.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + k[0].length
        }, this.yytext += k[0], this.match += k[0], this.matches = k, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(k[0].length), this.matched += k[0], R = this.performAction.call(this, this.yy, this, _, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), R)
          return R;
        if (this._backtrack) {
          for (var P in M)
            this[P] = M[P];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var k, _, R, L;
        this._more || (this.yytext = "", this.match = "");
        for (var M = this._currentRules(), P = 0; P < M.length; P++)
          if (R = this._input.match(this.rules[M[P]]), R && (!_ || R[0].length > _[0].length)) {
            if (_ = R, L = P, this.options.backtrack_lexer) {
              if (k = this.test_match(R, M[P]), k !== !1)
                return k;
              if (this._backtrack) {
                _ = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return _ ? (k = this.test_match(_, M[L]), k !== !1 ? k : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var _ = this.next();
        return _ || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(_) {
        this.conditionStack.push(_);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var _ = this.conditionStack.length - 1;
        return _ > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(_) {
        return _ = this.conditionStack.length - 1 - Math.abs(_ || 0), _ >= 0 ? this.conditionStack[_] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(_) {
        this.begin(_);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(_, R, L, M) {
        switch (L) {
          case 0:
            return this.pushState("shapeData"), R.yytext = "", 24;
          case 1:
            return this.pushState("shapeDataStr"), 24;
          case 2:
            return this.popState(), 24;
          case 3:
            const P = /\n\s*/g;
            return R.yytext = R.yytext.replace(P, "<br/>"), 24;
          case 4:
            return 24;
          case 5:
            this.popState();
            break;
          case 6:
            return _.getLogger().trace("Found comment", R.yytext), 6;
          case 7:
            return 8;
          case 8:
            this.begin("CLASS");
            break;
          case 9:
            return this.popState(), 17;
          case 10:
            this.popState();
            break;
          case 11:
            _.getLogger().trace("Begin icon"), this.begin("ICON");
            break;
          case 12:
            return _.getLogger().trace("SPACELINE"), 6;
          case 13:
            return 7;
          case 14:
            return 16;
          case 15:
            _.getLogger().trace("end icon"), this.popState();
            break;
          case 16:
            return _.getLogger().trace("Exploding node"), this.begin("NODE"), 20;
          case 17:
            return _.getLogger().trace("Cloud"), this.begin("NODE"), 20;
          case 18:
            return _.getLogger().trace("Explosion Bang"), this.begin("NODE"), 20;
          case 19:
            return _.getLogger().trace("Cloud Bang"), this.begin("NODE"), 20;
          case 20:
            return this.begin("NODE"), 20;
          case 21:
            return this.begin("NODE"), 20;
          case 22:
            return this.begin("NODE"), 20;
          case 23:
            return this.begin("NODE"), 20;
          case 24:
            return 13;
          case 25:
            return 23;
          case 26:
            return 11;
          case 27:
            this.begin("NSTR2");
            break;
          case 28:
            return "NODE_DESCR";
          case 29:
            this.popState();
            break;
          case 30:
            _.getLogger().trace("Starting NSTR"), this.begin("NSTR");
            break;
          case 31:
            return _.getLogger().trace("description:", R.yytext), "NODE_DESCR";
          case 32:
            this.popState();
            break;
          case 33:
            return this.popState(), _.getLogger().trace("node end ))"), "NODE_DEND";
          case 34:
            return this.popState(), _.getLogger().trace("node end )"), "NODE_DEND";
          case 35:
            return this.popState(), _.getLogger().trace("node end ...", R.yytext), "NODE_DEND";
          case 36:
            return this.popState(), _.getLogger().trace("node end (("), "NODE_DEND";
          case 37:
            return this.popState(), _.getLogger().trace("node end (-"), "NODE_DEND";
          case 38:
            return this.popState(), _.getLogger().trace("node end (-"), "NODE_DEND";
          case 39:
            return this.popState(), _.getLogger().trace("node end (("), "NODE_DEND";
          case 40:
            return this.popState(), _.getLogger().trace("node end (("), "NODE_DEND";
          case 41:
            return _.getLogger().trace("Long description:", R.yytext), 21;
          case 42:
            return _.getLogger().trace("Long description:", R.yytext), 21;
        }
      }, "anonymous"),
      rules: [/^(?:@\{)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^\"]+)/i, /^(?:[^}^"]+)/i, /^(?:\})/i, /^(?:\s*%%.*)/i, /^(?:kanban\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\n)/i, /^(?:::icon\()/i, /^(?:[\s]+[\n])/i, /^(?:[\n]+)/i, /^(?:[^\)]+)/i, /^(?:\))/i, /^(?:-\))/i, /^(?:\(-)/i, /^(?:\)\))/i, /^(?:\))/i, /^(?:\(\()/i, /^(?:\{\{)/i, /^(?:\()/i, /^(?:\[)/i, /^(?:[\s]+)/i, /^(?:[^\(\[\n\)\{\}@]+)/i, /^(?:$)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:[^"]+)/i, /^(?:["])/i, /^(?:[\)]\))/i, /^(?:[\)])/i, /^(?:[\]])/i, /^(?:\}\})/i, /^(?:\(-)/i, /^(?:-\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:[^\)\]\(\}]+)/i, /^(?:.+(?!\(\())/i],
      conditions: { shapeDataEndBracket: { rules: [], inclusive: !1 }, shapeDataStr: { rules: [2, 3], inclusive: !1 }, shapeData: { rules: [1, 4, 5], inclusive: !1 }, CLASS: { rules: [9, 10], inclusive: !1 }, ICON: { rules: [14, 15], inclusive: !1 }, NSTR2: { rules: [28, 29], inclusive: !1 }, NSTR: { rules: [31, 32], inclusive: !1 }, NODE: { rules: [27, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: !1 }, INITIAL: { rules: [0, 6, 7, 8, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], inclusive: !0 } }
    };
    return S;
  })();
  T.lexer = E;
  function A() {
    this.yy = {};
  }
  return w(A, "Parser"), A.prototype = T, T.Parser = A, new A();
})();
j8.parser = j8;
var Zit = j8, Va = [], dM = [], K8 = 0, pM = {}, Qit = /* @__PURE__ */ w(() => {
  Va = [], dM = [], K8 = 0, pM = {};
}, "clear"), Jit = /* @__PURE__ */ w((t) => {
  if (Va.length === 0)
    return null;
  const e = Va[0].level;
  let r = null;
  for (let n = Va.length - 1; n >= 0; n--)
    if (Va[n].level === e && !r && (r = Va[n]), Va[n].level < e)
      throw new Error('Items without section detected, found section ("' + Va[n].label + '")');
  return t === r?.level ? null : r;
}, "getSection"), wue = /* @__PURE__ */ w(function() {
  return dM;
}, "getSections"), eat = /* @__PURE__ */ w(function() {
  const t = [], e = [], r = wue(), n = Te();
  for (const i of r) {
    const a = {
      id: i.id,
      label: pr(i.label ?? "", n),
      isGroup: !0,
      ticket: i.ticket,
      shape: "kanbanSection",
      level: i.level,
      look: n.look
    };
    e.push(a);
    const s = Va.filter((o) => o.parentId === i.id);
    for (const o of s) {
      const l = {
        id: o.id,
        parentId: i.id,
        label: pr(o.label ?? "", n),
        isGroup: !1,
        ticket: o?.ticket,
        priority: o?.priority,
        assigned: o?.assigned,
        icon: o?.icon,
        shape: "kanbanItem",
        level: o.level,
        rx: 5,
        ry: 5,
        cssStyles: ["text-align: left"]
      };
      e.push(l);
    }
  }
  return { nodes: e, edges: t, other: {}, config: Te() };
}, "getData"), tat = /* @__PURE__ */ w((t, e, r, n, i) => {
  const a = Te();
  let s = a.mindmap?.padding ?? fr.mindmap.padding;
  switch (n) {
    case zn.ROUNDED_RECT:
    case zn.RECT:
    case zn.HEXAGON:
      s *= 2;
  }
  const o = {
    id: pr(e, a) || "kbn" + K8++,
    level: t,
    label: pr(r, a),
    width: a.mindmap?.maxNodeWidth ?? fr.mindmap.maxNodeWidth,
    padding: s,
    isGroup: !1
  };
  if (i !== void 0) {
    let u;
    i.includes(`
`) ? u = i + `
` : u = `{
` + i + `
}`;
    const h = Kx(u, { schema: jx });
    if (h.shape && (h.shape !== h.shape.toLowerCase() || h.shape.includes("_")))
      throw new Error(`No such shape: ${h.shape}. Shape names should be lowercase.`);
    h?.shape && h.shape === "kanbanItem" && (o.shape = h?.shape), h?.label && (o.label = h?.label), h?.icon && (o.icon = h?.icon.toString()), h?.assigned && (o.assigned = h?.assigned.toString()), h?.ticket && (o.ticket = h?.ticket.toString()), h?.priority && (o.priority = h?.priority);
  }
  const l = Jit(t);
  l ? o.parentId = l.id || "kbn" + K8++ : dM.push(o), Va.push(o);
}, "addNode"), zn = {
  DEFAULT: 0,
  NO_BORDER: 0,
  ROUNDED_RECT: 1,
  RECT: 2,
  CIRCLE: 3,
  CLOUD: 4,
  BANG: 5,
  HEXAGON: 6
}, rat = /* @__PURE__ */ w((t, e) => {
  switch (ae.debug("In get type", t, e), t) {
    case "[":
      return zn.RECT;
    case "(":
      return e === ")" ? zn.ROUNDED_RECT : zn.CLOUD;
    case "((":
      return zn.CIRCLE;
    case ")":
      return zn.CLOUD;
    case "))":
      return zn.BANG;
    case "{{":
      return zn.HEXAGON;
    default:
      return zn.DEFAULT;
  }
}, "getType"), nat = /* @__PURE__ */ w((t, e) => {
  pM[t] = e;
}, "setElementForId"), iat = /* @__PURE__ */ w((t) => {
  if (!t)
    return;
  const e = Te(), r = Va[Va.length - 1];
  t.icon && (r.icon = pr(t.icon, e)), t.class && (r.cssClasses = pr(t.class, e));
}, "decorateNode"), aat = /* @__PURE__ */ w((t) => {
  switch (t) {
    case zn.DEFAULT:
      return "no-border";
    case zn.RECT:
      return "rect";
    case zn.ROUNDED_RECT:
      return "rounded-rect";
    case zn.CIRCLE:
      return "circle";
    case zn.CLOUD:
      return "cloud";
    case zn.BANG:
      return "bang";
    case zn.HEXAGON:
      return "hexgon";
    // cspell: disable-line
    default:
      return "no-border";
  }
}, "type2Str"), sat = /* @__PURE__ */ w(() => ae, "getLogger"), oat = /* @__PURE__ */ w((t) => pM[t], "getElementById"), lat = {
  clear: Qit,
  addNode: tat,
  getSections: wue,
  getData: eat,
  nodeType: zn,
  getType: rat,
  setElementForId: nat,
  decorateNode: iat,
  type2Str: aat,
  getLogger: sat,
  getElementById: oat
}, cat = lat, uat = /* @__PURE__ */ w(async (t, e, r, n) => {
  ae.debug(`Rendering kanban diagram
` + t);
  const a = n.db.getData(), s = Te();
  s.htmlLabels = !1;
  const o = El(e), l = o.append("g");
  l.attr("class", "sections");
  const u = o.append("g");
  u.attr("class", "items");
  const h = a.nodes.filter(
    // TODO: TypeScript 5.5 will infer this predicate automatically
    (v) => v.isGroup
  );
  let f = 0;
  const d = 10, p = [];
  let g = 25;
  for (const v of h) {
    const y = s?.kanban?.sectionWidth || 200;
    f = f + 1, v.x = y * f + (f - 1) * d / 2, v.width = y, v.y = 0, v.height = y * 3, v.rx = 5, v.ry = 5, v.cssClasses = v.cssClasses + " section-" + f;
    const b = await lL(l, v);
    g = Math.max(g, b?.labelBBox?.height), p.push(b);
  }
  let m = 0;
  for (const v of h) {
    const y = p[m];
    m = m + 1;
    const b = s?.kanban?.sectionWidth || 200, x = -b * 3 / 2 + g;
    let T = x;
    const E = a.nodes.filter((k) => k.parentId === v.id);
    for (const k of E) {
      if (k.isGroup)
        throw new Error("Groups within groups are not allowed in Kanban diagrams");
      k.x = v.x, k.width = b - 1.5 * d;
      const R = (await d4(u, k, { config: s })).node().getBBox();
      k.y = T + R.height / 2, await H_(k), T = k.y + R.height / 2 + d / 2;
    }
    const A = y.cluster.select("rect"), S = Math.max(T - x + 3 * d, 50) + (g - 25);
    A.attr("height", S);
  }
  Q1(
    void 0,
    o,
    s.mindmap?.padding ?? fr.kanban.padding,
    s.mindmap?.useMaxWidth ?? fr.kanban.useMaxWidth
  );
}, "draw"), hat = {
  draw: uat
}, fat = /* @__PURE__ */ w((t) => {
  let e = "";
  for (let n = 0; n < t.THEME_COLOR_LIMIT; n++)
    t["lineColor" + n] = t["lineColor" + n] || t["cScaleInv" + n], Pc(t["lineColor" + n]) ? t["lineColor" + n] = _t(t["lineColor" + n], 20) : t["lineColor" + n] = Nt(t["lineColor" + n], 20);
  const r = /* @__PURE__ */ w((n, i) => t.darkMode ? Nt(n, i) : _t(n, i), "adjuster");
  for (let n = 0; n < t.THEME_COLOR_LIMIT; n++) {
    const i = "" + (17 - 3 * n);
    e += `
    .section-${n - 1} rect, .section-${n - 1} path, .section-${n - 1} circle, .section-${n - 1} polygon, .section-${n - 1} path  {
      fill: ${r(t["cScale" + n], 10)};
      stroke: ${r(t["cScale" + n], 10)};

    }
    .section-${n - 1} text {
     fill: ${t["cScaleLabel" + n]};
    }
    .node-icon-${n - 1} {
      font-size: 40px;
      color: ${t["cScaleLabel" + n]};
    }
    .section-edge-${n - 1}{
      stroke: ${t["cScale" + n]};
    }
    .edge-depth-${n - 1}{
      stroke-width: ${i};
    }
    .section-${n - 1} line {
      stroke: ${t["cScaleInv" + n]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.background};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .kanban-ticket-link {
    fill: ${t.background};
    stroke: ${t.nodeBorder};
    text-decoration: underline;
  }
    `;
  }
  return e;
}, "genSections"), dat = /* @__PURE__ */ w((t) => `
  .edge {
    stroke-width: 3;
  }
  ${fat(t)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${t.git0};
  }
  .section-root text {
    fill: ${t.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .cluster-label, .label {
    color: ${t.textColor};
    fill: ${t.textColor};
    }
  .kanban-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
    ${Rm()}
`, "getStyles"), pat = dat, gat = {
  db: cat,
  renderer: hat,
  parser: Zit,
  styles: pat
};
const mat = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: gat
}, Symbol.toStringTag, { value: "Module" }));
function yY(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Tue(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function H7(t, e) {
  let r = 0;
  if (e === void 0)
    for (let n of t)
      (n = +n) && (r += n);
  else {
    let n = -1;
    for (let i of t)
      (i = +e(i, ++n, t)) && (r += i);
  }
  return r;
}
function vat(t) {
  return t.target.depth;
}
function yat(t) {
  return t.depth;
}
function bat(t, e) {
  return e - 1 - t.height;
}
function Eue(t, e) {
  return t.sourceLinks.length ? t.depth : e - 1;
}
function xat(t) {
  return t.targetLinks.length ? t.depth : t.sourceLinks.length ? Tue(t.sourceLinks, vat) - 1 : 0;
}
function dy(t) {
  return function() {
    return t;
  };
}
function bY(t, e) {
  return _x(t.source, e.source) || t.index - e.index;
}
function xY(t, e) {
  return _x(t.target, e.target) || t.index - e.index;
}
function _x(t, e) {
  return t.y0 - e.y0;
}
function W7(t) {
  return t.value;
}
function wat(t) {
  return t.index;
}
function Tat(t) {
  return t.nodes;
}
function Eat(t) {
  return t.links;
}
function wY(t, e) {
  const r = t.get(e);
  if (!r) throw new Error("missing: " + e);
  return r;
}
function TY({ nodes: t }) {
  for (const e of t) {
    let r = e.y0, n = r;
    for (const i of e.sourceLinks)
      i.y0 = r + i.width / 2, r += i.width;
    for (const i of e.targetLinks)
      i.y1 = n + i.width / 2, n += i.width;
  }
}
function Sat() {
  let t = 0, e = 0, r = 1, n = 1, i = 24, a = 8, s, o = wat, l = Eue, u, h, f = Tat, d = Eat, p = 6;
  function g() {
    const I = { nodes: f.apply(null, arguments), links: d.apply(null, arguments) };
    return m(I), v(I), y(I), b(I), E(I), TY(I), I;
  }
  g.update = function(I) {
    return TY(I), I;
  }, g.nodeId = function(I) {
    return arguments.length ? (o = typeof I == "function" ? I : dy(I), g) : o;
  }, g.nodeAlign = function(I) {
    return arguments.length ? (l = typeof I == "function" ? I : dy(I), g) : l;
  }, g.nodeSort = function(I) {
    return arguments.length ? (u = I, g) : u;
  }, g.nodeWidth = function(I) {
    return arguments.length ? (i = +I, g) : i;
  }, g.nodePadding = function(I) {
    return arguments.length ? (a = s = +I, g) : a;
  }, g.nodes = function(I) {
    return arguments.length ? (f = typeof I == "function" ? I : dy(I), g) : f;
  }, g.links = function(I) {
    return arguments.length ? (d = typeof I == "function" ? I : dy(I), g) : d;
  }, g.linkSort = function(I) {
    return arguments.length ? (h = I, g) : h;
  }, g.size = function(I) {
    return arguments.length ? (t = e = 0, r = +I[0], n = +I[1], g) : [r - t, n - e];
  }, g.extent = function(I) {
    return arguments.length ? (t = +I[0][0], r = +I[1][0], e = +I[0][1], n = +I[1][1], g) : [[t, e], [r, n]];
  }, g.iterations = function(I) {
    return arguments.length ? (p = +I, g) : p;
  };
  function m({ nodes: I, links: N }) {
    for (const [D, $] of I.entries())
      $.index = D, $.sourceLinks = [], $.targetLinks = [];
    const O = new Map(I.map((D, $) => [o(D, $, I), D]));
    for (const [D, $] of N.entries()) {
      $.index = D;
      let { source: z, target: B } = $;
      typeof z != "object" && (z = $.source = wY(O, z)), typeof B != "object" && (B = $.target = wY(O, B)), z.sourceLinks.push($), B.targetLinks.push($);
    }
    if (h != null)
      for (const { sourceLinks: D, targetLinks: $ } of I)
        D.sort(h), $.sort(h);
  }
  function v({ nodes: I }) {
    for (const N of I)
      N.value = N.fixedValue === void 0 ? Math.max(H7(N.sourceLinks, W7), H7(N.targetLinks, W7)) : N.fixedValue;
  }
  function y({ nodes: I }) {
    const N = I.length;
    let O = new Set(I), D = /* @__PURE__ */ new Set(), $ = 0;
    for (; O.size; ) {
      for (const z of O) {
        z.depth = $;
        for (const { target: B } of z.sourceLinks)
          D.add(B);
      }
      if (++$ > N) throw new Error("circular link");
      O = D, D = /* @__PURE__ */ new Set();
    }
  }
  function b({ nodes: I }) {
    const N = I.length;
    let O = new Set(I), D = /* @__PURE__ */ new Set(), $ = 0;
    for (; O.size; ) {
      for (const z of O) {
        z.height = $;
        for (const { source: B } of z.targetLinks)
          D.add(B);
      }
      if (++$ > N) throw new Error("circular link");
      O = D, D = /* @__PURE__ */ new Set();
    }
  }
  function x({ nodes: I }) {
    const N = yY(I, ($) => $.depth) + 1, O = (r - t - i) / (N - 1), D = new Array(N);
    for (const $ of I) {
      const z = Math.max(0, Math.min(N - 1, Math.floor(l.call(null, $, N))));
      $.layer = z, $.x0 = t + z * O, $.x1 = $.x0 + i, D[z] ? D[z].push($) : D[z] = [$];
    }
    if (u) for (const $ of D)
      $.sort(u);
    return D;
  }
  function T(I) {
    const N = Tue(I, (O) => (n - e - (O.length - 1) * s) / H7(O, W7));
    for (const O of I) {
      let D = e;
      for (const $ of O) {
        $.y0 = D, $.y1 = D + $.value * N, D = $.y1 + s;
        for (const z of $.sourceLinks)
          z.width = z.value * N;
      }
      D = (n - D + s) / (O.length + 1);
      for (let $ = 0; $ < O.length; ++$) {
        const z = O[$];
        z.y0 += D * ($ + 1), z.y1 += D * ($ + 1);
      }
      M(O);
    }
  }
  function E(I) {
    const N = x(I);
    s = Math.min(a, (n - e) / (yY(N, (O) => O.length) - 1)), T(N);
    for (let O = 0; O < p; ++O) {
      const D = Math.pow(0.99, O), $ = Math.max(1 - D, (O + 1) / p);
      S(N, D, $), A(N, D, $);
    }
  }
  function A(I, N, O) {
    for (let D = 1, $ = I.length; D < $; ++D) {
      const z = I[D];
      for (const B of z) {
        let G = 0, W = 0;
        for (const { source: U, value: Z } of B.targetLinks) {
          let K = Z * (B.layer - U.layer);
          G += P(U, B) * K, W += K;
        }
        if (!(W > 0)) continue;
        let V = (G / W - B.y0) * N;
        B.y0 += V, B.y1 += V, L(B);
      }
      u === void 0 && z.sort(_x), k(z, O);
    }
  }
  function S(I, N, O) {
    for (let D = I.length, $ = D - 2; $ >= 0; --$) {
      const z = I[$];
      for (const B of z) {
        let G = 0, W = 0;
        for (const { target: U, value: Z } of B.sourceLinks) {
          let K = Z * (U.layer - B.layer);
          G += C(B, U) * K, W += K;
        }
        if (!(W > 0)) continue;
        let V = (G / W - B.y0) * N;
        B.y0 += V, B.y1 += V, L(B);
      }
      u === void 0 && z.sort(_x), k(z, O);
    }
  }
  function k(I, N) {
    const O = I.length >> 1, D = I[O];
    R(I, D.y0 - s, O - 1, N), _(I, D.y1 + s, O + 1, N), R(I, n, I.length - 1, N), _(I, e, 0, N);
  }
  function _(I, N, O, D) {
    for (; O < I.length; ++O) {
      const $ = I[O], z = (N - $.y0) * D;
      z > 1e-6 && ($.y0 += z, $.y1 += z), N = $.y1 + s;
    }
  }
  function R(I, N, O, D) {
    for (; O >= 0; --O) {
      const $ = I[O], z = ($.y1 - N) * D;
      z > 1e-6 && ($.y0 -= z, $.y1 -= z), N = $.y0 - s;
    }
  }
  function L({ sourceLinks: I, targetLinks: N }) {
    if (h === void 0) {
      for (const { source: { sourceLinks: O } } of N)
        O.sort(xY);
      for (const { target: { targetLinks: O } } of I)
        O.sort(bY);
    }
  }
  function M(I) {
    if (h === void 0)
      for (const { sourceLinks: N, targetLinks: O } of I)
        N.sort(xY), O.sort(bY);
  }
  function P(I, N) {
    let O = I.y0 - (I.sourceLinks.length - 1) * s / 2;
    for (const { target: D, width: $ } of I.sourceLinks) {
      if (D === N) break;
      O += $ + s;
    }
    for (const { source: D, width: $ } of N.targetLinks) {
      if (D === I) break;
      O -= $;
    }
    return O;
  }
  function C(I, N) {
    let O = N.y0 - (N.targetLinks.length - 1) * s / 2;
    for (const { source: D, width: $ } of N.targetLinks) {
      if (D === I) break;
      O += $ + s;
    }
    for (const { target: D, width: $ } of I.sourceLinks) {
      if (D === N) break;
      O -= $;
    }
    return O;
  }
  return g;
}
var Z8 = Math.PI, Q8 = 2 * Z8, wu = 1e-6, kat = Q8 - wu;
function J8() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function Sue() {
  return new J8();
}
J8.prototype = Sue.prototype = {
  constructor: J8,
  moveTo: function(t, e) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(t, e) {
    this._ += "L" + (this._x1 = +t) + "," + (this._y1 = +e);
  },
  quadraticCurveTo: function(t, e, r, n) {
    this._ += "Q" + +t + "," + +e + "," + (this._x1 = +r) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(t, e, r, n, i, a) {
    this._ += "C" + +t + "," + +e + "," + +r + "," + +n + "," + (this._x1 = +i) + "," + (this._y1 = +a);
  },
  arcTo: function(t, e, r, n, i) {
    t = +t, e = +e, r = +r, n = +n, i = +i;
    var a = this._x1, s = this._y1, o = r - t, l = n - e, u = a - t, h = s - e, f = u * u + h * h;
    if (i < 0) throw new Error("negative radius: " + i);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = t) + "," + (this._y1 = e);
    else if (f > wu) if (!(Math.abs(h * o - l * u) > wu) || !i)
      this._ += "L" + (this._x1 = t) + "," + (this._y1 = e);
    else {
      var d = r - a, p = n - s, g = o * o + l * l, m = d * d + p * p, v = Math.sqrt(g), y = Math.sqrt(f), b = i * Math.tan((Z8 - Math.acos((g + f - m) / (2 * v * y))) / 2), x = b / y, T = b / v;
      Math.abs(x - 1) > wu && (this._ += "L" + (t + x * u) + "," + (e + x * h)), this._ += "A" + i + "," + i + ",0,0," + +(h * d > u * p) + "," + (this._x1 = t + T * o) + "," + (this._y1 = e + T * l);
    }
  },
  arc: function(t, e, r, n, i, a) {
    t = +t, e = +e, r = +r, a = !!a;
    var s = r * Math.cos(n), o = r * Math.sin(n), l = t + s, u = e + o, h = 1 ^ a, f = a ? n - i : i - n;
    if (r < 0) throw new Error("negative radius: " + r);
    this._x1 === null ? this._ += "M" + l + "," + u : (Math.abs(this._x1 - l) > wu || Math.abs(this._y1 - u) > wu) && (this._ += "L" + l + "," + u), r && (f < 0 && (f = f % Q8 + Q8), f > kat ? this._ += "A" + r + "," + r + ",0,1," + h + "," + (t - s) + "," + (e - o) + "A" + r + "," + r + ",0,1," + h + "," + (this._x1 = l) + "," + (this._y1 = u) : f > wu && (this._ += "A" + r + "," + r + ",0," + +(f >= Z8) + "," + h + "," + (this._x1 = t + r * Math.cos(i)) + "," + (this._y1 = e + r * Math.sin(i))));
  },
  rect: function(t, e, r, n) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e) + "h" + +r + "v" + +n + "h" + -r + "Z";
  },
  toString: function() {
    return this._;
  }
};
function EY(t) {
  return function() {
    return t;
  };
}
function Cat(t) {
  return t[0];
}
function _at(t) {
  return t[1];
}
var Aat = Array.prototype.slice;
function Lat(t) {
  return t.source;
}
function Rat(t) {
  return t.target;
}
function Iat(t) {
  var e = Lat, r = Rat, n = Cat, i = _at, a = null;
  function s() {
    var o, l = Aat.call(arguments), u = e.apply(this, l), h = r.apply(this, l);
    if (a || (a = o = Sue()), t(a, +n.apply(this, (l[0] = u, l)), +i.apply(this, l), +n.apply(this, (l[0] = h, l)), +i.apply(this, l)), o) return a = null, o + "" || null;
  }
  return s.source = function(o) {
    return arguments.length ? (e = o, s) : e;
  }, s.target = function(o) {
    return arguments.length ? (r = o, s) : r;
  }, s.x = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : EY(+o), s) : n;
  }, s.y = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : EY(+o), s) : i;
  }, s.context = function(o) {
    return arguments.length ? (a = o ?? null, s) : a;
  }, s;
}
function Mat(t, e, r, n, i) {
  t.moveTo(e, r), t.bezierCurveTo(e = (e + n) / 2, r, e, i, n, i);
}
function Nat() {
  return Iat(Mat);
}
function Dat(t) {
  return [t.source.x1, t.y0];
}
function Oat(t) {
  return [t.target.x0, t.y1];
}
function Pat() {
  return Nat().source(Dat).target(Oat);
}
var e9 = (function() {
  var t = /* @__PURE__ */ w(function(o, l, u, h) {
    for (u = u || {}, h = o.length; h--; u[o[h]] = l) ;
    return u;
  }, "o"), e = [1, 9], r = [1, 10], n = [1, 5, 10, 12], i = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SANKEY: 4, NEWLINE: 5, csv: 6, opt_eof: 7, record: 8, csv_tail: 9, EOF: 10, "field[source]": 11, COMMA: 12, "field[target]": 13, "field[value]": 14, field: 15, escaped: 16, non_escaped: 17, DQUOTE: 18, ESCAPED_TEXT: 19, NON_ESCAPED_TEXT: 20, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SANKEY", 5: "NEWLINE", 10: "EOF", 11: "field[source]", 12: "COMMA", 13: "field[target]", 14: "field[value]", 18: "DQUOTE", 19: "ESCAPED_TEXT", 20: "NON_ESCAPED_TEXT" },
    productions_: [0, [3, 4], [6, 2], [9, 2], [9, 0], [7, 1], [7, 0], [8, 5], [15, 1], [15, 1], [16, 3], [17, 1]],
    performAction: /* @__PURE__ */ w(function(l, u, h, f, d, p, g) {
      var m = p.length - 1;
      switch (d) {
        case 7:
          const v = f.findOrCreateNode(p[m - 4].trim().replaceAll('""', '"')), y = f.findOrCreateNode(p[m - 2].trim().replaceAll('""', '"')), b = parseFloat(p[m].trim());
          f.addLink(v, y, b);
          break;
        case 8:
        case 9:
        case 11:
          this.$ = p[m];
          break;
        case 10:
          this.$ = p[m - 1];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, { 5: [1, 3] }, { 6: 4, 8: 5, 15: 6, 16: 7, 17: 8, 18: e, 20: r }, { 1: [2, 6], 7: 11, 10: [1, 12] }, t(r, [2, 4], { 9: 13, 5: [1, 14] }), { 12: [1, 15] }, t(n, [2, 8]), t(n, [2, 9]), { 19: [1, 16] }, t(n, [2, 11]), { 1: [2, 1] }, { 1: [2, 5] }, t(r, [2, 2]), { 6: 17, 8: 5, 15: 6, 16: 7, 17: 8, 18: e, 20: r }, { 15: 18, 16: 7, 17: 8, 18: e, 20: r }, { 18: [1, 19] }, t(r, [2, 3]), { 12: [1, 20] }, t(n, [2, 10]), { 15: 21, 16: 7, 17: 8, 18: e, 20: r }, t([1, 5, 10], [2, 7])],
    defaultActions: { 11: [2, 1], 12: [2, 5] },
    parseError: /* @__PURE__ */ w(function(l, u) {
      if (u.recoverable)
        this.trace(l);
      else {
        var h = new Error(l);
        throw h.hash = u, h;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(l) {
      var u = this, h = [0], f = [], d = [null], p = [], g = this.table, m = "", v = 0, y = 0, b = 2, x = 1, T = p.slice.call(arguments, 1), E = Object.create(this.lexer), A = { yy: {} };
      for (var S in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, S) && (A.yy[S] = this.yy[S]);
      E.setInput(l, A.yy), A.yy.lexer = E, A.yy.parser = this, typeof E.yylloc > "u" && (E.yylloc = {});
      var k = E.yylloc;
      p.push(k);
      var _ = E.options && E.options.ranges;
      typeof A.yy.parseError == "function" ? this.parseError = A.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function R(G) {
        h.length = h.length - 2 * G, d.length = d.length - G, p.length = p.length - G;
      }
      w(R, "popStack");
      function L() {
        var G;
        return G = f.pop() || E.lex() || x, typeof G != "number" && (G instanceof Array && (f = G, G = f.pop()), G = u.symbols_[G] || G), G;
      }
      w(L, "lex");
      for (var M, P, C, I, N = {}, O, D, $, z; ; ) {
        if (P = h[h.length - 1], this.defaultActions[P] ? C = this.defaultActions[P] : ((M === null || typeof M > "u") && (M = L()), C = g[P] && g[P][M]), typeof C > "u" || !C.length || !C[0]) {
          var B = "";
          z = [];
          for (O in g[P])
            this.terminals_[O] && O > b && z.push("'" + this.terminals_[O] + "'");
          E.showPosition ? B = "Parse error on line " + (v + 1) + `:
` + E.showPosition() + `
Expecting ` + z.join(", ") + ", got '" + (this.terminals_[M] || M) + "'" : B = "Parse error on line " + (v + 1) + ": Unexpected " + (M == x ? "end of input" : "'" + (this.terminals_[M] || M) + "'"), this.parseError(B, {
            text: E.match,
            token: this.terminals_[M] || M,
            line: E.yylineno,
            loc: k,
            expected: z
          });
        }
        if (C[0] instanceof Array && C.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + P + ", token: " + M);
        switch (C[0]) {
          case 1:
            h.push(M), d.push(E.yytext), p.push(E.yylloc), h.push(C[1]), M = null, y = E.yyleng, m = E.yytext, v = E.yylineno, k = E.yylloc;
            break;
          case 2:
            if (D = this.productions_[C[1]][1], N.$ = d[d.length - D], N._$ = {
              first_line: p[p.length - (D || 1)].first_line,
              last_line: p[p.length - 1].last_line,
              first_column: p[p.length - (D || 1)].first_column,
              last_column: p[p.length - 1].last_column
            }, _ && (N._$.range = [
              p[p.length - (D || 1)].range[0],
              p[p.length - 1].range[1]
            ]), I = this.performAction.apply(N, [
              m,
              y,
              v,
              A.yy,
              C[1],
              d,
              p
            ].concat(T)), typeof I < "u")
              return I;
            D && (h = h.slice(0, -1 * D * 2), d = d.slice(0, -1 * D), p = p.slice(0, -1 * D)), h.push(this.productions_[C[1]][0]), d.push(N.$), p.push(N._$), $ = g[h[h.length - 2]][h[h.length - 1]], h.push($);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, a = /* @__PURE__ */ (function() {
    var o = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(u, h) {
        if (this.yy.parser)
          this.yy.parser.parseError(u, h);
        else
          throw new Error(u);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(l, u) {
        return this.yy = u || this.yy || {}, this._input = l, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var l = this._input[0];
        this.yytext += l, this.yyleng++, this.offset++, this.match += l, this.matched += l;
        var u = l.match(/(?:\r\n?|\n).*/g);
        return u ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), l;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(l) {
        var u = l.length, h = l.split(/(?:\r\n?|\n)/g);
        this._input = l + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - u), this.offset -= u;
        var f = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), h.length - 1 && (this.yylineno -= h.length - 1);
        var d = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: h ? (h.length === f.length ? this.yylloc.first_column : 0) + f[f.length - h.length].length - h[0].length : this.yylloc.first_column - u
        }, this.options.ranges && (this.yylloc.range = [d[0], d[0] + this.yyleng - u]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(l) {
        this.unput(this.match.slice(l));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var l = this.matched.substr(0, this.matched.length - this.match.length);
        return (l.length > 20 ? "..." : "") + l.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var l = this.match;
        return l.length < 20 && (l += this._input.substr(0, 20 - l.length)), (l.substr(0, 20) + (l.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var l = this.pastInput(), u = new Array(l.length + 1).join("-");
        return l + this.upcomingInput() + `
` + u + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(l, u) {
        var h, f, d;
        if (this.options.backtrack_lexer && (d = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (d.yylloc.range = this.yylloc.range.slice(0))), f = l[0].match(/(?:\r\n?|\n).*/g), f && (this.yylineno += f.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: f ? f[f.length - 1].length - f[f.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + l[0].length
        }, this.yytext += l[0], this.match += l[0], this.matches = l, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(l[0].length), this.matched += l[0], h = this.performAction.call(this, this.yy, this, u, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), h)
          return h;
        if (this._backtrack) {
          for (var p in d)
            this[p] = d[p];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var l, u, h, f;
        this._more || (this.yytext = "", this.match = "");
        for (var d = this._currentRules(), p = 0; p < d.length; p++)
          if (h = this._input.match(this.rules[d[p]]), h && (!u || h[0].length > u[0].length)) {
            if (u = h, f = p, this.options.backtrack_lexer) {
              if (l = this.test_match(h, d[p]), l !== !1)
                return l;
              if (this._backtrack) {
                u = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return u ? (l = this.test_match(u, d[f]), l !== !1 ? l : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var u = this.next();
        return u || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(u) {
        this.conditionStack.push(u);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var u = this.conditionStack.length - 1;
        return u > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(u) {
        return u = this.conditionStack.length - 1 - Math.abs(u || 0), u >= 0 ? this.conditionStack[u] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(u) {
        this.begin(u);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ w(function(u, h, f, d) {
        switch (f) {
          case 0:
            return this.pushState("csv"), 4;
          case 1:
            return this.pushState("csv"), 4;
          case 2:
            return 10;
          case 3:
            return 5;
          case 4:
            return 12;
          case 5:
            return this.pushState("escaped_text"), 18;
          case 6:
            return 20;
          case 7:
            return this.popState("escaped_text"), 18;
          case 8:
            return 19;
        }
      }, "anonymous"),
      rules: [/^(?:sankey-beta\b)/i, /^(?:sankey\b)/i, /^(?:$)/i, /^(?:((\u000D\u000A)|(\u000A)))/i, /^(?:(\u002C))/i, /^(?:(\u0022))/i, /^(?:([\u0020-\u0021\u0023-\u002B\u002D-\u007E])*)/i, /^(?:(\u0022)(?!(\u0022)))/i, /^(?:(([\u0020-\u0021\u0023-\u002B\u002D-\u007E])|(\u002C)|(\u000D)|(\u000A)|(\u0022)(\u0022))*)/i],
      conditions: { csv: { rules: [2, 3, 4, 5, 6, 7, 8], inclusive: !1 }, escaped_text: { rules: [7, 8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8], inclusive: !0 } }
    };
    return o;
  })();
  i.lexer = a;
  function s() {
    this.yy = {};
  }
  return w(s, "Parser"), s.prototype = i, i.Parser = s, new s();
})();
e9.parser = e9;
var Ax = e9, r5 = [], n5 = [], Lx = /* @__PURE__ */ new Map(), $at = /* @__PURE__ */ w(() => {
  r5 = [], n5 = [], Lx = /* @__PURE__ */ new Map(), In();
}, "clear"), zd, Bat = (zd = class {
  constructor(e, r, n = 0) {
    this.source = e, this.target = r, this.value = n;
  }
}, w(zd, "SankeyLink"), zd), Fat = /* @__PURE__ */ w((t, e, r) => {
  r5.push(new Bat(t, e, r));
}, "addLink"), qd, zat = (qd = class {
  constructor(e) {
    this.ID = e;
  }
}, w(qd, "SankeyNode"), qd), qat = /* @__PURE__ */ w((t) => {
  t = at.sanitizeText(t, Te());
  let e = Lx.get(t);
  return e === void 0 && (e = new zat(t), Lx.set(t, e), n5.push(e)), e;
}, "findOrCreateNode"), Gat = /* @__PURE__ */ w(() => n5, "getNodes"), Uat = /* @__PURE__ */ w(() => r5, "getLinks"), Vat = /* @__PURE__ */ w(() => ({
  nodes: n5.map((t) => ({ id: t.ID })),
  links: r5.map((t) => ({
    source: t.source.ID,
    target: t.target.ID,
    value: t.value
  }))
}), "getGraph"), Hat = {
  nodesMap: Lx,
  getConfig: /* @__PURE__ */ w(() => Te().sankey, "getConfig"),
  getNodes: Gat,
  getLinks: Uat,
  getGraph: Vat,
  addLink: Fat,
  findOrCreateNode: qat,
  getAccTitle: Hn,
  setAccTitle: Ln,
  getAccDescription: Yn,
  setAccDescription: Wn,
  getDiagramTitle: Mn,
  setDiagramTitle: ti,
  clear: $at
}, nl, SY = (nl = class {
  static next(e) {
    return new nl(e + ++nl.count);
  }
  constructor(e) {
    this.id = e, this.href = `#${e}`;
  }
  toString() {
    return "url(" + this.href + ")";
  }
}, w(nl, "Uid"), nl.count = 0, nl), Wat = {
  left: yat,
  right: bat,
  center: xat,
  justify: Eue
}, Yat = /* @__PURE__ */ w(function(t, e, r, n) {
  const { securityLevel: i, sankey: a } = Te(), s = aX.sankey;
  let o;
  i === "sandbox" && (o = Qe("#i" + e));
  const l = Qe(i === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), u = i === "sandbox" ? l.select(`[id="${e}"]`) : Qe(`[id="${e}"]`), h = a?.width ?? s.width, f = a?.height ?? s.width, d = a?.useMaxWidth ?? s.useMaxWidth, p = a?.nodeAlignment ?? s.nodeAlignment, g = a?.prefix ?? s.prefix, m = a?.suffix ?? s.suffix, v = a?.showValues ?? s.showValues, y = n.db.getGraph(), b = Wat[p];
  Sat().nodeId((R) => R.id).nodeWidth(10).nodePadding(10 + (v ? 15 : 0)).nodeAlign(b).extent([
    [0, 0],
    [h, f]
  ])(y);
  const E = Bu(zme);
  u.append("g").attr("class", "nodes").selectAll(".node").data(y.nodes).join("g").attr("class", "node").attr("id", (R) => (R.uid = SY.next("node-")).id).attr("transform", function(R) {
    return "translate(" + R.x0 + "," + R.y0 + ")";
  }).attr("x", (R) => R.x0).attr("y", (R) => R.y0).append("rect").attr("height", (R) => R.y1 - R.y0).attr("width", (R) => R.x1 - R.x0).attr("fill", (R) => E(R.id));
  const A = /* @__PURE__ */ w(({ id: R, value: L }) => v ? `${R}
${g}${Math.round(L * 100) / 100}${m}` : R, "getText");
  u.append("g").attr("class", "node-labels").attr("font-size", 14).selectAll("text").data(y.nodes).join("text").attr("x", (R) => R.x0 < h / 2 ? R.x1 + 6 : R.x0 - 6).attr("y", (R) => (R.y1 + R.y0) / 2).attr("dy", `${v ? "0" : "0.35"}em`).attr("text-anchor", (R) => R.x0 < h / 2 ? "start" : "end").text(A);
  const S = u.append("g").attr("class", "links").attr("fill", "none").attr("stroke-opacity", 0.5).selectAll(".link").data(y.links).join("g").attr("class", "link").style("mix-blend-mode", "multiply"), k = a?.linkColor ?? "gradient";
  if (k === "gradient") {
    const R = S.append("linearGradient").attr("id", (L) => (L.uid = SY.next("linearGradient-")).id).attr("gradientUnits", "userSpaceOnUse").attr("x1", (L) => L.source.x1).attr("x2", (L) => L.target.x0);
    R.append("stop").attr("offset", "0%").attr("stop-color", (L) => E(L.source.id)), R.append("stop").attr("offset", "100%").attr("stop-color", (L) => E(L.target.id));
  }
  let _;
  switch (k) {
    case "gradient":
      _ = /* @__PURE__ */ w((R) => R.uid, "coloring");
      break;
    case "source":
      _ = /* @__PURE__ */ w((R) => E(R.source.id), "coloring");
      break;
    case "target":
      _ = /* @__PURE__ */ w((R) => E(R.target.id), "coloring");
      break;
    default:
      _ = k;
  }
  S.append("path").attr("d", Pat()).attr("stroke", _).attr("stroke-width", (R) => Math.max(1, R.width)), Q1(void 0, u, 0, d);
}, "draw"), Xat = {
  draw: Yat
}, jat = /* @__PURE__ */ w((t) => t.replaceAll(/^[^\S\n\r]+|[^\S\n\r]+$/g, "").replaceAll(/([\n\r])+/g, `
`).trim(), "prepareTextForParsing"), Kat = /* @__PURE__ */ w((t) => `.label {
      font-family: ${t.fontFamily};
    }`, "getStyles"), Zat = Kat, Qat = Ax.parse.bind(Ax);
Ax.parse = (t) => Qat(jat(t));
var Jat = {
  styles: Zat,
  parser: Ax,
  db: Hat,
  renderer: Xat
};
const est = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Jat
}, Symbol.toStringTag, { value: "Module" }));
var tst = fr.packet, Gd, kue = (Gd = class {
  constructor() {
    this.packet = [], this.setAccTitle = Ln, this.getAccTitle = Hn, this.setDiagramTitle = ti, this.getDiagramTitle = Mn, this.getAccDescription = Yn, this.setAccDescription = Wn;
  }
  getConfig() {
    const e = Xi({
      ...tst,
      ...mr().packet
    });
    return e.showBits && (e.paddingY += 10), e;
  }
  getPacket() {
    return this.packet;
  }
  pushWord(e) {
    e.length > 0 && this.packet.push(e);
  }
  clear() {
    In(), this.packet = [];
  }
}, w(Gd, "PacketDB"), Gd), rst = 1e4, nst = /* @__PURE__ */ w((t, e) => {
  Ph(t, e);
  let r = -1, n = [], i = 1;
  const { bitsPerRow: a } = e.getConfig();
  for (let { start: s, end: o, bits: l, label: u } of t.blocks) {
    if (s !== void 0 && o !== void 0 && o < s)
      throw new Error(`Packet block ${s} - ${o} is invalid. End must be greater than start.`);
    if (s ??= r + 1, s !== r + 1)
      throw new Error(
        `Packet block ${s} - ${o ?? s} is not contiguous. It should start from ${r + 1}.`
      );
    if (l === 0)
      throw new Error(`Packet block ${s} is invalid. Cannot have a zero bit field.`);
    for (o ??= s + (l ?? 1) - 1, l ??= o - s + 1, r = o, ae.debug(`Packet block ${s} - ${r} with label ${u}`); n.length <= a + 1 && e.getPacket().length < rst; ) {
      const [h, f] = ist({ start: s, end: o, bits: l, label: u }, i, a);
      if (n.push(h), h.end + 1 === i * a && (e.pushWord(n), n = [], i++), !f)
        break;
      ({ start: s, end: o, bits: l, label: u } = f);
    }
  }
  e.pushWord(n);
}, "populate"), ist = /* @__PURE__ */ w((t, e, r) => {
  if (t.start === void 0)
    throw new Error("start should have been set during first phase");
  if (t.end === void 0)
    throw new Error("end should have been set during first phase");
  if (t.start > t.end)
    throw new Error(`Block start ${t.start} is greater than block end ${t.end}.`);
  if (t.end + 1 <= e * r)
    return [t, void 0];
  const n = e * r - 1, i = e * r;
  return [
    {
      start: t.start,
      end: n,
      label: t.label,
      bits: n - t.start
    },
    {
      start: i,
      end: t.end,
      label: t.label,
      bits: t.end - i
    }
  ];
}, "getNextFittingBlock"), Cue = {
  // @ts-expect-error - PacketDB is not assignable to DiagramDB
  parser: { yy: void 0 },
  parse: /* @__PURE__ */ w(async (t) => {
    const e = await ru("packet", t), r = Cue.parser?.yy;
    if (!(r instanceof kue))
      throw new Error(
        "parser.parser?.yy was not a PacketDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
      );
    ae.debug(e), nst(e, r);
  }, "parse")
}, ast = /* @__PURE__ */ w((t, e, r, n) => {
  const i = n.db, a = i.getConfig(), { rowHeight: s, paddingY: o, bitWidth: l, bitsPerRow: u } = a, h = i.getPacket(), f = i.getDiagramTitle(), d = s + o, p = d * (h.length + 1) - (f ? 0 : s), g = l * u + 2, m = El(e);
  m.attr("viewbox", `0 0 ${g} ${p}`), Qi(m, p, g, a.useMaxWidth);
  for (const [v, y] of h.entries())
    sst(m, y, v, a);
  m.append("text").text(f).attr("x", g / 2).attr("y", p - d / 2).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr("class", "packetTitle");
}, "draw"), sst = /* @__PURE__ */ w((t, e, r, { rowHeight: n, paddingX: i, paddingY: a, bitWidth: s, bitsPerRow: o, showBits: l }) => {
  const u = t.append("g"), h = r * (n + a) + a;
  for (const f of e) {
    const d = f.start % o * s + 1, p = (f.end - f.start + 1) * s - i;
    if (u.append("rect").attr("x", d).attr("y", h).attr("width", p).attr("height", n).attr("class", "packetBlock"), u.append("text").attr("x", d + p / 2).attr("y", h + n / 2).attr("class", "packetLabel").attr("dominant-baseline", "middle").attr("text-anchor", "middle").text(f.label), !l)
      continue;
    const g = f.end === f.start, m = h - 2;
    u.append("text").attr("x", d + (g ? p / 2 : 0)).attr("y", m).attr("class", "packetByte start").attr("dominant-baseline", "auto").attr("text-anchor", g ? "middle" : "start").text(f.start), g || u.append("text").attr("x", d + p).attr("y", m).attr("class", "packetByte end").attr("dominant-baseline", "auto").attr("text-anchor", "end").text(f.end);
  }
}, "drawWord"), ost = { draw: ast }, lst = {
  byteFontSize: "10px",
  startByteColor: "black",
  endByteColor: "black",
  labelColor: "black",
  labelFontSize: "12px",
  titleColor: "black",
  titleFontSize: "14px",
  blockStrokeColor: "black",
  blockStrokeWidth: "1",
  blockFillColor: "#efefef"
}, cst = /* @__PURE__ */ w(({ packet: t } = {}) => {
  const e = Xi(lst, t);
  return `
	.packetByte {
		font-size: ${e.byteFontSize};
	}
	.packetByte.start {
		fill: ${e.startByteColor};
	}
	.packetByte.end {
		fill: ${e.endByteColor};
	}
	.packetLabel {
		fill: ${e.labelColor};
		font-size: ${e.labelFontSize};
	}
	.packetTitle {
		fill: ${e.titleColor};
		font-size: ${e.titleFontSize};
	}
	.packetBlock {
		stroke: ${e.blockStrokeColor};
		stroke-width: ${e.blockStrokeWidth};
		fill: ${e.blockFillColor};
	}
	`;
}, "styles"), ust = {
  parser: Cue,
  get db() {
    return new kue();
  },
  renderer: ost,
  styles: cst
};
const hst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: ust
}, Symbol.toStringTag, { value: "Module" }));
var bf = {
  showLegend: !0,
  ticks: 5,
  max: null,
  min: 0,
  graticule: "circle"
}, _ue = {
  axes: [],
  curves: [],
  options: bf
}, jh = structuredClone(_ue), fst = fr.radar, dst = /* @__PURE__ */ w(() => Xi({
  ...fst,
  ...mr().radar
}), "getConfig"), Aue = /* @__PURE__ */ w(() => jh.axes, "getAxes"), pst = /* @__PURE__ */ w(() => jh.curves, "getCurves"), gst = /* @__PURE__ */ w(() => jh.options, "getOptions"), mst = /* @__PURE__ */ w((t) => {
  jh.axes = t.map((e) => ({
    name: e.name,
    label: e.label ?? e.name
  }));
}, "setAxes"), vst = /* @__PURE__ */ w((t) => {
  jh.curves = t.map((e) => ({
    name: e.name,
    label: e.label ?? e.name,
    entries: yst(e.entries)
  }));
}, "setCurves"), yst = /* @__PURE__ */ w((t) => {
  if (t[0].axis == null)
    return t.map((r) => r.value);
  const e = Aue();
  if (e.length === 0)
    throw new Error("Axes must be populated before curves for reference entries");
  return e.map((r) => {
    const n = t.find((i) => i.axis?.$refText === r.name);
    if (n === void 0)
      throw new Error("Missing entry for axis " + r.label);
    return n.value;
  });
}, "computeCurveEntries"), bst = /* @__PURE__ */ w((t) => {
  const e = t.reduce(
    (r, n) => (r[n.name] = n, r),
    {}
  );
  jh.options = {
    showLegend: e.showLegend?.value ?? bf.showLegend,
    ticks: e.ticks?.value ?? bf.ticks,
    max: e.max?.value ?? bf.max,
    min: e.min?.value ?? bf.min,
    graticule: e.graticule?.value ?? bf.graticule
  };
}, "setOptions"), xst = /* @__PURE__ */ w(() => {
  In(), jh = structuredClone(_ue);
}, "clear"), Ig = {
  getAxes: Aue,
  getCurves: pst,
  getOptions: gst,
  setAxes: mst,
  setCurves: vst,
  setOptions: bst,
  getConfig: dst,
  clear: xst,
  setAccTitle: Ln,
  getAccTitle: Hn,
  setDiagramTitle: ti,
  getDiagramTitle: Mn,
  getAccDescription: Yn,
  setAccDescription: Wn
}, wst = /* @__PURE__ */ w((t) => {
  Ph(t, Ig);
  const { axes: e, curves: r, options: n } = t;
  Ig.setAxes(e), Ig.setCurves(r), Ig.setOptions(n);
}, "populate"), Tst = {
  parse: /* @__PURE__ */ w(async (t) => {
    const e = await ru("radar", t);
    ae.debug(e), wst(e);
  }, "parse")
}, Est = /* @__PURE__ */ w((t, e, r, n) => {
  const i = n.db, a = i.getAxes(), s = i.getCurves(), o = i.getOptions(), l = i.getConfig(), u = i.getDiagramTitle(), h = El(e), f = Sst(h, l), d = o.max ?? Math.max(...s.map((m) => Math.max(...m.entries))), p = o.min, g = Math.min(l.width, l.height) / 2;
  kst(f, a, g, o.ticks, o.graticule), Cst(f, a, g, l), Lue(f, a, s, p, d, o.graticule, l), Mue(f, s, o.showLegend, l), f.append("text").attr("class", "radarTitle").text(u).attr("x", 0).attr("y", -l.height / 2 - l.marginTop);
}, "draw"), Sst = /* @__PURE__ */ w((t, e) => {
  const r = e.width + e.marginLeft + e.marginRight, n = e.height + e.marginTop + e.marginBottom, i = {
    x: e.marginLeft + e.width / 2,
    y: e.marginTop + e.height / 2
  };
  return t.attr("viewbox", `0 0 ${r} ${n}`).attr("width", r).attr("height", n), t.append("g").attr("transform", `translate(${i.x}, ${i.y})`);
}, "drawFrame"), kst = /* @__PURE__ */ w((t, e, r, n, i) => {
  if (i === "circle")
    for (let a = 0; a < n; a++) {
      const s = r * (a + 1) / n;
      t.append("circle").attr("r", s).attr("class", "radarGraticule");
    }
  else if (i === "polygon") {
    const a = e.length;
    for (let s = 0; s < n; s++) {
      const o = r * (s + 1) / n, l = e.map((u, h) => {
        const f = 2 * h * Math.PI / a - Math.PI / 2, d = o * Math.cos(f), p = o * Math.sin(f);
        return `${d},${p}`;
      }).join(" ");
      t.append("polygon").attr("points", l).attr("class", "radarGraticule");
    }
  }
}, "drawGraticule"), Cst = /* @__PURE__ */ w((t, e, r, n) => {
  const i = e.length;
  for (let a = 0; a < i; a++) {
    const s = e[a].label, o = 2 * a * Math.PI / i - Math.PI / 2;
    t.append("line").attr("x1", 0).attr("y1", 0).attr("x2", r * n.axisScaleFactor * Math.cos(o)).attr("y2", r * n.axisScaleFactor * Math.sin(o)).attr("class", "radarAxisLine"), t.append("text").text(s).attr("x", r * n.axisLabelFactor * Math.cos(o)).attr("y", r * n.axisLabelFactor * Math.sin(o)).attr("class", "radarAxisLabel");
  }
}, "drawAxes");
function Lue(t, e, r, n, i, a, s) {
  const o = e.length, l = Math.min(s.width, s.height) / 2;
  r.forEach((u, h) => {
    if (u.entries.length !== o)
      return;
    const f = u.entries.map((d, p) => {
      const g = 2 * Math.PI * p / o - Math.PI / 2, m = Rue(d, n, i, l), v = m * Math.cos(g), y = m * Math.sin(g);
      return { x: v, y };
    });
    a === "circle" ? t.append("path").attr("d", Iue(f, s.curveTension)).attr("class", `radarCurve-${h}`) : a === "polygon" && t.append("polygon").attr("points", f.map((d) => `${d.x},${d.y}`).join(" ")).attr("class", `radarCurve-${h}`);
  });
}
w(Lue, "drawCurves");
function Rue(t, e, r, n) {
  const i = Math.min(Math.max(t, e), r);
  return n * (i - e) / (r - e);
}
w(Rue, "relativeRadius");
function Iue(t, e) {
  const r = t.length;
  let n = `M${t[0].x},${t[0].y}`;
  for (let i = 0; i < r; i++) {
    const a = t[(i - 1 + r) % r], s = t[i], o = t[(i + 1) % r], l = t[(i + 2) % r], u = {
      x: s.x + (o.x - a.x) * e,
      y: s.y + (o.y - a.y) * e
    }, h = {
      x: o.x - (l.x - s.x) * e,
      y: o.y - (l.y - s.y) * e
    };
    n += ` C${u.x},${u.y} ${h.x},${h.y} ${o.x},${o.y}`;
  }
  return `${n} Z`;
}
w(Iue, "closedRoundCurve");
function Mue(t, e, r, n) {
  if (!r)
    return;
  const i = (n.width / 2 + n.marginRight) * 3 / 4, a = -(n.height / 2 + n.marginTop) * 3 / 4, s = 20;
  e.forEach((o, l) => {
    const u = t.append("g").attr("transform", `translate(${i}, ${a + l * s})`);
    u.append("rect").attr("width", 12).attr("height", 12).attr("class", `radarLegendBox-${l}`), u.append("text").attr("x", 16).attr("y", 0).attr("class", "radarLegendText").text(o.label);
  });
}
w(Mue, "drawLegend");
var _st = { draw: Est }, Ast = /* @__PURE__ */ w((t, e) => {
  let r = "";
  for (let n = 0; n < t.THEME_COLOR_LIMIT; n++) {
    const i = t[`cScale${n}`];
    r += `
		.radarCurve-${n} {
			color: ${i};
			fill: ${i};
			fill-opacity: ${e.curveOpacity};
			stroke: ${i};
			stroke-width: ${e.curveStrokeWidth};
		}
		.radarLegendBox-${n} {
			fill: ${i};
			fill-opacity: ${e.curveOpacity};
			stroke: ${i};
		}
		`;
  }
  return r;
}, "genIndexStyles"), Lst = /* @__PURE__ */ w((t) => {
  const e = Px(), r = mr(), n = Xi(e, r.themeVariables), i = Xi(n.radar, t);
  return { themeVariables: n, radarOptions: i };
}, "buildRadarStyleOptions"), Rst = /* @__PURE__ */ w(({ radar: t } = {}) => {
  const { themeVariables: e, radarOptions: r } = Lst(t);
  return `
	.radarTitle {
		font-size: ${e.fontSize};
		color: ${e.titleColor};
		dominant-baseline: hanging;
		text-anchor: middle;
	}
	.radarAxisLine {
		stroke: ${r.axisColor};
		stroke-width: ${r.axisStrokeWidth};
	}
	.radarAxisLabel {
		dominant-baseline: middle;
		text-anchor: middle;
		font-size: ${r.axisLabelFontSize}px;
		color: ${r.axisColor};
	}
	.radarGraticule {
		fill: ${r.graticuleColor};
		fill-opacity: ${r.graticuleOpacity};
		stroke: ${r.graticuleColor};
		stroke-width: ${r.graticuleStrokeWidth};
	}
	.radarLegendText {
		text-anchor: start;
		font-size: ${r.legendFontSize}px;
		dominant-baseline: hanging;
	}
	${Ast(e, r)}
	`;
}, "styles"), Ist = {
  parser: Tst,
  db: Ig,
  renderer: _st,
  styles: Rst
};
const Mst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Ist
}, Symbol.toStringTag, { value: "Module" }));
var t9 = (function() {
  var t = /* @__PURE__ */ w(function(x, T, E, A) {
    for (E = E || {}, A = x.length; A--; E[x[A]] = T) ;
    return E;
  }, "o"), e = [1, 15], r = [1, 7], n = [1, 13], i = [1, 14], a = [1, 19], s = [1, 16], o = [1, 17], l = [1, 18], u = [8, 30], h = [8, 10, 21, 28, 29, 30, 31, 39, 43, 46], f = [1, 23], d = [1, 24], p = [8, 10, 15, 16, 21, 28, 29, 30, 31, 39, 43, 46], g = [8, 10, 15, 16, 21, 27, 28, 29, 30, 31, 39, 43, 46], m = [1, 49], v = {
    trace: /* @__PURE__ */ w(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, spaceLines: 3, SPACELINE: 4, NL: 5, separator: 6, SPACE: 7, EOF: 8, start: 9, BLOCK_DIAGRAM_KEY: 10, document: 11, stop: 12, statement: 13, link: 14, LINK: 15, START_LINK: 16, LINK_LABEL: 17, STR: 18, nodeStatement: 19, columnsStatement: 20, SPACE_BLOCK: 21, blockStatement: 22, classDefStatement: 23, cssClassStatement: 24, styleStatement: 25, node: 26, SIZE: 27, COLUMNS: 28, "id-block": 29, end: 30, NODE_ID: 31, nodeShapeNLabel: 32, dirList: 33, DIR: 34, NODE_DSTART: 35, NODE_DEND: 36, BLOCK_ARROW_START: 37, BLOCK_ARROW_END: 38, classDef: 39, CLASSDEF_ID: 40, CLASSDEF_STYLEOPTS: 41, DEFAULT: 42, class: 43, CLASSENTITY_IDS: 44, STYLECLASS: 45, style: 46, STYLE_ENTITY_IDS: 47, STYLE_DEFINITION_DATA: 48, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACELINE", 5: "NL", 7: "SPACE", 8: "EOF", 10: "BLOCK_DIAGRAM_KEY", 15: "LINK", 16: "START_LINK", 17: "LINK_LABEL", 18: "STR", 21: "SPACE_BLOCK", 27: "SIZE", 28: "COLUMNS", 29: "id-block", 30: "end", 31: "NODE_ID", 34: "DIR", 35: "NODE_DSTART", 36: "NODE_DEND", 37: "BLOCK_ARROW_START", 38: "BLOCK_ARROW_END", 39: "classDef", 40: "CLASSDEF_ID", 41: "CLASSDEF_STYLEOPTS", 42: "DEFAULT", 43: "class", 44: "CLASSENTITY_IDS", 45: "STYLECLASS", 46: "style", 47: "STYLE_ENTITY_IDS", 48: "STYLE_DEFINITION_DATA" },
    productions_: [0, [3, 1], [3, 2], [3, 2], [6, 1], [6, 1], [6, 1], [9, 3], [12, 1], [12, 1], [12, 2], [12, 2], [11, 1], [11, 2], [14, 1], [14, 4], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [19, 3], [19, 2], [19, 1], [20, 1], [22, 4], [22, 3], [26, 1], [26, 2], [33, 1], [33, 2], [32, 3], [32, 4], [23, 3], [23, 3], [24, 3], [25, 3]],
    performAction: /* @__PURE__ */ w(function(T, E, A, S, k, _, R) {
      var L = _.length - 1;
      switch (k) {
        case 4:
          S.getLogger().debug("Rule: separator (NL) ");
          break;
        case 5:
          S.getLogger().debug("Rule: separator (Space) ");
          break;
        case 6:
          S.getLogger().debug("Rule: separator (EOF) ");
          break;
        case 7:
          S.getLogger().debug("Rule: hierarchy: ", _[L - 1]), S.setHierarchy(_[L - 1]);
          break;
        case 8:
          S.getLogger().debug("Stop NL ");
          break;
        case 9:
          S.getLogger().debug("Stop EOF ");
          break;
        case 10:
          S.getLogger().debug("Stop NL2 ");
          break;
        case 11:
          S.getLogger().debug("Stop EOF2 ");
          break;
        case 12:
          S.getLogger().debug("Rule: statement: ", _[L]), typeof _[L].length == "number" ? this.$ = _[L] : this.$ = [_[L]];
          break;
        case 13:
          S.getLogger().debug("Rule: statement #2: ", _[L - 1]), this.$ = [_[L - 1]].concat(_[L]);
          break;
        case 14:
          S.getLogger().debug("Rule: link: ", _[L], T), this.$ = { edgeTypeStr: _[L], label: "" };
          break;
        case 15:
          S.getLogger().debug("Rule: LABEL link: ", _[L - 3], _[L - 1], _[L]), this.$ = { edgeTypeStr: _[L], label: _[L - 1] };
          break;
        case 18:
          const M = parseInt(_[L]), P = S.generateId();
          this.$ = { id: P, type: "space", label: "", width: M, children: [] };
          break;
        case 23:
          S.getLogger().debug("Rule: (nodeStatement link node) ", _[L - 2], _[L - 1], _[L], " typestr: ", _[L - 1].edgeTypeStr);
          const C = S.edgeStrToEdgeData(_[L - 1].edgeTypeStr);
          this.$ = [
            { id: _[L - 2].id, label: _[L - 2].label, type: _[L - 2].type, directions: _[L - 2].directions },
            { id: _[L - 2].id + "-" + _[L].id, start: _[L - 2].id, end: _[L].id, label: _[L - 1].label, type: "edge", directions: _[L].directions, arrowTypeEnd: C, arrowTypeStart: "arrow_open" },
            { id: _[L].id, label: _[L].label, type: S.typeStr2Type(_[L].typeStr), directions: _[L].directions }
          ];
          break;
        case 24:
          S.getLogger().debug("Rule: nodeStatement (abc88 node size) ", _[L - 1], _[L]), this.$ = { id: _[L - 1].id, label: _[L - 1].label, type: S.typeStr2Type(_[L - 1].typeStr), directions: _[L - 1].directions, widthInColumns: parseInt(_[L], 10) };
          break;
        case 25:
          S.getLogger().debug("Rule: nodeStatement (node) ", _[L]), this.$ = { id: _[L].id, label: _[L].label, type: S.typeStr2Type(_[L].typeStr), directions: _[L].directions, widthInColumns: 1 };
          break;
        case 26:
          S.getLogger().debug("APA123", this ? this : "na"), S.getLogger().debug("COLUMNS: ", _[L]), this.$ = { type: "column-setting", columns: _[L] === "auto" ? -1 : parseInt(_[L]) };
          break;
        case 27:
          S.getLogger().debug("Rule: id-block statement : ", _[L - 2], _[L - 1]), S.generateId(), this.$ = { ..._[L - 2], type: "composite", children: _[L - 1] };
          break;
        case 28:
          S.getLogger().debug("Rule: blockStatement : ", _[L - 2], _[L - 1], _[L]);
          const I = S.generateId();
          this.$ = { id: I, type: "composite", label: "", children: _[L - 1] };
          break;
        case 29:
          S.getLogger().debug("Rule: node (NODE_ID separator): ", _[L]), this.$ = { id: _[L] };
          break;
        case 30:
          S.getLogger().debug("Rule: node (NODE_ID nodeShapeNLabel separator): ", _[L - 1], _[L]), this.$ = { id: _[L - 1], label: _[L].label, typeStr: _[L].typeStr, directions: _[L].directions };
          break;
        case 31:
          S.getLogger().debug("Rule: dirList: ", _[L]), this.$ = [_[L]];
          break;
        case 32:
          S.getLogger().debug("Rule: dirList: ", _[L - 1], _[L]), this.$ = [_[L - 1]].concat(_[L]);
          break;
        case 33:
          S.getLogger().debug("Rule: nodeShapeNLabel: ", _[L - 2], _[L - 1], _[L]), this.$ = { typeStr: _[L - 2] + _[L], label: _[L - 1] };
          break;
        case 34:
          S.getLogger().debug("Rule: BLOCK_ARROW nodeShapeNLabel: ", _[L - 3], _[L - 2], " #3:", _[L - 1], _[L]), this.$ = { typeStr: _[L - 3] + _[L], label: _[L - 2], directions: _[L - 1] };
          break;
        case 35:
        case 36:
          this.$ = { type: "classDef", id: _[L - 1].trim(), css: _[L].trim() };
          break;
        case 37:
          this.$ = { type: "applyClass", id: _[L - 1].trim(), styleClass: _[L].trim() };
          break;
        case 38:
          this.$ = { type: "applyStyles", id: _[L - 1].trim(), stylesStr: _[L].trim() };
          break;
      }
    }, "anonymous"),
    table: [{ 9: 1, 10: [1, 2] }, { 1: [3] }, { 10: e, 11: 3, 13: 4, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }, { 8: [1, 20] }, t(u, [2, 12], { 13: 4, 19: 5, 20: 6, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 11: 21, 10: e, 21: r, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }), t(h, [2, 16], { 14: 22, 15: f, 16: d }), t(h, [2, 17]), t(h, [2, 18]), t(h, [2, 19]), t(h, [2, 20]), t(h, [2, 21]), t(h, [2, 22]), t(p, [2, 25], { 27: [1, 25] }), t(h, [2, 26]), { 19: 26, 26: 12, 31: a }, { 10: e, 11: 27, 13: 4, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }, { 40: [1, 28], 42: [1, 29] }, { 44: [1, 30] }, { 47: [1, 31] }, t(g, [2, 29], { 32: 32, 35: [1, 33], 37: [1, 34] }), { 1: [2, 7] }, t(u, [2, 13]), { 26: 35, 31: a }, { 31: [2, 14] }, { 17: [1, 36] }, t(p, [2, 24]), { 10: e, 11: 37, 13: 4, 14: 22, 15: f, 16: d, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: n, 29: i, 31: a, 39: s, 43: o, 46: l }, { 30: [1, 38] }, { 41: [1, 39] }, { 41: [1, 40] }, { 45: [1, 41] }, { 48: [1, 42] }, t(g, [2, 30]), { 18: [1, 43] }, { 18: [1, 44] }, t(p, [2, 23]), { 18: [1, 45] }, { 30: [1, 46] }, t(h, [2, 28]), t(h, [2, 35]), t(h, [2, 36]), t(h, [2, 37]), t(h, [2, 38]), { 36: [1, 47] }, { 33: 48, 34: m }, { 15: [1, 50] }, t(h, [2, 27]), t(g, [2, 33]), { 38: [1, 51] }, { 33: 52, 34: m, 38: [2, 31] }, { 31: [2, 15] }, t(g, [2, 34]), { 38: [2, 32] }],
    defaultActions: { 20: [2, 7], 23: [2, 14], 50: [2, 15], 52: [2, 32] },
    parseError: /* @__PURE__ */ w(function(T, E) {
      if (E.recoverable)
        this.trace(T);
      else {
        var A = new Error(T);
        throw A.hash = E, A;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ w(function(T) {
      var E = this, A = [0], S = [], k = [null], _ = [], R = this.table, L = "", M = 0, P = 0, C = 2, I = 1, N = _.slice.call(arguments, 1), O = Object.create(this.lexer), D = { yy: {} };
      for (var $ in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, $) && (D.yy[$] = this.yy[$]);
      O.setInput(T, D.yy), D.yy.lexer = O, D.yy.parser = this, typeof O.yylloc > "u" && (O.yylloc = {});
      var z = O.yylloc;
      _.push(z);
      var B = O.options && O.options.ranges;
      typeof D.yy.parseError == "function" ? this.parseError = D.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function G(Q) {
        A.length = A.length - 2 * Q, k.length = k.length - Q, _.length = _.length - Q;
      }
      w(G, "popStack");
      function W() {
        var Q;
        return Q = S.pop() || O.lex() || I, typeof Q != "number" && (Q instanceof Array && (S = Q, Q = S.pop()), Q = E.symbols_[Q] || Q), Q;
      }
      w(W, "lex");
      for (var V, U, Z, K, ce = {}, J, ee, j, X; ; ) {
        if (U = A[A.length - 1], this.defaultActions[U] ? Z = this.defaultActions[U] : ((V === null || typeof V > "u") && (V = W()), Z = R[U] && R[U][V]), typeof Z > "u" || !Z.length || !Z[0]) {
          var re = "";
          X = [];
          for (J in R[U])
            this.terminals_[J] && J > C && X.push("'" + this.terminals_[J] + "'");
          O.showPosition ? re = "Parse error on line " + (M + 1) + `:
` + O.showPosition() + `
Expecting ` + X.join(", ") + ", got '" + (this.terminals_[V] || V) + "'" : re = "Parse error on line " + (M + 1) + ": Unexpected " + (V == I ? "end of input" : "'" + (this.terminals_[V] || V) + "'"), this.parseError(re, {
            text: O.match,
            token: this.terminals_[V] || V,
            line: O.yylineno,
            loc: z,
            expected: X
          });
        }
        if (Z[0] instanceof Array && Z.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + U + ", token: " + V);
        switch (Z[0]) {
          case 1:
            A.push(V), k.push(O.yytext), _.push(O.yylloc), A.push(Z[1]), V = null, P = O.yyleng, L = O.yytext, M = O.yylineno, z = O.yylloc;
            break;
          case 2:
            if (ee = this.productions_[Z[1]][1], ce.$ = k[k.length - ee], ce._$ = {
              first_line: _[_.length - (ee || 1)].first_line,
              last_line: _[_.length - 1].last_line,
              first_column: _[_.length - (ee || 1)].first_column,
              last_column: _[_.length - 1].last_column
            }, B && (ce._$.range = [
              _[_.length - (ee || 1)].range[0],
              _[_.length - 1].range[1]
            ]), K = this.performAction.apply(ce, [
              L,
              P,
              M,
              D.yy,
              Z[1],
              k,
              _
            ].concat(N)), typeof K < "u")
              return K;
            ee && (A = A.slice(0, -1 * ee * 2), k = k.slice(0, -1 * ee), _ = _.slice(0, -1 * ee)), A.push(this.productions_[Z[1]][0]), k.push(ce.$), _.push(ce._$), j = R[A[A.length - 2]][A[A.length - 1]], A.push(j);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, y = /* @__PURE__ */ (function() {
    var x = {
      EOF: 1,
      parseError: /* @__PURE__ */ w(function(E, A) {
        if (this.yy.parser)
          this.yy.parser.parseError(E, A);
        else
          throw new Error(E);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ w(function(T, E) {
        return this.yy = E || this.yy || {}, this._input = T, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ w(function() {
        var T = this._input[0];
        this.yytext += T, this.yyleng++, this.offset++, this.match += T, this.matched += T;
        var E = T.match(/(?:\r\n?|\n).*/g);
        return E ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), T;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ w(function(T) {
        var E = T.length, A = T.split(/(?:\r\n?|\n)/g);
        this._input = T + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - E), this.offset -= E;
        var S = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), A.length - 1 && (this.yylineno -= A.length - 1);
        var k = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: A ? (A.length === S.length ? this.yylloc.first_column : 0) + S[S.length - A.length].length - A[0].length : this.yylloc.first_column - E
        }, this.options.ranges && (this.yylloc.range = [k[0], k[0] + this.yyleng - E]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ w(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ w(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ w(function(T) {
        this.unput(this.match.slice(T));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ w(function() {
        var T = this.matched.substr(0, this.matched.length - this.match.length);
        return (T.length > 20 ? "..." : "") + T.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ w(function() {
        var T = this.match;
        return T.length < 20 && (T += this._input.substr(0, 20 - T.length)), (T.substr(0, 20) + (T.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ w(function() {
        var T = this.pastInput(), E = new Array(T.length + 1).join("-");
        return T + this.upcomingInput() + `
` + E + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ w(function(T, E) {
        var A, S, k;
        if (this.options.backtrack_lexer && (k = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (k.yylloc.range = this.yylloc.range.slice(0))), S = T[0].match(/(?:\r\n?|\n).*/g), S && (this.yylineno += S.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: S ? S[S.length - 1].length - S[S.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + T[0].length
        }, this.yytext += T[0], this.match += T[0], this.matches = T, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(T[0].length), this.matched += T[0], A = this.performAction.call(this, this.yy, this, E, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), A)
          return A;
        if (this._backtrack) {
          for (var _ in k)
            this[_] = k[_];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ w(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var T, E, A, S;
        this._more || (this.yytext = "", this.match = "");
        for (var k = this._currentRules(), _ = 0; _ < k.length; _++)
          if (A = this._input.match(this.rules[k[_]]), A && (!E || A[0].length > E[0].length)) {
            if (E = A, S = _, this.options.backtrack_lexer) {
              if (T = this.test_match(A, k[_]), T !== !1)
                return T;
              if (this._backtrack) {
                E = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return E ? (T = this.test_match(E, k[S]), T !== !1 ? T : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ w(function() {
        var E = this.next();
        return E || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ w(function(E) {
        this.conditionStack.push(E);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ w(function() {
        var E = this.conditionStack.length - 1;
        return E > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ w(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ w(function(E) {
        return E = this.conditionStack.length - 1 - Math.abs(E || 0), E >= 0 ? this.conditionStack[E] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ w(function(E) {
        this.begin(E);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ w(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ w(function(E, A, S, k) {
        switch (S) {
          case 0:
            return E.getLogger().debug("Found block-beta"), 10;
          case 1:
            return E.getLogger().debug("Found id-block"), 29;
          case 2:
            return E.getLogger().debug("Found block"), 10;
          case 3:
            E.getLogger().debug(".", A.yytext);
            break;
          case 4:
            E.getLogger().debug("_", A.yytext);
            break;
          case 5:
            return 5;
          case 6:
            return A.yytext = -1, 28;
          case 7:
            return A.yytext = A.yytext.replace(/columns\s+/, ""), E.getLogger().debug("COLUMNS (LEX)", A.yytext), 28;
          case 8:
            this.pushState("md_string");
            break;
          case 9:
            return "MD_STR";
          case 10:
            this.popState();
            break;
          case 11:
            this.pushState("string");
            break;
          case 12:
            E.getLogger().debug("LEX: POPPING STR:", A.yytext), this.popState();
            break;
          case 13:
            return E.getLogger().debug("LEX: STR end:", A.yytext), "STR";
          case 14:
            return A.yytext = A.yytext.replace(/space\:/, ""), E.getLogger().debug("SPACE NUM (LEX)", A.yytext), 21;
          case 15:
            return A.yytext = "1", E.getLogger().debug("COLUMNS (LEX)", A.yytext), 21;
          case 16:
            return 42;
          case 17:
            return "LINKSTYLE";
          case 18:
            return "INTERPOLATE";
          case 19:
            return this.pushState("CLASSDEF"), 39;
          case 20:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 21:
            return this.popState(), this.pushState("CLASSDEFID"), 40;
          case 22:
            return this.popState(), 41;
          case 23:
            return this.pushState("CLASS"), 43;
          case 24:
            return this.popState(), this.pushState("CLASS_STYLE"), 44;
          case 25:
            return this.popState(), 45;
          case 26:
            return this.pushState("STYLE_STMNT"), 46;
          case 27:
            return this.popState(), this.pushState("STYLE_DEFINITION"), 47;
          case 28:
            return this.popState(), 48;
          case 29:
            return this.pushState("acc_title"), "acc_title";
          case 30:
            return this.popState(), "acc_title_value";
          case 31:
            return this.pushState("acc_descr"), "acc_descr";
          case 32:
            return this.popState(), "acc_descr_value";
          case 33:
            this.pushState("acc_descr_multiline");
            break;
          case 34:
            this.popState();
            break;
          case 35:
            return "acc_descr_multiline_value";
          case 36:
            return 30;
          case 37:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 38:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 39:
            return this.popState(), E.getLogger().debug("Lex: ))"), "NODE_DEND";
          case 40:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 41:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 42:
            return this.popState(), E.getLogger().debug("Lex: (-"), "NODE_DEND";
          case 43:
            return this.popState(), E.getLogger().debug("Lex: -)"), "NODE_DEND";
          case 44:
            return this.popState(), E.getLogger().debug("Lex: (("), "NODE_DEND";
          case 45:
            return this.popState(), E.getLogger().debug("Lex: ]]"), "NODE_DEND";
          case 46:
            return this.popState(), E.getLogger().debug("Lex: ("), "NODE_DEND";
          case 47:
            return this.popState(), E.getLogger().debug("Lex: ])"), "NODE_DEND";
          case 48:
            return this.popState(), E.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 49:
            return this.popState(), E.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 50:
            return this.popState(), E.getLogger().debug("Lex: )]"), "NODE_DEND";
          case 51:
            return this.popState(), E.getLogger().debug("Lex: )"), "NODE_DEND";
          case 52:
            return this.popState(), E.getLogger().debug("Lex: ]>"), "NODE_DEND";
          case 53:
            return this.popState(), E.getLogger().debug("Lex: ]"), "NODE_DEND";
          case 54:
            return E.getLogger().debug("Lexa: -)"), this.pushState("NODE"), 35;
          case 55:
            return E.getLogger().debug("Lexa: (-"), this.pushState("NODE"), 35;
          case 56:
            return E.getLogger().debug("Lexa: ))"), this.pushState("NODE"), 35;
          case 57:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 58:
            return E.getLogger().debug("Lex: ((("), this.pushState("NODE"), 35;
          case 59:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 60:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 61:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 62:
            return E.getLogger().debug("Lexc: >"), this.pushState("NODE"), 35;
          case 63:
            return E.getLogger().debug("Lexa: (["), this.pushState("NODE"), 35;
          case 64:
            return E.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 65:
            return this.pushState("NODE"), 35;
          case 66:
            return this.pushState("NODE"), 35;
          case 67:
            return this.pushState("NODE"), 35;
          case 68:
            return this.pushState("NODE"), 35;
          case 69:
            return this.pushState("NODE"), 35;
          case 70:
            return this.pushState("NODE"), 35;
          case 71:
            return this.pushState("NODE"), 35;
          case 72:
            return E.getLogger().debug("Lexa: ["), this.pushState("NODE"), 35;
          case 73:
            return this.pushState("BLOCK_ARROW"), E.getLogger().debug("LEX ARR START"), 37;
          case 74:
            return E.getLogger().debug("Lex: NODE_ID", A.yytext), 31;
          case 75:
            return E.getLogger().debug("Lex: EOF", A.yytext), 8;
          case 76:
            this.pushState("md_string");
            break;
          case 77:
            this.pushState("md_string");
            break;
          case 78:
            return "NODE_DESCR";
          case 79:
            this.popState();
            break;
          case 80:
            E.getLogger().debug("Lex: Starting string"), this.pushState("string");
            break;
          case 81:
            E.getLogger().debug("LEX ARR: Starting string"), this.pushState("string");
            break;
          case 82:
            return E.getLogger().debug("LEX: NODE_DESCR:", A.yytext), "NODE_DESCR";
          case 83:
            E.getLogger().debug("LEX POPPING"), this.popState();
            break;
          case 84:
            E.getLogger().debug("Lex: =>BAE"), this.pushState("ARROW_DIR");
            break;
          case 85:
            return A.yytext = A.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (right): dir:", A.yytext), "DIR";
          case 86:
            return A.yytext = A.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (left):", A.yytext), "DIR";
          case 87:
            return A.yytext = A.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (x):", A.yytext), "DIR";
          case 88:
            return A.yytext = A.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (y):", A.yytext), "DIR";
          case 89:
            return A.yytext = A.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (up):", A.yytext), "DIR";
          case 90:
            return A.yytext = A.yytext.replace(/^,\s*/, ""), E.getLogger().debug("Lex (down):", A.yytext), "DIR";
          case 91:
            return A.yytext = "]>", E.getLogger().debug("Lex (ARROW_DIR end):", A.yytext), this.popState(), this.popState(), "BLOCK_ARROW_END";
          case 92:
            return E.getLogger().debug("Lex: LINK", "#" + A.yytext + "#"), 15;
          case 93:
            return E.getLogger().debug("Lex: LINK", A.yytext), 15;
          case 94:
            return E.getLogger().debug("Lex: LINK", A.yytext), 15;
          case 95:
            return E.getLogger().debug("Lex: LINK", A.yytext), 15;
          case 96:
            return E.getLogger().debug("Lex: START_LINK", A.yytext), this.pushState("LLABEL"), 16;
          case 97:
            return E.getLogger().debug("Lex: START_LINK", A.yytext), this.pushState("LLABEL"), 16;
          case 98:
            return E.getLogger().debug("Lex: START_LINK", A.yytext), this.pushState("LLABEL"), 16;
          case 99:
            this.pushState("md_string");
            break;
          case 100:
            return E.getLogger().debug("Lex: Starting string"), this.pushState("string"), "LINK_LABEL";
          case 101:
            return this.popState(), E.getLogger().debug("Lex: LINK", "#" + A.yytext + "#"), 15;
          case 102:
            return this.popState(), E.getLogger().debug("Lex: LINK", A.yytext), 15;
          case 103:
            return this.popState(), E.getLogger().debug("Lex: LINK", A.yytext), 15;
          case 104:
            return E.getLogger().debug("Lex: COLON", A.yytext), A.yytext = A.yytext.slice(1), 27;
        }
      }, "anonymous"),
      rules: [/^(?:block-beta\b)/, /^(?:block:)/, /^(?:block\b)/, /^(?:[\s]+)/, /^(?:[\n]+)/, /^(?:((\u000D\u000A)|(\u000A)))/, /^(?:columns\s+auto\b)/, /^(?:columns\s+[\d]+)/, /^(?:["][`])/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:space[:]\d+)/, /^(?:space\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\s+)/, /^(?:DEFAULT\s+)/, /^(?:\w+\s+)/, /^(?:[^\n]*)/, /^(?:class\s+)/, /^(?:(\w+)+((,\s*\w+)*))/, /^(?:[^\n]*)/, /^(?:style\s+)/, /^(?:(\w+)+((,\s*\w+)*))/, /^(?:[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:end\b\s*)/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:[\)]\))/, /^(?:\}\})/, /^(?:\})/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\()/, /^(?:\]\])/, /^(?:\()/, /^(?:\]\))/, /^(?:\\\])/, /^(?:\/\])/, /^(?:\)\])/, /^(?:[\)])/, /^(?:\]>)/, /^(?:[\]])/, /^(?:-\))/, /^(?:\(-)/, /^(?:\)\))/, /^(?:\))/, /^(?:\(\(\()/, /^(?:\(\()/, /^(?:\{\{)/, /^(?:\{)/, /^(?:>)/, /^(?:\(\[)/, /^(?:\()/, /^(?:\[\[)/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\)\))/, /^(?:\[\\)/, /^(?:\[\/)/, /^(?:\[\\)/, /^(?:\[)/, /^(?:<\[)/, /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/, /^(?:$)/, /^(?:["][`])/, /^(?:["][`])/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["])/, /^(?:["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:\]>\s*\()/, /^(?:,?\s*right\s*)/, /^(?:,?\s*left\s*)/, /^(?:,?\s*x\s*)/, /^(?:,?\s*y\s*)/, /^(?:,?\s*up\s*)/, /^(?:,?\s*down\s*)/, /^(?:\)\s*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*~~[\~]+\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:["][`])/, /^(?:["])/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?::\d+)/],
      conditions: { STYLE_DEFINITION: { rules: [28], inclusive: !1 }, STYLE_STMNT: { rules: [27], inclusive: !1 }, CLASSDEFID: { rules: [22], inclusive: !1 }, CLASSDEF: { rules: [20, 21], inclusive: !1 }, CLASS_STYLE: { rules: [25], inclusive: !1 }, CLASS: { rules: [24], inclusive: !1 }, LLABEL: { rules: [99, 100, 101, 102, 103], inclusive: !1 }, ARROW_DIR: { rules: [85, 86, 87, 88, 89, 90, 91], inclusive: !1 }, BLOCK_ARROW: { rules: [76, 81, 84], inclusive: !1 }, NODE: { rules: [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 77, 80], inclusive: !1 }, md_string: { rules: [9, 10, 78, 79], inclusive: !1 }, space: { rules: [], inclusive: !1 }, string: { rules: [12, 13, 82, 83], inclusive: !1 }, acc_descr_multiline: { rules: [34, 35], inclusive: !1 }, acc_descr: { rules: [32], inclusive: !1 }, acc_title: { rules: [30], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 14, 15, 16, 17, 18, 19, 23, 26, 29, 31, 33, 36, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 92, 93, 94, 95, 96, 97, 98, 104], inclusive: !0 } }
    };
    return x;
  })();
  v.lexer = y;
  function b() {
    this.yy = {};
  }
  return w(b, "Parser"), b.prototype = v, v.Parser = b, new b();
})();
t9.parser = t9;
var Nst = t9, Rs = /* @__PURE__ */ new Map(), gM = [], r9 = /* @__PURE__ */ new Map(), kY = "color", CY = "fill", Dst = "bgFill", Nue = ",", Ost = Te(), Rx = /* @__PURE__ */ new Map(), Pst = /* @__PURE__ */ w((t) => at.sanitizeText(t, Ost), "sanitizeText"), $st = /* @__PURE__ */ w(function(t, e = "") {
  let r = Rx.get(t);
  r || (r = { id: t, styles: [], textStyles: [] }, Rx.set(t, r)), e?.split(Nue).forEach((n) => {
    const i = n.replace(/([^;]*);/, "$1").trim();
    if (RegExp(kY).exec(n)) {
      const s = i.replace(CY, Dst).replace(kY, CY);
      r.textStyles.push(s);
    }
    r.styles.push(i);
  });
}, "addStyleClass"), Bst = /* @__PURE__ */ w(function(t, e = "") {
  const r = Rs.get(t);
  e != null && (r.styles = e.split(Nue));
}, "addStyle2Node"), Fst = /* @__PURE__ */ w(function(t, e) {
  t.split(",").forEach(function(r) {
    let n = Rs.get(r);
    if (n === void 0) {
      const i = r.trim();
      n = { id: i, type: "na", children: [] }, Rs.set(i, n);
    }
    n.classes || (n.classes = []), n.classes.push(e);
  });
}, "setCssClass"), Due = /* @__PURE__ */ w((t, e) => {
  const r = t.flat(), n = [], a = r.find((s) => s?.type === "column-setting")?.columns ?? -1;
  for (const s of r) {
    if (typeof a == "number" && a > 0 && s.type !== "column-setting" && typeof s.widthInColumns == "number" && s.widthInColumns > a && ae.warn(
      `Block ${s.id} width ${s.widthInColumns} exceeds configured column width ${a}`
    ), s.label && (s.label = Pst(s.label)), s.type === "classDef") {
      $st(s.id, s.css);
      continue;
    }
    if (s.type === "applyClass") {
      Fst(s.id, s?.styleClass ?? "");
      continue;
    }
    if (s.type === "applyStyles") {
      s?.stylesStr && Bst(s.id, s?.stylesStr);
      continue;
    }
    if (s.type === "column-setting")
      e.columns = s.columns ?? -1;
    else if (s.type === "edge") {
      const o = (r9.get(s.id) ?? 0) + 1;
      r9.set(s.id, o), s.id = o + "-" + s.id, gM.push(s);
    } else {
      s.label || (s.type === "composite" ? s.label = "" : s.label = s.id);
      const o = Rs.get(s.id);
      if (o === void 0 ? Rs.set(s.id, s) : (s.type !== "na" && (o.type = s.type), s.label !== s.id && (o.label = s.label)), s.children && Due(s.children, s), s.type === "space") {
        const l = s.width ?? 1;
        for (let u = 0; u < l; u++) {
          const h = Zre(s);
          h.id = h.id + "-" + u, Rs.set(h.id, h), n.push(h);
        }
      } else o === void 0 && n.push(s);
    }
  }
  e.children = n;
}, "populateBlockDatabase"), mM = [], jg = { id: "root", type: "composite", children: [], columns: -1 }, zst = /* @__PURE__ */ w(() => {
  ae.debug("Clear called"), In(), jg = { id: "root", type: "composite", children: [], columns: -1 }, Rs = /* @__PURE__ */ new Map([["root", jg]]), mM = [], Rx = /* @__PURE__ */ new Map(), gM = [], r9 = /* @__PURE__ */ new Map();
}, "clear");
function Oue(t) {
  switch (ae.debug("typeStr2Type", t), t) {
    case "[]":
      return "square";
    case "()":
      return ae.debug("we have a round"), "round";
    case "(())":
      return "circle";
    case ">]":
      return "rect_left_inv_arrow";
    case "{}":
      return "diamond";
    case "{{}}":
      return "hexagon";
    case "([])":
      return "stadium";
    case "[[]]":
      return "subroutine";
    case "[()]":
      return "cylinder";
    case "((()))":
      return "doublecircle";
    case "[//]":
      return "lean_right";
    case "[\\\\]":
      return "lean_left";
    case "[/\\]":
      return "trapezoid";
    case "[\\/]":
      return "inv_trapezoid";
    case "<[]>":
      return "block_arrow";
    default:
      return "na";
  }
}
w(Oue, "typeStr2Type");
function Pue(t) {
  switch (ae.debug("typeStr2Type", t), t) {
    case "==":
      return "thick";
    default:
      return "normal";
  }
}
w(Pue, "edgeTypeStr2Type");
function $ue(t) {
  switch (t.replace(/^[\s-]+|[\s-]+$/g, "")) {
    case "x":
      return "arrow_cross";
    case "o":
      return "arrow_circle";
    case ">":
      return "arrow_point";
    default:
      return "";
  }
}
w($ue, "edgeStrToEdgeData");
var _Y = 0, qst = /* @__PURE__ */ w(() => (_Y++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + _Y), "generateId"), Gst = /* @__PURE__ */ w((t) => {
  jg.children = t, Due(t, jg), mM = jg.children;
}, "setHierarchy"), Ust = /* @__PURE__ */ w((t) => {
  const e = Rs.get(t);
  return e ? e.columns ? e.columns : e.children ? e.children.length : -1 : -1;
}, "getColumns"), Vst = /* @__PURE__ */ w(() => [...Rs.values()], "getBlocksFlat"), Hst = /* @__PURE__ */ w(() => mM || [], "getBlocks"), Wst = /* @__PURE__ */ w(() => gM, "getEdges"), Yst = /* @__PURE__ */ w((t) => Rs.get(t), "getBlock"), Xst = /* @__PURE__ */ w((t) => {
  Rs.set(t.id, t);
}, "setBlock"), jst = /* @__PURE__ */ w(() => ae, "getLogger"), Kst = /* @__PURE__ */ w(function() {
  return Rx;
}, "getClasses"), Zst = {
  getConfig: /* @__PURE__ */ w(() => mr().block, "getConfig"),
  typeStr2Type: Oue,
  edgeTypeStr2Type: Pue,
  edgeStrToEdgeData: $ue,
  getLogger: jst,
  getBlocksFlat: Vst,
  getBlocks: Hst,
  getEdges: Wst,
  setHierarchy: Gst,
  getBlock: Yst,
  setBlock: Xst,
  getColumns: Ust,
  getClasses: Kst,
  clear: zst,
  generateId: qst
}, Qst = Zst, py = /* @__PURE__ */ w((t, e) => {
  const r = l9, n = r(t, "r"), i = r(t, "g"), a = r(t, "b");
  return ac(n, i, a, e);
}, "fade"), Jst = /* @__PURE__ */ w((t) => `.label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }
  .cluster-label text {
    fill: ${t.titleColor};
  }
  .cluster-label span,p {
    color: ${t.titleColor};
  }



  .label text,span,p {
    fill: ${t.nodeTextColor || t.textColor};
    color: ${t.nodeTextColor || t.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${t.edgeLabelBackground};
      fill: ${t.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${py(t.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${py(t.mainBkg, 0.5)};
    fill: ${py(t.clusterBkg, 0.5)};
    stroke: ${py(t.clusterBorder, 0.2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  .cluster span,p {
    color: ${t.titleColor};
  }
  /* .cluster div {
    color: ${t.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${t.fontFamily};
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }
  ${Rm()}
`, "getStyles"), eot = Jst, tot = /* @__PURE__ */ w((t, e, r, n) => {
  e.forEach((i) => {
    hot[i](t, r, n);
  });
}, "insertMarkers"), rot = /* @__PURE__ */ w((t, e, r) => {
  ae.trace("Making markers for ", r), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), not = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), iot = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), aot = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", r + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), sot = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t.append("defs").append("marker").attr("id", r + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), oot = /* @__PURE__ */ w((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), lot = /* @__PURE__ */ w((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), cot = /* @__PURE__ */ w((t, e, r) => {
  t.append("marker").attr("id", r + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", r + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), uot = /* @__PURE__ */ w((t, e, r) => {
  t.append("defs").append("marker").attr("id", r + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), hot = {
  extension: rot,
  composition: not,
  aggregation: iot,
  dependency: aot,
  lollipop: sot,
  point: oot,
  circle: lot,
  cross: cot,
  barb: uot
}, fot = tot, vn = Te()?.block?.padding ?? 8;
function Bue(t, e) {
  if (t === 0 || !Number.isInteger(t))
    throw new Error("Columns must be an integer !== 0.");
  if (e < 0 || !Number.isInteger(e))
    throw new Error("Position must be a non-negative integer." + e);
  if (t < 0)
    return { px: e, py: 0 };
  if (t === 1)
    return { px: 0, py: e };
  const r = e % t, n = Math.floor(e / t);
  return { px: r, py: n };
}
w(Bue, "calculateBlockPosition");
var dot = /* @__PURE__ */ w((t) => {
  let e = 0, r = 0;
  for (const n of t.children) {
    const { width: i, height: a, x: s, y: o } = n.size ?? { width: 0, height: 0, x: 0, y: 0 };
    ae.debug(
      "getMaxChildSize abc95 child:",
      n.id,
      "width:",
      i,
      "height:",
      a,
      "x:",
      s,
      "y:",
      o,
      n.type
    ), n.type !== "space" && (i > e && (e = i / (t.widthInColumns ?? 1)), a > r && (r = a));
  }
  return { width: e, height: r };
}, "getMaxChildSize");
function Ix(t, e, r = 0, n = 0) {
  ae.debug(
    "setBlockSizes abc95 (start)",
    t.id,
    t?.size?.x,
    "block width =",
    t?.size,
    "siblingWidth",
    r
  ), t?.size?.width || (t.size = {
    width: r,
    height: n,
    x: 0,
    y: 0
  });
  let i = 0, a = 0;
  if (t.children?.length > 0) {
    for (const p of t.children)
      Ix(p, e);
    const s = dot(t);
    i = s.width, a = s.height, ae.debug("setBlockSizes abc95 maxWidth of", t.id, ":s children is ", i, a);
    for (const p of t.children)
      p.size && (ae.debug(
        `abc95 Setting size of children of ${t.id} id=${p.id} ${i} ${a} ${JSON.stringify(p.size)}`
      ), p.size.width = i * (p.widthInColumns ?? 1) + vn * ((p.widthInColumns ?? 1) - 1), p.size.height = a, p.size.x = 0, p.size.y = 0, ae.debug(
        `abc95 updating size of ${t.id} children child:${p.id} maxWidth:${i} maxHeight:${a}`
      ));
    for (const p of t.children)
      Ix(p, e, i, a);
    const o = t.columns ?? -1;
    let l = 0;
    for (const p of t.children)
      l += p.widthInColumns ?? 1;
    let u = t.children.length;
    o > 0 && o < l && (u = o);
    const h = Math.ceil(l / u);
    let f = u * (i + vn) + vn, d = h * (a + vn) + vn;
    if (f < r) {
      ae.debug(
        `Detected to small sibling: abc95 ${t.id} siblingWidth ${r} siblingHeight ${n} width ${f}`
      ), f = r, d = n;
      const p = (r - u * vn - vn) / u, g = (n - h * vn - vn) / h;
      ae.debug("Size indata abc88", t.id, "childWidth", p, "maxWidth", i), ae.debug("Size indata abc88", t.id, "childHeight", g, "maxHeight", a), ae.debug("Size indata abc88 xSize", u, "padding", vn);
      for (const m of t.children)
        m.size && (m.size.width = p, m.size.height = g, m.size.x = 0, m.size.y = 0);
    }
    if (ae.debug(
      `abc95 (finale calc) ${t.id} xSize ${u} ySize ${h} columns ${o}${t.children.length} width=${Math.max(f, t.size?.width || 0)}`
    ), f < (t?.size?.width || 0)) {
      f = t?.size?.width || 0;
      const p = o > 0 ? Math.min(t.children.length, o) : t.children.length;
      if (p > 0) {
        const g = (f - p * vn - vn) / p;
        ae.debug("abc95 (growing to fit) width", t.id, f, t.size?.width, g);
        for (const m of t.children)
          m.size && (m.size.width = g);
      }
    }
    t.size = {
      width: f,
      height: d,
      x: 0,
      y: 0
    };
  }
  ae.debug(
    "setBlockSizes abc94 (done)",
    t.id,
    t?.size?.x,
    t?.size?.width,
    t?.size?.y,
    t?.size?.height
  );
}
w(Ix, "setBlockSizes");
function vM(t, e) {
  ae.debug(
    `abc85 layout blocks (=>layoutBlocks) ${t.id} x: ${t?.size?.x} y: ${t?.size?.y} width: ${t?.size?.width}`
  );
  const r = t.columns ?? -1;
  if (ae.debug("layoutBlocks columns abc95", t.id, "=>", r, t), t.children && // find max width of children
  t.children.length > 0) {
    const n = t?.children[0]?.size?.width ?? 0, i = t.children.length * n + (t.children.length - 1) * vn;
    ae.debug("widthOfChildren 88", i, "posX");
    let a = 0;
    ae.debug("abc91 block?.size?.x", t.id, t?.size?.x);
    let s = t?.size?.x ? t?.size?.x + (-t?.size?.width / 2 || 0) : -vn, o = 0;
    for (const l of t.children) {
      const u = t;
      if (!l.size)
        continue;
      const { width: h, height: f } = l.size, { px: d, py: p } = Bue(r, a);
      if (p != o && (o = p, s = t?.size?.x ? t?.size?.x + (-t?.size?.width / 2 || 0) : -vn, ae.debug("New row in layout for block", t.id, " and child ", l.id, o)), ae.debug(
        `abc89 layout blocks (child) id: ${l.id} Pos: ${a} (px, py) ${d},${p} (${u?.size?.x},${u?.size?.y}) parent: ${u.id} width: ${h}${vn}`
      ), u.size) {
        const m = h / 2;
        l.size.x = s + vn + m, ae.debug(
          `abc91 layout blocks (calc) px, pyid:${l.id} startingPos=X${s} new startingPosX${l.size.x} ${m} padding=${vn} width=${h} halfWidth=${m} => x:${l.size.x} y:${l.size.y} ${l.widthInColumns} (width * (child?.w || 1)) / 2 ${h * (l?.widthInColumns ?? 1) / 2}`
        ), s = l.size.x + m, l.size.y = u.size.y - u.size.height / 2 + p * (f + vn) + f / 2 + vn, ae.debug(
          `abc88 layout blocks (calc) px, pyid:${l.id}startingPosX${s}${vn}${m}=>x:${l.size.x}y:${l.size.y}${l.widthInColumns}(width * (child?.w || 1)) / 2${h * (l?.widthInColumns ?? 1) / 2}`
        );
      }
      l.children && vM(l);
      let g = l?.widthInColumns ?? 1;
      r > 0 && (g = Math.min(g, r - a % r)), a += g, ae.debug("abc88 columnsPos", l, a);
    }
  }
  ae.debug(
    `layout blocks (<==layoutBlocks) ${t.id} x: ${t?.size?.x} y: ${t?.size?.y} width: ${t?.size?.width}`
  );
}
w(vM, "layoutBlocks");
function yM(t, { minX: e, minY: r, maxX: n, maxY: i } = { minX: 0, minY: 0, maxX: 0, maxY: 0 }) {
  if (t.size && t.id !== "root") {
    const { x: a, y: s, width: o, height: l } = t.size;
    a - o / 2 < e && (e = a - o / 2), s - l / 2 < r && (r = s - l / 2), a + o / 2 > n && (n = a + o / 2), s + l / 2 > i && (i = s + l / 2);
  }
  if (t.children)
    for (const a of t.children)
      ({ minX: e, minY: r, maxX: n, maxY: i } = yM(a, { minX: e, minY: r, maxX: n, maxY: i }));
  return { minX: e, minY: r, maxX: n, maxY: i };
}
w(yM, "findBounds");
function Fue(t) {
  const e = t.getBlock("root");
  if (!e)
    return;
  Ix(e, t, 0, 0), vM(e), ae.debug("getBlocks", JSON.stringify(e, null, 2));
  const { minX: r, minY: n, maxX: i, maxY: a } = yM(e), s = a - n, o = i - r;
  return { x: r, y: n, width: o, height: s };
}
w(Fue, "layout");
function n9(t, e) {
  e && t.attr("style", e);
}
w(n9, "applyStyle");
function zue(t, e) {
  const r = Qe(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), n = r.append("xhtml:div"), i = t.label, a = t.isNode ? "nodeLabel" : "edgeLabel", s = n.append("span");
  return s.html(pr(i, e)), n9(s, t.labelStyle), s.attr("class", a), n9(n, t.labelStyle), n.style("display", "inline-block"), n.style("white-space", "nowrap"), n.attr("xmlns", "http://www.w3.org/1999/xhtml"), r.node();
}
w(zue, "addHtmlLabel");
var pot = /* @__PURE__ */ w(async (t, e, r, n) => {
  let i = t || "";
  typeof i == "object" && (i = i[0]);
  const a = Te();
  if (Nr(a.flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), ae.debug("vertexText" + i);
    const s = await aL(mo(i)), o = {
      isNode: n,
      label: s,
      labelStyle: e.replace("fill:", "color:")
    };
    return zue(o, a);
  } else {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "text");
    s.setAttribute("style", e.replace("color:", "fill:"));
    let o = [];
    typeof i == "string" ? o = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? o = i : o = [];
    for (const l of o) {
      const u = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      u.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), u.setAttribute("dy", "1em"), u.setAttribute("x", "0"), r ? u.setAttribute("class", "title-row") : u.setAttribute("class", "row"), u.textContent = l.trim(), s.appendChild(u);
    }
    return s;
  }
}, "createLabel"), ja = pot, got = /* @__PURE__ */ w((t, e, r, n, i) => {
  e.arrowTypeStart && AY(t, "start", e.arrowTypeStart, r, n, i), e.arrowTypeEnd && AY(t, "end", e.arrowTypeEnd, r, n, i);
}, "addEdgeMarkers"), mot = {
  arrow_cross: "cross",
  arrow_point: "point",
  arrow_barb: "barb",
  arrow_circle: "circle",
  aggregation: "aggregation",
  extension: "extension",
  composition: "composition",
  dependency: "dependency",
  lollipop: "lollipop"
}, AY = /* @__PURE__ */ w((t, e, r, n, i, a) => {
  const s = mot[r];
  if (!s) {
    ae.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const o = e === "start" ? "Start" : "End";
  t.attr(`marker-${e}`, `url(${n}#${i}_${a}-${s}${o})`);
}, "addEdgeMarker"), i9 = {}, Si = {}, vot = /* @__PURE__ */ w(async (t, e) => {
  const r = Te(), n = Nr(r.flowchart.htmlLabels), i = e.labelType === "markdown" ? Na(
    t,
    e.label,
    {
      style: e.labelStyle,
      useHtmlLabels: n,
      addSvgBackground: !0
    },
    r
  ) : await ja(e.label, e.labelStyle), a = t.insert("g").attr("class", "edgeLabel"), s = a.insert("g").attr("class", "label");
  s.node().appendChild(i);
  let o = i.getBBox();
  if (n) {
    const u = i.children[0], h = Qe(i);
    o = u.getBoundingClientRect(), h.attr("width", o.width), h.attr("height", o.height);
  }
  s.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), i9[e.id] = a, e.width = o.width, e.height = o.height;
  let l;
  if (e.startLabelLeft) {
    const u = await ja(e.startLabelLeft, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), Si[e.id] || (Si[e.id] = {}), Si[e.id].startLeft = h, Mg(l, e.startLabelLeft);
  }
  if (e.startLabelRight) {
    const u = await ja(e.startLabelRight, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = h.node().appendChild(u), f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), Si[e.id] || (Si[e.id] = {}), Si[e.id].startRight = h, Mg(l, e.startLabelRight);
  }
  if (e.endLabelLeft) {
    const u = await ja(e.endLabelLeft, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), h.node().appendChild(u), Si[e.id] || (Si[e.id] = {}), Si[e.id].endLeft = h, Mg(l, e.endLabelLeft);
  }
  if (e.endLabelRight) {
    const u = await ja(e.endLabelRight, e.labelStyle), h = t.insert("g").attr("class", "edgeTerminals"), f = h.insert("g").attr("class", "inner");
    l = f.node().appendChild(u);
    const d = u.getBBox();
    f.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), h.node().appendChild(u), Si[e.id] || (Si[e.id] = {}), Si[e.id].endRight = h, Mg(l, e.endLabelRight);
  }
  return i;
}, "insertEdgeLabel");
function Mg(t, e) {
  Te().flowchart.htmlLabels && t && (t.style.width = e.length * 9 + "px", t.style.height = "12px");
}
w(Mg, "setTerminalWidth");
var yot = /* @__PURE__ */ w((t, e) => {
  ae.debug("Moving label abc88 ", t.id, t.label, i9[t.id], e);
  let r = e.updatedPath ? e.updatedPath : e.originalPath;
  const n = Te(), { subGraphTitleTotalMargin: i } = nm(n);
  if (t.label) {
    const a = i9[t.id];
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcLabelPosition(r);
      ae.debug(
        "Moving label " + t.label + " from (",
        s,
        ",",
        o,
        ") to (",
        l.x,
        ",",
        l.y,
        ") abc88"
      ), e.updatedPath && (s = l.x, o = l.y);
    }
    a.attr("transform", `translate(${s}, ${o + i / 2})`);
  }
  if (t.startLabelLeft) {
    const a = Si[t.id].startLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.startLabelRight) {
    const a = Si[t.id].startRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(
        t.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelLeft) {
    const a = Si[t.id].endLeft;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_left", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
  if (t.endLabelRight) {
    const a = Si[t.id].endRight;
    let s = t.x, o = t.y;
    if (r) {
      const l = Jt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_right", r);
      s = l.x, o = l.y;
    }
    a.attr("transform", `translate(${s}, ${o})`);
  }
}, "positionEdgeLabel"), bot = /* @__PURE__ */ w((t, e) => {
  const r = t.x, n = t.y, i = Math.abs(e.x - r), a = Math.abs(e.y - n), s = t.width / 2, o = t.height / 2;
  return i >= s || a >= o;
}, "outsideNode"), xot = /* @__PURE__ */ w((t, e, r) => {
  ae.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${t.x} y:${t.y} w:${t.width} h:${t.height}`);
  const n = t.x, i = t.y, a = Math.abs(n - r.x), s = t.width / 2;
  let o = r.x < e.x ? s - a : s + a;
  const l = t.height / 2, u = Math.abs(e.y - r.y), h = Math.abs(e.x - r.x);
  if (Math.abs(i - e.y) * s > Math.abs(n - e.x) * l) {
    let f = r.y < e.y ? e.y - l - i : i - l - e.y;
    o = h * f / u;
    const d = {
      x: r.x < e.x ? r.x + o : r.x - h + o,
      y: r.y < e.y ? r.y + u - f : r.y - u + f
    };
    return o === 0 && (d.x = e.x, d.y = e.y), h === 0 && (d.x = e.x), u === 0 && (d.y = e.y), ae.debug(`abc89 topp/bott calc, Q ${u}, q ${f}, R ${h}, r ${o}`, d), d;
  } else {
    r.x < e.x ? o = e.x - s - n : o = n - s - e.x;
    let f = u * o / h, d = r.x < e.x ? r.x + h - o : r.x - h + o, p = r.y < e.y ? r.y + f : r.y - f;
    return ae.debug(`sides calc abc89, Q ${u}, q ${f}, R ${h}, r ${o}`, { _x: d, _y: p }), o === 0 && (d = e.x, p = e.y), h === 0 && (d = e.x), u === 0 && (p = e.y), { x: d, y: p };
  }
}, "intersection"), LY = /* @__PURE__ */ w((t, e) => {
  ae.debug("abc88 cutPathAtIntersect", t, e);
  let r = [], n = t[0], i = !1;
  return t.forEach((a) => {
    if (!bot(e, a) && !i) {
      const s = xot(e, n, a);
      let o = !1;
      r.forEach((l) => {
        o = o || l.x === s.x && l.y === s.y;
      }), r.some((l) => l.x === s.x && l.y === s.y) || r.push(s), i = !0;
    } else
      n = a, i || r.push(a);
  }), r;
}, "cutPathAtIntersect"), wot = /* @__PURE__ */ w(function(t, e, r, n, i, a, s) {
  let o = r.points;
  ae.debug("abc88 InsertEdge: edge=", r, "e=", e);
  let l = !1;
  const u = a.node(e.v);
  var h = a.node(e.w);
  h?.intersect && u?.intersect && (o = o.slice(1, r.points.length - 1), o.unshift(u.intersect(o[0])), o.push(h.intersect(o[o.length - 1]))), r.toCluster && (ae.debug("to cluster abc88", n[r.toCluster]), o = LY(r.points, n[r.toCluster].node), l = !0), r.fromCluster && (ae.debug("from cluster abc88", n[r.fromCluster]), o = LY(o.reverse(), n[r.fromCluster].node).reverse(), l = !0);
  const f = o.filter((T) => !Number.isNaN(T.y));
  let d = Mf;
  r.curve && (i === "graph" || i === "flowchart") && (d = r.curve);
  const { x: p, y: g } = sZ(r), m = i1().x(p).y(g).curve(d);
  let v;
  switch (r.thickness) {
    case "normal":
      v = "edge-thickness-normal";
      break;
    case "thick":
      v = "edge-thickness-thick";
      break;
    case "invisible":
      v = "edge-thickness-thick";
      break;
    default:
      v = "";
  }
  switch (r.pattern) {
    case "solid":
      v += " edge-pattern-solid";
      break;
    case "dotted":
      v += " edge-pattern-dotted";
      break;
    case "dashed":
      v += " edge-pattern-dashed";
      break;
  }
  const y = t.append("path").attr("d", m(f)).attr("id", r.id).attr("class", " " + v + (r.classes ? " " + r.classes : "")).attr("style", r.style);
  let b = "";
  (Te().flowchart.arrowMarkerAbsolute || Te().state.arrowMarkerAbsolute) && (b = Bx(!0)), got(y, r, b, s, i);
  let x = {};
  return l && (x.updatedPath = o), x.originalPath = r.points, x;
}, "insertEdge"), Tot = /* @__PURE__ */ w((t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    switch (r) {
      case "x":
        e.add("right"), e.add("left");
        break;
      case "y":
        e.add("up"), e.add("down");
        break;
      default:
        e.add(r);
        break;
    }
  return e;
}, "expandAndDeduplicateDirections"), Eot = /* @__PURE__ */ w((t, e, r) => {
  const n = Tot(t), i = 2, a = e.height + 2 * r.padding, s = a / i, o = e.width + 2 * s + r.padding, l = r.padding / 2;
  return n.has("right") && n.has("left") && n.has("up") && n.has("down") ? [
    // Bottom
    { x: 0, y: 0 },
    { x: s, y: 0 },
    { x: o / 2, y: 2 * l },
    { x: o - s, y: 0 },
    { x: o, y: 0 },
    // Right
    { x: o, y: -a / 3 },
    { x: o + 2 * l, y: -a / 2 },
    { x: o, y: -2 * a / 3 },
    { x: o, y: -a },
    // Top
    { x: o - s, y: -a },
    { x: o / 2, y: -a - 2 * l },
    { x: s, y: -a },
    // Left
    { x: 0, y: -a },
    { x: 0, y: -2 * a / 3 },
    { x: -2 * l, y: -a / 2 },
    { x: 0, y: -a / 3 }
  ] : n.has("right") && n.has("left") && n.has("up") ? [
    { x: s, y: 0 },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ] : n.has("right") && n.has("left") && n.has("down") ? [
    { x: 0, y: 0 },
    { x: s, y: -a },
    { x: o - s, y: -a },
    { x: o, y: 0 }
  ] : n.has("right") && n.has("up") && n.has("down") ? [
    { x: 0, y: 0 },
    { x: o, y: -s },
    { x: o, y: -a + s },
    { x: 0, y: -a }
  ] : n.has("left") && n.has("up") && n.has("down") ? [
    { x: o, y: 0 },
    { x: 0, y: -s },
    { x: 0, y: -a + s },
    { x: o, y: -a }
  ] : n.has("right") && n.has("left") ? [
    { x: s, y: 0 },
    { x: s, y: -l },
    { x: o - s, y: -l },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: o - s, y: -a + l },
    { x: s, y: -a + l },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ] : n.has("up") && n.has("down") ? [
    // Bottom center
    { x: o / 2, y: 0 },
    // Left pont of bottom arrow
    { x: 0, y: -l },
    { x: s, y: -l },
    // Left top over vertical section
    { x: s, y: -a + l },
    { x: 0, y: -a + l },
    // Top of arrow
    { x: o / 2, y: -a },
    { x: o, y: -a + l },
    // Top of right vertical bar
    { x: o - s, y: -a + l },
    { x: o - s, y: -l },
    { x: o, y: -l }
  ] : n.has("right") && n.has("up") ? [
    { x: 0, y: 0 },
    { x: o, y: -s },
    { x: 0, y: -a }
  ] : n.has("right") && n.has("down") ? [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: 0, y: -a }
  ] : n.has("left") && n.has("up") ? [
    { x: o, y: 0 },
    { x: 0, y: -s },
    { x: o, y: -a }
  ] : n.has("left") && n.has("down") ? [
    { x: o, y: 0 },
    { x: 0, y: 0 },
    { x: o, y: -a }
  ] : n.has("right") ? [
    { x: s, y: -l },
    { x: s, y: -l },
    { x: o - s, y: -l },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: o - s, y: -a + l },
    // top left corner of arrow
    { x: s, y: -a + l },
    { x: s, y: -a + l }
  ] : n.has("left") ? [
    { x: s, y: 0 },
    { x: s, y: -l },
    // Two points, the right corners
    { x: o - s, y: -l },
    { x: o - s, y: -a + l },
    { x: s, y: -a + l },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ] : n.has("up") ? [
    // Bottom center
    { x: s, y: -l },
    // Left top over vertical section
    { x: s, y: -a + l },
    { x: 0, y: -a + l },
    // Top of arrow
    { x: o / 2, y: -a },
    { x: o, y: -a + l },
    // Top of right vertical bar
    { x: o - s, y: -a + l },
    { x: o - s, y: -l }
  ] : n.has("down") ? [
    // Bottom center
    { x: o / 2, y: 0 },
    // Left pont of bottom arrow
    { x: 0, y: -l },
    { x: s, y: -l },
    // Left top over vertical section
    { x: s, y: -a + l },
    { x: o - s, y: -a + l },
    { x: o - s, y: -l },
    { x: o, y: -l }
  ] : [{ x: 0, y: 0 }];
}, "getArrowPoints");
function que(t, e) {
  return t.intersect(e);
}
w(que, "intersectNode");
var Sot = que;
function Gue(t, e, r, n) {
  var i = t.x, a = t.y, s = i - n.x, o = a - n.y, l = Math.sqrt(e * e * o * o + r * r * s * s), u = Math.abs(e * r * s / l);
  n.x < i && (u = -u);
  var h = Math.abs(e * r * o / l);
  return n.y < a && (h = -h), { x: i + u, y: a + h };
}
w(Gue, "intersectEllipse");
var Uue = Gue;
function Vue(t, e, r) {
  return Uue(t, e, e, r);
}
w(Vue, "intersectCircle");
var kot = Vue;
function Hue(t, e, r, n) {
  var i, a, s, o, l, u, h, f, d, p, g, m, v, y, b;
  if (i = e.y - t.y, s = t.x - e.x, l = e.x * t.y - t.x * e.y, d = i * r.x + s * r.y + l, p = i * n.x + s * n.y + l, !(d !== 0 && p !== 0 && a9(d, p)) && (a = n.y - r.y, o = r.x - n.x, u = n.x * r.y - r.x * n.y, h = a * t.x + o * t.y + u, f = a * e.x + o * e.y + u, !(h !== 0 && f !== 0 && a9(h, f)) && (g = i * o - a * s, g !== 0)))
    return m = Math.abs(g / 2), v = s * u - o * l, y = v < 0 ? (v - m) / g : (v + m) / g, v = a * l - i * u, b = v < 0 ? (v - m) / g : (v + m) / g, { x: y, y: b };
}
w(Hue, "intersectLine");
function a9(t, e) {
  return t * e > 0;
}
w(a9, "sameSign");
var Cot = Hue, _ot = Wue;
function Wue(t, e, r) {
  var n = t.x, i = t.y, a = [], s = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof e.forEach == "function" ? e.forEach(function(g) {
    s = Math.min(s, g.x), o = Math.min(o, g.y);
  }) : (s = Math.min(s, e.x), o = Math.min(o, e.y));
  for (var l = n - t.width / 2 - s, u = i - t.height / 2 - o, h = 0; h < e.length; h++) {
    var f = e[h], d = e[h < e.length - 1 ? h + 1 : 0], p = Cot(
      t,
      r,
      { x: l + f.x, y: u + f.y },
      { x: l + d.x, y: u + d.y }
    );
    p && a.push(p);
  }
  return a.length ? (a.length > 1 && a.sort(function(g, m) {
    var v = g.x - r.x, y = g.y - r.y, b = Math.sqrt(v * v + y * y), x = m.x - r.x, T = m.y - r.y, E = Math.sqrt(x * x + T * T);
    return b < E ? -1 : b === E ? 0 : 1;
  }), a[0]) : t;
}
w(Wue, "intersectPolygon");
var Aot = /* @__PURE__ */ w((t, e) => {
  var r = t.x, n = t.y, i = e.x - r, a = e.y - n, s = t.width / 2, o = t.height / 2, l, u;
  return Math.abs(a) * s > Math.abs(i) * o ? (a < 0 && (o = -o), l = a === 0 ? 0 : o * i / a, u = o) : (i < 0 && (s = -s), l = s, u = i === 0 ? 0 : s * a / i), { x: r + l, y: n + u };
}, "intersectRect"), Lot = Aot, rn = {
  node: Sot,
  circle: kot,
  ellipse: Uue,
  polygon: _ot,
  rect: Lot
}, ii = /* @__PURE__ */ w(async (t, e, r, n) => {
  const i = Te();
  let a;
  const s = e.useHtmlLabels || Nr(i.flowchart.htmlLabels);
  r ? a = r : a = "node default";
  const o = t.insert("g").attr("class", a).attr("id", e.domId || e.id), l = o.insert("g").attr("class", "label").attr("style", e.labelStyle);
  let u;
  e.labelText === void 0 ? u = "" : u = typeof e.labelText == "string" ? e.labelText : e.labelText[0];
  const h = l.node();
  let f;
  e.labelType === "markdown" ? f = Na(
    l,
    pr(mo(u), i),
    {
      useHtmlLabels: s,
      width: e.width || i.flowchart.wrappingWidth,
      classes: "markdown-node-label"
    },
    i
  ) : f = h.appendChild(
    await ja(
      pr(mo(u), i),
      e.labelStyle,
      !1,
      n
    )
  );
  let d = f.getBBox();
  const p = e.padding / 2;
  if (Nr(i.flowchart.htmlLabels)) {
    const g = f.children[0], m = Qe(f), v = g.getElementsByTagName("img");
    if (v) {
      const y = u.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...v].map(
          (b) => new Promise((x) => {
            function T() {
              if (b.style.display = "flex", b.style.flexDirection = "column", y) {
                const E = i.fontSize ? i.fontSize : window.getComputedStyle(document.body).fontSize, S = parseInt(E, 10) * 5 + "px";
                b.style.minWidth = S, b.style.maxWidth = S;
              } else
                b.style.width = "100%";
              x(b);
            }
            w(T, "setupImage"), setTimeout(() => {
              b.complete && T();
            }), b.addEventListener("error", T), b.addEventListener("load", T);
          })
        )
      );
    }
    d = g.getBoundingClientRect(), m.attr("width", d.width), m.attr("height", d.height);
  }
  return s ? l.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")") : l.attr("transform", "translate(0, " + -d.height / 2 + ")"), e.centerLabel && l.attr("transform", "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")"), l.insert("rect", ":first-child"), { shapeSvg: o, bbox: d, halfPadding: p, label: l };
}, "labelHelper"), gn = /* @__PURE__ */ w((t, e) => {
  const r = e.node().getBBox();
  t.width = r.width, t.height = r.height;
}, "updateNodeBounds");
function qs(t, e, r, n) {
  return t.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
w(qs, "insertPolygonShape");
var Rot = /* @__PURE__ */ w(async (t, e) => {
  e.useHtmlLabels || Te().flowchart.htmlLabels || (e.centerLabel = !0);
  const { shapeSvg: n, bbox: i, halfPadding: a } = await ii(
    t,
    e,
    "node " + e.classes,
    !0
  );
  ae.info("Classes = ", e.classes);
  const s = n.insert("rect", ":first-child");
  return s.attr("rx", e.rx).attr("ry", e.ry).attr("x", -i.width / 2 - a).attr("y", -i.height / 2 - a).attr("width", i.width + e.padding).attr("height", i.height + e.padding), gn(e, s), e.intersect = function(o) {
    return rn.rect(e, o);
  }, n;
}, "note"), Iot = Rot, RY = /* @__PURE__ */ w((t) => t ? " " + t : "", "formatClass"), Ba = /* @__PURE__ */ w((t, e) => `${e || "node default"}${RY(t.classes)} ${RY(
  t.class
)}`, "getClassesFromNode"), IY = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = i + a, o = [
    { x: s / 2, y: 0 },
    { x: s, y: -s / 2 },
    { x: s / 2, y: -s },
    { x: 0, y: -s / 2 }
  ];
  ae.info("Question main (Circle)");
  const l = qs(r, s, s, o);
  return l.attr("style", e.style), gn(e, l), e.intersect = function(u) {
    return ae.warn("Intersect called"), rn.polygon(e, o, u);
  }, r;
}, "question"), Mot = /* @__PURE__ */ w((t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = 28, i = [
    { x: 0, y: n / 2 },
    { x: n / 2, y: 0 },
    { x: 0, y: -n / 2 },
    { x: -n / 2, y: 0 }
  ];
  return r.insert("polygon", ":first-child").attr(
    "points",
    i.map(function(s) {
      return s.x + "," + s.y;
    }).join(" ")
  ).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), e.width = 28, e.height = 28, e.intersect = function(s) {
    return rn.circle(e, 14, s);
  }, r;
}, "choice"), Not = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = 4, a = n.height + e.padding, s = a / i, o = n.width + 2 * s + e.padding, l = [
    { x: s, y: 0 },
    { x: o - s, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - s, y: -a },
    { x: s, y: -a },
    { x: 0, y: -a / 2 }
  ], u = qs(r, o, a, l);
  return u.attr("style", e.style), gn(e, u), e.intersect = function(h) {
    return rn.polygon(e, l, h);
  }, r;
}, "hexagon"), Dot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(t, e, void 0, !0), i = 2, a = n.height + 2 * e.padding, s = a / i, o = n.width + 2 * s + e.padding, l = Eot(e.directions, n, e), u = qs(r, o, a, l);
  return u.attr("style", e.style), gn(e, u), e.intersect = function(h) {
    return rn.polygon(e, l, h);
  }, r;
}, "block_arrow"), Oot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: -a / 2, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -a },
    { x: -a / 2, y: -a },
    { x: 0, y: -a / 2 }
  ];
  return qs(r, i, a, s).attr("style", e.style), e.width = i + a, e.height = a, e.intersect = function(l) {
    return rn.polygon(e, s, l);
  }, r;
}, "rect_left_inv_arrow"), Pot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(t, e, Ba(e), !0), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: -2 * a / 6, y: 0 },
    { x: i - a / 6, y: 0 },
    { x: i + 2 * a / 6, y: -a },
    { x: a / 6, y: -a }
  ], o = qs(r, i, a, s);
  return o.attr("style", e.style), gn(e, o), e.intersect = function(l) {
    return rn.polygon(e, s, l);
  }, r;
}, "lean_right"), $ot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: 2 * a / 6, y: 0 },
    { x: i + a / 6, y: 0 },
    { x: i - 2 * a / 6, y: -a },
    { x: -a / 6, y: -a }
  ], o = qs(r, i, a, s);
  return o.attr("style", e.style), gn(e, o), e.intersect = function(l) {
    return rn.polygon(e, s, l);
  }, r;
}, "lean_left"), Bot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: -2 * a / 6, y: 0 },
    { x: i + 2 * a / 6, y: 0 },
    { x: i - a / 6, y: -a },
    { x: a / 6, y: -a }
  ], o = qs(r, i, a, s);
  return o.attr("style", e.style), gn(e, o), e.intersect = function(l) {
    return rn.polygon(e, s, l);
  }, r;
}, "trapezoid"), Fot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: a / 6, y: 0 },
    { x: i - a / 6, y: 0 },
    { x: i + 2 * a / 6, y: -a },
    { x: -2 * a / 6, y: -a }
  ], o = qs(r, i, a, s);
  return o.attr("style", e.style), gn(e, o), e.intersect = function(l) {
    return rn.polygon(e, s, l);
  }, r;
}, "inv_trapezoid"), zot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: 0, y: 0 },
    { x: i + a / 2, y: 0 },
    { x: i, y: -a / 2 },
    { x: i + a / 2, y: -a },
    { x: 0, y: -a }
  ], o = qs(r, i, a, s);
  return o.attr("style", e.style), gn(e, o), e.intersect = function(l) {
    return rn.polygon(e, s, l);
  }, r;
}, "rect_right_inv_arrow"), qot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = i / 2, s = a / (2.5 + i / 50), o = n.height + s + e.padding, l = "M 0," + s + " a " + a + "," + s + " 0,0,0 " + i + " 0 a " + a + "," + s + " 0,0,0 " + -i + " 0 l 0," + o + " a " + a + "," + s + " 0,0,0 " + i + " 0 l 0," + -o, u = r.attr("label-offset-y", s).insert("path", ":first-child").attr("style", e.style).attr("d", l).attr("transform", "translate(" + -i / 2 + "," + -(o / 2 + s) + ")");
  return gn(e, u), e.intersect = function(h) {
    const f = rn.rect(e, h), d = f.x - e.x;
    if (a != 0 && (Math.abs(d) < e.width / 2 || Math.abs(d) == e.width / 2 && Math.abs(f.y - e.y) > e.height / 2 - s)) {
      let p = s * s * (1 - d * d / (a * a));
      p != 0 && (p = Math.sqrt(p)), p = s - p, h.y - e.y > 0 && (p = -p), f.y += p;
    }
    return f;
  }, r;
}, "cylinder"), Got = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ii(
    t,
    e,
    "node " + e.classes + " " + e.class,
    !0
  ), a = r.insert("rect", ":first-child"), s = e.positioned ? e.width : n.width + e.padding, o = e.positioned ? e.height : n.height + e.padding, l = e.positioned ? -s / 2 : -n.width / 2 - i, u = e.positioned ? -o / 2 : -n.height / 2 - i;
  if (a.attr("class", "basic label-container").attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", l).attr("y", u).attr("width", s).attr("height", o), e.props) {
    const h = new Set(Object.keys(e.props));
    e.props.borders && (i5(a, e.props.borders, s, o), h.delete("borders")), h.forEach((f) => {
      ae.warn(`Unknown node property ${f}`);
    });
  }
  return gn(e, a), e.intersect = function(h) {
    return rn.rect(e, h);
  }, r;
}, "rect"), Uot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ii(
    t,
    e,
    "node " + e.classes,
    !0
  ), a = r.insert("rect", ":first-child"), s = e.positioned ? e.width : n.width + e.padding, o = e.positioned ? e.height : n.height + e.padding, l = e.positioned ? -s / 2 : -n.width / 2 - i, u = e.positioned ? -o / 2 : -n.height / 2 - i;
  if (a.attr("class", "basic cluster composite label-container").attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", l).attr("y", u).attr("width", s).attr("height", o), e.props) {
    const h = new Set(Object.keys(e.props));
    e.props.borders && (i5(a, e.props.borders, s, o), h.delete("borders")), h.forEach((f) => {
      ae.warn(`Unknown node property ${f}`);
    });
  }
  return gn(e, a), e.intersect = function(h) {
    return rn.rect(e, h);
  }, r;
}, "composite"), Vot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r } = await ii(t, e, "label", !0);
  ae.trace("Classes = ", e.class);
  const n = r.insert("rect", ":first-child"), i = 0, a = 0;
  if (n.attr("width", i).attr("height", a), r.attr("class", "label edgeLabel"), e.props) {
    const s = new Set(Object.keys(e.props));
    e.props.borders && (i5(n, e.props.borders, i, a), s.delete("borders")), s.forEach((o) => {
      ae.warn(`Unknown node property ${o}`);
    });
  }
  return gn(e, n), e.intersect = function(s) {
    return rn.rect(e, s);
  }, r;
}, "labelRect");
function i5(t, e, r, n) {
  const i = [], a = /* @__PURE__ */ w((o) => {
    i.push(o, 0);
  }, "addBorder"), s = /* @__PURE__ */ w((o) => {
    i.push(0, o);
  }, "skipBorder");
  e.includes("t") ? (ae.debug("add top border"), a(r)) : s(r), e.includes("r") ? (ae.debug("add right border"), a(n)) : s(n), e.includes("b") ? (ae.debug("add bottom border"), a(r)) : s(r), e.includes("l") ? (ae.debug("add left border"), a(n)) : s(n), t.attr("stroke-dasharray", i.join(" "));
}
w(i5, "applyNodePropertyBorders");
var Hot = /* @__PURE__ */ w(async (t, e) => {
  let r;
  e.classes ? r = "node " + e.classes : r = "node default";
  const n = t.insert("g").attr("class", r).attr("id", e.domId || e.id), i = n.insert("rect", ":first-child"), a = n.insert("line"), s = n.insert("g").attr("class", "label"), o = e.labelText.flat ? e.labelText.flat() : e.labelText;
  let l = "";
  typeof o == "object" ? l = o[0] : l = o, ae.info("Label text abc79", l, o, typeof o == "object");
  const u = s.node().appendChild(await ja(l, e.labelStyle, !0, !0));
  let h = { width: 0, height: 0 };
  if (Nr(Te().flowchart.htmlLabels)) {
    const m = u.children[0], v = Qe(u);
    h = m.getBoundingClientRect(), v.attr("width", h.width), v.attr("height", h.height);
  }
  ae.info("Text 2", o);
  const f = o.slice(1, o.length);
  let d = u.getBBox();
  const p = s.node().appendChild(
    await ja(
      f.join ? f.join("<br/>") : f,
      e.labelStyle,
      !0,
      !0
    )
  );
  if (Nr(Te().flowchart.htmlLabels)) {
    const m = p.children[0], v = Qe(p);
    h = m.getBoundingClientRect(), v.attr("width", h.width), v.attr("height", h.height);
  }
  const g = e.padding / 2;
  return Qe(p).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (h.width > d.width ? 0 : (d.width - h.width) / 2) + ", " + (d.height + g + 5) + ")"
  ), Qe(u).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (h.width < d.width ? 0 : -(d.width - h.width) / 2) + ", 0)"
  ), h = s.node().getBBox(), s.attr(
    "transform",
    "translate(" + -h.width / 2 + ", " + (-h.height / 2 - g + 3) + ")"
  ), i.attr("class", "outer title-state").attr("x", -h.width / 2 - g).attr("y", -h.height / 2 - g).attr("width", h.width + e.padding).attr("height", h.height + e.padding), a.attr("class", "divider").attr("x1", -h.width / 2 - g).attr("x2", h.width / 2 + g).attr("y1", -h.height / 2 - g + d.height + g).attr("y2", -h.height / 2 - g + d.height + g), gn(e, i), e.intersect = function(m) {
    return rn.rect(e, m);
  }, n;
}, "rectWithTitle"), Wot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.height + e.padding, a = n.width + i / 4 + e.padding, s = r.insert("rect", ":first-child").attr("style", e.style).attr("rx", i / 2).attr("ry", i / 2).attr("x", -a / 2).attr("y", -i / 2).attr("width", a).attr("height", i);
  return gn(e, s), e.intersect = function(o) {
    return rn.rect(e, o);
  }, r;
}, "stadium"), Yot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), a = r.insert("circle", ":first-child");
  return a.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i).attr("width", n.width + e.padding).attr("height", n.height + e.padding), ae.info("Circle main"), gn(e, a), e.intersect = function(s) {
    return ae.info("Circle intersect", e, n.width / 2 + i, s), rn.circle(e, n.width / 2 + i, s);
  }, r;
}, "circle"), Xot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), a = 5, s = r.insert("g", ":first-child"), o = s.insert("circle"), l = s.insert("circle");
  return s.attr("class", e.class), o.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i + a).attr("width", n.width + e.padding + a * 2).attr("height", n.height + e.padding + a * 2), l.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i).attr("width", n.width + e.padding).attr("height", n.height + e.padding), ae.info("DoubleCircle main"), gn(e, o), e.intersect = function(u) {
    return ae.info("DoubleCircle intersect", e, n.width / 2 + i + a, u), rn.circle(e, n.width / 2 + i + a, u);
  }, r;
}, "doublecircle"), jot = /* @__PURE__ */ w(async (t, e) => {
  const { shapeSvg: r, bbox: n } = await ii(
    t,
    e,
    Ba(e, void 0),
    !0
  ), i = n.width + e.padding, a = n.height + e.padding, s = [
    { x: 0, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -a },
    { x: 0, y: -a },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: i + 8, y: 0 },
    { x: i + 8, y: -a },
    { x: -8, y: -a },
    { x: -8, y: 0 }
  ], o = qs(r, i, a, s);
  return o.attr("style", e.style), gn(e, o), e.intersect = function(l) {
    return rn.polygon(e, s, l);
  }, r;
}, "subroutine"), Kot = /* @__PURE__ */ w((t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = r.insert("circle", ":first-child");
  return n.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), gn(e, n), e.intersect = function(i) {
    return rn.circle(e, 7, i);
  }, r;
}, "start"), MY = /* @__PURE__ */ w((t, e, r) => {
  const n = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
  let i = 70, a = 10;
  r === "LR" && (i = 10, a = 70);
  const s = n.append("rect").attr("x", -1 * i / 2).attr("y", -1 * a / 2).attr("width", i).attr("height", a).attr("class", "fork-join");
  return gn(e, s), e.height = e.height + e.padding / 2, e.width = e.width + e.padding / 2, e.intersect = function(o) {
    return rn.rect(e, o);
  }, n;
}, "forkJoin"), Zot = /* @__PURE__ */ w((t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = r.insert("circle", ":first-child"), i = r.insert("circle", ":first-child");
  return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), n.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), gn(e, i), e.intersect = function(a) {
    return rn.circle(e, 7, a);
  }, r;
}, "end"), Qot = /* @__PURE__ */ w(async (t, e) => {
  const r = e.padding / 2, n = 4, i = 8;
  let a;
  e.classes ? a = "node " + e.classes : a = "node default";
  const s = t.insert("g").attr("class", a).attr("id", e.domId || e.id), o = s.insert("rect", ":first-child"), l = s.insert("line"), u = s.insert("line");
  let h = 0, f = n;
  const d = s.insert("g").attr("class", "label");
  let p = 0;
  const g = e.classData.annotations?.[0], m = e.classData.annotations[0] ? "\xAB" + e.classData.annotations[0] + "\xBB" : "", v = d.node().appendChild(await ja(m, e.labelStyle, !0, !0));
  let y = v.getBBox();
  if (Nr(Te().flowchart.htmlLabels)) {
    const k = v.children[0], _ = Qe(v);
    y = k.getBoundingClientRect(), _.attr("width", y.width), _.attr("height", y.height);
  }
  e.classData.annotations[0] && (f += y.height + n, h += y.width);
  let b = e.classData.label;
  e.classData.type !== void 0 && e.classData.type !== "" && (Te().flowchart.htmlLabels ? b += "&lt;" + e.classData.type + "&gt;" : b += "<" + e.classData.type + ">");
  const x = d.node().appendChild(await ja(b, e.labelStyle, !0, !0));
  Qe(x).attr("class", "classTitle");
  let T = x.getBBox();
  if (Nr(Te().flowchart.htmlLabels)) {
    const k = x.children[0], _ = Qe(x);
    T = k.getBoundingClientRect(), _.attr("width", T.width), _.attr("height", T.height);
  }
  f += T.height + n, T.width > h && (h = T.width);
  const E = [];
  e.classData.members.forEach(async (k) => {
    const _ = k.getDisplayDetails();
    let R = _.displayText;
    Te().flowchart.htmlLabels && (R = R.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const L = d.node().appendChild(
      await ja(
        R,
        _.cssStyle ? _.cssStyle : e.labelStyle,
        !0,
        !0
      )
    );
    let M = L.getBBox();
    if (Nr(Te().flowchart.htmlLabels)) {
      const P = L.children[0], C = Qe(L);
      M = P.getBoundingClientRect(), C.attr("width", M.width), C.attr("height", M.height);
    }
    M.width > h && (h = M.width), f += M.height + n, E.push(L);
  }), f += i;
  const A = [];
  if (e.classData.methods.forEach(async (k) => {
    const _ = k.getDisplayDetails();
    let R = _.displayText;
    Te().flowchart.htmlLabels && (R = R.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const L = d.node().appendChild(
      await ja(
        R,
        _.cssStyle ? _.cssStyle : e.labelStyle,
        !0,
        !0
      )
    );
    let M = L.getBBox();
    if (Nr(Te().flowchart.htmlLabels)) {
      const P = L.children[0], C = Qe(L);
      M = P.getBoundingClientRect(), C.attr("width", M.width), C.attr("height", M.height);
    }
    M.width > h && (h = M.width), f += M.height + n, A.push(L);
  }), f += i, g) {
    let k = (h - y.width) / 2;
    Qe(v).attr(
      "transform",
      "translate( " + (-1 * h / 2 + k) + ", " + -1 * f / 2 + ")"
    ), p = y.height + n;
  }
  let S = (h - T.width) / 2;
  return Qe(x).attr(
    "transform",
    "translate( " + (-1 * h / 2 + S) + ", " + (-1 * f / 2 + p) + ")"
  ), p += T.height + n, l.attr("class", "divider").attr("x1", -h / 2 - r).attr("x2", h / 2 + r).attr("y1", -f / 2 - r + i + p).attr("y2", -f / 2 - r + i + p), p += i, E.forEach((k) => {
    Qe(k).attr(
      "transform",
      "translate( " + -h / 2 + ", " + (-1 * f / 2 + p + i / 2) + ")"
    );
    const _ = k?.getBBox();
    p += (_?.height ?? 0) + n;
  }), p += i, u.attr("class", "divider").attr("x1", -h / 2 - r).attr("x2", h / 2 + r).attr("y1", -f / 2 - r + i + p).attr("y2", -f / 2 - r + i + p), p += i, A.forEach((k) => {
    Qe(k).attr(
      "transform",
      "translate( " + -h / 2 + ", " + (-1 * f / 2 + p) + ")"
    );
    const _ = k?.getBBox();
    p += (_?.height ?? 0) + n;
  }), o.attr("style", e.style).attr("class", "outer title-state").attr("x", -h / 2 - r).attr("y", -(f / 2) - r).attr("width", h + e.padding).attr("height", f + e.padding), gn(e, o), e.intersect = function(k) {
    return rn.rect(e, k);
  }, s;
}, "class_box"), NY = {
  rhombus: IY,
  composite: Uot,
  question: IY,
  rect: Got,
  labelRect: Vot,
  rectWithTitle: Hot,
  choice: Mot,
  circle: Yot,
  doublecircle: Xot,
  stadium: Wot,
  hexagon: Not,
  block_arrow: Dot,
  rect_left_inv_arrow: Oot,
  lean_right: Pot,
  lean_left: $ot,
  trapezoid: Bot,
  inv_trapezoid: Fot,
  rect_right_inv_arrow: zot,
  cylinder: qot,
  start: Kot,
  end: Zot,
  note: Iot,
  subroutine: jot,
  fork: MY,
  join: MY,
  class_box: Qot
}, w2 = {}, Yue = /* @__PURE__ */ w(async (t, e, r) => {
  let n, i;
  if (e.link) {
    let a;
    Te().securityLevel === "sandbox" ? a = "_top" : e.linkTarget && (a = e.linkTarget || "_blank"), n = t.insert("svg:a").attr("xlink:href", e.link).attr("target", a), i = await NY[e.shape](n, e, r);
  } else
    i = await NY[e.shape](t, e, r), n = i;
  return e.tooltip && i.attr("title", e.tooltip), e.class && i.attr("class", "node default " + e.class), w2[e.id] = n, e.haveCallback && w2[e.id].attr("class", w2[e.id].attr("class") + " clickable"), n;
}, "insertNode"), Jot = /* @__PURE__ */ w((t) => {
  const e = w2[t.id];
  ae.trace(
    "Transforming node",
    t.diff,
    t,
    "translate(" + (t.x - t.width / 2 - 5) + ", " + t.width / 2 + ")"
  );
  const r = 8, n = t.diff || 0;
  return t.clusterNode ? e.attr(
    "transform",
    "translate(" + (t.x + n - t.width / 2) + ", " + (t.y - t.height / 2 - r) + ")"
  ) : e.attr("transform", "translate(" + t.x + ", " + t.y + ")"), n;
}, "positionNode");
function bM(t, e, r = !1) {
  const n = t;
  let i = "default";
  (n?.classes?.length || 0) > 0 && (i = (n?.classes ?? []).join(" ")), i = i + " flowchart-label";
  let a = 0, s = "", o;
  switch (n.type) {
    case "round":
      a = 5, s = "rect";
      break;
    case "composite":
      a = 0, s = "composite", o = 0;
      break;
    case "square":
      s = "rect";
      break;
    case "diamond":
      s = "question";
      break;
    case "hexagon":
      s = "hexagon";
      break;
    case "block_arrow":
      s = "block_arrow";
      break;
    case "odd":
      s = "rect_left_inv_arrow";
      break;
    case "lean_right":
      s = "lean_right";
      break;
    case "lean_left":
      s = "lean_left";
      break;
    case "trapezoid":
      s = "trapezoid";
      break;
    case "inv_trapezoid":
      s = "inv_trapezoid";
      break;
    case "rect_left_inv_arrow":
      s = "rect_left_inv_arrow";
      break;
    case "circle":
      s = "circle";
      break;
    case "ellipse":
      s = "ellipse";
      break;
    case "stadium":
      s = "stadium";
      break;
    case "subroutine":
      s = "subroutine";
      break;
    case "cylinder":
      s = "cylinder";
      break;
    case "group":
      s = "rect";
      break;
    case "doublecircle":
      s = "doublecircle";
      break;
    default:
      s = "rect";
  }
  const l = W9(n?.styles ?? []), u = n.label, h = n.size ?? { width: 0, height: 0, x: 0, y: 0 };
  return {
    labelStyle: l.labelStyle,
    shape: s,
    labelText: u,
    rx: a,
    ry: a,
    class: i,
    style: l.style,
    id: n.id,
    directions: n.directions,
    width: h.width,
    height: h.height,
    x: h.x,
    y: h.y,
    positioned: r,
    intersect: void 0,
    type: n.type,
    padding: o ?? mr()?.block?.padding ?? 0
  };
}
w(bM, "getNodeFromBlock");
async function Xue(t, e, r) {
  const n = bM(e, r, !1);
  if (n.type === "group")
    return;
  const i = mr(), a = await Yue(t, n, { config: i }), s = a.node().getBBox(), o = r.getBlock(n.id);
  o.size = { width: s.width, height: s.height, x: 0, y: 0, node: a }, r.setBlock(o), a.remove();
}
w(Xue, "calculateBlockSize");
async function jue(t, e, r) {
  const n = bM(e, r, !0);
  if (r.getBlock(n.id).type !== "space") {
    const a = mr();
    await Yue(t, n, { config: a }), e.intersect = n?.intersect, Jot(n);
  }
}
w(jue, "insertBlockPositioned");
async function a5(t, e, r, n) {
  for (const i of e)
    await n(t, i, r), i.children && await a5(t, i.children, r, n);
}
w(a5, "performOperations");
async function Kue(t, e, r) {
  await a5(t, e, r, Xue);
}
w(Kue, "calculateBlockSizes");
async function Zue(t, e, r) {
  await a5(t, e, r, jue);
}
w(Zue, "insertBlocks");
async function Que(t, e, r, n, i) {
  const a = new ma({
    multigraph: !0,
    compound: !0
  });
  a.setGraph({
    rankdir: "TB",
    nodesep: 10,
    ranksep: 10,
    marginx: 8,
    marginy: 8
  });
  for (const s of r)
    s.size && a.setNode(s.id, {
      width: s.size.width,
      height: s.size.height,
      intersect: s.intersect
    });
  for (const s of e)
    if (s.start && s.end) {
      const o = n.getBlock(s.start), l = n.getBlock(s.end);
      if (o?.size && l?.size) {
        const u = o.size, h = l.size, f = [
          { x: u.x, y: u.y },
          { x: u.x + (h.x - u.x) / 2, y: u.y + (h.y - u.y) / 2 },
          { x: h.x, y: h.y }
        ];
        wot(
          t,
          { v: s.start, w: s.end, name: s.id },
          {
            ...s,
            arrowTypeEnd: s.arrowTypeEnd,
            arrowTypeStart: s.arrowTypeStart,
            points: f,
            classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
          },
          void 0,
          "block",
          a,
          i
        ), s.label && (await vot(t, {
          ...s,
          label: s.label,
          labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
          arrowTypeEnd: s.arrowTypeEnd,
          arrowTypeStart: s.arrowTypeStart,
          points: f,
          classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
        }), yot(
          { ...s, x: f[1].x, y: f[1].y },
          {
            originalPath: f
          }
        ));
      }
    }
}
w(Que, "insertEdges");
var elt = /* @__PURE__ */ w(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), tlt = /* @__PURE__ */ w(async function(t, e, r, n) {
  const { securityLevel: i, block: a } = mr(), s = n.db;
  let o;
  i === "sandbox" && (o = Qe("#i" + e));
  const l = Qe(i === "sandbox" ? o.nodes()[0].contentDocument.body : "body"), u = i === "sandbox" ? l.select(`[id="${e}"]`) : Qe(`[id="${e}"]`);
  fot(u, ["point", "circle", "cross"], n.type, e);
  const f = s.getBlocks(), d = s.getBlocksFlat(), p = s.getEdges(), g = u.insert("g").attr("class", "block");
  await Kue(g, f, s);
  const m = Fue(s);
  if (await Zue(g, f, s), await Que(g, p, d, s, e), m) {
    const v = m, y = Math.max(1, Math.round(0.125 * (v.width / v.height))), b = v.height + y + 10, x = v.width + 10, { useMaxWidth: T } = a;
    Qi(u, b, x, !!T), ae.debug("Here Bounds", m, v), u.attr(
      "viewBox",
      `${v.x - 5} ${v.y - 5} ${v.width + 10} ${v.height + 10}`
    );
  }
}, "draw"), rlt = {
  draw: tlt,
  getClasses: elt
}, nlt = {
  parser: Nst,
  db: Qst,
  renderer: rlt,
  styles: eot
};
const ilt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: nlt
}, Symbol.toStringTag, { value: "Module" }));
var T2 = { exports: {} }, E2 = { exports: {} }, S2 = { exports: {} }, alt = S2.exports, DY;
function slt() {
  return DY || (DY = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i();
    })(alt, function() {
      return (
        /******/
        (function(r) {
          var n = {};
          function i(a) {
            if (n[a])
              return n[a].exports;
            var s = n[a] = {
              /******/
              i: a,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return r[a].call(s.exports, s, s.exports, i), s.l = !0, s.exports;
          }
          return i.m = r, i.c = n, i.i = function(a) {
            return a;
          }, i.d = function(a, s, o) {
            i.o(a, s) || Object.defineProperty(a, s, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: o
              /******/
            });
          }, i.n = function(a) {
            var s = a && a.__esModule ? (
              /******/
              function() {
                return a.default;
              }
            ) : (
              /******/
              function() {
                return a;
              }
            );
            return i.d(s, "a", s), s;
          }, i.o = function(a, s) {
            return Object.prototype.hasOwnProperty.call(a, s);
          }, i.p = "", i(i.s = 28);
        })([
          /* 0 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.QUALITY = 1, a.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, a.DEFAULT_INCREMENTAL = !1, a.DEFAULT_ANIMATION_ON_LAYOUT = !0, a.DEFAULT_ANIMATION_DURING_LAYOUT = !1, a.DEFAULT_ANIMATION_PERIOD = 50, a.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, a.DEFAULT_GRAPH_MARGIN = 15, a.NODE_DIMENSIONS_INCLUDE_LABELS = !1, a.SIMPLE_NODE_SIZE = 40, a.SIMPLE_NODE_HALF_SIZE = a.SIMPLE_NODE_SIZE / 2, a.EMPTY_COMPOUND_NODE_SIZE = 40, a.MIN_EDGE_LENGTH = 1, a.WORLD_BOUNDARY = 1e6, a.INITIAL_WORLD_BOUNDARY = a.WORLD_BOUNDARY / 1e3, a.WORLD_CENTER_X = 1200, a.WORLD_CENTER_Y = 900, r.exports = a;
          }),
          /* 1 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(8), o = i(9);
            function l(h, f, d) {
              a.call(this, d), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = d, this.bendpoints = [], this.source = h, this.target = f;
            }
            l.prototype = Object.create(a.prototype);
            for (var u in a)
              l[u] = a[u];
            l.prototype.getSource = function() {
              return this.source;
            }, l.prototype.getTarget = function() {
              return this.target;
            }, l.prototype.isInterGraph = function() {
              return this.isInterGraph;
            }, l.prototype.getLength = function() {
              return this.length;
            }, l.prototype.isOverlapingSourceAndTarget = function() {
              return this.isOverlapingSourceAndTarget;
            }, l.prototype.getBendpoints = function() {
              return this.bendpoints;
            }, l.prototype.getLca = function() {
              return this.lca;
            }, l.prototype.getSourceInLca = function() {
              return this.sourceInLca;
            }, l.prototype.getTargetInLca = function() {
              return this.targetInLca;
            }, l.prototype.getOtherEnd = function(h) {
              if (this.source === h)
                return this.target;
              if (this.target === h)
                return this.source;
              throw "Node is not incident with this edge";
            }, l.prototype.getOtherEndInGraph = function(h, f) {
              for (var d = this.getOtherEnd(h), p = f.getGraphManager().getRoot(); ; ) {
                if (d.getOwner() == f)
                  return d;
                if (d.getOwner() == p)
                  break;
                d = d.getOwner().getParent();
              }
              return null;
            }, l.prototype.updateLength = function() {
              var h = new Array(4);
              this.isOverlapingSourceAndTarget = s.getIntersection(this.target.getRect(), this.source.getRect(), h), this.isOverlapingSourceAndTarget || (this.lengthX = h[0] - h[2], this.lengthY = h[1] - h[3], Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
            }, l.prototype.updateLengthSimple = function() {
              this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            }, r.exports = l;
          }),
          /* 2 */
          /***/
          (function(r, n, i) {
            function a(s) {
              this.vGraphObject = s;
            }
            r.exports = a;
          }),
          /* 3 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(13), l = i(0), u = i(16), h = i(5);
            function f(p, g, m, v) {
              m == null && v == null && (v = g), a.call(this, v), p.graphManager != null && (p = p.graphManager), this.estimatedSize = s.MIN_VALUE, this.inclusionTreeDepth = s.MAX_VALUE, this.vGraphObject = v, this.edges = [], this.graphManager = p, m != null && g != null ? this.rect = new o(g.x, g.y, m.width, m.height) : this.rect = new o();
            }
            f.prototype = Object.create(a.prototype);
            for (var d in a)
              f[d] = a[d];
            f.prototype.getEdges = function() {
              return this.edges;
            }, f.prototype.getChild = function() {
              return this.child;
            }, f.prototype.getOwner = function() {
              return this.owner;
            }, f.prototype.getWidth = function() {
              return this.rect.width;
            }, f.prototype.setWidth = function(p) {
              this.rect.width = p;
            }, f.prototype.getHeight = function() {
              return this.rect.height;
            }, f.prototype.setHeight = function(p) {
              this.rect.height = p;
            }, f.prototype.getCenterX = function() {
              return this.rect.x + this.rect.width / 2;
            }, f.prototype.getCenterY = function() {
              return this.rect.y + this.rect.height / 2;
            }, f.prototype.getCenter = function() {
              return new h(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            }, f.prototype.getLocation = function() {
              return new h(this.rect.x, this.rect.y);
            }, f.prototype.getRect = function() {
              return this.rect;
            }, f.prototype.getDiagonal = function() {
              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            }, f.prototype.getHalfTheDiagonal = function() {
              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            }, f.prototype.setRect = function(p, g) {
              this.rect.x = p.x, this.rect.y = p.y, this.rect.width = g.width, this.rect.height = g.height;
            }, f.prototype.setCenter = function(p, g) {
              this.rect.x = p - this.rect.width / 2, this.rect.y = g - this.rect.height / 2;
            }, f.prototype.setLocation = function(p, g) {
              this.rect.x = p, this.rect.y = g;
            }, f.prototype.moveBy = function(p, g) {
              this.rect.x += p, this.rect.y += g;
            }, f.prototype.getEdgeListToNode = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (v.target == p) {
                  if (v.source != m) throw "Incorrect edge source!";
                  g.push(v);
                }
              }), g;
            }, f.prototype.getEdgesBetween = function(p) {
              var g = [], m = this;
              return m.edges.forEach(function(v) {
                if (!(v.source == m || v.target == m)) throw "Incorrect edge source and/or target";
                (v.target == p || v.source == p) && g.push(v);
              }), g;
            }, f.prototype.getNeighborsList = function() {
              var p = /* @__PURE__ */ new Set(), g = this;
              return g.edges.forEach(function(m) {
                if (m.source == g)
                  p.add(m.target);
                else {
                  if (m.target != g)
                    throw "Incorrect incidency!";
                  p.add(m.source);
                }
              }), p;
            }, f.prototype.withChildren = function() {
              var p = /* @__PURE__ */ new Set(), g, m;
              if (p.add(this), this.child != null)
                for (var v = this.child.getNodes(), y = 0; y < v.length; y++)
                  g = v[y], m = g.withChildren(), m.forEach(function(b) {
                    p.add(b);
                  });
              return p;
            }, f.prototype.getNoOfChildren = function() {
              var p = 0, g;
              if (this.child == null)
                p = 1;
              else
                for (var m = this.child.getNodes(), v = 0; v < m.length; v++)
                  g = m[v], p += g.getNoOfChildren();
              return p == 0 && (p = 1), p;
            }, f.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, f.prototype.calcEstimatedSize = function() {
              return this.child == null ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
            }, f.prototype.scatter = function() {
              var p, g, m = -l.INITIAL_WORLD_BOUNDARY, v = l.INITIAL_WORLD_BOUNDARY;
              p = l.WORLD_CENTER_X + u.nextDouble() * (v - m) + m;
              var y = -l.INITIAL_WORLD_BOUNDARY, b = l.INITIAL_WORLD_BOUNDARY;
              g = l.WORLD_CENTER_Y + u.nextDouble() * (b - y) + y, this.rect.x = p, this.rect.y = g;
            }, f.prototype.updateBounds = function() {
              if (this.getChild() == null)
                throw "assert failed";
              if (this.getChild().getNodes().length != 0) {
                var p = this.getChild();
                if (p.updateBounds(!0), this.rect.x = p.getLeft(), this.rect.y = p.getTop(), this.setWidth(p.getRight() - p.getLeft()), this.setHeight(p.getBottom() - p.getTop()), l.NODE_DIMENSIONS_INCLUDE_LABELS) {
                  var g = p.getRight() - p.getLeft(), m = p.getBottom() - p.getTop();
                  this.labelWidth && (this.labelPosHorizontal == "left" ? (this.rect.x -= this.labelWidth, this.setWidth(g + this.labelWidth)) : this.labelPosHorizontal == "center" && this.labelWidth > g ? (this.rect.x -= (this.labelWidth - g) / 2, this.setWidth(this.labelWidth)) : this.labelPosHorizontal == "right" && this.setWidth(g + this.labelWidth)), this.labelHeight && (this.labelPosVertical == "top" ? (this.rect.y -= this.labelHeight, this.setHeight(m + this.labelHeight)) : this.labelPosVertical == "center" && this.labelHeight > m ? (this.rect.y -= (this.labelHeight - m) / 2, this.setHeight(this.labelHeight)) : this.labelPosVertical == "bottom" && this.setHeight(m + this.labelHeight));
                }
              }
            }, f.prototype.getInclusionTreeDepth = function() {
              if (this.inclusionTreeDepth == s.MAX_VALUE)
                throw "assert failed";
              return this.inclusionTreeDepth;
            }, f.prototype.transform = function(p) {
              var g = this.rect.x;
              g > l.WORLD_BOUNDARY ? g = l.WORLD_BOUNDARY : g < -l.WORLD_BOUNDARY && (g = -l.WORLD_BOUNDARY);
              var m = this.rect.y;
              m > l.WORLD_BOUNDARY ? m = l.WORLD_BOUNDARY : m < -l.WORLD_BOUNDARY && (m = -l.WORLD_BOUNDARY);
              var v = new h(g, m), y = p.inverseTransformPoint(v);
              this.setLocation(y.x, y.y);
            }, f.prototype.getLeft = function() {
              return this.rect.x;
            }, f.prototype.getRight = function() {
              return this.rect.x + this.rect.width;
            }, f.prototype.getTop = function() {
              return this.rect.y;
            }, f.prototype.getBottom = function() {
              return this.rect.y + this.rect.height;
            }, f.prototype.getParent = function() {
              return this.owner == null ? null : this.owner.getParent();
            }, r.exports = f;
          }),
          /* 4 */
          /***/
          (function(r, n, i) {
            var a = i(0);
            function s() {
            }
            for (var o in a)
              s[o] = a[o];
            s.MAX_ITERATIONS = 2500, s.DEFAULT_EDGE_LENGTH = 50, s.DEFAULT_SPRING_STRENGTH = 0.45, s.DEFAULT_REPULSION_STRENGTH = 4500, s.DEFAULT_GRAVITY_STRENGTH = 0.4, s.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, s.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, s.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, s.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, s.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, s.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3, s.COOLING_ADAPTATION_FACTOR = 0.33, s.ADAPTATION_LOWER_NODE_LIMIT = 1e3, s.ADAPTATION_UPPER_NODE_LIMIT = 5e3, s.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, s.MAX_NODE_DISPLACEMENT = s.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3, s.MIN_REPULSION_DIST = s.DEFAULT_EDGE_LENGTH / 10, s.CONVERGENCE_CHECK_PERIOD = 100, s.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1, s.MIN_EDGE_LENGTH = 1, s.GRID_CALCULATION_CHECK_PERIOD = 10, r.exports = s;
          }),
          /* 5 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              s == null && o == null ? (this.x = 0, this.y = 0) : (this.x = s, this.y = o);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getDifference = function(s) {
              return new DimensionD(this.x - s.x, this.y - s.y);
            }, a.prototype.getCopy = function() {
              return new a(this.x, this.y);
            }, a.prototype.translate = function(s) {
              return this.x += s.width, this.y += s.height, this;
            }, r.exports = a;
          }),
          /* 6 */
          /***/
          (function(r, n, i) {
            var a = i(2), s = i(10), o = i(0), l = i(7), u = i(3), h = i(1), f = i(13), d = i(12), p = i(11);
            function g(v, y, b) {
              a.call(this, b), this.estimatedSize = s.MIN_VALUE, this.margin = o.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = v, y != null && y instanceof l ? this.graphManager = y : y != null && y instanceof Layout && (this.graphManager = y.graphManager);
            }
            g.prototype = Object.create(a.prototype);
            for (var m in a)
              g[m] = a[m];
            g.prototype.getNodes = function() {
              return this.nodes;
            }, g.prototype.getEdges = function() {
              return this.edges;
            }, g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getParent = function() {
              return this.parent;
            }, g.prototype.getLeft = function() {
              return this.left;
            }, g.prototype.getRight = function() {
              return this.right;
            }, g.prototype.getTop = function() {
              return this.top;
            }, g.prototype.getBottom = function() {
              return this.bottom;
            }, g.prototype.isConnected = function() {
              return this.isConnected;
            }, g.prototype.add = function(v, y, b) {
              if (y == null && b == null) {
                var x = v;
                if (this.graphManager == null)
                  throw "Graph has no graph mgr!";
                if (this.getNodes().indexOf(x) > -1)
                  throw "Node already in graph!";
                return x.owner = this, this.getNodes().push(x), x;
              } else {
                var T = v;
                if (!(this.getNodes().indexOf(y) > -1 && this.getNodes().indexOf(b) > -1))
                  throw "Source or target not in graph!";
                if (!(y.owner == b.owner && y.owner == this))
                  throw "Both owners must be this graph!";
                return y.owner != b.owner ? null : (T.source = y, T.target = b, T.isInterGraph = !1, this.getEdges().push(T), y.edges.push(T), b != y && b.edges.push(T), T);
              }
            }, g.prototype.remove = function(v) {
              var y = v;
              if (v instanceof u) {
                if (y == null)
                  throw "Node is null!";
                if (!(y.owner != null && y.owner == this))
                  throw "Owner graph is invalid!";
                if (this.graphManager == null)
                  throw "Owner graph manager is invalid!";
                for (var b = y.edges.slice(), x, T = b.length, E = 0; E < T; E++)
                  x = b[E], x.isInterGraph ? this.graphManager.remove(x) : x.source.owner.remove(x);
                var A = this.nodes.indexOf(y);
                if (A == -1)
                  throw "Node not in owner node list!";
                this.nodes.splice(A, 1);
              } else if (v instanceof h) {
                var x = v;
                if (x == null)
                  throw "Edge is null!";
                if (!(x.source != null && x.target != null))
                  throw "Source and/or target is null!";
                if (!(x.source.owner != null && x.target.owner != null && x.source.owner == this && x.target.owner == this))
                  throw "Source and/or target owner is invalid!";
                var S = x.source.edges.indexOf(x), k = x.target.edges.indexOf(x);
                if (!(S > -1 && k > -1))
                  throw "Source and/or target doesn't know this edge!";
                x.source.edges.splice(S, 1), x.target != x.source && x.target.edges.splice(k, 1);
                var A = x.source.owner.getEdges().indexOf(x);
                if (A == -1)
                  throw "Not in owner's edge list!";
                x.source.owner.getEdges().splice(A, 1);
              }
            }, g.prototype.updateLeftTop = function() {
              for (var v = s.MAX_VALUE, y = s.MAX_VALUE, b, x, T, E = this.getNodes(), A = E.length, S = 0; S < A; S++) {
                var k = E[S];
                b = k.getTop(), x = k.getLeft(), v > b && (v = b), y > x && (y = x);
              }
              return v == s.MAX_VALUE ? null : (E[0].getParent().paddingLeft != null ? T = E[0].getParent().paddingLeft : T = this.margin, this.left = y - T, this.top = v - T, new d(this.left, this.top));
            }, g.prototype.updateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, x = s.MAX_VALUE, T = -s.MAX_VALUE, E, A, S, k, _, R = this.nodes, L = R.length, M = 0; M < L; M++) {
                var P = R[M];
                v && P.child != null && P.updateBounds(), E = P.getLeft(), A = P.getRight(), S = P.getTop(), k = P.getBottom(), y > E && (y = E), b < A && (b = A), x > S && (x = S), T < k && (T = k);
              }
              var C = new f(y, x, b - y, T - x);
              y == s.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), R[0].getParent().paddingLeft != null ? _ = R[0].getParent().paddingLeft : _ = this.margin, this.left = C.x - _, this.right = C.x + C.width + _, this.top = C.y - _, this.bottom = C.y + C.height + _;
            }, g.calculateBounds = function(v) {
              for (var y = s.MAX_VALUE, b = -s.MAX_VALUE, x = s.MAX_VALUE, T = -s.MAX_VALUE, E, A, S, k, _ = v.length, R = 0; R < _; R++) {
                var L = v[R];
                E = L.getLeft(), A = L.getRight(), S = L.getTop(), k = L.getBottom(), y > E && (y = E), b < A && (b = A), x > S && (x = S), T < k && (T = k);
              }
              var M = new f(y, x, b - y, T - x);
              return M;
            }, g.prototype.getInclusionTreeDepth = function() {
              return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
            }, g.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, g.prototype.calcEstimatedSize = function() {
              for (var v = 0, y = this.nodes, b = y.length, x = 0; x < b; x++) {
                var T = y[x];
                v += T.calcEstimatedSize();
              }
              return v == 0 ? this.estimatedSize = o.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = v / Math.sqrt(this.nodes.length), this.estimatedSize;
            }, g.prototype.updateConnected = function() {
              var v = this;
              if (this.nodes.length == 0) {
                this.isConnected = !0;
                return;
              }
              var y = new p(), b = /* @__PURE__ */ new Set(), x = this.nodes[0], T, E, A = x.withChildren();
              for (A.forEach(function(M) {
                y.push(M), b.add(M);
              }); y.length !== 0; ) {
                x = y.shift(), T = x.getEdges();
                for (var S = T.length, k = 0; k < S; k++) {
                  var _ = T[k];
                  if (E = _.getOtherEndInGraph(x, this), E != null && !b.has(E)) {
                    var R = E.withChildren();
                    R.forEach(function(M) {
                      y.push(M), b.add(M);
                    });
                  }
                }
              }
              if (this.isConnected = !1, b.size >= this.nodes.length) {
                var L = 0;
                b.forEach(function(M) {
                  M.owner == v && L++;
                }), L == this.nodes.length && (this.isConnected = !0);
              }
            }, r.exports = g;
          }),
          /* 7 */
          /***/
          (function(r, n, i) {
            var a, s = i(1);
            function o(l) {
              a = i(6), this.layout = l, this.graphs = [], this.edges = [];
            }
            o.prototype.addRoot = function() {
              var l = this.layout.newGraph(), u = this.layout.newNode(null), h = this.add(l, u);
              return this.setRootGraph(h), this.rootGraph;
            }, o.prototype.add = function(l, u, h, f, d) {
              if (h == null && f == null && d == null) {
                if (l == null)
                  throw "Graph is null!";
                if (u == null)
                  throw "Parent node is null!";
                if (this.graphs.indexOf(l) > -1)
                  throw "Graph already in this graph mgr!";
                if (this.graphs.push(l), l.parent != null)
                  throw "Already has a parent!";
                if (u.child != null)
                  throw "Already has a child!";
                return l.parent = u, u.child = l, l;
              } else {
                d = h, f = u, h = l;
                var p = f.getOwner(), g = d.getOwner();
                if (!(p != null && p.getGraphManager() == this))
                  throw "Source not in this graph mgr!";
                if (!(g != null && g.getGraphManager() == this))
                  throw "Target not in this graph mgr!";
                if (p == g)
                  return h.isInterGraph = !1, p.add(h, f, d);
                if (h.isInterGraph = !0, h.source = f, h.target = d, this.edges.indexOf(h) > -1)
                  throw "Edge already in inter-graph edge list!";
                if (this.edges.push(h), !(h.source != null && h.target != null))
                  throw "Edge source and/or target is null!";
                if (!(h.source.edges.indexOf(h) == -1 && h.target.edges.indexOf(h) == -1))
                  throw "Edge already in source and/or target incidency list!";
                return h.source.edges.push(h), h.target.edges.push(h), h;
              }
            }, o.prototype.remove = function(l) {
              if (l instanceof a) {
                var u = l;
                if (u.getGraphManager() != this)
                  throw "Graph not in this graph mgr";
                if (!(u == this.rootGraph || u.parent != null && u.parent.graphManager == this))
                  throw "Invalid parent node!";
                var h = [];
                h = h.concat(u.getEdges());
                for (var f, d = h.length, p = 0; p < d; p++)
                  f = h[p], u.remove(f);
                var g = [];
                g = g.concat(u.getNodes());
                var m;
                d = g.length;
                for (var p = 0; p < d; p++)
                  m = g[p], u.remove(m);
                u == this.rootGraph && this.setRootGraph(null);
                var v = this.graphs.indexOf(u);
                this.graphs.splice(v, 1), u.parent = null;
              } else if (l instanceof s) {
                if (f = l, f == null)
                  throw "Edge is null!";
                if (!f.isInterGraph)
                  throw "Not an inter-graph edge!";
                if (!(f.source != null && f.target != null))
                  throw "Source and/or target is null!";
                if (!(f.source.edges.indexOf(f) != -1 && f.target.edges.indexOf(f) != -1))
                  throw "Source and/or target doesn't know this edge!";
                var v = f.source.edges.indexOf(f);
                if (f.source.edges.splice(v, 1), v = f.target.edges.indexOf(f), f.target.edges.splice(v, 1), !(f.source.owner != null && f.source.owner.getGraphManager() != null))
                  throw "Edge owner graph or owner graph manager is null!";
                if (f.source.owner.getGraphManager().edges.indexOf(f) == -1)
                  throw "Not in owner graph manager's edge list!";
                var v = f.source.owner.getGraphManager().edges.indexOf(f);
                f.source.owner.getGraphManager().edges.splice(v, 1);
              }
            }, o.prototype.updateBounds = function() {
              this.rootGraph.updateBounds(!0);
            }, o.prototype.getGraphs = function() {
              return this.graphs;
            }, o.prototype.getAllNodes = function() {
              if (this.allNodes == null) {
                for (var l = [], u = this.getGraphs(), h = u.length, f = 0; f < h; f++)
                  l = l.concat(u[f].getNodes());
                this.allNodes = l;
              }
              return this.allNodes;
            }, o.prototype.resetAllNodes = function() {
              this.allNodes = null;
            }, o.prototype.resetAllEdges = function() {
              this.allEdges = null;
            }, o.prototype.resetAllNodesToApplyGravitation = function() {
              this.allNodesToApplyGravitation = null;
            }, o.prototype.getAllEdges = function() {
              if (this.allEdges == null) {
                var l = [], u = this.getGraphs();
                u.length;
                for (var h = 0; h < u.length; h++)
                  l = l.concat(u[h].getEdges());
                l = l.concat(this.edges), this.allEdges = l;
              }
              return this.allEdges;
            }, o.prototype.getAllNodesToApplyGravitation = function() {
              return this.allNodesToApplyGravitation;
            }, o.prototype.setAllNodesToApplyGravitation = function(l) {
              if (this.allNodesToApplyGravitation != null)
                throw "assert failed";
              this.allNodesToApplyGravitation = l;
            }, o.prototype.getRoot = function() {
              return this.rootGraph;
            }, o.prototype.setRootGraph = function(l) {
              if (l.getGraphManager() != this)
                throw "Root not in this graph mgr!";
              this.rootGraph = l, l.parent == null && (l.parent = this.layout.newNode("Root node"));
            }, o.prototype.getLayout = function() {
              return this.layout;
            }, o.prototype.isOneAncestorOfOther = function(l, u) {
              if (!(l != null && u != null))
                throw "assert failed";
              if (l == u)
                return !0;
              var h = l.getOwner(), f;
              do {
                if (f = h.getParent(), f == null)
                  break;
                if (f == u)
                  return !0;
                if (h = f.getOwner(), h == null)
                  break;
              } while (!0);
              h = u.getOwner();
              do {
                if (f = h.getParent(), f == null)
                  break;
                if (f == l)
                  return !0;
                if (h = f.getOwner(), h == null)
                  break;
              } while (!0);
              return !1;
            }, o.prototype.calcLowestCommonAncestors = function() {
              for (var l, u, h, f, d, p = this.getAllEdges(), g = p.length, m = 0; m < g; m++) {
                if (l = p[m], u = l.source, h = l.target, l.lca = null, l.sourceInLca = u, l.targetInLca = h, u == h) {
                  l.lca = u.getOwner();
                  continue;
                }
                for (f = u.getOwner(); l.lca == null; ) {
                  for (l.targetInLca = h, d = h.getOwner(); l.lca == null; ) {
                    if (d == f) {
                      l.lca = d;
                      break;
                    }
                    if (d == this.rootGraph)
                      break;
                    if (l.lca != null)
                      throw "assert failed";
                    l.targetInLca = d.getParent(), d = l.targetInLca.getOwner();
                  }
                  if (f == this.rootGraph)
                    break;
                  l.lca == null && (l.sourceInLca = f.getParent(), f = l.sourceInLca.getOwner());
                }
                if (l.lca == null)
                  throw "assert failed";
              }
            }, o.prototype.calcLowestCommonAncestor = function(l, u) {
              if (l == u)
                return l.getOwner();
              var h = l.getOwner();
              do {
                if (h == null)
                  break;
                var f = u.getOwner();
                do {
                  if (f == null)
                    break;
                  if (f == h)
                    return f;
                  f = f.getParent().getOwner();
                } while (!0);
                h = h.getParent().getOwner();
              } while (!0);
              return h;
            }, o.prototype.calcInclusionTreeDepths = function(l, u) {
              l == null && u == null && (l = this.rootGraph, u = 1);
              for (var h, f = l.getNodes(), d = f.length, p = 0; p < d; p++)
                h = f[p], h.inclusionTreeDepth = u, h.child != null && this.calcInclusionTreeDepths(h.child, u + 1);
            }, o.prototype.includesInvalidEdge = function() {
              for (var l, u = [], h = this.edges.length, f = 0; f < h; f++)
                l = this.edges[f], this.isOneAncestorOfOther(l.source, l.target) && u.push(l);
              for (var f = 0; f < u.length; f++)
                this.remove(u[f]);
              return !1;
            }, r.exports = o;
          }),
          /* 8 */
          /***/
          (function(r, n, i) {
            var a = i(12);
            function s() {
            }
            s.calcSeparationAmount = function(o, l, u, h) {
              if (!o.intersects(l))
                throw "assert failed";
              var f = new Array(2);
              this.decideDirectionsForOverlappingNodes(o, l, f), u[0] = Math.min(o.getRight(), l.getRight()) - Math.max(o.x, l.x), u[1] = Math.min(o.getBottom(), l.getBottom()) - Math.max(o.y, l.y), o.getX() <= l.getX() && o.getRight() >= l.getRight() ? u[0] += Math.min(l.getX() - o.getX(), o.getRight() - l.getRight()) : l.getX() <= o.getX() && l.getRight() >= o.getRight() && (u[0] += Math.min(o.getX() - l.getX(), l.getRight() - o.getRight())), o.getY() <= l.getY() && o.getBottom() >= l.getBottom() ? u[1] += Math.min(l.getY() - o.getY(), o.getBottom() - l.getBottom()) : l.getY() <= o.getY() && l.getBottom() >= o.getBottom() && (u[1] += Math.min(o.getY() - l.getY(), l.getBottom() - o.getBottom()));
              var d = Math.abs((l.getCenterY() - o.getCenterY()) / (l.getCenterX() - o.getCenterX()));
              l.getCenterY() === o.getCenterY() && l.getCenterX() === o.getCenterX() && (d = 1);
              var p = d * u[0], g = u[1] / d;
              u[0] < g ? g = u[0] : p = u[1], u[0] = -1 * f[0] * (g / 2 + h), u[1] = -1 * f[1] * (p / 2 + h);
            }, s.decideDirectionsForOverlappingNodes = function(o, l, u) {
              o.getCenterX() < l.getCenterX() ? u[0] = -1 : u[0] = 1, o.getCenterY() < l.getCenterY() ? u[1] = -1 : u[1] = 1;
            }, s.getIntersection2 = function(o, l, u) {
              var h = o.getCenterX(), f = o.getCenterY(), d = l.getCenterX(), p = l.getCenterY();
              if (o.intersects(l))
                return u[0] = h, u[1] = f, u[2] = d, u[3] = p, !0;
              var g = o.getX(), m = o.getY(), v = o.getRight(), y = o.getX(), b = o.getBottom(), x = o.getRight(), T = o.getWidthHalf(), E = o.getHeightHalf(), A = l.getX(), S = l.getY(), k = l.getRight(), _ = l.getX(), R = l.getBottom(), L = l.getRight(), M = l.getWidthHalf(), P = l.getHeightHalf(), C = !1, I = !1;
              if (h === d) {
                if (f > p)
                  return u[0] = h, u[1] = m, u[2] = d, u[3] = R, !1;
                if (f < p)
                  return u[0] = h, u[1] = b, u[2] = d, u[3] = S, !1;
              } else if (f === p) {
                if (h > d)
                  return u[0] = g, u[1] = f, u[2] = k, u[3] = p, !1;
                if (h < d)
                  return u[0] = v, u[1] = f, u[2] = A, u[3] = p, !1;
              } else {
                var N = o.height / o.width, O = l.height / l.width, D = (p - f) / (d - h), $ = void 0, z = void 0, B = void 0, G = void 0, W = void 0, V = void 0;
                if (-N === D ? h > d ? (u[0] = y, u[1] = b, C = !0) : (u[0] = v, u[1] = m, C = !0) : N === D && (h > d ? (u[0] = g, u[1] = m, C = !0) : (u[0] = x, u[1] = b, C = !0)), -O === D ? d > h ? (u[2] = _, u[3] = R, I = !0) : (u[2] = k, u[3] = S, I = !0) : O === D && (d > h ? (u[2] = A, u[3] = S, I = !0) : (u[2] = L, u[3] = R, I = !0)), C && I)
                  return !1;
                if (h > d ? f > p ? ($ = this.getCardinalDirection(N, D, 4), z = this.getCardinalDirection(O, D, 2)) : ($ = this.getCardinalDirection(-N, D, 3), z = this.getCardinalDirection(-O, D, 1)) : f > p ? ($ = this.getCardinalDirection(-N, D, 1), z = this.getCardinalDirection(-O, D, 3)) : ($ = this.getCardinalDirection(N, D, 2), z = this.getCardinalDirection(O, D, 4)), !C)
                  switch ($) {
                    case 1:
                      G = m, B = h + -E / D, u[0] = B, u[1] = G;
                      break;
                    case 2:
                      B = x, G = f + T * D, u[0] = B, u[1] = G;
                      break;
                    case 3:
                      G = b, B = h + E / D, u[0] = B, u[1] = G;
                      break;
                    case 4:
                      B = y, G = f + -T * D, u[0] = B, u[1] = G;
                      break;
                  }
                if (!I)
                  switch (z) {
                    case 1:
                      V = S, W = d + -P / D, u[2] = W, u[3] = V;
                      break;
                    case 2:
                      W = L, V = p + M * D, u[2] = W, u[3] = V;
                      break;
                    case 3:
                      V = R, W = d + P / D, u[2] = W, u[3] = V;
                      break;
                    case 4:
                      W = _, V = p + -M * D, u[2] = W, u[3] = V;
                      break;
                  }
              }
              return !1;
            }, s.getCardinalDirection = function(o, l, u) {
              return o > l ? u : 1 + u % 4;
            }, s.getIntersection = function(o, l, u, h) {
              if (h == null)
                return this.getIntersection2(o, l, u);
              var f = o.x, d = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, x = void 0, T = void 0, E = void 0, A = void 0, S = void 0, k = void 0, _ = void 0, R = void 0, L = void 0;
              return E = g - d, S = f - p, _ = p * d - f * g, A = b - v, k = m - y, R = y * v - m * b, L = E * k - A * S, L === 0 ? null : (x = (S * R - k * _) / L, T = (A * _ - E * R) / L, new a(x, T));
            }, s.angleOfVector = function(o, l, u, h) {
              var f = void 0;
              return o !== u ? (f = Math.atan((h - l) / (u - o)), u < o ? f += Math.PI : h < l && (f += this.TWO_PI)) : h < l ? f = this.ONE_AND_HALF_PI : f = this.HALF_PI, f;
            }, s.doIntersect = function(o, l, u, h) {
              var f = o.x, d = o.y, p = l.x, g = l.y, m = u.x, v = u.y, y = h.x, b = h.y, x = (p - f) * (b - v) - (y - m) * (g - d);
              if (x === 0)
                return !1;
              var T = ((b - v) * (y - f) + (m - y) * (b - d)) / x, E = ((d - g) * (y - f) + (p - f) * (b - d)) / x;
              return 0 < T && T < 1 && 0 < E && E < 1;
            }, s.findCircleLineIntersections = function(o, l, u, h, f, d, p) {
              var g = (u - o) * (u - o) + (h - l) * (h - l), m = 2 * ((o - f) * (u - o) + (l - d) * (h - l)), v = (o - f) * (o - f) + (l - d) * (l - d) - p * p, y = m * m - 4 * g * v;
              if (y >= 0) {
                var b = (-m + Math.sqrt(m * m - 4 * g * v)) / (2 * g), x = (-m - Math.sqrt(m * m - 4 * g * v)) / (2 * g), T = null;
                return b >= 0 && b <= 1 ? [b] : x >= 0 && x <= 1 ? [x] : T;
              } else return null;
            }, s.HALF_PI = 0.5 * Math.PI, s.ONE_AND_HALF_PI = 1.5 * Math.PI, s.TWO_PI = 2 * Math.PI, s.THREE_PI = 3 * Math.PI, r.exports = s;
          }),
          /* 9 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.sign = function(s) {
              return s > 0 ? 1 : s < 0 ? -1 : 0;
            }, a.floor = function(s) {
              return s < 0 ? Math.ceil(s) : Math.floor(s);
            }, a.ceil = function(s) {
              return s < 0 ? Math.floor(s) : Math.ceil(s);
            }, r.exports = a;
          }),
          /* 10 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.MAX_VALUE = 2147483647, a.MIN_VALUE = -2147483648, r.exports = a;
          }),
          /* 11 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function f(d, p) {
                for (var g = 0; g < p.length; g++) {
                  var m = p[g];
                  m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(d, m.key, m);
                }
              }
              return function(d, p, g) {
                return p && f(d.prototype, p), g && f(d, g), d;
              };
            })();
            function s(f, d) {
              if (!(f instanceof d))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function(d) {
              return { value: d, next: null, prev: null };
            }, l = function(d, p, g, m) {
              return d !== null ? d.next = p : m.head = p, g !== null ? g.prev = p : m.tail = p, p.prev = d, p.next = g, m.length++, p;
            }, u = function(d, p) {
              var g = d.prev, m = d.next;
              return g !== null ? g.next = m : p.head = m, m !== null ? m.prev = g : p.tail = g, d.prev = d.next = null, p.length--, d;
            }, h = (function() {
              function f(d) {
                var p = this;
                s(this, f), this.length = 0, this.head = null, this.tail = null, d?.forEach(function(g) {
                  return p.push(g);
                });
              }
              return a(f, [{
                key: "size",
                value: function() {
                  return this.length;
                }
              }, {
                key: "insertBefore",
                value: function(p, g) {
                  return l(g.prev, o(p), g, this);
                }
              }, {
                key: "insertAfter",
                value: function(p, g) {
                  return l(g, o(p), g.next, this);
                }
              }, {
                key: "insertNodeBefore",
                value: function(p, g) {
                  return l(g.prev, p, g, this);
                }
              }, {
                key: "insertNodeAfter",
                value: function(p, g) {
                  return l(g, p, g.next, this);
                }
              }, {
                key: "push",
                value: function(p) {
                  return l(this.tail, o(p), null, this);
                }
              }, {
                key: "unshift",
                value: function(p) {
                  return l(null, o(p), this.head, this);
                }
              }, {
                key: "remove",
                value: function(p) {
                  return u(p, this);
                }
              }, {
                key: "pop",
                value: function() {
                  return u(this.tail, this).value;
                }
              }, {
                key: "popNode",
                value: function() {
                  return u(this.tail, this);
                }
              }, {
                key: "shift",
                value: function() {
                  return u(this.head, this).value;
                }
              }, {
                key: "shiftNode",
                value: function() {
                  return u(this.head, this);
                }
              }, {
                key: "get_object_at",
                value: function(p) {
                  if (p <= this.length()) {
                    for (var g = 1, m = this.head; g < p; )
                      m = m.next, g++;
                    return m.value;
                  }
                }
              }, {
                key: "set_object_at",
                value: function(p, g) {
                  if (p <= this.length()) {
                    for (var m = 1, v = this.head; m < p; )
                      v = v.next, m++;
                    v.value = g;
                  }
                }
              }]), f;
            })();
            r.exports = h;
          }),
          /* 12 */
          /***/
          (function(r, n, i) {
            function a(s, o, l) {
              this.x = null, this.y = null, s == null && o == null && l == null ? (this.x = 0, this.y = 0) : typeof s == "number" && typeof o == "number" && l == null ? (this.x = s, this.y = o) : s.constructor.name == "Point" && o == null && l == null && (l = s, this.x = l.x, this.y = l.y);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.getLocation = function() {
              return new a(this.x, this.y);
            }, a.prototype.setLocation = function(s, o, l) {
              s.constructor.name == "Point" && o == null && l == null ? (l = s, this.setLocation(l.x, l.y)) : typeof s == "number" && typeof o == "number" && l == null && (parseInt(s) == s && parseInt(o) == o ? this.move(s, o) : (this.x = Math.floor(s + 0.5), this.y = Math.floor(o + 0.5)));
            }, a.prototype.move = function(s, o) {
              this.x = s, this.y = o;
            }, a.prototype.translate = function(s, o) {
              this.x += s, this.y += o;
            }, a.prototype.equals = function(s) {
              if (s.constructor.name == "Point") {
                var o = s;
                return this.x == o.x && this.y == o.y;
              }
              return this == s;
            }, a.prototype.toString = function() {
              return new a().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            }, r.exports = a;
          }),
          /* 13 */
          /***/
          (function(r, n, i) {
            function a(s, o, l, u) {
              this.x = 0, this.y = 0, this.width = 0, this.height = 0, s != null && o != null && l != null && u != null && (this.x = s, this.y = o, this.width = l, this.height = u);
            }
            a.prototype.getX = function() {
              return this.x;
            }, a.prototype.setX = function(s) {
              this.x = s;
            }, a.prototype.getY = function() {
              return this.y;
            }, a.prototype.setY = function(s) {
              this.y = s;
            }, a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, a.prototype.getRight = function() {
              return this.x + this.width;
            }, a.prototype.getBottom = function() {
              return this.y + this.height;
            }, a.prototype.intersects = function(s) {
              return !(this.getRight() < s.x || this.getBottom() < s.y || s.getRight() < this.x || s.getBottom() < this.y);
            }, a.prototype.getCenterX = function() {
              return this.x + this.width / 2;
            }, a.prototype.getMinX = function() {
              return this.getX();
            }, a.prototype.getMaxX = function() {
              return this.getX() + this.width;
            }, a.prototype.getCenterY = function() {
              return this.y + this.height / 2;
            }, a.prototype.getMinY = function() {
              return this.getY();
            }, a.prototype.getMaxY = function() {
              return this.getY() + this.height;
            }, a.prototype.getWidthHalf = function() {
              return this.width / 2;
            }, a.prototype.getHeightHalf = function() {
              return this.height / 2;
            }, r.exports = a;
          }),
          /* 14 */
          /***/
          (function(r, n, i) {
            var a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
              return typeof o;
            } : function(o) {
              return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            };
            function s() {
            }
            s.lastID = 0, s.createID = function(o) {
              return s.isPrimitive(o) ? o : (o.uniqueID != null || (o.uniqueID = s.getString(), s.lastID++), o.uniqueID);
            }, s.getString = function(o) {
              return o == null && (o = s.lastID), "Object#" + o;
            }, s.isPrimitive = function(o) {
              var l = typeof o > "u" ? "undefined" : a(o);
              return o == null || l != "object" && l != "function";
            }, r.exports = s;
          }),
          /* 15 */
          /***/
          (function(r, n, i) {
            function a(m) {
              if (Array.isArray(m)) {
                for (var v = 0, y = Array(m.length); v < m.length; v++)
                  y[v] = m[v];
                return y;
              } else
                return Array.from(m);
            }
            var s = i(0), o = i(7), l = i(3), u = i(1), h = i(6), f = i(5), d = i(17), p = i(29);
            function g(m) {
              p.call(this), this.layoutQuality = s.QUALITY, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = s.DEFAULT_INCREMENTAL, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new o(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, m != null && (this.isRemoteUse = m);
            }
            g.RANDOM_SEED = 1, g.prototype = Object.create(p.prototype), g.prototype.getGraphManager = function() {
              return this.graphManager;
            }, g.prototype.getAllNodes = function() {
              return this.graphManager.getAllNodes();
            }, g.prototype.getAllEdges = function() {
              return this.graphManager.getAllEdges();
            }, g.prototype.getAllNodesToApplyGravitation = function() {
              return this.graphManager.getAllNodesToApplyGravitation();
            }, g.prototype.newGraphManager = function() {
              var m = new o(this);
              return this.graphManager = m, m;
            }, g.prototype.newGraph = function(m) {
              return new h(null, this.graphManager, m);
            }, g.prototype.newNode = function(m) {
              return new l(this.graphManager, m);
            }, g.prototype.newEdge = function(m) {
              return new u(null, null, m);
            }, g.prototype.checkLayoutSuccess = function() {
              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            }, g.prototype.runLayout = function() {
              this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters();
              var m;
              return this.checkLayoutSuccess() ? m = !1 : m = this.layout(), s.ANIMATE === "during" ? !1 : (m && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, m);
            }, g.prototype.doPostLayout = function() {
              this.incremental || this.transform(), this.update();
            }, g.prototype.update2 = function() {
              if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
                for (var m = this.graphManager.getAllEdges(), v = 0; v < m.length; v++)
                  m[v];
                for (var y = this.graphManager.getRoot().getNodes(), v = 0; v < y.length; v++)
                  y[v];
                this.update(this.graphManager.getRoot());
              }
            }, g.prototype.update = function(m) {
              if (m == null)
                this.update2();
              else if (m instanceof l) {
                var v = m;
                if (v.getChild() != null)
                  for (var y = v.getChild().getNodes(), b = 0; b < y.length; b++)
                    update(y[b]);
                if (v.vGraphObject != null) {
                  var x = v.vGraphObject;
                  x.update(v);
                }
              } else if (m instanceof u) {
                var T = m;
                if (T.vGraphObject != null) {
                  var E = T.vGraphObject;
                  E.update(T);
                }
              } else if (m instanceof h) {
                var A = m;
                if (A.vGraphObject != null) {
                  var S = A.vGraphObject;
                  S.update(A);
                }
              }
            }, g.prototype.initParameters = function() {
              this.isSubLayout || (this.layoutQuality = s.QUALITY, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = s.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
            }, g.prototype.transform = function(m) {
              if (m == null)
                this.transform(new f(0, 0));
              else {
                var v = new d(), y = this.graphManager.getRoot().updateLeftTop();
                if (y != null) {
                  v.setWorldOrgX(m.x), v.setWorldOrgY(m.y), v.setDeviceOrgX(y.x), v.setDeviceOrgY(y.y);
                  for (var b = this.getAllNodes(), x, T = 0; T < b.length; T++)
                    x = b[T], x.transform(v);
                }
              }
            }, g.prototype.positionNodesRandomly = function(m) {
              if (m == null)
                this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
              else
                for (var v, y, b = m.getNodes(), x = 0; x < b.length; x++)
                  v = b[x], y = v.getChild(), y == null || y.getNodes().length == 0 ? v.scatter() : (this.positionNodesRandomly(y), v.updateBounds());
            }, g.prototype.getFlatForest = function() {
              for (var m = [], v = !0, y = this.graphManager.getRoot().getNodes(), b = !0, x = 0; x < y.length; x++)
                y[x].getChild() != null && (b = !1);
              if (!b)
                return m;
              var T = /* @__PURE__ */ new Set(), E = [], A = /* @__PURE__ */ new Map(), S = [];
              for (S = S.concat(y); S.length > 0 && v; ) {
                for (E.push(S[0]); E.length > 0 && v; ) {
                  var k = E[0];
                  E.splice(0, 1), T.add(k);
                  for (var _ = k.getEdges(), x = 0; x < _.length; x++) {
                    var R = _[x].getOtherEnd(k);
                    if (A.get(k) != R)
                      if (!T.has(R))
                        E.push(R), A.set(R, k);
                      else {
                        v = !1;
                        break;
                      }
                  }
                }
                if (!v)
                  m = [];
                else {
                  var L = [].concat(a(T));
                  m.push(L);
                  for (var x = 0; x < L.length; x++) {
                    var M = L[x], P = S.indexOf(M);
                    P > -1 && S.splice(P, 1);
                  }
                  T = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ new Map();
                }
              }
              return m;
            }, g.prototype.createDummyNodesForBendpoints = function(m) {
              for (var v = [], y = m.source, b = this.graphManager.calcLowestCommonAncestor(m.source, m.target), x = 0; x < m.bendpoints.length; x++) {
                var T = this.newNode(null);
                T.setRect(new Point(0, 0), new Dimension(1, 1)), b.add(T);
                var E = this.newEdge(null);
                this.graphManager.add(E, y, T), v.add(T), y = T;
              }
              var E = this.newEdge(null);
              return this.graphManager.add(E, y, m.target), this.edgeToDummyNodes.set(m, v), m.isInterGraph() ? this.graphManager.remove(m) : b.remove(m), v;
            }, g.prototype.createBendpointsFromDummyNodes = function() {
              var m = [];
              m = m.concat(this.graphManager.getAllEdges()), m = [].concat(a(this.edgeToDummyNodes.keys())).concat(m);
              for (var v = 0; v < m.length; v++) {
                var y = m[v];
                if (y.bendpoints.length > 0) {
                  for (var b = this.edgeToDummyNodes.get(y), x = 0; x < b.length; x++) {
                    var T = b[x], E = new f(T.getCenterX(), T.getCenterY()), A = y.bendpoints.get(x);
                    A.x = E.x, A.y = E.y, T.getOwner().remove(T);
                  }
                  this.graphManager.add(y, y.source, y.target);
                }
              }
            }, g.transform = function(m, v, y, b) {
              if (y != null && b != null) {
                var x = v;
                if (m <= 50) {
                  var T = v / y;
                  x -= (v - T) / 50 * (50 - m);
                } else {
                  var E = v * b;
                  x += (E - v) / 50 * (m - 50);
                }
                return x;
              } else {
                var A, S;
                return m <= 50 ? (A = 9 * v / 500, S = v / 10) : (A = 9 * v / 50, S = -8 * v), A * m + S;
              }
            }, g.findCenterOfTree = function(m) {
              var v = [];
              v = v.concat(m);
              var y = [], b = /* @__PURE__ */ new Map(), x = !1, T = null;
              (v.length == 1 || v.length == 2) && (x = !0, T = v[0]);
              for (var E = 0; E < v.length; E++) {
                var A = v[E], S = A.getNeighborsList().size;
                b.set(A, A.getNeighborsList().size), S == 1 && y.push(A);
              }
              var k = [];
              for (k = k.concat(y); !x; ) {
                var _ = [];
                _ = _.concat(k), k = [];
                for (var E = 0; E < v.length; E++) {
                  var A = v[E], R = v.indexOf(A);
                  R >= 0 && v.splice(R, 1);
                  var L = A.getNeighborsList();
                  L.forEach(function(C) {
                    if (y.indexOf(C) < 0) {
                      var I = b.get(C), N = I - 1;
                      N == 1 && k.push(C), b.set(C, N);
                    }
                  });
                }
                y = y.concat(k), (v.length == 1 || v.length == 2) && (x = !0, T = v[0]);
              }
              return T;
            }, g.prototype.setGraphManager = function(m) {
              this.graphManager = m;
            }, r.exports = g;
          }),
          /* 16 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.seed = 1, a.x = 0, a.nextDouble = function() {
              return a.x = Math.sin(a.seed++) * 1e4, a.x - Math.floor(a.x);
            }, r.exports = a;
          }),
          /* 17 */
          /***/
          (function(r, n, i) {
            var a = i(5);
            function s(o, l) {
              this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
            }
            s.prototype.getWorldOrgX = function() {
              return this.lworldOrgX;
            }, s.prototype.setWorldOrgX = function(o) {
              this.lworldOrgX = o;
            }, s.prototype.getWorldOrgY = function() {
              return this.lworldOrgY;
            }, s.prototype.setWorldOrgY = function(o) {
              this.lworldOrgY = o;
            }, s.prototype.getWorldExtX = function() {
              return this.lworldExtX;
            }, s.prototype.setWorldExtX = function(o) {
              this.lworldExtX = o;
            }, s.prototype.getWorldExtY = function() {
              return this.lworldExtY;
            }, s.prototype.setWorldExtY = function(o) {
              this.lworldExtY = o;
            }, s.prototype.getDeviceOrgX = function() {
              return this.ldeviceOrgX;
            }, s.prototype.setDeviceOrgX = function(o) {
              this.ldeviceOrgX = o;
            }, s.prototype.getDeviceOrgY = function() {
              return this.ldeviceOrgY;
            }, s.prototype.setDeviceOrgY = function(o) {
              this.ldeviceOrgY = o;
            }, s.prototype.getDeviceExtX = function() {
              return this.ldeviceExtX;
            }, s.prototype.setDeviceExtX = function(o) {
              this.ldeviceExtX = o;
            }, s.prototype.getDeviceExtY = function() {
              return this.ldeviceExtY;
            }, s.prototype.setDeviceExtY = function(o) {
              this.ldeviceExtY = o;
            }, s.prototype.transformX = function(o) {
              var l = 0, u = this.lworldExtX;
              return u != 0 && (l = this.ldeviceOrgX + (o - this.lworldOrgX) * this.ldeviceExtX / u), l;
            }, s.prototype.transformY = function(o) {
              var l = 0, u = this.lworldExtY;
              return u != 0 && (l = this.ldeviceOrgY + (o - this.lworldOrgY) * this.ldeviceExtY / u), l;
            }, s.prototype.inverseTransformX = function(o) {
              var l = 0, u = this.ldeviceExtX;
              return u != 0 && (l = this.lworldOrgX + (o - this.ldeviceOrgX) * this.lworldExtX / u), l;
            }, s.prototype.inverseTransformY = function(o) {
              var l = 0, u = this.ldeviceExtY;
              return u != 0 && (l = this.lworldOrgY + (o - this.ldeviceOrgY) * this.lworldExtY / u), l;
            }, s.prototype.inverseTransformPoint = function(o) {
              var l = new a(this.inverseTransformX(o.x), this.inverseTransformY(o.y));
              return l;
            }, r.exports = s;
          }),
          /* 18 */
          /***/
          (function(r, n, i) {
            function a(p) {
              if (Array.isArray(p)) {
                for (var g = 0, m = Array(p.length); g < p.length; g++)
                  m[g] = p[g];
                return m;
              } else
                return Array.from(p);
            }
            var s = i(15), o = i(4), l = i(0), u = i(8), h = i(9);
            function f() {
              s.call(this), this.useSmartIdealEdgeLengthCalculation = o.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = o.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = o.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = o.MAX_ITERATIONS;
            }
            f.prototype = Object.create(s.prototype);
            for (var d in s)
              f[d] = s[d];
            f.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = o.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
            }, f.prototype.calcIdealEdgeLengths = function() {
              for (var p, g, m, v, y, b, x, T = this.getGraphManager().getAllEdges(), E = 0; E < T.length; E++)
                p = T[E], g = p.idealLength, p.isInterGraph && (v = p.getSource(), y = p.getTarget(), b = p.getSourceInLca().getEstimatedSize(), x = p.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (p.idealLength += b + x - 2 * l.SIMPLE_NODE_SIZE), m = p.getLca().getInclusionTreeDepth(), p.idealLength += g * o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (v.getInclusionTreeDepth() + y.getInclusionTreeDepth() - 2 * m));
            }, f.prototype.initSpringEmbedder = function() {
              var p = this.getAllNodes().length;
              this.incremental ? (p > o.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * o.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - o.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (p > o.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(o.COOLING_ADAPTATION_FACTOR, 1 - (p - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * (1 - o.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations), this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
            }, f.prototype.calcSpringForces = function() {
              for (var p = this.getAllEdges(), g, m = 0; m < p.length; m++)
                g = p[m], this.calcSpringForce(g, g.idealLength);
            }, f.prototype.calcRepulsionForces = function() {
              var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, m, v, y, b, x = this.getAllNodes(), T;
              if (this.useFRGridVariant)
                for (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && p && this.updateGrid(), T = /* @__PURE__ */ new Set(), m = 0; m < x.length; m++)
                  y = x[m], this.calculateRepulsionForceOfANode(y, T, p, g), T.add(y);
              else
                for (m = 0; m < x.length; m++)
                  for (y = x[m], v = m + 1; v < x.length; v++)
                    b = x[v], y.getOwner() == b.getOwner() && this.calcRepulsionForce(y, b);
            }, f.prototype.calcGravitationalForces = function() {
              for (var p, g = this.getAllNodesToApplyGravitation(), m = 0; m < g.length; m++)
                p = g[m], this.calcGravitationalForce(p);
            }, f.prototype.moveNodes = function() {
              for (var p = this.getAllNodes(), g, m = 0; m < p.length; m++)
                g = p[m], g.move();
            }, f.prototype.calcSpringForce = function(p, g) {
              var m = p.getSource(), v = p.getTarget(), y, b, x, T;
              if (this.uniformLeafNodeSizes && m.getChild() == null && v.getChild() == null)
                p.updateLengthSimple();
              else if (p.updateLength(), p.isOverlapingSourceAndTarget)
                return;
              y = p.getLength(), y != 0 && (b = p.edgeElasticity * (y - g), x = b * (p.lengthX / y), T = b * (p.lengthY / y), m.springForceX += x, m.springForceY += T, v.springForceX -= x, v.springForceY -= T);
            }, f.prototype.calcRepulsionForce = function(p, g) {
              var m = p.getRect(), v = g.getRect(), y = new Array(2), b = new Array(4), x, T, E, A, S, k, _;
              if (m.intersects(v)) {
                u.calcSeparationAmount(m, v, y, o.DEFAULT_EDGE_LENGTH / 2), k = 2 * y[0], _ = 2 * y[1];
                var R = p.noOfChildren * g.noOfChildren / (p.noOfChildren + g.noOfChildren);
                p.repulsionForceX -= R * k, p.repulsionForceY -= R * _, g.repulsionForceX += R * k, g.repulsionForceY += R * _;
              } else
                this.uniformLeafNodeSizes && p.getChild() == null && g.getChild() == null ? (x = v.getCenterX() - m.getCenterX(), T = v.getCenterY() - m.getCenterY()) : (u.getIntersection(m, v, b), x = b[2] - b[0], T = b[3] - b[1]), Math.abs(x) < o.MIN_REPULSION_DIST && (x = h.sign(x) * o.MIN_REPULSION_DIST), Math.abs(T) < o.MIN_REPULSION_DIST && (T = h.sign(T) * o.MIN_REPULSION_DIST), E = x * x + T * T, A = Math.sqrt(E), S = (p.nodeRepulsion / 2 + g.nodeRepulsion / 2) * p.noOfChildren * g.noOfChildren / E, k = S * x / A, _ = S * T / A, p.repulsionForceX -= k, p.repulsionForceY -= _, g.repulsionForceX += k, g.repulsionForceY += _;
            }, f.prototype.calcGravitationalForce = function(p) {
              var g, m, v, y, b, x, T, E;
              g = p.getOwner(), m = (g.getRight() + g.getLeft()) / 2, v = (g.getTop() + g.getBottom()) / 2, y = p.getCenterX() - m, b = p.getCenterY() - v, x = Math.abs(y) + p.getWidth() / 2, T = Math.abs(b) + p.getHeight() / 2, p.getOwner() == this.graphManager.getRoot() ? (E = g.getEstimatedSize() * this.gravityRangeFactor, (x > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y, p.gravitationForceY = -this.gravityConstant * b)) : (E = g.getEstimatedSize() * this.compoundGravityRangeFactor, (x > E || T > E) && (p.gravitationForceX = -this.gravityConstant * y * this.compoundGravityConstant, p.gravitationForceY = -this.gravityConstant * b * this.compoundGravityConstant));
            }, f.prototype.isConverged = function() {
              var p, g = !1;
              return this.totalIterations > this.maxIterations / 3 && (g = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2), p = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, p || g;
            }, f.prototype.animate = function() {
              this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
            }, f.prototype.calcNoOfChildrenForAllNodes = function() {
              for (var p, g = this.graphManager.getAllNodes(), m = 0; m < g.length; m++)
                p = g[m], p.noOfChildren = p.getNoOfChildren();
            }, f.prototype.calcGrid = function(p) {
              var g = 0, m = 0;
              g = parseInt(Math.ceil((p.getRight() - p.getLeft()) / this.repulsionRange)), m = parseInt(Math.ceil((p.getBottom() - p.getTop()) / this.repulsionRange));
              for (var v = new Array(g), y = 0; y < g; y++)
                v[y] = new Array(m);
              for (var y = 0; y < g; y++)
                for (var b = 0; b < m; b++)
                  v[y][b] = new Array();
              return v;
            }, f.prototype.addNodeToGrid = function(p, g, m) {
              var v = 0, y = 0, b = 0, x = 0;
              v = parseInt(Math.floor((p.getRect().x - g) / this.repulsionRange)), y = parseInt(Math.floor((p.getRect().width + p.getRect().x - g) / this.repulsionRange)), b = parseInt(Math.floor((p.getRect().y - m) / this.repulsionRange)), x = parseInt(Math.floor((p.getRect().height + p.getRect().y - m) / this.repulsionRange));
              for (var T = v; T <= y; T++)
                for (var E = b; E <= x; E++)
                  this.grid[T][E].push(p), p.setGridCoordinates(v, y, b, x);
            }, f.prototype.updateGrid = function() {
              var p, g, m = this.getAllNodes();
              for (this.grid = this.calcGrid(this.graphManager.getRoot()), p = 0; p < m.length; p++)
                g = m[p], this.addNodeToGrid(g, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
            }, f.prototype.calculateRepulsionForceOfANode = function(p, g, m, v) {
              if (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && m || v) {
                var y = /* @__PURE__ */ new Set();
                p.surrounding = new Array();
                for (var b, x = this.grid, T = p.startX - 1; T < p.finishX + 2; T++)
                  for (var E = p.startY - 1; E < p.finishY + 2; E++)
                    if (!(T < 0 || E < 0 || T >= x.length || E >= x[0].length)) {
                      for (var A = 0; A < x[T][E].length; A++)
                        if (b = x[T][E][A], !(p.getOwner() != b.getOwner() || p == b) && !g.has(b) && !y.has(b)) {
                          var S = Math.abs(p.getCenterX() - b.getCenterX()) - (p.getWidth() / 2 + b.getWidth() / 2), k = Math.abs(p.getCenterY() - b.getCenterY()) - (p.getHeight() / 2 + b.getHeight() / 2);
                          S <= this.repulsionRange && k <= this.repulsionRange && y.add(b);
                        }
                    }
                p.surrounding = [].concat(a(y));
              }
              for (T = 0; T < p.surrounding.length; T++)
                this.calcRepulsionForce(p, p.surrounding[T]);
            }, f.prototype.calcRepulsionRange = function() {
              return 0;
            }, r.exports = f;
          }),
          /* 19 */
          /***/
          (function(r, n, i) {
            var a = i(1), s = i(4);
            function o(u, h, f) {
              a.call(this, u, h, f), this.idealLength = s.DEFAULT_EDGE_LENGTH, this.edgeElasticity = s.DEFAULT_SPRING_STRENGTH;
            }
            o.prototype = Object.create(a.prototype);
            for (var l in a)
              o[l] = a[l];
            r.exports = o;
          }),
          /* 20 */
          /***/
          (function(r, n, i) {
            var a = i(3), s = i(4);
            function o(u, h, f, d) {
              a.call(this, u, h, f, d), this.nodeRepulsion = s.DEFAULT_REPULSION_STRENGTH, this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
            }
            o.prototype = Object.create(a.prototype);
            for (var l in a)
              o[l] = a[l];
            o.prototype.setGridCoordinates = function(u, h, f, d) {
              this.startX = u, this.finishX = h, this.startY = f, this.finishY = d;
            }, r.exports = o;
          }),
          /* 21 */
          /***/
          (function(r, n, i) {
            function a(s, o) {
              this.width = 0, this.height = 0, s !== null && o !== null && (this.height = o, this.width = s);
            }
            a.prototype.getWidth = function() {
              return this.width;
            }, a.prototype.setWidth = function(s) {
              this.width = s;
            }, a.prototype.getHeight = function() {
              return this.height;
            }, a.prototype.setHeight = function(s) {
              this.height = s;
            }, r.exports = a;
          }),
          /* 22 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.map = {}, this.keys = [];
            }
            s.prototype.put = function(o, l) {
              var u = a.createID(o);
              this.contains(u) || (this.map[u] = l, this.keys.push(o));
            }, s.prototype.contains = function(o) {
              return a.createID(o), this.map[o] != null;
            }, s.prototype.get = function(o) {
              var l = a.createID(o);
              return this.map[l];
            }, s.prototype.keySet = function() {
              return this.keys;
            }, r.exports = s;
          }),
          /* 23 */
          /***/
          (function(r, n, i) {
            var a = i(14);
            function s() {
              this.set = {};
            }
            s.prototype.add = function(o) {
              var l = a.createID(o);
              this.contains(l) || (this.set[l] = o);
            }, s.prototype.remove = function(o) {
              delete this.set[a.createID(o)];
            }, s.prototype.clear = function() {
              this.set = {};
            }, s.prototype.contains = function(o) {
              return this.set[a.createID(o)] == o;
            }, s.prototype.isEmpty = function() {
              return this.size() === 0;
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAllTo = function(o) {
              for (var l = Object.keys(this.set), u = l.length, h = 0; h < u; h++)
                o.push(this.set[l[h]]);
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAll = function(o) {
              for (var l = o.length, u = 0; u < l; u++) {
                var h = o[u];
                this.add(h);
              }
            }, r.exports = s;
          }),
          /* 24 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.multMat = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++) {
                l[u] = [];
                for (var h = 0; h < o[0].length; h++) {
                  l[u][h] = 0;
                  for (var f = 0; f < s[0].length; f++)
                    l[u][h] += s[u][f] * o[f][h];
                }
              }
              return l;
            }, a.transpose = function(s) {
              for (var o = [], l = 0; l < s[0].length; l++) {
                o[l] = [];
                for (var u = 0; u < s.length; u++)
                  o[l][u] = s[u][l];
              }
              return o;
            }, a.multCons = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++)
                l[u] = s[u] * o;
              return l;
            }, a.minusOp = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++)
                l[u] = s[u] - o[u];
              return l;
            }, a.dotProduct = function(s, o) {
              for (var l = 0, u = 0; u < s.length; u++)
                l += s[u] * o[u];
              return l;
            }, a.mag = function(s) {
              return Math.sqrt(this.dotProduct(s, s));
            }, a.normalize = function(s) {
              for (var o = [], l = this.mag(s), u = 0; u < s.length; u++)
                o[u] = s[u] / l;
              return o;
            }, a.multGamma = function(s) {
              for (var o = [], l = 0, u = 0; u < s.length; u++)
                l += s[u];
              l *= -1 / s.length;
              for (var h = 0; h < s.length; h++)
                o[h] = l + s[h];
              return o;
            }, a.multL = function(s, o, l) {
              for (var u = [], h = [], f = [], d = 0; d < o[0].length; d++) {
                for (var p = 0, g = 0; g < o.length; g++)
                  p += -0.5 * o[g][d] * s[g];
                h[d] = p;
              }
              for (var m = 0; m < l.length; m++) {
                for (var v = 0, y = 0; y < l.length; y++)
                  v += l[m][y] * h[y];
                f[m] = v;
              }
              for (var b = 0; b < o.length; b++) {
                for (var x = 0, T = 0; T < o[0].length; T++)
                  x += o[b][T] * f[T];
                u[b] = x;
              }
              return u;
            }, r.exports = a;
          }),
          /* 25 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function u(h, f) {
                for (var d = 0; d < f.length; d++) {
                  var p = f[d];
                  p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(h, p.key, p);
                }
              }
              return function(h, f, d) {
                return f && u(h.prototype, f), d && u(h, d), h;
              };
            })();
            function s(u, h) {
              if (!(u instanceof h))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = i(11), l = (function() {
              function u(h, f) {
                s(this, u), (f !== null || f !== void 0) && (this.compareFunction = this._defaultCompareFunction);
                var d = void 0;
                h instanceof o ? d = h.size() : d = h.length, this._quicksort(h, 0, d - 1);
              }
              return a(u, [{
                key: "_quicksort",
                value: function(f, d, p) {
                  if (d < p) {
                    var g = this._partition(f, d, p);
                    this._quicksort(f, d, g), this._quicksort(f, g + 1, p);
                  }
                }
              }, {
                key: "_partition",
                value: function(f, d, p) {
                  for (var g = this._get(f, d), m = d, v = p; ; ) {
                    for (; this.compareFunction(g, this._get(f, v)); )
                      v--;
                    for (; this.compareFunction(this._get(f, m), g); )
                      m++;
                    if (m < v)
                      this._swap(f, m, v), m++, v--;
                    else return v;
                  }
                }
              }, {
                key: "_get",
                value: function(f, d) {
                  return f instanceof o ? f.get_object_at(d) : f[d];
                }
              }, {
                key: "_set",
                value: function(f, d, p) {
                  f instanceof o ? f.set_object_at(d, p) : f[d] = p;
                }
              }, {
                key: "_swap",
                value: function(f, d, p) {
                  var g = this._get(f, d);
                  this._set(f, d, this._get(f, p)), this._set(f, p, g);
                }
              }, {
                key: "_defaultCompareFunction",
                value: function(f, d) {
                  return d > f;
                }
              }]), u;
            })();
            r.exports = l;
          }),
          /* 26 */
          /***/
          (function(r, n, i) {
            function a() {
            }
            a.svd = function(s) {
              this.U = null, this.V = null, this.s = null, this.m = 0, this.n = 0, this.m = s.length, this.n = s[0].length;
              var o = Math.min(this.m, this.n);
              this.s = (function(He) {
                for (var rt = []; He-- > 0; )
                  rt.push(0);
                return rt;
              })(Math.min(this.m + 1, this.n)), this.U = (function(He) {
                var rt = function ct(ut) {
                  if (ut.length == 0)
                    return 0;
                  for (var nt = [], bt = 0; bt < ut[0]; bt++)
                    nt.push(ct(ut.slice(1)));
                  return nt;
                };
                return rt(He);
              })([this.m, o]), this.V = (function(He) {
                var rt = function ct(ut) {
                  if (ut.length == 0)
                    return 0;
                  for (var nt = [], bt = 0; bt < ut[0]; bt++)
                    nt.push(ct(ut.slice(1)));
                  return nt;
                };
                return rt(He);
              })([this.n, this.n]);
              for (var l = (function(He) {
                for (var rt = []; He-- > 0; )
                  rt.push(0);
                return rt;
              })(this.n), u = (function(He) {
                for (var rt = []; He-- > 0; )
                  rt.push(0);
                return rt;
              })(this.m), h = !0, f = Math.min(this.m - 1, this.n), d = Math.max(0, Math.min(this.n - 2, this.m)), p = 0; p < Math.max(f, d); p++) {
                if (p < f) {
                  this.s[p] = 0;
                  for (var g = p; g < this.m; g++)
                    this.s[p] = a.hypot(this.s[p], s[g][p]);
                  if (this.s[p] !== 0) {
                    s[p][p] < 0 && (this.s[p] = -this.s[p]);
                    for (var m = p; m < this.m; m++)
                      s[m][p] /= this.s[p];
                    s[p][p] += 1;
                  }
                  this.s[p] = -this.s[p];
                }
                for (var v = p + 1; v < this.n; v++) {
                  if (/* @__PURE__ */ (function(He, rt) {
                    return He && rt;
                  })(p < f, this.s[p] !== 0)) {
                    for (var y = 0, b = p; b < this.m; b++)
                      y += s[b][p] * s[b][v];
                    y = -y / s[p][p];
                    for (var x = p; x < this.m; x++)
                      s[x][v] += y * s[x][p];
                  }
                  l[v] = s[p][v];
                }
                if (/* @__PURE__ */ (function(He, rt) {
                  return rt;
                })(h, p < f))
                  for (var T = p; T < this.m; T++)
                    this.U[T][p] = s[T][p];
                if (p < d) {
                  l[p] = 0;
                  for (var E = p + 1; E < this.n; E++)
                    l[p] = a.hypot(l[p], l[E]);
                  if (l[p] !== 0) {
                    l[p + 1] < 0 && (l[p] = -l[p]);
                    for (var A = p + 1; A < this.n; A++)
                      l[A] /= l[p];
                    l[p + 1] += 1;
                  }
                  if (l[p] = -l[p], /* @__PURE__ */ (function(He, rt) {
                    return He && rt;
                  })(p + 1 < this.m, l[p] !== 0)) {
                    for (var S = p + 1; S < this.m; S++)
                      u[S] = 0;
                    for (var k = p + 1; k < this.n; k++)
                      for (var _ = p + 1; _ < this.m; _++)
                        u[_] += l[k] * s[_][k];
                    for (var R = p + 1; R < this.n; R++)
                      for (var L = -l[R] / l[p + 1], M = p + 1; M < this.m; M++)
                        s[M][R] += L * u[M];
                  }
                  for (var P = p + 1; P < this.n; P++)
                    this.V[P][p] = l[P];
                }
              }
              var C = Math.min(this.n, this.m + 1);
              f < this.n && (this.s[f] = s[f][f]), this.m < C && (this.s[C - 1] = 0), d + 1 < C && (l[d] = s[d][C - 1]), l[C - 1] = 0;
              {
                for (var I = f; I < o; I++) {
                  for (var N = 0; N < this.m; N++)
                    this.U[N][I] = 0;
                  this.U[I][I] = 1;
                }
                for (var O = f - 1; O >= 0; O--)
                  if (this.s[O] !== 0) {
                    for (var D = O + 1; D < o; D++) {
                      for (var $ = 0, z = O; z < this.m; z++)
                        $ += this.U[z][O] * this.U[z][D];
                      $ = -$ / this.U[O][O];
                      for (var B = O; B < this.m; B++)
                        this.U[B][D] += $ * this.U[B][O];
                    }
                    for (var G = O; G < this.m; G++)
                      this.U[G][O] = -this.U[G][O];
                    this.U[O][O] = 1 + this.U[O][O];
                    for (var W = 0; W < O - 1; W++)
                      this.U[W][O] = 0;
                  } else {
                    for (var V = 0; V < this.m; V++)
                      this.U[V][O] = 0;
                    this.U[O][O] = 1;
                  }
              }
              for (var U = this.n - 1; U >= 0; U--) {
                if (/* @__PURE__ */ (function(He, rt) {
                  return He && rt;
                })(U < d, l[U] !== 0))
                  for (var Z = U + 1; Z < o; Z++) {
                    for (var K = 0, ce = U + 1; ce < this.n; ce++)
                      K += this.V[ce][U] * this.V[ce][Z];
                    K = -K / this.V[U + 1][U];
                    for (var J = U + 1; J < this.n; J++)
                      this.V[J][Z] += K * this.V[J][U];
                  }
                for (var ee = 0; ee < this.n; ee++)
                  this.V[ee][U] = 0;
                this.V[U][U] = 1;
              }
              for (var j = C - 1, X = Math.pow(2, -52), re = Math.pow(2, -966); C > 0; ) {
                var Q = void 0, ue = void 0;
                for (Q = C - 2; Q >= -1 && Q !== -1; Q--)
                  if (Math.abs(l[Q]) <= re + X * (Math.abs(this.s[Q]) + Math.abs(this.s[Q + 1]))) {
                    l[Q] = 0;
                    break;
                  }
                if (Q === C - 2)
                  ue = 4;
                else {
                  var ne = void 0;
                  for (ne = C - 1; ne >= Q && ne !== Q; ne--) {
                    var xe = (ne !== C ? Math.abs(l[ne]) : 0) + (ne !== Q + 1 ? Math.abs(l[ne - 1]) : 0);
                    if (Math.abs(this.s[ne]) <= re + X * xe) {
                      this.s[ne] = 0;
                      break;
                    }
                  }
                  ne === Q ? ue = 3 : ne === C - 1 ? ue = 1 : (ue = 2, Q = ne);
                }
                switch (Q++, ue) {
                  case 1:
                    {
                      var Y = l[C - 2];
                      l[C - 2] = 0;
                      for (var Ne = C - 2; Ne >= Q; Ne--) {
                        var fe = a.hypot(this.s[Ne], Y), qe = this.s[Ne] / fe, ze = Y / fe;
                        this.s[Ne] = fe, Ne !== Q && (Y = -ze * l[Ne - 1], l[Ne - 1] = qe * l[Ne - 1]);
                        for (var Ge = 0; Ge < this.n; Ge++)
                          fe = qe * this.V[Ge][Ne] + ze * this.V[Ge][C - 1], this.V[Ge][C - 1] = -ze * this.V[Ge][Ne] + qe * this.V[Ge][C - 1], this.V[Ge][Ne] = fe;
                      }
                    }
                    break;
                  case 2:
                    {
                      var Ee = l[Q - 1];
                      l[Q - 1] = 0;
                      for (var Oe = Q; Oe < C; Oe++) {
                        var Ce = a.hypot(this.s[Oe], Ee), Ae = this.s[Oe] / Ce, $e = Ee / Ce;
                        this.s[Oe] = Ce, Ee = -$e * l[Oe], l[Oe] = Ae * l[Oe];
                        for (var me = 0; me < this.m; me++)
                          Ce = Ae * this.U[me][Oe] + $e * this.U[me][Q - 1], this.U[me][Q - 1] = -$e * this.U[me][Oe] + Ae * this.U[me][Q - 1], this.U[me][Oe] = Ce;
                      }
                    }
                    break;
                  case 3:
                    {
                      var Ie = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[C - 1]), Math.abs(this.s[C - 2])), Math.abs(l[C - 2])), Math.abs(this.s[Q])), Math.abs(l[Q])), te = this.s[C - 1] / Ie, he = this.s[C - 2] / Ie, F = l[C - 2] / Ie, oe = this.s[Q] / Ie, se = l[Q] / Ie, ge = ((he + te) * (he - te) + F * F) / 2, de = te * F * (te * F), we = 0;
                      /* @__PURE__ */ (function(He, rt) {
                        return He || rt;
                      })(ge !== 0, de !== 0) && (we = Math.sqrt(ge * ge + de), ge < 0 && (we = -we), we = de / (ge + we));
                      for (var _e = (oe + te) * (oe - te) + we, Se = oe * se, Me = Q; Me < C - 1; Me++) {
                        var Xe = a.hypot(_e, Se), We = _e / Xe, Ke = Se / Xe;
                        Me !== Q && (l[Me - 1] = Xe), _e = We * this.s[Me] + Ke * l[Me], l[Me] = We * l[Me] - Ke * this.s[Me], Se = Ke * this.s[Me + 1], this.s[Me + 1] = We * this.s[Me + 1];
                        for (var Ze = 0; Ze < this.n; Ze++)
                          Xe = We * this.V[Ze][Me] + Ke * this.V[Ze][Me + 1], this.V[Ze][Me + 1] = -Ke * this.V[Ze][Me] + We * this.V[Ze][Me + 1], this.V[Ze][Me] = Xe;
                        if (Xe = a.hypot(_e, Se), We = _e / Xe, Ke = Se / Xe, this.s[Me] = Xe, _e = We * l[Me] + Ke * this.s[Me + 1], this.s[Me + 1] = -Ke * l[Me] + We * this.s[Me + 1], Se = Ke * l[Me + 1], l[Me + 1] = We * l[Me + 1], Me < this.m - 1)
                          for (var Pe = 0; Pe < this.m; Pe++)
                            Xe = We * this.U[Pe][Me] + Ke * this.U[Pe][Me + 1], this.U[Pe][Me + 1] = -Ke * this.U[Pe][Me] + We * this.U[Pe][Me + 1], this.U[Pe][Me] = Xe;
                      }
                      l[C - 2] = _e;
                    }
                    break;
                  case 4:
                    {
                      if (this.s[Q] <= 0) {
                        this.s[Q] = this.s[Q] < 0 ? -this.s[Q] : 0;
                        for (var Ve = 0; Ve <= j; Ve++)
                          this.V[Ve][Q] = -this.V[Ve][Q];
                      }
                      for (; Q < j && !(this.s[Q] >= this.s[Q + 1]); ) {
                        var ht = this.s[Q];
                        if (this.s[Q] = this.s[Q + 1], this.s[Q + 1] = ht, Q < this.n - 1)
                          for (var st = 0; st < this.n; st++)
                            ht = this.V[st][Q + 1], this.V[st][Q + 1] = this.V[st][Q], this.V[st][Q] = ht;
                        if (Q < this.m - 1)
                          for (var Ue = 0; Ue < this.m; Ue++)
                            ht = this.U[Ue][Q + 1], this.U[Ue][Q + 1] = this.U[Ue][Q], this.U[Ue][Q] = ht;
                        Q++;
                      }
                      C--;
                    }
                    break;
                }
              }
              var Et = { U: this.U, V: this.V, S: this.s };
              return Et;
            }, a.hypot = function(s, o) {
              var l = void 0;
              return Math.abs(s) > Math.abs(o) ? (l = o / s, l = Math.abs(s) * Math.sqrt(1 + l * l)) : o != 0 ? (l = s / o, l = Math.abs(o) * Math.sqrt(1 + l * l)) : l = 0, l;
            }, r.exports = a;
          }),
          /* 27 */
          /***/
          (function(r, n, i) {
            var a = /* @__PURE__ */ (function() {
              function l(u, h) {
                for (var f = 0; f < h.length; f++) {
                  var d = h[f];
                  d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(u, d.key, d);
                }
              }
              return function(u, h, f) {
                return h && l(u.prototype, h), f && l(u, f), u;
              };
            })();
            function s(l, u) {
              if (!(l instanceof u))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = (function() {
              function l(u, h) {
                var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
                s(this, l), this.sequence1 = u, this.sequence2 = h, this.match_score = f, this.mismatch_penalty = d, this.gap_penalty = p, this.iMax = u.length + 1, this.jMax = h.length + 1, this.grid = new Array(this.iMax);
                for (var g = 0; g < this.iMax; g++) {
                  this.grid[g] = new Array(this.jMax);
                  for (var m = 0; m < this.jMax; m++)
                    this.grid[g][m] = 0;
                }
                this.tracebackGrid = new Array(this.iMax);
                for (var v = 0; v < this.iMax; v++) {
                  this.tracebackGrid[v] = new Array(this.jMax);
                  for (var y = 0; y < this.jMax; y++)
                    this.tracebackGrid[v][y] = [null, null, null];
                }
                this.alignments = [], this.score = -1, this.computeGrids();
              }
              return a(l, [{
                key: "getScore",
                value: function() {
                  return this.score;
                }
              }, {
                key: "getAlignments",
                value: function() {
                  return this.alignments;
                }
                // Main dynamic programming procedure
              }, {
                key: "computeGrids",
                value: function() {
                  for (var h = 1; h < this.jMax; h++)
                    this.grid[0][h] = this.grid[0][h - 1] + this.gap_penalty, this.tracebackGrid[0][h] = [!1, !1, !0];
                  for (var f = 1; f < this.iMax; f++)
                    this.grid[f][0] = this.grid[f - 1][0] + this.gap_penalty, this.tracebackGrid[f][0] = [!1, !0, !1];
                  for (var d = 1; d < this.iMax; d++)
                    for (var p = 1; p < this.jMax; p++) {
                      var g = void 0;
                      this.sequence1[d - 1] === this.sequence2[p - 1] ? g = this.grid[d - 1][p - 1] + this.match_score : g = this.grid[d - 1][p - 1] + this.mismatch_penalty;
                      var m = this.grid[d - 1][p] + this.gap_penalty, v = this.grid[d][p - 1] + this.gap_penalty, y = [g, m, v], b = this.arrayAllMaxIndexes(y);
                      this.grid[d][p] = y[b[0]], this.tracebackGrid[d][p] = [b.includes(0), b.includes(1), b.includes(2)];
                    }
                  this.score = this.grid[this.iMax - 1][this.jMax - 1];
                }
                // Gets all possible valid sequence combinations
              }, {
                key: "alignmentTraceback",
                value: function() {
                  var h = [];
                  for (h.push({
                    pos: [this.sequence1.length, this.sequence2.length],
                    seq1: "",
                    seq2: ""
                  }); h[0]; ) {
                    var f = h[0], d = this.tracebackGrid[f.pos[0]][f.pos[1]];
                    d[0] && h.push({
                      pos: [f.pos[0] - 1, f.pos[1] - 1],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), d[1] && h.push({
                      pos: [f.pos[0] - 1, f.pos[1]],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: "-" + f.seq2
                    }), d[2] && h.push({
                      pos: [f.pos[0], f.pos[1] - 1],
                      seq1: "-" + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), f.pos[0] === 0 && f.pos[1] === 0 && this.alignments.push({
                      sequence1: f.seq1,
                      sequence2: f.seq2
                    }), h.shift();
                  }
                  return this.alignments;
                }
                // Helper Functions
              }, {
                key: "getAllIndexes",
                value: function(h, f) {
                  for (var d = [], p = -1; (p = h.indexOf(f, p + 1)) !== -1; )
                    d.push(p);
                  return d;
                }
              }, {
                key: "arrayAllMaxIndexes",
                value: function(h) {
                  return this.getAllIndexes(h, Math.max.apply(null, h));
                }
              }]), l;
            })();
            r.exports = o;
          }),
          /* 28 */
          /***/
          (function(r, n, i) {
            var a = function() {
            };
            a.FDLayout = i(18), a.FDLayoutConstants = i(4), a.FDLayoutEdge = i(19), a.FDLayoutNode = i(20), a.DimensionD = i(21), a.HashMap = i(22), a.HashSet = i(23), a.IGeometry = i(8), a.IMath = i(9), a.Integer = i(10), a.Point = i(12), a.PointD = i(5), a.RandomSeed = i(16), a.RectangleD = i(13), a.Transform = i(17), a.UniqueIDGeneretor = i(14), a.Quicksort = i(25), a.LinkedList = i(11), a.LGraphObject = i(2), a.LGraph = i(6), a.LEdge = i(1), a.LGraphManager = i(7), a.LNode = i(3), a.Layout = i(15), a.LayoutConstants = i(0), a.NeedlemanWunsch = i(27), a.Matrix = i(24), a.SVD = i(26), r.exports = a;
          }),
          /* 29 */
          /***/
          (function(r, n, i) {
            function a() {
              this.listeners = [];
            }
            var s = a.prototype;
            s.addListener = function(o, l) {
              this.listeners.push({
                event: o,
                callback: l
              });
            }, s.removeListener = function(o, l) {
              for (var u = this.listeners.length; u >= 0; u--) {
                var h = this.listeners[u];
                h.event === o && h.callback === l && this.listeners.splice(u, 1);
              }
            }, s.emit = function(o, l) {
              for (var u = 0; u < this.listeners.length; u++) {
                var h = this.listeners[u];
                o === h.event && h.callback(l);
              }
            }, r.exports = a;
          })
          /******/
        ])
      );
    });
  })(S2)), S2.exports;
}
var olt = E2.exports, OY;
function llt() {
  return OY || (OY = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(slt());
    })(olt, function(r) {
      return (
        /******/
        (() => {
          var n = {
            /***/
            45: (
              /***/
              ((o, l, u) => {
                var h = {};
                h.layoutBase = u(551), h.CoSEConstants = u(806), h.CoSEEdge = u(767), h.CoSEGraph = u(880), h.CoSEGraphManager = u(578), h.CoSELayout = u(765), h.CoSENode = u(991), h.ConstraintHandler = u(902), o.exports = h;
              })
            ),
            /***/
            806: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayoutConstants;
                function f() {
                }
                for (var d in h)
                  f[d] = h[d];
                f.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, f.DEFAULT_RADIAL_SEPARATION = h.DEFAULT_EDGE_LENGTH, f.DEFAULT_COMPONENT_SEPERATION = 60, f.TILE = !0, f.TILING_PADDING_VERTICAL = 10, f.TILING_PADDING_HORIZONTAL = 10, f.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, f.ENFORCE_CONSTRAINTS = !0, f.APPLY_LAYOUT = !0, f.RELAX_MOVEMENT_ON_CONSTRAINTS = !0, f.TREE_REDUCTION_ON_INCREMENTAL = !0, f.PURE_INCREMENTAL = f.DEFAULT_INCREMENTAL, o.exports = f;
              })
            ),
            /***/
            767: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayoutEdge;
                function f(p, g, m) {
                  h.call(this, p, g, m);
                }
                f.prototype = Object.create(h.prototype);
                for (var d in h)
                  f[d] = h[d];
                o.exports = f;
              })
            ),
            /***/
            880: (
              /***/
              ((o, l, u) => {
                var h = u(551).LGraph;
                function f(p, g, m) {
                  h.call(this, p, g, m);
                }
                f.prototype = Object.create(h.prototype);
                for (var d in h)
                  f[d] = h[d];
                o.exports = f;
              })
            ),
            /***/
            578: (
              /***/
              ((o, l, u) => {
                var h = u(551).LGraphManager;
                function f(p) {
                  h.call(this, p);
                }
                f.prototype = Object.create(h.prototype);
                for (var d in h)
                  f[d] = h[d];
                o.exports = f;
              })
            ),
            /***/
            765: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayout, f = u(578), d = u(880), p = u(991), g = u(767), m = u(806), v = u(902), y = u(551).FDLayoutConstants, b = u(551).LayoutConstants, x = u(551).Point, T = u(551).PointD, E = u(551).DimensionD, A = u(551).Layout, S = u(551).Integer, k = u(551).IGeometry, _ = u(551).LGraph, R = u(551).Transform, L = u(551).LinkedList;
                function M() {
                  h.call(this), this.toBeTiled = {}, this.constraints = {};
                }
                M.prototype = Object.create(h.prototype);
                for (var P in h)
                  M[P] = h[P];
                M.prototype.newGraphManager = function() {
                  var C = new f(this);
                  return this.graphManager = C, C;
                }, M.prototype.newGraph = function(C) {
                  return new d(null, this.graphManager, C);
                }, M.prototype.newNode = function(C) {
                  return new p(this.graphManager, C);
                }, M.prototype.newEdge = function(C) {
                  return new g(null, null, C);
                }, M.prototype.initParameters = function() {
                  h.prototype.initParameters.call(this, arguments), this.isSubLayout || (m.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = m.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = m.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = y.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = y.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = y.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = y.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1);
                }, M.prototype.initSpringEmbedder = function() {
                  h.prototype.initSpringEmbedder.call(this), this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / y.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = 0.04, this.coolingAdjuster = 1;
                }, M.prototype.layout = function() {
                  var C = b.DEFAULT_CREATE_BENDS_AS_NEEDED;
                  return C && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
                }, M.prototype.classicLayout = function() {
                  if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
                    if (m.TREE_REDUCTION_ON_INCREMENTAL) {
                      this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                      var I = new Set(this.getAllNodes()), N = this.nodesWithGravity.filter(function($) {
                        return I.has($);
                      });
                      this.graphManager.setAllNodesToApplyGravitation(N);
                    }
                  } else {
                    var C = this.getFlatForest();
                    if (C.length > 0)
                      this.positionNodesRadially(C);
                    else {
                      this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                      var I = new Set(this.getAllNodes()), N = this.nodesWithGravity.filter(function(O) {
                        return I.has(O);
                      });
                      this.graphManager.setAllNodesToApplyGravitation(N), this.positionNodesRandomly();
                    }
                  }
                  return Object.keys(this.constraints).length > 0 && (v.handleConstraints(this), this.initConstraintVariables()), this.initSpringEmbedder(), m.APPLY_LAYOUT && this.runSpringEmbedder(), !0;
                }, M.prototype.tick = function() {
                  if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished)
                    if (this.prunedNodesAll.length > 0)
                      this.isTreeGrowing = !0;
                    else
                      return !0;
                  if (this.totalIterations % y.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                    if (this.isConverged())
                      if (this.prunedNodesAll.length > 0)
                        this.isTreeGrowing = !0;
                      else
                        return !0;
                    this.coolingCycle++, this.layoutQuality == 0 ? this.coolingAdjuster = this.coolingCycle : this.layoutQuality == 1 && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
                  }
                  if (this.isTreeGrowing) {
                    if (this.growTreeIterations % 10 == 0)
                      if (this.prunedNodesAll.length > 0) {
                        this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
                        var C = new Set(this.getAllNodes()), I = this.nodesWithGravity.filter(function(D) {
                          return C.has(D);
                        });
                        this.graphManager.setAllNodesToApplyGravitation(I), this.graphManager.updateBounds(), this.updateGrid(), m.PURE_INCREMENTAL ? this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 : this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                      } else
                        this.isTreeGrowing = !1, this.isGrowthFinished = !0;
                    this.growTreeIterations++;
                  }
                  if (this.isGrowthFinished) {
                    if (this.isConverged())
                      return !0;
                    this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), m.PURE_INCREMENTAL ? this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100) : this.coolingFactor = y.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
                  }
                  var N = !this.isTreeGrowing && !this.isGrowthFinished, O = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
                  return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(N, O), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
                }, M.prototype.getPositionsData = function() {
                  for (var C = this.graphManager.getAllNodes(), I = {}, N = 0; N < C.length; N++) {
                    var O = C[N].rect, D = C[N].id;
                    I[D] = {
                      id: D,
                      x: O.getCenterX(),
                      y: O.getCenterY(),
                      w: O.width,
                      h: O.height
                    };
                  }
                  return I;
                }, M.prototype.runSpringEmbedder = function() {
                  this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
                  var C = !1;
                  if (y.ANIMATE === "during")
                    this.emit("layoutstarted");
                  else {
                    for (; !C; )
                      C = this.tick();
                    this.graphManager.updateBounds();
                  }
                }, M.prototype.moveNodes = function() {
                  for (var C = this.getAllNodes(), I, N = 0; N < C.length; N++)
                    I = C[N], I.calculateDisplacement();
                  Object.keys(this.constraints).length > 0 && this.updateDisplacements();
                  for (var N = 0; N < C.length; N++)
                    I = C[N], I.move();
                }, M.prototype.initConstraintVariables = function() {
                  var C = this;
                  this.idToNodeMap = /* @__PURE__ */ new Map(), this.fixedNodeSet = /* @__PURE__ */ new Set();
                  for (var I = this.graphManager.getAllNodes(), N = 0; N < I.length; N++) {
                    var O = I[N];
                    this.idToNodeMap.set(O.id, O);
                  }
                  var D = function J(ee) {
                    for (var j = ee.getChild().getNodes(), X, re = 0, Q = 0; Q < j.length; Q++)
                      X = j[Q], X.getChild() == null ? C.fixedNodeSet.has(X.id) && (re += 100) : re += J(X);
                    return re;
                  };
                  if (this.constraints.fixedNodeConstraint) {
                    this.constraints.fixedNodeConstraint.forEach(function(j) {
                      C.fixedNodeSet.add(j.nodeId);
                    });
                    for (var I = this.graphManager.getAllNodes(), O, N = 0; N < I.length; N++)
                      if (O = I[N], O.getChild() != null) {
                        var $ = D(O);
                        $ > 0 && (O.fixedNodeWeight = $);
                      }
                  }
                  if (this.constraints.relativePlacementConstraint) {
                    var z = /* @__PURE__ */ new Map(), B = /* @__PURE__ */ new Map();
                    if (this.dummyToNodeForVerticalAlignment = /* @__PURE__ */ new Map(), this.dummyToNodeForHorizontalAlignment = /* @__PURE__ */ new Map(), this.fixedNodesOnHorizontal = /* @__PURE__ */ new Set(), this.fixedNodesOnVertical = /* @__PURE__ */ new Set(), this.fixedNodeSet.forEach(function(J) {
                      C.fixedNodesOnHorizontal.add(J), C.fixedNodesOnVertical.add(J);
                    }), this.constraints.alignmentConstraint) {
                      if (this.constraints.alignmentConstraint.vertical)
                        for (var G = this.constraints.alignmentConstraint.vertical, N = 0; N < G.length; N++)
                          this.dummyToNodeForVerticalAlignment.set("dummy" + N, []), G[N].forEach(function(ee) {
                            z.set(ee, "dummy" + N), C.dummyToNodeForVerticalAlignment.get("dummy" + N).push(ee), C.fixedNodeSet.has(ee) && C.fixedNodesOnHorizontal.add("dummy" + N);
                          });
                      if (this.constraints.alignmentConstraint.horizontal)
                        for (var W = this.constraints.alignmentConstraint.horizontal, N = 0; N < W.length; N++)
                          this.dummyToNodeForHorizontalAlignment.set("dummy" + N, []), W[N].forEach(function(ee) {
                            B.set(ee, "dummy" + N), C.dummyToNodeForHorizontalAlignment.get("dummy" + N).push(ee), C.fixedNodeSet.has(ee) && C.fixedNodesOnVertical.add("dummy" + N);
                          });
                    }
                    if (m.RELAX_MOVEMENT_ON_CONSTRAINTS)
                      this.shuffle = function(J) {
                        var ee, j, X;
                        for (X = J.length - 1; X >= 2 * J.length / 3; X--)
                          ee = Math.floor(Math.random() * (X + 1)), j = J[X], J[X] = J[ee], J[ee] = j;
                        return J;
                      }, this.nodesInRelativeHorizontal = [], this.nodesInRelativeVertical = [], this.nodeToRelativeConstraintMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToRelativeConstraintMapVertical = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapVertical = /* @__PURE__ */ new Map(), this.constraints.relativePlacementConstraint.forEach(function(J) {
                        if (J.left) {
                          var ee = z.has(J.left) ? z.get(J.left) : J.left, j = z.has(J.right) ? z.get(J.right) : J.right;
                          C.nodesInRelativeHorizontal.includes(ee) || (C.nodesInRelativeHorizontal.push(ee), C.nodeToRelativeConstraintMapHorizontal.set(ee, []), C.dummyToNodeForVerticalAlignment.has(ee) ? C.nodeToTempPositionMapHorizontal.set(ee, C.idToNodeMap.get(C.dummyToNodeForVerticalAlignment.get(ee)[0]).getCenterX()) : C.nodeToTempPositionMapHorizontal.set(ee, C.idToNodeMap.get(ee).getCenterX())), C.nodesInRelativeHorizontal.includes(j) || (C.nodesInRelativeHorizontal.push(j), C.nodeToRelativeConstraintMapHorizontal.set(j, []), C.dummyToNodeForVerticalAlignment.has(j) ? C.nodeToTempPositionMapHorizontal.set(j, C.idToNodeMap.get(C.dummyToNodeForVerticalAlignment.get(j)[0]).getCenterX()) : C.nodeToTempPositionMapHorizontal.set(j, C.idToNodeMap.get(j).getCenterX())), C.nodeToRelativeConstraintMapHorizontal.get(ee).push({ right: j, gap: J.gap }), C.nodeToRelativeConstraintMapHorizontal.get(j).push({ left: ee, gap: J.gap });
                        } else {
                          var X = B.has(J.top) ? B.get(J.top) : J.top, re = B.has(J.bottom) ? B.get(J.bottom) : J.bottom;
                          C.nodesInRelativeVertical.includes(X) || (C.nodesInRelativeVertical.push(X), C.nodeToRelativeConstraintMapVertical.set(X, []), C.dummyToNodeForHorizontalAlignment.has(X) ? C.nodeToTempPositionMapVertical.set(X, C.idToNodeMap.get(C.dummyToNodeForHorizontalAlignment.get(X)[0]).getCenterY()) : C.nodeToTempPositionMapVertical.set(X, C.idToNodeMap.get(X).getCenterY())), C.nodesInRelativeVertical.includes(re) || (C.nodesInRelativeVertical.push(re), C.nodeToRelativeConstraintMapVertical.set(re, []), C.dummyToNodeForHorizontalAlignment.has(re) ? C.nodeToTempPositionMapVertical.set(re, C.idToNodeMap.get(C.dummyToNodeForHorizontalAlignment.get(re)[0]).getCenterY()) : C.nodeToTempPositionMapVertical.set(re, C.idToNodeMap.get(re).getCenterY())), C.nodeToRelativeConstraintMapVertical.get(X).push({ bottom: re, gap: J.gap }), C.nodeToRelativeConstraintMapVertical.get(re).push({ top: X, gap: J.gap });
                        }
                      });
                    else {
                      var V = /* @__PURE__ */ new Map(), U = /* @__PURE__ */ new Map();
                      this.constraints.relativePlacementConstraint.forEach(function(J) {
                        if (J.left) {
                          var ee = z.has(J.left) ? z.get(J.left) : J.left, j = z.has(J.right) ? z.get(J.right) : J.right;
                          V.has(ee) ? V.get(ee).push(j) : V.set(ee, [j]), V.has(j) ? V.get(j).push(ee) : V.set(j, [ee]);
                        } else {
                          var X = B.has(J.top) ? B.get(J.top) : J.top, re = B.has(J.bottom) ? B.get(J.bottom) : J.bottom;
                          U.has(X) ? U.get(X).push(re) : U.set(X, [re]), U.has(re) ? U.get(re).push(X) : U.set(re, [X]);
                        }
                      });
                      var Z = function(ee, j) {
                        var X = [], re = [], Q = new L(), ue = /* @__PURE__ */ new Set(), ne = 0;
                        return ee.forEach(function(xe, Y) {
                          if (!ue.has(Y)) {
                            X[ne] = [], re[ne] = !1;
                            var Ne = Y;
                            for (Q.push(Ne), ue.add(Ne), X[ne].push(Ne); Q.length != 0; ) {
                              Ne = Q.shift(), j.has(Ne) && (re[ne] = !0);
                              var fe = ee.get(Ne);
                              fe.forEach(function(qe) {
                                ue.has(qe) || (Q.push(qe), ue.add(qe), X[ne].push(qe));
                              });
                            }
                            ne++;
                          }
                        }), { components: X, isFixed: re };
                      }, K = Z(V, C.fixedNodesOnHorizontal);
                      this.componentsOnHorizontal = K.components, this.fixedComponentsOnHorizontal = K.isFixed;
                      var ce = Z(U, C.fixedNodesOnVertical);
                      this.componentsOnVertical = ce.components, this.fixedComponentsOnVertical = ce.isFixed;
                    }
                  }
                }, M.prototype.updateDisplacements = function() {
                  var C = this;
                  if (this.constraints.fixedNodeConstraint && this.constraints.fixedNodeConstraint.forEach(function(ce) {
                    var J = C.idToNodeMap.get(ce.nodeId);
                    J.displacementX = 0, J.displacementY = 0;
                  }), this.constraints.alignmentConstraint) {
                    if (this.constraints.alignmentConstraint.vertical)
                      for (var I = this.constraints.alignmentConstraint.vertical, N = 0; N < I.length; N++) {
                        for (var O = 0, D = 0; D < I[N].length; D++) {
                          if (this.fixedNodeSet.has(I[N][D])) {
                            O = 0;
                            break;
                          }
                          O += this.idToNodeMap.get(I[N][D]).displacementX;
                        }
                        for (var $ = O / I[N].length, D = 0; D < I[N].length; D++)
                          this.idToNodeMap.get(I[N][D]).displacementX = $;
                      }
                    if (this.constraints.alignmentConstraint.horizontal)
                      for (var z = this.constraints.alignmentConstraint.horizontal, N = 0; N < z.length; N++) {
                        for (var B = 0, D = 0; D < z[N].length; D++) {
                          if (this.fixedNodeSet.has(z[N][D])) {
                            B = 0;
                            break;
                          }
                          B += this.idToNodeMap.get(z[N][D]).displacementY;
                        }
                        for (var G = B / z[N].length, D = 0; D < z[N].length; D++)
                          this.idToNodeMap.get(z[N][D]).displacementY = G;
                      }
                  }
                  if (this.constraints.relativePlacementConstraint)
                    if (m.RELAX_MOVEMENT_ON_CONSTRAINTS)
                      this.totalIterations % 10 == 0 && (this.shuffle(this.nodesInRelativeHorizontal), this.shuffle(this.nodesInRelativeVertical)), this.nodesInRelativeHorizontal.forEach(function(ce) {
                        if (!C.fixedNodesOnHorizontal.has(ce)) {
                          var J = 0;
                          C.dummyToNodeForVerticalAlignment.has(ce) ? J = C.idToNodeMap.get(C.dummyToNodeForVerticalAlignment.get(ce)[0]).displacementX : J = C.idToNodeMap.get(ce).displacementX, C.nodeToRelativeConstraintMapHorizontal.get(ce).forEach(function(ee) {
                            if (ee.right) {
                              var j = C.nodeToTempPositionMapHorizontal.get(ee.right) - C.nodeToTempPositionMapHorizontal.get(ce) - J;
                              j < ee.gap && (J -= ee.gap - j);
                            } else {
                              var j = C.nodeToTempPositionMapHorizontal.get(ce) - C.nodeToTempPositionMapHorizontal.get(ee.left) + J;
                              j < ee.gap && (J += ee.gap - j);
                            }
                          }), C.nodeToTempPositionMapHorizontal.set(ce, C.nodeToTempPositionMapHorizontal.get(ce) + J), C.dummyToNodeForVerticalAlignment.has(ce) ? C.dummyToNodeForVerticalAlignment.get(ce).forEach(function(ee) {
                            C.idToNodeMap.get(ee).displacementX = J;
                          }) : C.idToNodeMap.get(ce).displacementX = J;
                        }
                      }), this.nodesInRelativeVertical.forEach(function(ce) {
                        if (!C.fixedNodesOnHorizontal.has(ce)) {
                          var J = 0;
                          C.dummyToNodeForHorizontalAlignment.has(ce) ? J = C.idToNodeMap.get(C.dummyToNodeForHorizontalAlignment.get(ce)[0]).displacementY : J = C.idToNodeMap.get(ce).displacementY, C.nodeToRelativeConstraintMapVertical.get(ce).forEach(function(ee) {
                            if (ee.bottom) {
                              var j = C.nodeToTempPositionMapVertical.get(ee.bottom) - C.nodeToTempPositionMapVertical.get(ce) - J;
                              j < ee.gap && (J -= ee.gap - j);
                            } else {
                              var j = C.nodeToTempPositionMapVertical.get(ce) - C.nodeToTempPositionMapVertical.get(ee.top) + J;
                              j < ee.gap && (J += ee.gap - j);
                            }
                          }), C.nodeToTempPositionMapVertical.set(ce, C.nodeToTempPositionMapVertical.get(ce) + J), C.dummyToNodeForHorizontalAlignment.has(ce) ? C.dummyToNodeForHorizontalAlignment.get(ce).forEach(function(ee) {
                            C.idToNodeMap.get(ee).displacementY = J;
                          }) : C.idToNodeMap.get(ce).displacementY = J;
                        }
                      });
                    else {
                      for (var N = 0; N < this.componentsOnHorizontal.length; N++) {
                        var W = this.componentsOnHorizontal[N];
                        if (this.fixedComponentsOnHorizontal[N])
                          for (var D = 0; D < W.length; D++)
                            this.dummyToNodeForVerticalAlignment.has(W[D]) ? this.dummyToNodeForVerticalAlignment.get(W[D]).forEach(function(ee) {
                              C.idToNodeMap.get(ee).displacementX = 0;
                            }) : this.idToNodeMap.get(W[D]).displacementX = 0;
                        else {
                          for (var V = 0, U = 0, D = 0; D < W.length; D++)
                            if (this.dummyToNodeForVerticalAlignment.has(W[D])) {
                              var Z = this.dummyToNodeForVerticalAlignment.get(W[D]);
                              V += Z.length * this.idToNodeMap.get(Z[0]).displacementX, U += Z.length;
                            } else
                              V += this.idToNodeMap.get(W[D]).displacementX, U++;
                          for (var K = V / U, D = 0; D < W.length; D++)
                            this.dummyToNodeForVerticalAlignment.has(W[D]) ? this.dummyToNodeForVerticalAlignment.get(W[D]).forEach(function(ee) {
                              C.idToNodeMap.get(ee).displacementX = K;
                            }) : this.idToNodeMap.get(W[D]).displacementX = K;
                        }
                      }
                      for (var N = 0; N < this.componentsOnVertical.length; N++) {
                        var W = this.componentsOnVertical[N];
                        if (this.fixedComponentsOnVertical[N])
                          for (var D = 0; D < W.length; D++)
                            this.dummyToNodeForHorizontalAlignment.has(W[D]) ? this.dummyToNodeForHorizontalAlignment.get(W[D]).forEach(function(j) {
                              C.idToNodeMap.get(j).displacementY = 0;
                            }) : this.idToNodeMap.get(W[D]).displacementY = 0;
                        else {
                          for (var V = 0, U = 0, D = 0; D < W.length; D++)
                            if (this.dummyToNodeForHorizontalAlignment.has(W[D])) {
                              var Z = this.dummyToNodeForHorizontalAlignment.get(W[D]);
                              V += Z.length * this.idToNodeMap.get(Z[0]).displacementY, U += Z.length;
                            } else
                              V += this.idToNodeMap.get(W[D]).displacementY, U++;
                          for (var K = V / U, D = 0; D < W.length; D++)
                            this.dummyToNodeForHorizontalAlignment.has(W[D]) ? this.dummyToNodeForHorizontalAlignment.get(W[D]).forEach(function(Q) {
                              C.idToNodeMap.get(Q).displacementY = K;
                            }) : this.idToNodeMap.get(W[D]).displacementY = K;
                        }
                      }
                    }
                }, M.prototype.calculateNodesToApplyGravitationTo = function() {
                  var C = [], I, N = this.graphManager.getGraphs(), O = N.length, D;
                  for (D = 0; D < O; D++)
                    I = N[D], I.updateConnected(), I.isConnected || (C = C.concat(I.getNodes()));
                  return C;
                }, M.prototype.createBendpoints = function() {
                  var C = [];
                  C = C.concat(this.graphManager.getAllEdges());
                  var I = /* @__PURE__ */ new Set(), N;
                  for (N = 0; N < C.length; N++) {
                    var O = C[N];
                    if (!I.has(O)) {
                      var D = O.getSource(), $ = O.getTarget();
                      if (D == $)
                        O.getBendpoints().push(new T()), O.getBendpoints().push(new T()), this.createDummyNodesForBendpoints(O), I.add(O);
                      else {
                        var z = [];
                        if (z = z.concat(D.getEdgeListToNode($)), z = z.concat($.getEdgeListToNode(D)), !I.has(z[0])) {
                          if (z.length > 1) {
                            var B;
                            for (B = 0; B < z.length; B++) {
                              var G = z[B];
                              G.getBendpoints().push(new T()), this.createDummyNodesForBendpoints(G);
                            }
                          }
                          z.forEach(function(W) {
                            I.add(W);
                          });
                        }
                      }
                    }
                    if (I.size == C.length)
                      break;
                  }
                }, M.prototype.positionNodesRadially = function(C) {
                  for (var I = new x(0, 0), N = Math.ceil(Math.sqrt(C.length)), O = 0, D = 0, $ = 0, z = new T(0, 0), B = 0; B < C.length; B++) {
                    B % N == 0 && ($ = 0, D = O, B != 0 && (D += m.DEFAULT_COMPONENT_SEPERATION), O = 0);
                    var G = C[B], W = A.findCenterOfTree(G);
                    I.x = $, I.y = D, z = M.radialLayout(G, W, I), z.y > O && (O = Math.floor(z.y)), $ = Math.floor(z.x + m.DEFAULT_COMPONENT_SEPERATION);
                  }
                  this.transform(new T(b.WORLD_CENTER_X - z.x / 2, b.WORLD_CENTER_Y - z.y / 2));
                }, M.radialLayout = function(C, I, N) {
                  var O = Math.max(this.maxDiagonalInTree(C), m.DEFAULT_RADIAL_SEPARATION);
                  M.branchRadialLayout(I, null, 0, 359, 0, O);
                  var D = _.calculateBounds(C), $ = new R();
                  $.setDeviceOrgX(D.getMinX()), $.setDeviceOrgY(D.getMinY()), $.setWorldOrgX(N.x), $.setWorldOrgY(N.y);
                  for (var z = 0; z < C.length; z++) {
                    var B = C[z];
                    B.transform($);
                  }
                  var G = new T(D.getMaxX(), D.getMaxY());
                  return $.inverseTransformPoint(G);
                }, M.branchRadialLayout = function(C, I, N, O, D, $) {
                  var z = (O - N + 1) / 2;
                  z < 0 && (z += 180);
                  var B = (z + N) % 360, G = B * k.TWO_PI / 360, W = D * Math.cos(G), V = D * Math.sin(G);
                  C.setCenter(W, V);
                  var U = [];
                  U = U.concat(C.getEdges());
                  var Z = U.length;
                  I != null && Z--;
                  for (var K = 0, ce = U.length, J, ee = C.getEdgesBetween(I); ee.length > 1; ) {
                    var j = ee[0];
                    ee.splice(0, 1);
                    var X = U.indexOf(j);
                    X >= 0 && U.splice(X, 1), ce--, Z--;
                  }
                  I != null ? J = (U.indexOf(ee[0]) + 1) % ce : J = 0;
                  for (var re = Math.abs(O - N) / Z, Q = J; K != Z; Q = ++Q % ce) {
                    var ue = U[Q].getOtherEnd(C);
                    if (ue != I) {
                      var ne = (N + K * re) % 360, xe = (ne + re) % 360;
                      M.branchRadialLayout(ue, C, ne, xe, D + $, $), K++;
                    }
                  }
                }, M.maxDiagonalInTree = function(C) {
                  for (var I = S.MIN_VALUE, N = 0; N < C.length; N++) {
                    var O = C[N], D = O.getDiagonal();
                    D > I && (I = D);
                  }
                  return I;
                }, M.prototype.calcRepulsionRange = function() {
                  return 2 * (this.level + 1) * this.idealEdgeLength;
                }, M.prototype.groupZeroDegreeMembers = function() {
                  var C = this, I = {};
                  this.memberGroups = {}, this.idToDummyNode = {};
                  for (var N = [], O = this.graphManager.getAllNodes(), D = 0; D < O.length; D++) {
                    var $ = O[D], z = $.getParent();
                    this.getNodeDegreeWithChildren($) === 0 && (z.id == null || !this.getToBeTiled(z)) && N.push($);
                  }
                  for (var D = 0; D < N.length; D++) {
                    var $ = N[D], B = $.getParent().id;
                    typeof I[B] > "u" && (I[B] = []), I[B] = I[B].concat($);
                  }
                  Object.keys(I).forEach(function(G) {
                    if (I[G].length > 1) {
                      var W = "DummyCompound_" + G;
                      C.memberGroups[W] = I[G];
                      var V = I[G][0].getParent(), U = new p(C.graphManager);
                      U.id = W, U.paddingLeft = V.paddingLeft || 0, U.paddingRight = V.paddingRight || 0, U.paddingBottom = V.paddingBottom || 0, U.paddingTop = V.paddingTop || 0, C.idToDummyNode[W] = U;
                      var Z = C.getGraphManager().add(C.newGraph(), U), K = V.getChild();
                      K.add(U);
                      for (var ce = 0; ce < I[G].length; ce++) {
                        var J = I[G][ce];
                        K.remove(J), Z.add(J);
                      }
                    }
                  });
                }, M.prototype.clearCompounds = function() {
                  var C = {}, I = {};
                  this.performDFSOnCompounds();
                  for (var N = 0; N < this.compoundOrder.length; N++)
                    I[this.compoundOrder[N].id] = this.compoundOrder[N], C[this.compoundOrder[N].id] = [].concat(this.compoundOrder[N].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[N].getChild()), this.compoundOrder[N].child = null;
                  this.graphManager.resetAllNodes(), this.tileCompoundMembers(C, I);
                }, M.prototype.clearZeroDegreeMembers = function() {
                  var C = this, I = this.tiledZeroDegreePack = [];
                  Object.keys(this.memberGroups).forEach(function(N) {
                    var O = C.idToDummyNode[N];
                    if (I[N] = C.tileNodes(C.memberGroups[N], O.paddingLeft + O.paddingRight), O.rect.width = I[N].width, O.rect.height = I[N].height, O.setCenter(I[N].centerX, I[N].centerY), O.labelMarginLeft = 0, O.labelMarginTop = 0, m.NODE_DIMENSIONS_INCLUDE_LABELS) {
                      var D = O.rect.width, $ = O.rect.height;
                      O.labelWidth && (O.labelPosHorizontal == "left" ? (O.rect.x -= O.labelWidth, O.setWidth(D + O.labelWidth), O.labelMarginLeft = O.labelWidth) : O.labelPosHorizontal == "center" && O.labelWidth > D ? (O.rect.x -= (O.labelWidth - D) / 2, O.setWidth(O.labelWidth), O.labelMarginLeft = (O.labelWidth - D) / 2) : O.labelPosHorizontal == "right" && O.setWidth(D + O.labelWidth)), O.labelHeight && (O.labelPosVertical == "top" ? (O.rect.y -= O.labelHeight, O.setHeight($ + O.labelHeight), O.labelMarginTop = O.labelHeight) : O.labelPosVertical == "center" && O.labelHeight > $ ? (O.rect.y -= (O.labelHeight - $) / 2, O.setHeight(O.labelHeight), O.labelMarginTop = (O.labelHeight - $) / 2) : O.labelPosVertical == "bottom" && O.setHeight($ + O.labelHeight));
                    }
                  });
                }, M.prototype.repopulateCompounds = function() {
                  for (var C = this.compoundOrder.length - 1; C >= 0; C--) {
                    var I = this.compoundOrder[C], N = I.id, O = I.paddingLeft, D = I.paddingTop, $ = I.labelMarginLeft, z = I.labelMarginTop;
                    this.adjustLocations(this.tiledMemberPack[N], I.rect.x, I.rect.y, O, D, $, z);
                  }
                }, M.prototype.repopulateZeroDegreeMembers = function() {
                  var C = this, I = this.tiledZeroDegreePack;
                  Object.keys(I).forEach(function(N) {
                    var O = C.idToDummyNode[N], D = O.paddingLeft, $ = O.paddingTop, z = O.labelMarginLeft, B = O.labelMarginTop;
                    C.adjustLocations(I[N], O.rect.x, O.rect.y, D, $, z, B);
                  });
                }, M.prototype.getToBeTiled = function(C) {
                  var I = C.id;
                  if (this.toBeTiled[I] != null)
                    return this.toBeTiled[I];
                  var N = C.getChild();
                  if (N == null)
                    return this.toBeTiled[I] = !1, !1;
                  for (var O = N.getNodes(), D = 0; D < O.length; D++) {
                    var $ = O[D];
                    if (this.getNodeDegree($) > 0)
                      return this.toBeTiled[I] = !1, !1;
                    if ($.getChild() == null) {
                      this.toBeTiled[$.id] = !1;
                      continue;
                    }
                    if (!this.getToBeTiled($))
                      return this.toBeTiled[I] = !1, !1;
                  }
                  return this.toBeTiled[I] = !0, !0;
                }, M.prototype.getNodeDegree = function(C) {
                  C.id;
                  for (var I = C.getEdges(), N = 0, O = 0; O < I.length; O++) {
                    var D = I[O];
                    D.getSource().id !== D.getTarget().id && (N = N + 1);
                  }
                  return N;
                }, M.prototype.getNodeDegreeWithChildren = function(C) {
                  var I = this.getNodeDegree(C);
                  if (C.getChild() == null)
                    return I;
                  for (var N = C.getChild().getNodes(), O = 0; O < N.length; O++) {
                    var D = N[O];
                    I += this.getNodeDegreeWithChildren(D);
                  }
                  return I;
                }, M.prototype.performDFSOnCompounds = function() {
                  this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
                }, M.prototype.fillCompexOrderByDFS = function(C) {
                  for (var I = 0; I < C.length; I++) {
                    var N = C[I];
                    N.getChild() != null && this.fillCompexOrderByDFS(N.getChild().getNodes()), this.getToBeTiled(N) && this.compoundOrder.push(N);
                  }
                }, M.prototype.adjustLocations = function(C, I, N, O, D, $, z) {
                  I += O + $, N += D + z;
                  for (var B = I, G = 0; G < C.rows.length; G++) {
                    var W = C.rows[G];
                    I = B;
                    for (var V = 0, U = 0; U < W.length; U++) {
                      var Z = W[U];
                      Z.rect.x = I, Z.rect.y = N, I += Z.rect.width + C.horizontalPadding, Z.rect.height > V && (V = Z.rect.height);
                    }
                    N += V + C.verticalPadding;
                  }
                }, M.prototype.tileCompoundMembers = function(C, I) {
                  var N = this;
                  this.tiledMemberPack = [], Object.keys(C).forEach(function(O) {
                    var D = I[O];
                    if (N.tiledMemberPack[O] = N.tileNodes(C[O], D.paddingLeft + D.paddingRight), D.rect.width = N.tiledMemberPack[O].width, D.rect.height = N.tiledMemberPack[O].height, D.setCenter(N.tiledMemberPack[O].centerX, N.tiledMemberPack[O].centerY), D.labelMarginLeft = 0, D.labelMarginTop = 0, m.NODE_DIMENSIONS_INCLUDE_LABELS) {
                      var $ = D.rect.width, z = D.rect.height;
                      D.labelWidth && (D.labelPosHorizontal == "left" ? (D.rect.x -= D.labelWidth, D.setWidth($ + D.labelWidth), D.labelMarginLeft = D.labelWidth) : D.labelPosHorizontal == "center" && D.labelWidth > $ ? (D.rect.x -= (D.labelWidth - $) / 2, D.setWidth(D.labelWidth), D.labelMarginLeft = (D.labelWidth - $) / 2) : D.labelPosHorizontal == "right" && D.setWidth($ + D.labelWidth)), D.labelHeight && (D.labelPosVertical == "top" ? (D.rect.y -= D.labelHeight, D.setHeight(z + D.labelHeight), D.labelMarginTop = D.labelHeight) : D.labelPosVertical == "center" && D.labelHeight > z ? (D.rect.y -= (D.labelHeight - z) / 2, D.setHeight(D.labelHeight), D.labelMarginTop = (D.labelHeight - z) / 2) : D.labelPosVertical == "bottom" && D.setHeight(z + D.labelHeight));
                    }
                  });
                }, M.prototype.tileNodes = function(C, I) {
                  var N = this.tileNodesByFavoringDim(C, I, !0), O = this.tileNodesByFavoringDim(C, I, !1), D = this.getOrgRatio(N), $ = this.getOrgRatio(O), z;
                  return $ < D ? z = O : z = N, z;
                }, M.prototype.getOrgRatio = function(C) {
                  var I = C.width, N = C.height, O = I / N;
                  return O < 1 && (O = 1 / O), O;
                }, M.prototype.calcIdealRowWidth = function(C, I) {
                  var N = m.TILING_PADDING_VERTICAL, O = m.TILING_PADDING_HORIZONTAL, D = C.length, $ = 0, z = 0, B = 0;
                  C.forEach(function(ce) {
                    $ += ce.getWidth(), z += ce.getHeight(), ce.getWidth() > B && (B = ce.getWidth());
                  });
                  var G = $ / D, W = z / D, V = Math.pow(N - O, 2) + 4 * (G + O) * (W + N) * D, U = (O - N + Math.sqrt(V)) / (2 * (G + O)), Z;
                  I ? (Z = Math.ceil(U), Z == U && Z++) : Z = Math.floor(U);
                  var K = Z * (G + O) - O;
                  return B > K && (K = B), K += O * 2, K;
                }, M.prototype.tileNodesByFavoringDim = function(C, I, N) {
                  var O = m.TILING_PADDING_VERTICAL, D = m.TILING_PADDING_HORIZONTAL, $ = m.TILING_COMPARE_BY, z = {
                    rows: [],
                    rowWidth: [],
                    rowHeight: [],
                    width: 0,
                    height: I,
                    // assume minHeight equals to minWidth
                    verticalPadding: O,
                    horizontalPadding: D,
                    centerX: 0,
                    centerY: 0
                  };
                  $ && (z.idealRowWidth = this.calcIdealRowWidth(C, N));
                  var B = function(J) {
                    return J.rect.width * J.rect.height;
                  }, G = function(J, ee) {
                    return B(ee) - B(J);
                  };
                  C.sort(function(ce, J) {
                    var ee = G;
                    return z.idealRowWidth ? (ee = $, ee(ce.id, J.id)) : ee(ce, J);
                  });
                  for (var W = 0, V = 0, U = 0; U < C.length; U++) {
                    var Z = C[U];
                    W += Z.getCenterX(), V += Z.getCenterY();
                  }
                  z.centerX = W / C.length, z.centerY = V / C.length;
                  for (var U = 0; U < C.length; U++) {
                    var Z = C[U];
                    if (z.rows.length == 0)
                      this.insertNodeToRow(z, Z, 0, I);
                    else if (this.canAddHorizontal(z, Z.rect.width, Z.rect.height)) {
                      var K = z.rows.length - 1;
                      z.idealRowWidth || (K = this.getShortestRowIndex(z)), this.insertNodeToRow(z, Z, K, I);
                    } else
                      this.insertNodeToRow(z, Z, z.rows.length, I);
                    this.shiftToLastRow(z);
                  }
                  return z;
                }, M.prototype.insertNodeToRow = function(C, I, N, O) {
                  var D = O;
                  if (N == C.rows.length) {
                    var $ = [];
                    C.rows.push($), C.rowWidth.push(D), C.rowHeight.push(0);
                  }
                  var z = C.rowWidth[N] + I.rect.width;
                  C.rows[N].length > 0 && (z += C.horizontalPadding), C.rowWidth[N] = z, C.width < z && (C.width = z);
                  var B = I.rect.height;
                  N > 0 && (B += C.verticalPadding);
                  var G = 0;
                  B > C.rowHeight[N] && (G = C.rowHeight[N], C.rowHeight[N] = B, G = C.rowHeight[N] - G), C.height += G, C.rows[N].push(I);
                }, M.prototype.getShortestRowIndex = function(C) {
                  for (var I = -1, N = Number.MAX_VALUE, O = 0; O < C.rows.length; O++)
                    C.rowWidth[O] < N && (I = O, N = C.rowWidth[O]);
                  return I;
                }, M.prototype.getLongestRowIndex = function(C) {
                  for (var I = -1, N = Number.MIN_VALUE, O = 0; O < C.rows.length; O++)
                    C.rowWidth[O] > N && (I = O, N = C.rowWidth[O]);
                  return I;
                }, M.prototype.canAddHorizontal = function(C, I, N) {
                  if (C.idealRowWidth) {
                    var O = C.rows.length - 1, D = C.rowWidth[O];
                    return D + I + C.horizontalPadding <= C.idealRowWidth;
                  }
                  var $ = this.getShortestRowIndex(C);
                  if ($ < 0)
                    return !0;
                  var z = C.rowWidth[$];
                  if (z + C.horizontalPadding + I <= C.width) return !0;
                  var B = 0;
                  C.rowHeight[$] < N && $ > 0 && (B = N + C.verticalPadding - C.rowHeight[$]);
                  var G;
                  C.width - z >= I + C.horizontalPadding ? G = (C.height + B) / (z + I + C.horizontalPadding) : G = (C.height + B) / C.width, B = N + C.verticalPadding;
                  var W;
                  return C.width < I ? W = (C.height + B) / I : W = (C.height + B) / C.width, W < 1 && (W = 1 / W), G < 1 && (G = 1 / G), G < W;
                }, M.prototype.shiftToLastRow = function(C) {
                  var I = this.getLongestRowIndex(C), N = C.rowWidth.length - 1, O = C.rows[I], D = O[O.length - 1], $ = D.width + C.horizontalPadding;
                  if (C.width - C.rowWidth[N] > $ && I != N) {
                    O.splice(-1, 1), C.rows[N].push(D), C.rowWidth[I] = C.rowWidth[I] - $, C.rowWidth[N] = C.rowWidth[N] + $, C.width = C.rowWidth[instance.getLongestRowIndex(C)];
                    for (var z = Number.MIN_VALUE, B = 0; B < O.length; B++)
                      O[B].height > z && (z = O[B].height);
                    I > 0 && (z += C.verticalPadding);
                    var G = C.rowHeight[I] + C.rowHeight[N];
                    C.rowHeight[I] = z, C.rowHeight[N] < D.height + C.verticalPadding && (C.rowHeight[N] = D.height + C.verticalPadding);
                    var W = C.rowHeight[I] + C.rowHeight[N];
                    C.height += W - G, this.shiftToLastRow(C);
                  }
                }, M.prototype.tilingPreLayout = function() {
                  m.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
                }, M.prototype.tilingPostLayout = function() {
                  m.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
                }, M.prototype.reduceTrees = function() {
                  for (var C = [], I = !0, N; I; ) {
                    var O = this.graphManager.getAllNodes(), D = [];
                    I = !1;
                    for (var $ = 0; $ < O.length; $++)
                      if (N = O[$], N.getEdges().length == 1 && !N.getEdges()[0].isInterGraph && N.getChild() == null) {
                        if (m.PURE_INCREMENTAL) {
                          var z = N.getEdges()[0].getOtherEnd(N), B = new E(N.getCenterX() - z.getCenterX(), N.getCenterY() - z.getCenterY());
                          D.push([N, N.getEdges()[0], N.getOwner(), B]);
                        } else
                          D.push([N, N.getEdges()[0], N.getOwner()]);
                        I = !0;
                      }
                    if (I == !0) {
                      for (var G = [], W = 0; W < D.length; W++)
                        D[W][0].getEdges().length == 1 && (G.push(D[W]), D[W][0].getOwner().remove(D[W][0]));
                      C.push(G), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                    }
                  }
                  this.prunedNodesAll = C;
                }, M.prototype.growTree = function(C) {
                  for (var I = C.length, N = C[I - 1], O, D = 0; D < N.length; D++)
                    O = N[D], this.findPlaceforPrunedNode(O), O[2].add(O[0]), O[2].add(O[1], O[1].source, O[1].target);
                  C.splice(C.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                }, M.prototype.findPlaceforPrunedNode = function(C) {
                  var I, N, O = C[0];
                  if (O == C[1].source ? N = C[1].target : N = C[1].source, m.PURE_INCREMENTAL)
                    O.setCenter(N.getCenterX() + C[3].getWidth(), N.getCenterY() + C[3].getHeight());
                  else {
                    var D = N.startX, $ = N.finishX, z = N.startY, B = N.finishY, G = 0, W = 0, V = 0, U = 0, Z = [G, V, W, U];
                    if (z > 0)
                      for (var K = D; K <= $; K++)
                        Z[0] += this.grid[K][z - 1].length + this.grid[K][z].length - 1;
                    if ($ < this.grid.length - 1)
                      for (var K = z; K <= B; K++)
                        Z[1] += this.grid[$ + 1][K].length + this.grid[$][K].length - 1;
                    if (B < this.grid[0].length - 1)
                      for (var K = D; K <= $; K++)
                        Z[2] += this.grid[K][B + 1].length + this.grid[K][B].length - 1;
                    if (D > 0)
                      for (var K = z; K <= B; K++)
                        Z[3] += this.grid[D - 1][K].length + this.grid[D][K].length - 1;
                    for (var ce = S.MAX_VALUE, J, ee, j = 0; j < Z.length; j++)
                      Z[j] < ce ? (ce = Z[j], J = 1, ee = j) : Z[j] == ce && J++;
                    if (J == 3 && ce == 0)
                      Z[0] == 0 && Z[1] == 0 && Z[2] == 0 ? I = 1 : Z[0] == 0 && Z[1] == 0 && Z[3] == 0 ? I = 0 : Z[0] == 0 && Z[2] == 0 && Z[3] == 0 ? I = 3 : Z[1] == 0 && Z[2] == 0 && Z[3] == 0 && (I = 2);
                    else if (J == 2 && ce == 0) {
                      var X = Math.floor(Math.random() * 2);
                      Z[0] == 0 && Z[1] == 0 ? X == 0 ? I = 0 : I = 1 : Z[0] == 0 && Z[2] == 0 ? X == 0 ? I = 0 : I = 2 : Z[0] == 0 && Z[3] == 0 ? X == 0 ? I = 0 : I = 3 : Z[1] == 0 && Z[2] == 0 ? X == 0 ? I = 1 : I = 2 : Z[1] == 0 && Z[3] == 0 ? X == 0 ? I = 1 : I = 3 : X == 0 ? I = 2 : I = 3;
                    } else if (J == 4 && ce == 0) {
                      var X = Math.floor(Math.random() * 4);
                      I = X;
                    } else
                      I = ee;
                    I == 0 ? O.setCenter(N.getCenterX(), N.getCenterY() - N.getHeight() / 2 - y.DEFAULT_EDGE_LENGTH - O.getHeight() / 2) : I == 1 ? O.setCenter(N.getCenterX() + N.getWidth() / 2 + y.DEFAULT_EDGE_LENGTH + O.getWidth() / 2, N.getCenterY()) : I == 2 ? O.setCenter(N.getCenterX(), N.getCenterY() + N.getHeight() / 2 + y.DEFAULT_EDGE_LENGTH + O.getHeight() / 2) : O.setCenter(N.getCenterX() - N.getWidth() / 2 - y.DEFAULT_EDGE_LENGTH - O.getWidth() / 2, N.getCenterY());
                  }
                }, o.exports = M;
              })
            ),
            /***/
            991: (
              /***/
              ((o, l, u) => {
                var h = u(551).FDLayoutNode, f = u(551).IMath;
                function d(g, m, v, y) {
                  h.call(this, g, m, v, y);
                }
                d.prototype = Object.create(h.prototype);
                for (var p in h)
                  d[p] = h[p];
                d.prototype.calculateDisplacement = function() {
                  var g = this.graphManager.getLayout();
                  this.getChild() != null && this.fixedNodeWeight ? (this.displacementX += g.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight, this.displacementY += g.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight) : (this.displacementX += g.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY += g.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren), Math.abs(this.displacementX) > g.coolingFactor * g.maxNodeDisplacement && (this.displacementX = g.coolingFactor * g.maxNodeDisplacement * f.sign(this.displacementX)), Math.abs(this.displacementY) > g.coolingFactor * g.maxNodeDisplacement && (this.displacementY = g.coolingFactor * g.maxNodeDisplacement * f.sign(this.displacementY)), this.child && this.child.getNodes().length > 0 && this.propogateDisplacementToChildren(this.displacementX, this.displacementY);
                }, d.prototype.propogateDisplacementToChildren = function(g, m) {
                  for (var v = this.getChild().getNodes(), y, b = 0; b < v.length; b++)
                    y = v[b], y.getChild() == null ? (y.displacementX += g, y.displacementY += m) : y.propogateDisplacementToChildren(g, m);
                }, d.prototype.move = function() {
                  var g = this.graphManager.getLayout();
                  (this.child == null || this.child.getNodes().length == 0) && (this.moveBy(this.displacementX, this.displacementY), g.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY)), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
                }, d.prototype.setPred1 = function(g) {
                  this.pred1 = g;
                }, d.prototype.getPred1 = function() {
                  return pred1;
                }, d.prototype.getPred2 = function() {
                  return pred2;
                }, d.prototype.setNext = function(g) {
                  this.next = g;
                }, d.prototype.getNext = function() {
                  return next;
                }, d.prototype.setProcessed = function(g) {
                  this.processed = g;
                }, d.prototype.isProcessed = function() {
                  return processed;
                }, o.exports = d;
              })
            ),
            /***/
            902: (
              /***/
              ((o, l, u) => {
                function h(v) {
                  if (Array.isArray(v)) {
                    for (var y = 0, b = Array(v.length); y < v.length; y++)
                      b[y] = v[y];
                    return b;
                  } else
                    return Array.from(v);
                }
                var f = u(806), d = u(551).LinkedList, p = u(551).Matrix, g = u(551).SVD;
                function m() {
                }
                m.handleConstraints = function(v) {
                  var y = {};
                  y.fixedNodeConstraint = v.constraints.fixedNodeConstraint, y.alignmentConstraint = v.constraints.alignmentConstraint, y.relativePlacementConstraint = v.constraints.relativePlacementConstraint;
                  for (var b = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), T = [], E = [], A = v.getAllNodes(), S = 0, k = 0; k < A.length; k++) {
                    var _ = A[k];
                    _.getChild() == null && (x.set(_.id, S++), T.push(_.getCenterX()), E.push(_.getCenterY()), b.set(_.id, _));
                  }
                  y.relativePlacementConstraint && y.relativePlacementConstraint.forEach(function(he) {
                    !he.gap && he.gap != 0 && (he.left ? he.gap = f.DEFAULT_EDGE_LENGTH + b.get(he.left).getWidth() / 2 + b.get(he.right).getWidth() / 2 : he.gap = f.DEFAULT_EDGE_LENGTH + b.get(he.top).getHeight() / 2 + b.get(he.bottom).getHeight() / 2);
                  });
                  var R = function(F, oe) {
                    return { x: F.x - oe.x, y: F.y - oe.y };
                  }, L = function(F) {
                    var oe = 0, se = 0;
                    return F.forEach(function(ge) {
                      oe += T[x.get(ge)], se += E[x.get(ge)];
                    }), { x: oe / F.size, y: se / F.size };
                  }, M = function(F, oe, se, ge, de) {
                    function we(Pe, Ve) {
                      var ht = new Set(Pe), st = !0, Ue = !1, Et = void 0;
                      try {
                        for (var He = Ve[Symbol.iterator](), rt; !(st = (rt = He.next()).done); st = !0) {
                          var ct = rt.value;
                          ht.add(ct);
                        }
                      } catch (ut) {
                        Ue = !0, Et = ut;
                      } finally {
                        try {
                          !st && He.return && He.return();
                        } finally {
                          if (Ue)
                            throw Et;
                        }
                      }
                      return ht;
                    }
                    var _e = /* @__PURE__ */ new Map();
                    F.forEach(function(Pe, Ve) {
                      _e.set(Ve, 0);
                    }), F.forEach(function(Pe, Ve) {
                      Pe.forEach(function(ht) {
                        _e.set(ht.id, _e.get(ht.id) + 1);
                      });
                    });
                    var Se = /* @__PURE__ */ new Map(), Me = /* @__PURE__ */ new Map(), Xe = new d();
                    _e.forEach(function(Pe, Ve) {
                      Pe == 0 ? (Xe.push(Ve), se || (oe == "horizontal" ? Se.set(Ve, x.has(Ve) ? T[x.get(Ve)] : ge.get(Ve)) : Se.set(Ve, x.has(Ve) ? E[x.get(Ve)] : ge.get(Ve)))) : Se.set(Ve, Number.NEGATIVE_INFINITY), se && Me.set(Ve, /* @__PURE__ */ new Set([Ve]));
                    }), se && de.forEach(function(Pe) {
                      var Ve = [];
                      if (Pe.forEach(function(Ue) {
                        se.has(Ue) && Ve.push(Ue);
                      }), Ve.length > 0) {
                        var ht = 0;
                        Ve.forEach(function(Ue) {
                          oe == "horizontal" ? (Se.set(Ue, x.has(Ue) ? T[x.get(Ue)] : ge.get(Ue)), ht += Se.get(Ue)) : (Se.set(Ue, x.has(Ue) ? E[x.get(Ue)] : ge.get(Ue)), ht += Se.get(Ue));
                        }), ht = ht / Ve.length, Pe.forEach(function(Ue) {
                          se.has(Ue) || Se.set(Ue, ht);
                        });
                      } else {
                        var st = 0;
                        Pe.forEach(function(Ue) {
                          oe == "horizontal" ? st += x.has(Ue) ? T[x.get(Ue)] : ge.get(Ue) : st += x.has(Ue) ? E[x.get(Ue)] : ge.get(Ue);
                        }), st = st / Pe.length, Pe.forEach(function(Ue) {
                          Se.set(Ue, st);
                        });
                      }
                    });
                    for (var We = function() {
                      var Ve = Xe.shift(), ht = F.get(Ve);
                      ht.forEach(function(st) {
                        if (Se.get(st.id) < Se.get(Ve) + st.gap)
                          if (se && se.has(st.id)) {
                            var Ue = void 0;
                            if (oe == "horizontal" ? Ue = x.has(st.id) ? T[x.get(st.id)] : ge.get(st.id) : Ue = x.has(st.id) ? E[x.get(st.id)] : ge.get(st.id), Se.set(st.id, Ue), Ue < Se.get(Ve) + st.gap) {
                              var Et = Se.get(Ve) + st.gap - Ue;
                              Me.get(Ve).forEach(function(He) {
                                Se.set(He, Se.get(He) - Et);
                              });
                            }
                          } else
                            Se.set(st.id, Se.get(Ve) + st.gap);
                        _e.set(st.id, _e.get(st.id) - 1), _e.get(st.id) == 0 && Xe.push(st.id), se && Me.set(st.id, we(Me.get(Ve), Me.get(st.id)));
                      });
                    }; Xe.length != 0; )
                      We();
                    if (se) {
                      var Ke = /* @__PURE__ */ new Set();
                      F.forEach(function(Pe, Ve) {
                        Pe.length == 0 && Ke.add(Ve);
                      });
                      var Ze = [];
                      Me.forEach(function(Pe, Ve) {
                        if (Ke.has(Ve)) {
                          var ht = !1, st = !0, Ue = !1, Et = void 0;
                          try {
                            for (var He = Pe[Symbol.iterator](), rt; !(st = (rt = He.next()).done); st = !0) {
                              var ct = rt.value;
                              se.has(ct) && (ht = !0);
                            }
                          } catch (bt) {
                            Ue = !0, Et = bt;
                          } finally {
                            try {
                              !st && He.return && He.return();
                            } finally {
                              if (Ue)
                                throw Et;
                            }
                          }
                          if (!ht) {
                            var ut = !1, nt = void 0;
                            Ze.forEach(function(bt, er) {
                              bt.has([].concat(h(Pe))[0]) && (ut = !0, nt = er);
                            }), ut ? Pe.forEach(function(bt) {
                              Ze[nt].add(bt);
                            }) : Ze.push(new Set(Pe));
                          }
                        }
                      }), Ze.forEach(function(Pe, Ve) {
                        var ht = Number.POSITIVE_INFINITY, st = Number.POSITIVE_INFINITY, Ue = Number.NEGATIVE_INFINITY, Et = Number.NEGATIVE_INFINITY, He = !0, rt = !1, ct = void 0;
                        try {
                          for (var ut = Pe[Symbol.iterator](), nt; !(He = (nt = ut.next()).done); He = !0) {
                            var bt = nt.value, er = void 0;
                            oe == "horizontal" ? er = x.has(bt) ? T[x.get(bt)] : ge.get(bt) : er = x.has(bt) ? E[x.get(bt)] : ge.get(bt);
                            var Dt = Se.get(bt);
                            er < ht && (ht = er), er > Ue && (Ue = er), Dt < st && (st = Dt), Dt > Et && (Et = Dt);
                          }
                        } catch (ke) {
                          rt = !0, ct = ke;
                        } finally {
                          try {
                            !He && ut.return && ut.return();
                          } finally {
                            if (rt)
                              throw ct;
                          }
                        }
                        var ir = (ht + Ue) / 2 - (st + Et) / 2, wr = !0, ar = !1, Wt = void 0;
                        try {
                          for (var ur = Pe[Symbol.iterator](), cn; !(wr = (cn = ur.next()).done); wr = !0) {
                            var ft = cn.value;
                            Se.set(ft, Se.get(ft) + ir);
                          }
                        } catch (ke) {
                          ar = !0, Wt = ke;
                        } finally {
                          try {
                            !wr && ur.return && ur.return();
                          } finally {
                            if (ar)
                              throw Wt;
                          }
                        }
                      });
                    }
                    return Se;
                  }, P = function(F) {
                    var oe = 0, se = 0, ge = 0, de = 0;
                    if (F.forEach(function(Me) {
                      Me.left ? T[x.get(Me.left)] - T[x.get(Me.right)] >= 0 ? oe++ : se++ : E[x.get(Me.top)] - E[x.get(Me.bottom)] >= 0 ? ge++ : de++;
                    }), oe > se && ge > de)
                      for (var we = 0; we < x.size; we++)
                        T[we] = -1 * T[we], E[we] = -1 * E[we];
                    else if (oe > se)
                      for (var _e = 0; _e < x.size; _e++)
                        T[_e] = -1 * T[_e];
                    else if (ge > de)
                      for (var Se = 0; Se < x.size; Se++)
                        E[Se] = -1 * E[Se];
                  }, C = function(F) {
                    var oe = [], se = new d(), ge = /* @__PURE__ */ new Set(), de = 0;
                    return F.forEach(function(we, _e) {
                      if (!ge.has(_e)) {
                        oe[de] = [];
                        var Se = _e;
                        for (se.push(Se), ge.add(Se), oe[de].push(Se); se.length != 0; ) {
                          Se = se.shift();
                          var Me = F.get(Se);
                          Me.forEach(function(Xe) {
                            ge.has(Xe.id) || (se.push(Xe.id), ge.add(Xe.id), oe[de].push(Xe.id));
                          });
                        }
                        de++;
                      }
                    }), oe;
                  }, I = function(F) {
                    var oe = /* @__PURE__ */ new Map();
                    return F.forEach(function(se, ge) {
                      oe.set(ge, []);
                    }), F.forEach(function(se, ge) {
                      se.forEach(function(de) {
                        oe.get(ge).push(de), oe.get(de.id).push({ id: ge, gap: de.gap, direction: de.direction });
                      });
                    }), oe;
                  }, N = function(F) {
                    var oe = /* @__PURE__ */ new Map();
                    return F.forEach(function(se, ge) {
                      oe.set(ge, []);
                    }), F.forEach(function(se, ge) {
                      se.forEach(function(de) {
                        oe.get(de.id).push({ id: ge, gap: de.gap, direction: de.direction });
                      });
                    }), oe;
                  }, O = [], D = [], $ = !1, z = !1, B = /* @__PURE__ */ new Set(), G = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), V = [];
                  if (y.fixedNodeConstraint && y.fixedNodeConstraint.forEach(function(he) {
                    B.add(he.nodeId);
                  }), y.relativePlacementConstraint && (y.relativePlacementConstraint.forEach(function(he) {
                    he.left ? (G.has(he.left) ? G.get(he.left).push({ id: he.right, gap: he.gap, direction: "horizontal" }) : G.set(he.left, [{ id: he.right, gap: he.gap, direction: "horizontal" }]), G.has(he.right) || G.set(he.right, [])) : (G.has(he.top) ? G.get(he.top).push({ id: he.bottom, gap: he.gap, direction: "vertical" }) : G.set(he.top, [{ id: he.bottom, gap: he.gap, direction: "vertical" }]), G.has(he.bottom) || G.set(he.bottom, []));
                  }), W = I(G), V = C(W)), f.TRANSFORM_ON_CONSTRAINT_HANDLING) {
                    if (y.fixedNodeConstraint && y.fixedNodeConstraint.length > 1)
                      y.fixedNodeConstraint.forEach(function(he, F) {
                        O[F] = [he.position.x, he.position.y], D[F] = [T[x.get(he.nodeId)], E[x.get(he.nodeId)]];
                      }), $ = !0;
                    else if (y.alignmentConstraint)
                      (function() {
                        var he = 0;
                        if (y.alignmentConstraint.vertical) {
                          for (var F = y.alignmentConstraint.vertical, oe = function(Se) {
                            var Me = /* @__PURE__ */ new Set();
                            F[Se].forEach(function(Ke) {
                              Me.add(Ke);
                            });
                            var Xe = new Set([].concat(h(Me)).filter(function(Ke) {
                              return B.has(Ke);
                            })), We = void 0;
                            Xe.size > 0 ? We = T[x.get(Xe.values().next().value)] : We = L(Me).x, F[Se].forEach(function(Ke) {
                              O[he] = [We, E[x.get(Ke)]], D[he] = [T[x.get(Ke)], E[x.get(Ke)]], he++;
                            });
                          }, se = 0; se < F.length; se++)
                            oe(se);
                          $ = !0;
                        }
                        if (y.alignmentConstraint.horizontal) {
                          for (var ge = y.alignmentConstraint.horizontal, de = function(Se) {
                            var Me = /* @__PURE__ */ new Set();
                            ge[Se].forEach(function(Ke) {
                              Me.add(Ke);
                            });
                            var Xe = new Set([].concat(h(Me)).filter(function(Ke) {
                              return B.has(Ke);
                            })), We = void 0;
                            Xe.size > 0 ? We = T[x.get(Xe.values().next().value)] : We = L(Me).y, ge[Se].forEach(function(Ke) {
                              O[he] = [T[x.get(Ke)], We], D[he] = [T[x.get(Ke)], E[x.get(Ke)]], he++;
                            });
                          }, we = 0; we < ge.length; we++)
                            de(we);
                          $ = !0;
                        }
                        y.relativePlacementConstraint && (z = !0);
                      })();
                    else if (y.relativePlacementConstraint) {
                      for (var U = 0, Z = 0, K = 0; K < V.length; K++)
                        V[K].length > U && (U = V[K].length, Z = K);
                      if (U < W.size / 2)
                        P(y.relativePlacementConstraint), $ = !1, z = !1;
                      else {
                        var ce = /* @__PURE__ */ new Map(), J = /* @__PURE__ */ new Map(), ee = [];
                        V[Z].forEach(function(he) {
                          G.get(he).forEach(function(F) {
                            F.direction == "horizontal" ? (ce.has(he) ? ce.get(he).push(F) : ce.set(he, [F]), ce.has(F.id) || ce.set(F.id, []), ee.push({ left: he, right: F.id })) : (J.has(he) ? J.get(he).push(F) : J.set(he, [F]), J.has(F.id) || J.set(F.id, []), ee.push({ top: he, bottom: F.id }));
                          });
                        }), P(ee), z = !1;
                        var j = M(ce, "horizontal"), X = M(J, "vertical");
                        V[Z].forEach(function(he, F) {
                          D[F] = [T[x.get(he)], E[x.get(he)]], O[F] = [], j.has(he) ? O[F][0] = j.get(he) : O[F][0] = T[x.get(he)], X.has(he) ? O[F][1] = X.get(he) : O[F][1] = E[x.get(he)];
                        }), $ = !0;
                      }
                    }
                    if ($) {
                      for (var re = void 0, Q = p.transpose(O), ue = p.transpose(D), ne = 0; ne < Q.length; ne++)
                        Q[ne] = p.multGamma(Q[ne]), ue[ne] = p.multGamma(ue[ne]);
                      var xe = p.multMat(Q, p.transpose(ue)), Y = g.svd(xe);
                      re = p.multMat(Y.V, p.transpose(Y.U));
                      for (var Ne = 0; Ne < x.size; Ne++) {
                        var fe = [T[Ne], E[Ne]], qe = [re[0][0], re[1][0]], ze = [re[0][1], re[1][1]];
                        T[Ne] = p.dotProduct(fe, qe), E[Ne] = p.dotProduct(fe, ze);
                      }
                      z && P(y.relativePlacementConstraint);
                    }
                  }
                  if (f.ENFORCE_CONSTRAINTS) {
                    if (y.fixedNodeConstraint && y.fixedNodeConstraint.length > 0) {
                      var Ge = { x: 0, y: 0 };
                      y.fixedNodeConstraint.forEach(function(he, F) {
                        var oe = { x: T[x.get(he.nodeId)], y: E[x.get(he.nodeId)] }, se = he.position, ge = R(se, oe);
                        Ge.x += ge.x, Ge.y += ge.y;
                      }), Ge.x /= y.fixedNodeConstraint.length, Ge.y /= y.fixedNodeConstraint.length, T.forEach(function(he, F) {
                        T[F] += Ge.x;
                      }), E.forEach(function(he, F) {
                        E[F] += Ge.y;
                      }), y.fixedNodeConstraint.forEach(function(he) {
                        T[x.get(he.nodeId)] = he.position.x, E[x.get(he.nodeId)] = he.position.y;
                      });
                    }
                    if (y.alignmentConstraint) {
                      if (y.alignmentConstraint.vertical)
                        for (var Ee = y.alignmentConstraint.vertical, Oe = function(F) {
                          var oe = /* @__PURE__ */ new Set();
                          Ee[F].forEach(function(de) {
                            oe.add(de);
                          });
                          var se = new Set([].concat(h(oe)).filter(function(de) {
                            return B.has(de);
                          })), ge = void 0;
                          se.size > 0 ? ge = T[x.get(se.values().next().value)] : ge = L(oe).x, oe.forEach(function(de) {
                            B.has(de) || (T[x.get(de)] = ge);
                          });
                        }, Ce = 0; Ce < Ee.length; Ce++)
                          Oe(Ce);
                      if (y.alignmentConstraint.horizontal)
                        for (var Ae = y.alignmentConstraint.horizontal, $e = function(F) {
                          var oe = /* @__PURE__ */ new Set();
                          Ae[F].forEach(function(de) {
                            oe.add(de);
                          });
                          var se = new Set([].concat(h(oe)).filter(function(de) {
                            return B.has(de);
                          })), ge = void 0;
                          se.size > 0 ? ge = E[x.get(se.values().next().value)] : ge = L(oe).y, oe.forEach(function(de) {
                            B.has(de) || (E[x.get(de)] = ge);
                          });
                        }, me = 0; me < Ae.length; me++)
                          $e(me);
                    }
                    y.relativePlacementConstraint && (function() {
                      var he = /* @__PURE__ */ new Map(), F = /* @__PURE__ */ new Map(), oe = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Map(), ge = /* @__PURE__ */ new Map(), de = /* @__PURE__ */ new Map(), we = /* @__PURE__ */ new Set(), _e = /* @__PURE__ */ new Set();
                      if (B.forEach(function(wt) {
                        we.add(wt), _e.add(wt);
                      }), y.alignmentConstraint) {
                        if (y.alignmentConstraint.vertical)
                          for (var Se = y.alignmentConstraint.vertical, Me = function(lt) {
                            oe.set("dummy" + lt, []), Se[lt].forEach(function(je) {
                              he.set(je, "dummy" + lt), oe.get("dummy" + lt).push(je), B.has(je) && we.add("dummy" + lt);
                            }), ge.set("dummy" + lt, T[x.get(Se[lt][0])]);
                          }, Xe = 0; Xe < Se.length; Xe++)
                            Me(Xe);
                        if (y.alignmentConstraint.horizontal)
                          for (var We = y.alignmentConstraint.horizontal, Ke = function(lt) {
                            se.set("dummy" + lt, []), We[lt].forEach(function(je) {
                              F.set(je, "dummy" + lt), se.get("dummy" + lt).push(je), B.has(je) && _e.add("dummy" + lt);
                            }), de.set("dummy" + lt, E[x.get(We[lt][0])]);
                          }, Ze = 0; Ze < We.length; Ze++)
                            Ke(Ze);
                      }
                      var Pe = /* @__PURE__ */ new Map(), Ve = /* @__PURE__ */ new Map(), ht = function(lt) {
                        G.get(lt).forEach(function(je) {
                          var Qt = void 0, pe = void 0;
                          je.direction == "horizontal" ? (Qt = he.get(lt) ? he.get(lt) : lt, he.get(je.id) ? pe = { id: he.get(je.id), gap: je.gap, direction: je.direction } : pe = je, Pe.has(Qt) ? Pe.get(Qt).push(pe) : Pe.set(Qt, [pe]), Pe.has(pe.id) || Pe.set(pe.id, [])) : (Qt = F.get(lt) ? F.get(lt) : lt, F.get(je.id) ? pe = { id: F.get(je.id), gap: je.gap, direction: je.direction } : pe = je, Ve.has(Qt) ? Ve.get(Qt).push(pe) : Ve.set(Qt, [pe]), Ve.has(pe.id) || Ve.set(pe.id, []));
                        });
                      }, st = !0, Ue = !1, Et = void 0;
                      try {
                        for (var He = G.keys()[Symbol.iterator](), rt; !(st = (rt = He.next()).done); st = !0) {
                          var ct = rt.value;
                          ht(ct);
                        }
                      } catch (wt) {
                        Ue = !0, Et = wt;
                      } finally {
                        try {
                          !st && He.return && He.return();
                        } finally {
                          if (Ue)
                            throw Et;
                        }
                      }
                      var ut = I(Pe), nt = I(Ve), bt = C(ut), er = C(nt), Dt = N(Pe), ir = N(Ve), wr = [], ar = [];
                      bt.forEach(function(wt, lt) {
                        wr[lt] = [], wt.forEach(function(je) {
                          Dt.get(je).length == 0 && wr[lt].push(je);
                        });
                      }), er.forEach(function(wt, lt) {
                        ar[lt] = [], wt.forEach(function(je) {
                          ir.get(je).length == 0 && ar[lt].push(je);
                        });
                      });
                      var Wt = M(Pe, "horizontal", we, ge, wr), ur = M(Ve, "vertical", _e, de, ar), cn = function(lt) {
                        oe.get(lt) ? oe.get(lt).forEach(function(je) {
                          T[x.get(je)] = Wt.get(lt);
                        }) : T[x.get(lt)] = Wt.get(lt);
                      }, ft = !0, ke = !1, Je = void 0;
                      try {
                        for (var xt = Wt.keys()[Symbol.iterator](), lr; !(ft = (lr = xt.next()).done); ft = !0) {
                          var Vr = lr.value;
                          cn(Vr);
                        }
                      } catch (wt) {
                        ke = !0, Je = wt;
                      } finally {
                        try {
                          !ft && xt.return && xt.return();
                        } finally {
                          if (ke)
                            throw Je;
                        }
                      }
                      var hr = function(lt) {
                        se.get(lt) ? se.get(lt).forEach(function(je) {
                          E[x.get(je)] = ur.get(lt);
                        }) : E[x.get(lt)] = ur.get(lt);
                      }, Kr = !0, bi = !1, En = void 0;
                      try {
                        for (var Sn = ur.keys()[Symbol.iterator](), dt; !(Kr = (dt = Sn.next()).done); Kr = !0) {
                          var Vr = dt.value;
                          hr(Vr);
                        }
                      } catch (wt) {
                        bi = !0, En = wt;
                      } finally {
                        try {
                          !Kr && Sn.return && Sn.return();
                        } finally {
                          if (bi)
                            throw En;
                        }
                      }
                    })();
                  }
                  for (var Ie = 0; Ie < A.length; Ie++) {
                    var te = A[Ie];
                    te.getChild() == null && te.setCenter(T[x.get(te.id)], E[x.get(te.id)]);
                  }
                }, o.exports = m;
              })
            ),
            /***/
            551: (
              /***/
              ((o) => {
                o.exports = r;
              })
            )
            /******/
          }, i = {};
          function a(o) {
            var l = i[o];
            if (l !== void 0)
              return l.exports;
            var u = i[o] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return n[o](u, u.exports, a), u.exports;
          }
          var s = a(45);
          return s;
        })()
      );
    });
  })(E2)), E2.exports;
}
var clt = T2.exports, PY;
function ult() {
  return PY || (PY = 1, (function(t, e) {
    (function(n, i) {
      t.exports = i(llt());
    })(clt, function(r) {
      return (
        /******/
        (() => {
          var n = {
            /***/
            658: (
              /***/
              ((o) => {
                o.exports = Object.assign != null ? Object.assign.bind(Object) : function(l) {
                  for (var u = arguments.length, h = Array(u > 1 ? u - 1 : 0), f = 1; f < u; f++)
                    h[f - 1] = arguments[f];
                  return h.forEach(function(d) {
                    Object.keys(d).forEach(function(p) {
                      return l[p] = d[p];
                    });
                  }), l;
                };
              })
            ),
            /***/
            548: (
              /***/
              ((o, l, u) => {
                var h = /* @__PURE__ */ (function() {
                  function p(g, m) {
                    var v = [], y = !0, b = !1, x = void 0;
                    try {
                      for (var T = g[Symbol.iterator](), E; !(y = (E = T.next()).done) && (v.push(E.value), !(m && v.length === m)); y = !0)
                        ;
                    } catch (A) {
                      b = !0, x = A;
                    } finally {
                      try {
                        !y && T.return && T.return();
                      } finally {
                        if (b) throw x;
                      }
                    }
                    return v;
                  }
                  return function(g, m) {
                    if (Array.isArray(g))
                      return g;
                    if (Symbol.iterator in Object(g))
                      return p(g, m);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  };
                })(), f = u(140).layoutBase.LinkedList, d = {};
                d.getTopMostNodes = function(p) {
                  for (var g = {}, m = 0; m < p.length; m++)
                    g[p[m].id()] = !0;
                  var v = p.filter(function(y, b) {
                    typeof y == "number" && (y = b);
                    for (var x = y.parent()[0]; x != null; ) {
                      if (g[x.id()])
                        return !1;
                      x = x.parent()[0];
                    }
                    return !0;
                  });
                  return v;
                }, d.connectComponents = function(p, g, m, v) {
                  var y = new f(), b = /* @__PURE__ */ new Set(), x = [], T = void 0, E = void 0, A = void 0, S = !1, k = 1, _ = [], R = [], L = function() {
                    var P = p.collection();
                    R.push(P);
                    var C = m[0], I = p.collection();
                    I.merge(C).merge(C.descendants().intersection(g)), x.push(C), I.forEach(function(D) {
                      y.push(D), b.add(D), P.merge(D);
                    });
                    for (var N = function() {
                      C = y.shift();
                      var $ = p.collection();
                      C.neighborhood().nodes().forEach(function(W) {
                        g.intersection(C.edgesWith(W)).length > 0 && $.merge(W);
                      });
                      for (var z = 0; z < $.length; z++) {
                        var B = $[z];
                        if (T = m.intersection(B.union(B.ancestors())), T != null && !b.has(T[0])) {
                          var G = T.union(T.descendants());
                          G.forEach(function(W) {
                            y.push(W), b.add(W), P.merge(W), m.has(W) && x.push(W);
                          });
                        }
                      }
                    }; y.length != 0; )
                      N();
                    if (P.forEach(function(D) {
                      g.intersection(D.connectedEdges()).forEach(function($) {
                        P.has($.source()) && P.has($.target()) && P.merge($);
                      });
                    }), x.length == m.length && (S = !0), !S || S && k > 1) {
                      E = x[0], A = E.connectedEdges().length, x.forEach(function(D) {
                        D.connectedEdges().length < A && (A = D.connectedEdges().length, E = D);
                      }), _.push(E.id());
                      var O = p.collection();
                      O.merge(x[0]), x.forEach(function(D) {
                        O.merge(D);
                      }), x = [], m = m.difference(O), k++;
                    }
                  };
                  do
                    L();
                  while (!S);
                  return v && _.length > 0 && v.set("dummy" + (v.size + 1), _), R;
                }, d.relocateComponent = function(p, g, m) {
                  if (!m.fixedNodeConstraint) {
                    var v = Number.POSITIVE_INFINITY, y = Number.NEGATIVE_INFINITY, b = Number.POSITIVE_INFINITY, x = Number.NEGATIVE_INFINITY;
                    if (m.quality == "draft") {
                      var T = !0, E = !1, A = void 0;
                      try {
                        for (var S = g.nodeIndexes[Symbol.iterator](), k; !(T = (k = S.next()).done); T = !0) {
                          var _ = k.value, R = h(_, 2), L = R[0], M = R[1], P = m.cy.getElementById(L);
                          if (P) {
                            var C = P.boundingBox(), I = g.xCoords[M] - C.w / 2, N = g.xCoords[M] + C.w / 2, O = g.yCoords[M] - C.h / 2, D = g.yCoords[M] + C.h / 2;
                            I < v && (v = I), N > y && (y = N), O < b && (b = O), D > x && (x = D);
                          }
                        }
                      } catch (W) {
                        E = !0, A = W;
                      } finally {
                        try {
                          !T && S.return && S.return();
                        } finally {
                          if (E)
                            throw A;
                        }
                      }
                      var $ = p.x - (y + v) / 2, z = p.y - (x + b) / 2;
                      g.xCoords = g.xCoords.map(function(W) {
                        return W + $;
                      }), g.yCoords = g.yCoords.map(function(W) {
                        return W + z;
                      });
                    } else {
                      Object.keys(g).forEach(function(W) {
                        var V = g[W], U = V.getRect().x, Z = V.getRect().x + V.getRect().width, K = V.getRect().y, ce = V.getRect().y + V.getRect().height;
                        U < v && (v = U), Z > y && (y = Z), K < b && (b = K), ce > x && (x = ce);
                      });
                      var B = p.x - (y + v) / 2, G = p.y - (x + b) / 2;
                      Object.keys(g).forEach(function(W) {
                        var V = g[W];
                        V.setCenter(V.getCenterX() + B, V.getCenterY() + G);
                      });
                    }
                  }
                }, d.calcBoundingBox = function(p, g, m, v) {
                  for (var y = Number.MAX_SAFE_INTEGER, b = Number.MIN_SAFE_INTEGER, x = Number.MAX_SAFE_INTEGER, T = Number.MIN_SAFE_INTEGER, E = void 0, A = void 0, S = void 0, k = void 0, _ = p.descendants().not(":parent"), R = _.length, L = 0; L < R; L++) {
                    var M = _[L];
                    E = g[v.get(M.id())] - M.width() / 2, A = g[v.get(M.id())] + M.width() / 2, S = m[v.get(M.id())] - M.height() / 2, k = m[v.get(M.id())] + M.height() / 2, y > E && (y = E), b < A && (b = A), x > S && (x = S), T < k && (T = k);
                  }
                  var P = {};
                  return P.topLeftX = y, P.topLeftY = x, P.width = b - y, P.height = T - x, P;
                }, d.calcParentsWithoutChildren = function(p, g) {
                  var m = p.collection();
                  return g.nodes(":parent").forEach(function(v) {
                    var y = !1;
                    v.children().forEach(function(b) {
                      b.css("display") != "none" && (y = !0);
                    }), y || m.merge(v);
                  }), m;
                }, o.exports = d;
              })
            ),
            /***/
            816: (
              /***/
              ((o, l, u) => {
                var h = u(548), f = u(140).CoSELayout, d = u(140).CoSENode, p = u(140).layoutBase.PointD, g = u(140).layoutBase.DimensionD, m = u(140).layoutBase.LayoutConstants, v = u(140).layoutBase.FDLayoutConstants, y = u(140).CoSEConstants, b = function(T, E) {
                  var A = T.cy, S = T.eles, k = S.nodes(), _ = S.edges(), R = void 0, L = void 0, M = void 0, P = {};
                  T.randomize && (R = E.nodeIndexes, L = E.xCoords, M = E.yCoords);
                  var C = function(W) {
                    return typeof W == "function";
                  }, I = function(W, V) {
                    return C(W) ? W(V) : W;
                  }, N = h.calcParentsWithoutChildren(A, S), O = function G(W, V, U, Z) {
                    for (var K = V.length, ce = 0; ce < K; ce++) {
                      var J = V[ce], ee = null;
                      J.intersection(N).length == 0 && (ee = J.children());
                      var j = void 0, X = J.layoutDimensions({
                        nodeDimensionsIncludeLabels: Z.nodeDimensionsIncludeLabels
                      });
                      if (J.outerWidth() != null && J.outerHeight() != null)
                        if (Z.randomize)
                          if (!J.isParent())
                            j = W.add(new d(U.graphManager, new p(L[R.get(J.id())] - X.w / 2, M[R.get(J.id())] - X.h / 2), new g(parseFloat(X.w), parseFloat(X.h))));
                          else {
                            var re = h.calcBoundingBox(J, L, M, R);
                            J.intersection(N).length == 0 ? j = W.add(new d(U.graphManager, new p(re.topLeftX, re.topLeftY), new g(re.width, re.height))) : j = W.add(new d(U.graphManager, new p(re.topLeftX, re.topLeftY), new g(parseFloat(X.w), parseFloat(X.h))));
                          }
                        else
                          j = W.add(new d(U.graphManager, new p(J.position("x") - X.w / 2, J.position("y") - X.h / 2), new g(parseFloat(X.w), parseFloat(X.h))));
                      else
                        j = W.add(new d(this.graphManager));
                      if (j.id = J.data("id"), j.nodeRepulsion = I(Z.nodeRepulsion, J), j.paddingLeft = parseInt(J.css("padding")), j.paddingTop = parseInt(J.css("padding")), j.paddingRight = parseInt(J.css("padding")), j.paddingBottom = parseInt(J.css("padding")), Z.nodeDimensionsIncludeLabels && (j.labelWidth = J.boundingBox({ includeLabels: !0, includeNodes: !1, includeOverlays: !1 }).w, j.labelHeight = J.boundingBox({ includeLabels: !0, includeNodes: !1, includeOverlays: !1 }).h, j.labelPosVertical = J.css("text-valign"), j.labelPosHorizontal = J.css("text-halign")), P[J.data("id")] = j, isNaN(j.rect.x) && (j.rect.x = 0), isNaN(j.rect.y) && (j.rect.y = 0), ee != null && ee.length > 0) {
                        var Q = void 0;
                        Q = U.getGraphManager().add(U.newGraph(), j), G(Q, ee, U, Z);
                      }
                    }
                  }, D = function(W, V, U) {
                    for (var Z = 0, K = 0, ce = 0; ce < U.length; ce++) {
                      var J = U[ce], ee = P[J.data("source")], j = P[J.data("target")];
                      if (ee && j && ee !== j && ee.getEdgesBetween(j).length == 0) {
                        var X = V.add(W.newEdge(), ee, j);
                        X.id = J.id(), X.idealLength = I(T.idealEdgeLength, J), X.edgeElasticity = I(T.edgeElasticity, J), Z += X.idealLength, K++;
                      }
                    }
                    T.idealEdgeLength != null && (K > 0 ? y.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = Z / K : C(T.idealEdgeLength) ? y.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = 50 : y.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = T.idealEdgeLength, y.MIN_REPULSION_DIST = v.MIN_REPULSION_DIST = v.DEFAULT_EDGE_LENGTH / 10, y.DEFAULT_RADIAL_SEPARATION = v.DEFAULT_EDGE_LENGTH);
                  }, $ = function(W, V) {
                    V.fixedNodeConstraint && (W.constraints.fixedNodeConstraint = V.fixedNodeConstraint), V.alignmentConstraint && (W.constraints.alignmentConstraint = V.alignmentConstraint), V.relativePlacementConstraint && (W.constraints.relativePlacementConstraint = V.relativePlacementConstraint);
                  };
                  T.nestingFactor != null && (y.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = v.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = T.nestingFactor), T.gravity != null && (y.DEFAULT_GRAVITY_STRENGTH = v.DEFAULT_GRAVITY_STRENGTH = T.gravity), T.numIter != null && (y.MAX_ITERATIONS = v.MAX_ITERATIONS = T.numIter), T.gravityRange != null && (y.DEFAULT_GRAVITY_RANGE_FACTOR = v.DEFAULT_GRAVITY_RANGE_FACTOR = T.gravityRange), T.gravityCompound != null && (y.DEFAULT_COMPOUND_GRAVITY_STRENGTH = v.DEFAULT_COMPOUND_GRAVITY_STRENGTH = T.gravityCompound), T.gravityRangeCompound != null && (y.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = v.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = T.gravityRangeCompound), T.initialEnergyOnIncremental != null && (y.DEFAULT_COOLING_FACTOR_INCREMENTAL = v.DEFAULT_COOLING_FACTOR_INCREMENTAL = T.initialEnergyOnIncremental), T.tilingCompareBy != null && (y.TILING_COMPARE_BY = T.tilingCompareBy), T.quality == "proof" ? m.QUALITY = 2 : m.QUALITY = 0, y.NODE_DIMENSIONS_INCLUDE_LABELS = v.NODE_DIMENSIONS_INCLUDE_LABELS = m.NODE_DIMENSIONS_INCLUDE_LABELS = T.nodeDimensionsIncludeLabels, y.DEFAULT_INCREMENTAL = v.DEFAULT_INCREMENTAL = m.DEFAULT_INCREMENTAL = !T.randomize, y.ANIMATE = v.ANIMATE = m.ANIMATE = T.animate, y.TILE = T.tile, y.TILING_PADDING_VERTICAL = typeof T.tilingPaddingVertical == "function" ? T.tilingPaddingVertical.call() : T.tilingPaddingVertical, y.TILING_PADDING_HORIZONTAL = typeof T.tilingPaddingHorizontal == "function" ? T.tilingPaddingHorizontal.call() : T.tilingPaddingHorizontal, y.DEFAULT_INCREMENTAL = v.DEFAULT_INCREMENTAL = m.DEFAULT_INCREMENTAL = !0, y.PURE_INCREMENTAL = !T.randomize, m.DEFAULT_UNIFORM_LEAF_NODE_SIZES = T.uniformNodeDimensions, T.step == "transformed" && (y.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, y.ENFORCE_CONSTRAINTS = !1, y.APPLY_LAYOUT = !1), T.step == "enforced" && (y.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, y.ENFORCE_CONSTRAINTS = !0, y.APPLY_LAYOUT = !1), T.step == "cose" && (y.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, y.ENFORCE_CONSTRAINTS = !1, y.APPLY_LAYOUT = !0), T.step == "all" && (T.randomize ? y.TRANSFORM_ON_CONSTRAINT_HANDLING = !0 : y.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, y.ENFORCE_CONSTRAINTS = !0, y.APPLY_LAYOUT = !0), T.fixedNodeConstraint || T.alignmentConstraint || T.relativePlacementConstraint ? y.TREE_REDUCTION_ON_INCREMENTAL = !1 : y.TREE_REDUCTION_ON_INCREMENTAL = !0;
                  var z = new f(), B = z.newGraphManager();
                  return O(B.addRoot(), h.getTopMostNodes(k), z, T), D(z, B, _), $(z, T), z.runLayout(), P;
                };
                o.exports = { coseLayout: b };
              })
            ),
            /***/
            212: (
              /***/
              ((o, l, u) => {
                var h = /* @__PURE__ */ (function() {
                  function T(E, A) {
                    for (var S = 0; S < A.length; S++) {
                      var k = A[S];
                      k.enumerable = k.enumerable || !1, k.configurable = !0, "value" in k && (k.writable = !0), Object.defineProperty(E, k.key, k);
                    }
                  }
                  return function(E, A, S) {
                    return A && T(E.prototype, A), S && T(E, S), E;
                  };
                })();
                function f(T, E) {
                  if (!(T instanceof E))
                    throw new TypeError("Cannot call a class as a function");
                }
                var d = u(658), p = u(548), g = u(657), m = g.spectralLayout, v = u(816), y = v.coseLayout, b = Object.freeze({
                  // 'draft', 'default' or 'proof' 
                  // - 'draft' only applies spectral layout 
                  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)
                  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) 
                  quality: "default",
                  // Use random node positions at beginning of layout
                  // if this is set to false, then quality option must be "proof"
                  randomize: !0,
                  // Whether or not to animate the layout
                  animate: !0,
                  // Duration of animation in ms, if enabled
                  animationDuration: 1e3,
                  // Easing of animation, if enabled
                  animationEasing: void 0,
                  // Fit the viewport to the repositioned nodes
                  fit: !0,
                  // Padding around layout
                  padding: 30,
                  // Whether to include labels in node dimensions. Valid in "proof" quality
                  nodeDimensionsIncludeLabels: !1,
                  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions
                  uniformNodeDimensions: !1,
                  // Whether to pack disconnected components - valid only if randomize: true
                  packComponents: !0,
                  // Layout step - all, transformed, enforced, cose - for debug purpose only
                  step: "all",
                  /* spectral layout options */
                  // False for random, true for greedy
                  samplingType: !0,
                  // Sample size to construct distance matrix
                  sampleSize: 25,
                  // Separation amount between nodes
                  nodeSeparation: 75,
                  // Power iteration tolerance
                  piTol: 1e-7,
                  /* CoSE layout options */
                  // Node repulsion (non overlapping) multiplier
                  nodeRepulsion: function(E) {
                    return 4500;
                  },
                  // Ideal edge (non nested) length
                  idealEdgeLength: function(E) {
                    return 50;
                  },
                  // Divisor to compute edge forces
                  edgeElasticity: function(E) {
                    return 0.45;
                  },
                  // Nesting factor (multiplier) to compute ideal edge length for nested edges
                  nestingFactor: 0.1,
                  // Gravity force (constant)
                  gravity: 0.25,
                  // Maximum number of iterations to perform
                  numIter: 2500,
                  // For enabling tiling
                  tile: !0,
                  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.
                  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.
                  tilingCompareBy: void 0,
                  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
                  tilingPaddingVertical: 10,
                  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
                  tilingPaddingHorizontal: 10,
                  // Gravity range (constant) for compounds
                  gravityRangeCompound: 1.5,
                  // Gravity force (constant) for compounds
                  gravityCompound: 1,
                  // Gravity range (constant)
                  gravityRange: 3.8,
                  // Initial cooling factor for incremental layout  
                  initialEnergyOnIncremental: 0.3,
                  /* constraint options */
                  // Fix required nodes to predefined positions
                  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]
                  fixedNodeConstraint: void 0,
                  // Align required nodes in vertical/horizontal direction
                  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}
                  alignmentConstraint: void 0,
                  // Place two nodes relatively in vertical/horizontal direction 
                  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]
                  relativePlacementConstraint: void 0,
                  /* layout event callbacks */
                  ready: function() {
                  },
                  // on layoutready
                  stop: function() {
                  }
                  // on layoutstop
                }), x = (function() {
                  function T(E) {
                    f(this, T), this.options = d({}, b, E);
                  }
                  return h(T, [{
                    key: "run",
                    value: function() {
                      var A = this, S = this.options, k = S.cy, _ = S.eles, R = [], L = [], M = void 0, P = [];
                      S.fixedNodeConstraint && (!Array.isArray(S.fixedNodeConstraint) || S.fixedNodeConstraint.length == 0) && (S.fixedNodeConstraint = void 0), S.alignmentConstraint && (S.alignmentConstraint.vertical && (!Array.isArray(S.alignmentConstraint.vertical) || S.alignmentConstraint.vertical.length == 0) && (S.alignmentConstraint.vertical = void 0), S.alignmentConstraint.horizontal && (!Array.isArray(S.alignmentConstraint.horizontal) || S.alignmentConstraint.horizontal.length == 0) && (S.alignmentConstraint.horizontal = void 0)), S.relativePlacementConstraint && (!Array.isArray(S.relativePlacementConstraint) || S.relativePlacementConstraint.length == 0) && (S.relativePlacementConstraint = void 0);
                      var C = S.fixedNodeConstraint || S.alignmentConstraint || S.relativePlacementConstraint;
                      C && (S.tile = !1, S.packComponents = !1);
                      var I = void 0, N = !1;
                      if (k.layoutUtilities && S.packComponents && (I = k.layoutUtilities("get"), I || (I = k.layoutUtilities()), N = !0), _.nodes().length > 0)
                        if (N) {
                          var $ = p.getTopMostNodes(S.eles.nodes());
                          if (M = p.connectComponents(k, S.eles, $), M.forEach(function(xe) {
                            var Y = xe.boundingBox();
                            P.push({ x: Y.x1 + Y.w / 2, y: Y.y1 + Y.h / 2 });
                          }), S.randomize && M.forEach(function(xe) {
                            S.eles = xe, R.push(m(S));
                          }), S.quality == "default" || S.quality == "proof") {
                            var z = k.collection();
                            if (S.tile) {
                              var B = /* @__PURE__ */ new Map(), G = [], W = [], V = 0, U = { nodeIndexes: B, xCoords: G, yCoords: W }, Z = [];
                              if (M.forEach(function(xe, Y) {
                                xe.edges().length == 0 && (xe.nodes().forEach(function(Ne, fe) {
                                  z.merge(xe.nodes()[fe]), Ne.isParent() || (U.nodeIndexes.set(xe.nodes()[fe].id(), V++), U.xCoords.push(xe.nodes()[0].position().x), U.yCoords.push(xe.nodes()[0].position().y));
                                }), Z.push(Y));
                              }), z.length > 1) {
                                var K = z.boundingBox();
                                P.push({ x: K.x1 + K.w / 2, y: K.y1 + K.h / 2 }), M.push(z), R.push(U);
                                for (var ce = Z.length - 1; ce >= 0; ce--)
                                  M.splice(Z[ce], 1), R.splice(Z[ce], 1), P.splice(Z[ce], 1);
                              }
                            }
                            M.forEach(function(xe, Y) {
                              S.eles = xe, L.push(y(S, R[Y])), p.relocateComponent(P[Y], L[Y], S);
                            });
                          } else
                            M.forEach(function(xe, Y) {
                              p.relocateComponent(P[Y], R[Y], S);
                            });
                          var J = /* @__PURE__ */ new Set();
                          if (M.length > 1) {
                            var ee = [], j = _.filter(function(xe) {
                              return xe.css("display") == "none";
                            });
                            M.forEach(function(xe, Y) {
                              var Ne = void 0;
                              if (S.quality == "draft" && (Ne = R[Y].nodeIndexes), xe.nodes().not(j).length > 0) {
                                var fe = {};
                                fe.edges = [], fe.nodes = [];
                                var qe = void 0;
                                xe.nodes().not(j).forEach(function(ze) {
                                  if (S.quality == "draft")
                                    if (!ze.isParent())
                                      qe = Ne.get(ze.id()), fe.nodes.push({ x: R[Y].xCoords[qe] - ze.boundingbox().w / 2, y: R[Y].yCoords[qe] - ze.boundingbox().h / 2, width: ze.boundingbox().w, height: ze.boundingbox().h });
                                    else {
                                      var Ge = p.calcBoundingBox(ze, R[Y].xCoords, R[Y].yCoords, Ne);
                                      fe.nodes.push({ x: Ge.topLeftX, y: Ge.topLeftY, width: Ge.width, height: Ge.height });
                                    }
                                  else
                                    L[Y][ze.id()] && fe.nodes.push({ x: L[Y][ze.id()].getLeft(), y: L[Y][ze.id()].getTop(), width: L[Y][ze.id()].getWidth(), height: L[Y][ze.id()].getHeight() });
                                }), xe.edges().forEach(function(ze) {
                                  var Ge = ze.source(), Ee = ze.target();
                                  if (Ge.css("display") != "none" && Ee.css("display") != "none")
                                    if (S.quality == "draft") {
                                      var Oe = Ne.get(Ge.id()), Ce = Ne.get(Ee.id()), Ae = [], $e = [];
                                      if (Ge.isParent()) {
                                        var me = p.calcBoundingBox(Ge, R[Y].xCoords, R[Y].yCoords, Ne);
                                        Ae.push(me.topLeftX + me.width / 2), Ae.push(me.topLeftY + me.height / 2);
                                      } else
                                        Ae.push(R[Y].xCoords[Oe]), Ae.push(R[Y].yCoords[Oe]);
                                      if (Ee.isParent()) {
                                        var Ie = p.calcBoundingBox(Ee, R[Y].xCoords, R[Y].yCoords, Ne);
                                        $e.push(Ie.topLeftX + Ie.width / 2), $e.push(Ie.topLeftY + Ie.height / 2);
                                      } else
                                        $e.push(R[Y].xCoords[Ce]), $e.push(R[Y].yCoords[Ce]);
                                      fe.edges.push({ startX: Ae[0], startY: Ae[1], endX: $e[0], endY: $e[1] });
                                    } else
                                      L[Y][Ge.id()] && L[Y][Ee.id()] && fe.edges.push({ startX: L[Y][Ge.id()].getCenterX(), startY: L[Y][Ge.id()].getCenterY(), endX: L[Y][Ee.id()].getCenterX(), endY: L[Y][Ee.id()].getCenterY() });
                                }), fe.nodes.length > 0 && (ee.push(fe), J.add(Y));
                              }
                            });
                            var X = I.packComponents(ee, S.randomize).shifts;
                            if (S.quality == "draft")
                              R.forEach(function(xe, Y) {
                                var Ne = xe.xCoords.map(function(qe) {
                                  return qe + X[Y].dx;
                                }), fe = xe.yCoords.map(function(qe) {
                                  return qe + X[Y].dy;
                                });
                                xe.xCoords = Ne, xe.yCoords = fe;
                              });
                            else {
                              var re = 0;
                              J.forEach(function(xe) {
                                Object.keys(L[xe]).forEach(function(Y) {
                                  var Ne = L[xe][Y];
                                  Ne.setCenter(Ne.getCenterX() + X[re].dx, Ne.getCenterY() + X[re].dy);
                                }), re++;
                              });
                            }
                          }
                        } else {
                          var O = S.eles.boundingBox();
                          if (P.push({ x: O.x1 + O.w / 2, y: O.y1 + O.h / 2 }), S.randomize) {
                            var D = m(S);
                            R.push(D);
                          }
                          S.quality == "default" || S.quality == "proof" ? (L.push(y(S, R[0])), p.relocateComponent(P[0], L[0], S)) : p.relocateComponent(P[0], R[0], S);
                        }
                      var Q = function(Y, Ne) {
                        if (S.quality == "default" || S.quality == "proof") {
                          typeof Y == "number" && (Y = Ne);
                          var fe = void 0, qe = void 0, ze = Y.data("id");
                          return L.forEach(function(Ee) {
                            ze in Ee && (fe = { x: Ee[ze].getRect().getCenterX(), y: Ee[ze].getRect().getCenterY() }, qe = Ee[ze]);
                          }), S.nodeDimensionsIncludeLabels && (qe.labelWidth && (qe.labelPosHorizontal == "left" ? fe.x += qe.labelWidth / 2 : qe.labelPosHorizontal == "right" && (fe.x -= qe.labelWidth / 2)), qe.labelHeight && (qe.labelPosVertical == "top" ? fe.y += qe.labelHeight / 2 : qe.labelPosVertical == "bottom" && (fe.y -= qe.labelHeight / 2))), fe == null && (fe = { x: Y.position("x"), y: Y.position("y") }), {
                            x: fe.x,
                            y: fe.y
                          };
                        } else {
                          var Ge = void 0;
                          return R.forEach(function(Ee) {
                            var Oe = Ee.nodeIndexes.get(Y.id());
                            Oe != null && (Ge = { x: Ee.xCoords[Oe], y: Ee.yCoords[Oe] });
                          }), Ge == null && (Ge = { x: Y.position("x"), y: Y.position("y") }), {
                            x: Ge.x,
                            y: Ge.y
                          };
                        }
                      };
                      if (S.quality == "default" || S.quality == "proof" || S.randomize) {
                        var ue = p.calcParentsWithoutChildren(k, _), ne = _.filter(function(xe) {
                          return xe.css("display") == "none";
                        });
                        S.eles = _.not(ne), _.nodes().not(":parent").not(ne).layoutPositions(A, S, Q), ue.length > 0 && ue.forEach(function(xe) {
                          xe.position(Q(xe));
                        });
                      } else
                        console.log("If randomize option is set to false, then quality option must be 'default' or 'proof'.");
                    }
                  }]), T;
                })();
                o.exports = x;
              })
            ),
            /***/
            657: (
              /***/
              ((o, l, u) => {
                var h = u(548), f = u(140).layoutBase.Matrix, d = u(140).layoutBase.SVD, p = function(m) {
                  var v = m.cy, y = m.eles, b = y.nodes(), x = y.nodes(":parent"), T = /* @__PURE__ */ new Map(), E = /* @__PURE__ */ new Map(), A = /* @__PURE__ */ new Map(), S = [], k = [], _ = [], R = [], L = [], M = [], P = [], C = [], I = void 0, N = 1e8, O = 1e-9, D = m.piTol, $ = m.samplingType, z = m.nodeSeparation, B = void 0, G = function() {
                    for (var F = 0, oe = 0, se = !1; oe < B; ) {
                      F = Math.floor(Math.random() * I), se = !1;
                      for (var ge = 0; ge < oe; ge++)
                        if (R[ge] == F) {
                          se = !0;
                          break;
                        }
                      if (!se)
                        R[oe] = F, oe++;
                      else
                        continue;
                    }
                  }, W = function(F, oe, se) {
                    for (var ge = [], de = 0, we = 0, _e = 0, Se = void 0, Me = [], Xe = 0, We = 1, Ke = 0; Ke < I; Ke++)
                      Me[Ke] = N;
                    for (ge[we] = F, Me[F] = 0; we >= de; ) {
                      _e = ge[de++];
                      for (var Ze = S[_e], Pe = 0; Pe < Ze.length; Pe++)
                        Se = E.get(Ze[Pe]), Me[Se] == N && (Me[Se] = Me[_e] + 1, ge[++we] = Se);
                      M[_e][oe] = Me[_e] * z;
                    }
                    if (se) {
                      for (var Ve = 0; Ve < I; Ve++)
                        M[Ve][oe] < L[Ve] && (L[Ve] = M[Ve][oe]);
                      for (var ht = 0; ht < I; ht++)
                        L[ht] > Xe && (Xe = L[ht], We = ht);
                    }
                    return We;
                  }, V = function(F) {
                    var oe = void 0;
                    if (F) {
                      oe = Math.floor(Math.random() * I);
                      for (var ge = 0; ge < I; ge++)
                        L[ge] = N;
                      for (var de = 0; de < B; de++)
                        R[de] = oe, oe = W(oe, de, F);
                    } else {
                      G();
                      for (var se = 0; se < B; se++)
                        W(R[se], se, F);
                    }
                    for (var we = 0; we < I; we++)
                      for (var _e = 0; _e < B; _e++)
                        M[we][_e] *= M[we][_e];
                    for (var Se = 0; Se < B; Se++)
                      P[Se] = [];
                    for (var Me = 0; Me < B; Me++)
                      for (var Xe = 0; Xe < B; Xe++)
                        P[Me][Xe] = M[R[Xe]][Me];
                  }, U = function() {
                    for (var F = d.svd(P), oe = F.S, se = F.U, ge = F.V, de = oe[0] * oe[0] * oe[0], we = [], _e = 0; _e < B; _e++) {
                      we[_e] = [];
                      for (var Se = 0; Se < B; Se++)
                        we[_e][Se] = 0, _e == Se && (we[_e][Se] = oe[_e] / (oe[_e] * oe[_e] + de / (oe[_e] * oe[_e])));
                    }
                    C = f.multMat(f.multMat(ge, we), f.transpose(se));
                  }, Z = function() {
                    for (var F = void 0, oe = void 0, se = [], ge = [], de = [], we = [], _e = 0; _e < I; _e++)
                      se[_e] = Math.random(), ge[_e] = Math.random();
                    se = f.normalize(se), ge = f.normalize(ge);
                    for (var Se = O, Me = O, Xe = void 0; ; ) {
                      for (var We = 0; We < I; We++)
                        de[We] = se[We];
                      if (se = f.multGamma(f.multL(f.multGamma(de), M, C)), F = f.dotProduct(de, se), se = f.normalize(se), Se = f.dotProduct(de, se), Xe = Math.abs(Se / Me), Xe <= 1 + D && Xe >= 1)
                        break;
                      Me = Se;
                    }
                    for (var Ke = 0; Ke < I; Ke++)
                      de[Ke] = se[Ke];
                    for (Me = O; ; ) {
                      for (var Ze = 0; Ze < I; Ze++)
                        we[Ze] = ge[Ze];
                      if (we = f.minusOp(we, f.multCons(de, f.dotProduct(de, we))), ge = f.multGamma(f.multL(f.multGamma(we), M, C)), oe = f.dotProduct(we, ge), ge = f.normalize(ge), Se = f.dotProduct(we, ge), Xe = Math.abs(Se / Me), Xe <= 1 + D && Xe >= 1)
                        break;
                      Me = Se;
                    }
                    for (var Pe = 0; Pe < I; Pe++)
                      we[Pe] = ge[Pe];
                    k = f.multCons(de, Math.sqrt(Math.abs(F))), _ = f.multCons(we, Math.sqrt(Math.abs(oe)));
                  };
                  h.connectComponents(v, y, h.getTopMostNodes(b), T), x.forEach(function(he) {
                    h.connectComponents(v, y, h.getTopMostNodes(he.descendants().intersection(y)), T);
                  });
                  for (var K = 0, ce = 0; ce < b.length; ce++)
                    b[ce].isParent() || E.set(b[ce].id(), K++);
                  var J = !0, ee = !1, j = void 0;
                  try {
                    for (var X = T.keys()[Symbol.iterator](), re; !(J = (re = X.next()).done); J = !0) {
                      var Q = re.value;
                      E.set(Q, K++);
                    }
                  } catch (he) {
                    ee = !0, j = he;
                  } finally {
                    try {
                      !J && X.return && X.return();
                    } finally {
                      if (ee)
                        throw j;
                    }
                  }
                  for (var ue = 0; ue < E.size; ue++)
                    S[ue] = [];
                  x.forEach(function(he) {
                    for (var F = he.children().intersection(y); F.nodes(":childless").length == 0; )
                      F = F.nodes()[0].children().intersection(y);
                    var oe = 0, se = F.nodes(":childless")[0].connectedEdges().length;
                    F.nodes(":childless").forEach(function(ge, de) {
                      ge.connectedEdges().length < se && (se = ge.connectedEdges().length, oe = de);
                    }), A.set(he.id(), F.nodes(":childless")[oe].id());
                  }), b.forEach(function(he) {
                    var F = void 0;
                    he.isParent() ? F = E.get(A.get(he.id())) : F = E.get(he.id()), he.neighborhood().nodes().forEach(function(oe) {
                      y.intersection(he.edgesWith(oe)).length > 0 && (oe.isParent() ? S[F].push(A.get(oe.id())) : S[F].push(oe.id()));
                    });
                  });
                  var ne = function(F) {
                    var oe = E.get(F), se = void 0;
                    T.get(F).forEach(function(ge) {
                      v.getElementById(ge).isParent() ? se = A.get(ge) : se = ge, S[oe].push(se), S[E.get(se)].push(F);
                    });
                  }, xe = !0, Y = !1, Ne = void 0;
                  try {
                    for (var fe = T.keys()[Symbol.iterator](), qe; !(xe = (qe = fe.next()).done); xe = !0) {
                      var ze = qe.value;
                      ne(ze);
                    }
                  } catch (he) {
                    Y = !0, Ne = he;
                  } finally {
                    try {
                      !xe && fe.return && fe.return();
                    } finally {
                      if (Y)
                        throw Ne;
                    }
                  }
                  I = E.size;
                  var Ge = void 0;
                  if (I > 2) {
                    B = I < m.sampleSize ? I : m.sampleSize;
                    for (var Ee = 0; Ee < I; Ee++)
                      M[Ee] = [];
                    for (var Oe = 0; Oe < B; Oe++)
                      C[Oe] = [];
                    return m.quality == "draft" || m.step == "all" ? (V($), U(), Z(), Ge = { nodeIndexes: E, xCoords: k, yCoords: _ }) : (E.forEach(function(he, F) {
                      k.push(v.getElementById(F).position("x")), _.push(v.getElementById(F).position("y"));
                    }), Ge = { nodeIndexes: E, xCoords: k, yCoords: _ }), Ge;
                  } else {
                    var Ce = E.keys(), Ae = v.getElementById(Ce.next().value), $e = Ae.position(), me = Ae.outerWidth();
                    if (k.push($e.x), _.push($e.y), I == 2) {
                      var Ie = v.getElementById(Ce.next().value), te = Ie.outerWidth();
                      k.push($e.x + me / 2 + te / 2 + m.idealEdgeLength), _.push($e.y);
                    }
                    return Ge = { nodeIndexes: E, xCoords: k, yCoords: _ }, Ge;
                  }
                };
                o.exports = { spectralLayout: p };
              })
            ),
            /***/
            579: (
              /***/
              ((o, l, u) => {
                var h = u(212), f = function(p) {
                  p && p("layout", "fcose", h);
                };
                typeof cytoscape < "u" && f(cytoscape), o.exports = f;
              })
            ),
            /***/
            140: (
              /***/
              ((o) => {
                o.exports = r;
              })
            )
            /******/
          }, i = {};
          function a(o) {
            var l = i[o];
            if (l !== void 0)
              return l.exports;
            var u = i[o] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return n[o](u, u.exports, a), u.exports;
          }
          var s = a(579);
          return s;
        })()
      );
    });
  })(T2)), T2.exports;
}
var hlt = ult();
const flt = /* @__PURE__ */ Oc(hlt);
var $Y = {
  L: "left",
  R: "right",
  T: "top",
  B: "bottom"
}, BY = {
  L: /* @__PURE__ */ w((t) => `${t},${t / 2} 0,${t} 0,0`, "L"),
  R: /* @__PURE__ */ w((t) => `0,${t / 2} ${t},0 ${t},${t}`, "R"),
  T: /* @__PURE__ */ w((t) => `0,0 ${t},0 ${t / 2},${t}`, "T"),
  B: /* @__PURE__ */ w((t) => `${t / 2},0 ${t},${t} 0,${t}`, "B")
}, gy = {
  L: /* @__PURE__ */ w((t, e) => t - e + 2, "L"),
  R: /* @__PURE__ */ w((t, e) => t - 2, "R"),
  T: /* @__PURE__ */ w((t, e) => t - e + 2, "T"),
  B: /* @__PURE__ */ w((t, e) => t - 2, "B")
}, dlt = /* @__PURE__ */ w(function(t) {
  return Fi(t) ? t === "L" ? "R" : "L" : t === "T" ? "B" : "T";
}, "getOppositeArchitectureDirection"), FY = /* @__PURE__ */ w(function(t) {
  const e = t;
  return e === "L" || e === "R" || e === "T" || e === "B";
}, "isArchitectureDirection"), Fi = /* @__PURE__ */ w(function(t) {
  const e = t;
  return e === "L" || e === "R";
}, "isArchitectureDirectionX"), Dc = /* @__PURE__ */ w(function(t) {
  const e = t;
  return e === "T" || e === "B";
}, "isArchitectureDirectionY"), xM = /* @__PURE__ */ w(function(t, e) {
  const r = Fi(t) && Dc(e), n = Dc(t) && Fi(e);
  return r || n;
}, "isArchitectureDirectionXY"), plt = /* @__PURE__ */ w(function(t) {
  const e = t[0], r = t[1], n = Fi(e) && Dc(r), i = Dc(e) && Fi(r);
  return n || i;
}, "isArchitecturePairXY"), glt = /* @__PURE__ */ w(function(t) {
  return t !== "LL" && t !== "RR" && t !== "TT" && t !== "BB";
}, "isValidArchitectureDirectionPair"), s9 = /* @__PURE__ */ w(function(t, e) {
  const r = `${t}${e}`;
  return glt(r) ? r : void 0;
}, "getArchitectureDirectionPair"), mlt = /* @__PURE__ */ w(function([t, e], r) {
  const n = r[0], i = r[1];
  return Fi(n) ? Dc(i) ? [t + (n === "L" ? -1 : 1), e + (i === "T" ? 1 : -1)] : [t + (n === "L" ? -1 : 1), e] : Fi(i) ? [t + (i === "L" ? 1 : -1), e + (n === "T" ? 1 : -1)] : [t, e + (n === "T" ? 1 : -1)];
}, "shiftPositionByArchitectureDirectionPair"), vlt = /* @__PURE__ */ w(function(t) {
  return t === "LT" || t === "TL" ? [1, 1] : t === "BL" || t === "LB" ? [1, -1] : t === "BR" || t === "RB" ? [-1, -1] : [-1, 1];
}, "getArchitectureDirectionXYFactors"), ylt = /* @__PURE__ */ w(function(t, e) {
  return xM(t, e) ? "bend" : Fi(t) ? "horizontal" : "vertical";
}, "getArchitectureDirectionAlignment"), blt = /* @__PURE__ */ w(function(t) {
  return t.type === "service";
}, "isArchitectureService"), xlt = /* @__PURE__ */ w(function(t) {
  return t.type === "junction";
}, "isArchitectureJunction"), Jue = /* @__PURE__ */ w((t) => t.data(), "edgeData"), Af = /* @__PURE__ */ w((t) => t.data(), "nodeData"), wlt = fr.architecture, Ud, ehe = (Ud = class {
  constructor() {
    this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.elements = {}, this.setAccTitle = Ln, this.getAccTitle = Hn, this.setDiagramTitle = ti, this.getDiagramTitle = Mn, this.getAccDescription = Yn, this.setAccDescription = Wn, this.clear();
  }
  clear() {
    this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.dataStructures = void 0, this.elements = {}, In();
  }
  addService({
    id: e,
    icon: r,
    in: n,
    title: i,
    iconText: a
  }) {
    if (this.registeredIds[e] !== void 0)
      throw new Error(
        `The service id [${e}] is already in use by another ${this.registeredIds[e]}`
      );
    if (n !== void 0) {
      if (e === n)
        throw new Error(`The service [${e}] cannot be placed within itself`);
      if (this.registeredIds[n] === void 0)
        throw new Error(
          `The service [${e}]'s parent does not exist. Please make sure the parent is created before this service`
        );
      if (this.registeredIds[n] === "node")
        throw new Error(`The service [${e}]'s parent is not a group`);
    }
    this.registeredIds[e] = "node", this.nodes[e] = {
      id: e,
      type: "service",
      icon: r,
      iconText: a,
      title: i,
      edges: [],
      in: n
    };
  }
  getServices() {
    return Object.values(this.nodes).filter(blt);
  }
  addJunction({ id: e, in: r }) {
    this.registeredIds[e] = "node", this.nodes[e] = {
      id: e,
      type: "junction",
      edges: [],
      in: r
    };
  }
  getJunctions() {
    return Object.values(this.nodes).filter(xlt);
  }
  getNodes() {
    return Object.values(this.nodes);
  }
  getNode(e) {
    return this.nodes[e] ?? null;
  }
  addGroup({ id: e, icon: r, in: n, title: i }) {
    if (this.registeredIds?.[e] !== void 0)
      throw new Error(
        `The group id [${e}] is already in use by another ${this.registeredIds[e]}`
      );
    if (n !== void 0) {
      if (e === n)
        throw new Error(`The group [${e}] cannot be placed within itself`);
      if (this.registeredIds?.[n] === void 0)
        throw new Error(
          `The group [${e}]'s parent does not exist. Please make sure the parent is created before this group`
        );
      if (this.registeredIds?.[n] === "node")
        throw new Error(`The group [${e}]'s parent is not a group`);
    }
    this.registeredIds[e] = "group", this.groups[e] = {
      id: e,
      icon: r,
      title: i,
      in: n
    };
  }
  getGroups() {
    return Object.values(this.groups);
  }
  addEdge({
    lhsId: e,
    rhsId: r,
    lhsDir: n,
    rhsDir: i,
    lhsInto: a,
    rhsInto: s,
    lhsGroup: o,
    rhsGroup: l,
    title: u
  }) {
    if (!FY(n))
      throw new Error(
        `Invalid direction given for left hand side of edge ${e}--${r}. Expected (L,R,T,B) got ${String(n)}`
      );
    if (!FY(i))
      throw new Error(
        `Invalid direction given for right hand side of edge ${e}--${r}. Expected (L,R,T,B) got ${String(i)}`
      );
    if (this.nodes[e] === void 0 && this.groups[e] === void 0)
      throw new Error(
        `The left-hand id [${e}] does not yet exist. Please create the service/group before declaring an edge to it.`
      );
    if (this.nodes[r] === void 0 && this.groups[r] === void 0)
      throw new Error(
        `The right-hand id [${r}] does not yet exist. Please create the service/group before declaring an edge to it.`
      );
    const h = this.nodes[e].in, f = this.nodes[r].in;
    if (o && h && f && h == f)
      throw new Error(
        `The left-hand id [${e}] is modified to traverse the group boundary, but the edge does not pass through two groups.`
      );
    if (l && h && f && h == f)
      throw new Error(
        `The right-hand id [${r}] is modified to traverse the group boundary, but the edge does not pass through two groups.`
      );
    const d = {
      lhsId: e,
      lhsDir: n,
      lhsInto: a,
      lhsGroup: o,
      rhsId: r,
      rhsDir: i,
      rhsInto: s,
      rhsGroup: l,
      title: u
    };
    this.edges.push(d), this.nodes[e] && this.nodes[r] && (this.nodes[e].edges.push(this.edges[this.edges.length - 1]), this.nodes[r].edges.push(this.edges[this.edges.length - 1]));
  }
  getEdges() {
    return this.edges;
  }
  /**
   * Returns the current diagram's adjacency list, spatial map, & group alignments.
   * If they have not been created, run the algorithms to generate them.
   * @returns
   */
  getDataStructures() {
    if (this.dataStructures === void 0) {
      const e = {}, r = Object.entries(this.nodes).reduce((l, [u, h]) => (l[u] = h.edges.reduce((f, d) => {
        const p = this.getNode(d.lhsId)?.in, g = this.getNode(d.rhsId)?.in;
        if (p && g && p !== g) {
          const m = ylt(d.lhsDir, d.rhsDir);
          m !== "bend" && (e[p] ??= {}, e[p][g] = m, e[g] ??= {}, e[g][p] = m);
        }
        if (d.lhsId === u) {
          const m = s9(d.lhsDir, d.rhsDir);
          m && (f[m] = d.rhsId);
        } else {
          const m = s9(d.rhsDir, d.lhsDir);
          m && (f[m] = d.lhsId);
        }
        return f;
      }, {}), l), {}), n = Object.keys(r)[0], i = { [n]: 1 }, a = Object.keys(r).reduce(
        (l, u) => u === n ? l : { ...l, [u]: 1 },
        {}
      ), s = /* @__PURE__ */ w((l) => {
        const u = { [l]: [0, 0] }, h = [l];
        for (; h.length > 0; ) {
          const f = h.shift();
          if (f) {
            i[f] = 1, delete a[f];
            const d = r[f], [p, g] = u[f];
            Object.entries(d).forEach(([m, v]) => {
              i[v] || (u[v] = mlt(
                [p, g],
                m
              ), h.push(v));
            });
          }
        }
        return u;
      }, "BFS"), o = [s(n)];
      for (; Object.keys(a).length > 0; )
        o.push(s(Object.keys(a)[0]));
      this.dataStructures = {
        adjList: r,
        spatialMaps: o,
        groupAlignments: e
      };
    }
    return this.dataStructures;
  }
  setElementForId(e, r) {
    this.elements[e] = r;
  }
  getElementById(e) {
    return this.elements[e];
  }
  getConfig() {
    return Xi({
      ...wlt,
      ...mr().architecture
    });
  }
  getConfigField(e) {
    return this.getConfig()[e];
  }
}, w(Ud, "ArchitectureDB"), Ud), Tlt = /* @__PURE__ */ w((t, e) => {
  Ph(t, e), t.groups.map((r) => e.addGroup(r)), t.services.map((r) => e.addService({ ...r, type: "service" })), t.junctions.map((r) => e.addJunction({ ...r, type: "junction" })), t.edges.map((r) => e.addEdge(r));
}, "populateDb"), the = {
  parser: {
    // @ts-expect-error - ArchitectureDB is not assignable to DiagramDB
    yy: void 0
  },
  parse: /* @__PURE__ */ w(async (t) => {
    const e = await ru("architecture", t);
    ae.debug(e);
    const r = the.parser?.yy;
    if (!(r instanceof ehe))
      throw new Error(
        "parser.parser?.yy was not a ArchitectureDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
      );
    Tlt(e, r);
  }, "parse")
}, Elt = /* @__PURE__ */ w((t) => `
  .edge {
    stroke-width: ${t.archEdgeWidth};
    stroke: ${t.archEdgeColor};
    fill: none;
  }

  .arrow {
    fill: ${t.archEdgeArrowColor};
  }

  .node-bkg {
    fill: none;
    stroke: ${t.archGroupBorderColor};
    stroke-width: ${t.archGroupBorderWidth};
    stroke-dasharray: 8;
  }
  .node-icon-text {
    display: flex; 
    align-items: center;
  }
  
  .node-icon-text > div {
    color: #fff;
    margin: 1px;
    height: fit-content;
    text-align: center;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
  }
`, "getStyles"), Slt = Elt, hf = /* @__PURE__ */ w((t) => `<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/>${t}</g>`, "wrapIcon"), j1 = {
  prefix: "mermaid-architecture",
  height: 80,
  width: 80,
  icons: {
    database: {
      body: hf(
        '<path id="b" data-name="4" d="m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="c" data-name="3" d="m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="d" data-name="2" d="m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse id="e" data-name="1" cx="40" cy="22.14" rx="20" ry="7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="20" y1="57.86" x2="20" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="60" y1="57.86" x2="60" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    server: {
      body: hf(
        '<rect x="17.5" y="17.5" width="45" height="45" rx="2" ry="2" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="32.5" x2="62.5" y2="32.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="47.5" x2="62.5" y2="47.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><g><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g>'
      )
    },
    disk: {
      body: hf(
        '<rect x="20" y="15" width="40" height="50" rx="1" ry="1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="14" ry="14.58" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="4" ry="4.17" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z" style="fill: #fff; stroke-width: 0px;"/>'
      )
    },
    internet: {
      body: hf(
        '<circle cx="40" cy="40" r="22.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="40" y1="17.5" x2="40" y2="62.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="40" x2="62.5" y2="40" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="30.1" x2="60.25" y2="30.1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="49.9" x2="60.25" y2="49.9" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    cloud: {
      body: hf(
        '<path d="m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    unknown: XZ,
    blank: {
      body: hf("")
    }
  }
}, klt = /* @__PURE__ */ w(async function(t, e, r) {
  const n = r.getConfigField("padding"), i = r.getConfigField("iconSize"), a = i / 2, s = i / 6, o = s / 2;
  await Promise.all(
    e.edges().map(async (l) => {
      const {
        source: u,
        sourceDir: h,
        sourceArrow: f,
        sourceGroup: d,
        target: p,
        targetDir: g,
        targetArrow: m,
        targetGroup: v,
        label: y
      } = Jue(l);
      let { x: b, y: x } = l[0].sourceEndpoint();
      const { x: T, y: E } = l[0].midpoint();
      let { x: A, y: S } = l[0].targetEndpoint();
      const k = n + 4;
      if (d && (Fi(h) ? b += h === "L" ? -k : k : x += h === "T" ? -k : k + 18), v && (Fi(g) ? A += g === "L" ? -k : k : S += g === "T" ? -k : k + 18), !d && r.getNode(u)?.type === "junction" && (Fi(h) ? b += h === "L" ? a : -a : x += h === "T" ? a : -a), !v && r.getNode(p)?.type === "junction" && (Fi(g) ? A += g === "L" ? a : -a : S += g === "T" ? a : -a), l[0]._private.rscratch) {
        const _ = t.insert("g");
        if (_.insert("path").attr("d", `M ${b},${x} L ${T},${E} L${A},${S} `).attr("class", "edge").attr("id", Nf(u, p, { prefix: "L" })), f) {
          const R = Fi(h) ? gy[h](b, s) : b - o, L = Dc(h) ? gy[h](x, s) : x - o;
          _.insert("polygon").attr("points", BY[h](s)).attr("transform", `translate(${R},${L})`).attr("class", "arrow");
        }
        if (m) {
          const R = Fi(g) ? gy[g](A, s) : A - o, L = Dc(g) ? gy[g](S, s) : S - o;
          _.insert("polygon").attr("points", BY[g](s)).attr("transform", `translate(${R},${L})`).attr("class", "arrow");
        }
        if (y) {
          const R = xM(h, g) ? "XY" : Fi(h) ? "X" : "Y";
          let L = 0;
          R === "X" ? L = Math.abs(b - A) : R === "Y" ? L = Math.abs(x - S) / 1.5 : L = Math.abs(b - A) / 2;
          const M = _.append("g");
          if (await Na(
            M,
            y,
            {
              useHtmlLabels: !1,
              width: L,
              classes: "architecture-service-label"
            },
            Te()
          ), M.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), R === "X")
            M.attr("transform", "translate(" + T + ", " + E + ")");
          else if (R === "Y")
            M.attr("transform", "translate(" + T + ", " + E + ") rotate(-90)");
          else if (R === "XY") {
            const P = s9(h, g);
            if (P && plt(P)) {
              const C = M.node().getBoundingClientRect(), [I, N] = vlt(P);
              M.attr("dominant-baseline", "auto").attr("transform", `rotate(${-1 * I * N * 45})`);
              const O = M.node().getBoundingClientRect();
              M.attr(
                "transform",
                `
                translate(${T}, ${E - C.height / 2})
                translate(${I * O.width / 2}, ${N * O.height / 2})
                rotate(${-1 * I * N * 45}, 0, ${C.height / 2})
              `
              );
            }
          }
        }
      }
    })
  );
}, "drawEdges"), Clt = /* @__PURE__ */ w(async function(t, e, r) {
  const i = r.getConfigField("padding") * 0.75, a = r.getConfigField("fontSize"), o = r.getConfigField("iconSize") / 2;
  await Promise.all(
    e.nodes().map(async (l) => {
      const u = Af(l);
      if (u.type === "group") {
        const { h, w: f, x1: d, y1: p } = l.boundingBox(), g = t.append("rect");
        g.attr("id", `group-${u.id}`).attr("x", d + o).attr("y", p + o).attr("width", f).attr("height", h).attr("class", "node-bkg");
        const m = t.append("g");
        let v = d, y = p;
        if (u.icon) {
          const b = m.append("g");
          b.html(
            `<g>${await fc(u.icon, { height: i, width: i, fallbackPrefix: j1.prefix })}</g>`
          ), b.attr(
            "transform",
            "translate(" + (v + o + 1) + ", " + (y + o + 1) + ")"
          ), v += i, y += a / 2 - 1 - 2;
        }
        if (u.label) {
          const b = m.append("g");
          await Na(
            b,
            u.label,
            {
              useHtmlLabels: !1,
              width: f,
              classes: "architecture-service-label"
            },
            Te()
          ), b.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "start").attr("text-anchor", "start"), b.attr(
            "transform",
            "translate(" + (v + o + 4) + ", " + (y + o + 2) + ")"
          );
        }
        r.setElementForId(u.id, g);
      }
    })
  );
}, "drawGroups"), _lt = /* @__PURE__ */ w(async function(t, e, r) {
  const n = Te();
  for (const i of r) {
    const a = e.append("g"), s = t.getConfigField("iconSize");
    if (i.title) {
      const h = a.append("g");
      await Na(
        h,
        i.title,
        {
          useHtmlLabels: !1,
          width: s * 1.5,
          classes: "architecture-service-label"
        },
        n
      ), h.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), h.attr("transform", "translate(" + s / 2 + ", " + s + ")");
    }
    const o = a.append("g");
    if (i.icon)
      o.html(
        `<g>${await fc(i.icon, { height: s, width: s, fallbackPrefix: j1.prefix })}</g>`
      );
    else if (i.iconText) {
      o.html(
        `<g>${await fc("blank", { height: s, width: s, fallbackPrefix: j1.prefix })}</g>`
      );
      const d = o.append("g").append("foreignObject").attr("width", s).attr("height", s).append("div").attr("class", "node-icon-text").attr("style", `height: ${s}px;`).append("div").html(pr(i.iconText, n)), p = parseInt(
        window.getComputedStyle(d.node(), null).getPropertyValue("font-size").replace(/\D/g, "")
      ) ?? 16;
      d.attr("style", `-webkit-line-clamp: ${Math.floor((s - 2) / p)};`);
    } else
      o.append("path").attr("class", "node-bkg").attr("id", "node-" + i.id).attr(
        "d",
        `M0 ${s} v${-s} q0,-5 5,-5 h${s} q5,0 5,5 v${s} H0 Z`
      );
    a.attr("id", `service-${i.id}`).attr("class", "architecture-service");
    const { width: l, height: u } = a.node().getBBox();
    i.width = l, i.height = u, t.setElementForId(i.id, a);
  }
  return 0;
}, "drawServices"), Alt = /* @__PURE__ */ w(function(t, e, r) {
  r.forEach((n) => {
    const i = e.append("g"), a = t.getConfigField("iconSize");
    i.append("g").append("rect").attr("id", "node-" + n.id).attr("fill-opacity", "0").attr("width", a).attr("height", a), i.attr("class", "architecture-junction");
    const { width: o, height: l } = i._groups[0][0].getBBox();
    i.width = o, i.height = l, t.setElementForId(n.id, i);
  });
}, "drawJunctions");
KZ([
  {
    name: j1.prefix,
    icons: j1
  }
]);
yo.use(flt);
function rhe(t, e, r) {
  t.forEach((n) => {
    e.add({
      group: "nodes",
      data: {
        type: "service",
        id: n.id,
        icon: n.icon,
        label: n.title,
        parent: n.in,
        width: r.getConfigField("iconSize"),
        height: r.getConfigField("iconSize")
      },
      classes: "node-service"
    });
  });
}
w(rhe, "addServices");
function nhe(t, e, r) {
  t.forEach((n) => {
    e.add({
      group: "nodes",
      data: {
        type: "junction",
        id: n.id,
        parent: n.in,
        width: r.getConfigField("iconSize"),
        height: r.getConfigField("iconSize")
      },
      classes: "node-junction"
    });
  });
}
w(nhe, "addJunctions");
function ihe(t, e) {
  e.nodes().map((r) => {
    const n = Af(r);
    if (n.type === "group")
      return;
    n.x = r.position().x, n.y = r.position().y, t.getElementById(n.id).attr("transform", "translate(" + (n.x || 0) + "," + (n.y || 0) + ")");
  });
}
w(ihe, "positionNodes");
function ahe(t, e) {
  t.forEach((r) => {
    e.add({
      group: "nodes",
      data: {
        type: "group",
        id: r.id,
        icon: r.icon,
        label: r.title,
        parent: r.in
      },
      classes: "node-group"
    });
  });
}
w(ahe, "addGroups");
function she(t, e) {
  t.forEach((r) => {
    const { lhsId: n, rhsId: i, lhsInto: a, lhsGroup: s, rhsInto: o, lhsDir: l, rhsDir: u, rhsGroup: h, title: f } = r, d = xM(r.lhsDir, r.rhsDir) ? "segments" : "straight", p = {
      id: `${n}-${i}`,
      label: f,
      source: n,
      sourceDir: l,
      sourceArrow: a,
      sourceGroup: s,
      sourceEndpoint: l === "L" ? "0 50%" : l === "R" ? "100% 50%" : l === "T" ? "50% 0" : "50% 100%",
      target: i,
      targetDir: u,
      targetArrow: o,
      targetGroup: h,
      targetEndpoint: u === "L" ? "0 50%" : u === "R" ? "100% 50%" : u === "T" ? "50% 0" : "50% 100%"
    };
    e.add({
      group: "edges",
      data: p,
      classes: d
    });
  });
}
w(she, "addEdges");
function ohe(t, e, r) {
  const n = /* @__PURE__ */ w((o, l) => Object.entries(o).reduce(
    (u, [h, f]) => {
      let d = 0;
      const p = Object.entries(f);
      if (p.length === 1)
        return u[h] = p[0][1], u;
      for (let g = 0; g < p.length - 1; g++)
        for (let m = g + 1; m < p.length; m++) {
          const [v, y] = p[g], [b, x] = p[m];
          if (r[v]?.[b] === l)
            u[h] ??= [], u[h] = [...u[h], ...y, ...x];
          else if (v === "default" || b === "default")
            u[h] ??= [], u[h] = [...u[h], ...y, ...x];
          else {
            const E = `${h}-${d++}`;
            u[E] = y;
            const A = `${h}-${d++}`;
            u[A] = x;
          }
        }
      return u;
    },
    {}
  ), "flattenAlignments"), i = e.map((o) => {
    const l = {}, u = {};
    return Object.entries(o).forEach(([h, [f, d]]) => {
      const p = t.getNode(h)?.in ?? "default";
      l[d] ??= {}, l[d][p] ??= [], l[d][p].push(h), u[f] ??= {}, u[f][p] ??= [], u[f][p].push(h);
    }), {
      horiz: Object.values(n(l, "horizontal")).filter(
        (h) => h.length > 1
      ),
      vert: Object.values(n(u, "vertical")).filter(
        (h) => h.length > 1
      )
    };
  }), [a, s] = i.reduce(
    ([o, l], { horiz: u, vert: h }) => [
      [...o, ...u],
      [...l, ...h]
    ],
    [[], []]
  );
  return {
    horizontal: a,
    vertical: s
  };
}
w(ohe, "getAlignments");
function lhe(t, e) {
  const r = [], n = /* @__PURE__ */ w((a) => `${a[0]},${a[1]}`, "posToStr"), i = /* @__PURE__ */ w((a) => a.split(",").map((s) => parseInt(s)), "strToPos");
  return t.forEach((a) => {
    const s = Object.fromEntries(
      Object.entries(a).map(([h, f]) => [n(f), h])
    ), o = [n([0, 0])], l = {}, u = {
      L: [-1, 0],
      R: [1, 0],
      T: [0, 1],
      B: [0, -1]
    };
    for (; o.length > 0; ) {
      const h = o.shift();
      if (h) {
        l[h] = 1;
        const f = s[h];
        if (f) {
          const d = i(h);
          Object.entries(u).forEach(([p, g]) => {
            const m = n([d[0] + g[0], d[1] + g[1]]), v = s[m];
            v && !l[m] && (o.push(m), r.push({
              [$Y[p]]: v,
              [$Y[dlt(p)]]: f,
              gap: 1.5 * e.getConfigField("iconSize")
            }));
          });
        }
      }
    }
  }), r;
}
w(lhe, "getRelativeConstraints");
function che(t, e, r, n, i, { spatialMaps: a, groupAlignments: s }) {
  return new Promise((o) => {
    const l = Qe("body").append("div").attr("id", "cy").attr("style", "display:none"), u = yo({
      container: document.getElementById("cy"),
      style: [
        {
          selector: "edge",
          style: {
            "curve-style": "straight",
            label: "data(label)",
            "source-endpoint": "data(sourceEndpoint)",
            "target-endpoint": "data(targetEndpoint)"
          }
        },
        {
          selector: "edge.segments",
          style: {
            "curve-style": "segments",
            "segment-weights": "0",
            "segment-distances": [0.5],
            // @ts-ignore Incorrect library types
            "edge-distances": "endpoints",
            "source-endpoint": "data(sourceEndpoint)",
            "target-endpoint": "data(targetEndpoint)"
          }
        },
        {
          selector: "node",
          style: {
            // @ts-ignore Incorrect library types
            "compound-sizing-wrt-labels": "include"
          }
        },
        {
          selector: "node[label]",
          style: {
            "text-valign": "bottom",
            "text-halign": "center",
            "font-size": `${i.getConfigField("fontSize")}px`
          }
        },
        {
          selector: ".node-service",
          style: {
            label: "data(label)",
            width: "data(width)",
            height: "data(height)"
          }
        },
        {
          selector: ".node-junction",
          style: {
            width: "data(width)",
            height: "data(height)"
          }
        },
        {
          selector: ".node-group",
          style: {
            // @ts-ignore Incorrect library types
            padding: `${i.getConfigField("padding")}px`
          }
        }
      ],
      layout: {
        name: "grid",
        boundingBox: {
          x1: 0,
          x2: 100,
          y1: 0,
          y2: 100
        }
      }
    });
    l.remove(), ahe(r, u), rhe(t, u, i), nhe(e, u, i), she(n, u);
    const h = ohe(i, a, s), f = lhe(a, i), d = u.layout({
      name: "fcose",
      quality: "proof",
      styleEnabled: !1,
      animate: !1,
      nodeDimensionsIncludeLabels: !1,
      // Adjust the edge parameters if it passes through the border of a group
      // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67
      idealEdgeLength(p) {
        const [g, m] = p.connectedNodes(), { parent: v } = Af(g), { parent: y } = Af(m);
        return v === y ? 1.5 * i.getConfigField("iconSize") : 0.5 * i.getConfigField("iconSize");
      },
      edgeElasticity(p) {
        const [g, m] = p.connectedNodes(), { parent: v } = Af(g), { parent: y } = Af(m);
        return v === y ? 0.45 : 1e-3;
      },
      alignmentConstraint: h,
      relativePlacementConstraint: f
    });
    d.one("layoutstop", () => {
      function p(g, m, v, y) {
        let b, x;
        const { x: T, y: E } = g, { x: A, y: S } = m;
        x = (y - E + (T - v) * (E - S) / (T - A)) / Math.sqrt(1 + Math.pow((E - S) / (T - A), 2)), b = Math.sqrt(Math.pow(y - E, 2) + Math.pow(v - T, 2) - Math.pow(x, 2));
        const k = Math.sqrt(Math.pow(A - T, 2) + Math.pow(S - E, 2));
        b = b / k;
        let _ = (A - T) * (y - E) - (S - E) * (v - T);
        switch (!0) {
          case _ >= 0:
            _ = 1;
            break;
          case _ < 0:
            _ = -1;
            break;
        }
        let R = (A - T) * (v - T) + (S - E) * (y - E);
        switch (!0) {
          case R >= 0:
            R = 1;
            break;
          case R < 0:
            R = -1;
            break;
        }
        return x = Math.abs(x) * _, b = b * R, {
          distances: x,
          weights: b
        };
      }
      w(p, "getSegmentWeights"), u.startBatch();
      for (const g of Object.values(u.edges()))
        if (g.data?.()) {
          const { x: m, y: v } = g.source().position(), { x: y, y: b } = g.target().position();
          if (m !== y && v !== b) {
            const x = g.sourceEndpoint(), T = g.targetEndpoint(), { sourceDir: E } = Jue(g), [A, S] = Dc(E) ? [x.x, T.y] : [T.x, x.y], { weights: k, distances: _ } = p(x, T, A, S);
            g.style("segment-distances", _), g.style("segment-weights", k);
          }
        }
      u.endBatch(), d.run();
    }), d.run(), u.ready((p) => {
      ae.info("Ready", p), o(u);
    });
  });
}
w(che, "layoutArchitecture");
var Llt = /* @__PURE__ */ w(async (t, e, r, n) => {
  const i = n.db, a = i.getServices(), s = i.getJunctions(), o = i.getGroups(), l = i.getEdges(), u = i.getDataStructures(), h = El(e), f = h.append("g");
  f.attr("class", "architecture-edges");
  const d = h.append("g");
  d.attr("class", "architecture-services");
  const p = h.append("g");
  p.attr("class", "architecture-groups"), await _lt(i, d, a), Alt(i, d, s);
  const g = await che(a, s, o, l, i, u);
  await klt(f, g, i), await Clt(p, g, i), ihe(i, g), Q1(void 0, h, i.getConfigField("padding"), i.getConfigField("useMaxWidth"));
}, "draw"), Rlt = { draw: Llt }, Ilt = {
  parser: the,
  get db() {
    return new ehe();
  },
  renderer: Rlt,
  styles: Slt
};
const Mlt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Ilt
}, Symbol.toStringTag, { value: "Module" }));
var Vd, uhe = (Vd = class {
  constructor() {
    this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.setAccTitle = Ln, this.getAccTitle = Hn, this.setDiagramTitle = ti, this.getDiagramTitle = Mn, this.getAccDescription = Yn, this.setAccDescription = Wn;
  }
  getNodes() {
    return this.nodes;
  }
  getConfig() {
    const e = fr, r = mr();
    return Xi({
      ...e.treemap,
      ...r.treemap ?? {}
    });
  }
  addNode(e, r) {
    this.nodes.push(e), this.levels.set(e, r), r === 0 && (this.outerNodes.push(e), this.root ??= e);
  }
  getRoot() {
    return { name: "", children: this.outerNodes };
  }
  addClass(e, r) {
    const n = this.classes.get(e) ?? { id: e, styles: [], textStyles: [] }, i = r.replace(/\\,/g, "\xA7\xA7\xA7").replace(/,/g, ";").replace(//g, ",").split(";");
    i && i.forEach((a) => {
      B9(a) && (n?.textStyles ? n.textStyles.push(a) : n.textStyles = [a]), n?.styles ? n.styles.push(a) : n.styles = [a];
    }), this.classes.set(e, n);
  }
  getClasses() {
    return this.classes;
  }
  getStylesForClass(e) {
    return this.classes.get(e)?.styles ?? [];
  }
  clear() {
    In(), this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.root = void 0;
  }
}, w(Vd, "TreeMapDB"), Vd);
function hhe(t) {
  if (!t.length)
    return [];
  const e = [], r = [];
  return t.forEach((n) => {
    const i = {
      name: n.name,
      children: n.type === "Leaf" ? void 0 : []
    };
    for (i.classSelector = n?.classSelector, n?.cssCompiledStyles && (i.cssCompiledStyles = [n.cssCompiledStyles]), n.type === "Leaf" && n.value !== void 0 && (i.value = n.value); r.length > 0 && r[r.length - 1].level >= n.level; )
      r.pop();
    if (r.length === 0)
      e.push(i);
    else {
      const a = r[r.length - 1].node;
      a.children ? a.children.push(i) : a.children = [i];
    }
    n.type !== "Leaf" && r.push({ node: i, level: n.level });
  }), e;
}
w(hhe, "buildHierarchy");
var Nlt = /* @__PURE__ */ w((t, e) => {
  Ph(t, e);
  const r = [];
  for (const a of t.TreemapRows ?? [])
    a.$type === "ClassDefStatement" && e.addClass(a.className ?? "", a.styleText ?? "");
  for (const a of t.TreemapRows ?? []) {
    const s = a.item;
    if (!s)
      continue;
    const o = a.indent ? parseInt(a.indent) : 0, l = Dlt(s), u = s.classSelector ? e.getStylesForClass(s.classSelector) : [], h = u.length > 0 ? u.join(";") : void 0, f = {
      level: o,
      name: l,
      type: s.$type,
      value: s.value,
      classSelector: s.classSelector,
      cssCompiledStyles: h
    };
    r.push(f);
  }
  const n = hhe(r), i = /* @__PURE__ */ w((a, s) => {
    for (const o of a)
      e.addNode(o, s), o.children && o.children.length > 0 && i(o.children, s + 1);
  }, "addNodesRecursively");
  i(n, 0);
}, "populate"), Dlt = /* @__PURE__ */ w((t) => t.name ? String(t.name) : "", "getItemName"), fhe = {
  // @ts-expect-error - TreeMapDB is not assignable to DiagramDB
  parser: { yy: void 0 },
  parse: /* @__PURE__ */ w(async (t) => {
    try {
      const r = await ru("treemap", t);
      ae.debug("Treemap AST:", r);
      const n = fhe.parser?.yy;
      if (!(n instanceof uhe))
        throw new Error(
          "parser.parser?.yy was not a TreemapDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
        );
      Nlt(r, n);
    } catch (e) {
      throw ae.error("Error parsing treemap:", e), e;
    }
  }, "parse")
}, Olt = 10, ff = 10, _p = 25, Plt = /* @__PURE__ */ w((t, e, r, n) => {
  const i = n.db, a = i.getConfig(), s = a.padding ?? Olt, o = i.getDiagramTitle(), l = i.getRoot(), { themeVariables: u } = mr();
  if (!l)
    return;
  const h = o ? 30 : 0, f = El(e), d = a.nodeWidth ? a.nodeWidth * ff : 960, p = a.nodeHeight ? a.nodeHeight * ff : 500, g = d, m = p + h;
  f.attr("viewBox", `0 0 ${g} ${m}`), Qi(f, m, g, a.useMaxWidth);
  let v;
  try {
    const C = a.valueFormat || ",";
    if (C === "$0,0")
      v = /* @__PURE__ */ w((I) => "$" + Tu(",")(I), "valueFormat");
    else if (C.startsWith("$") && C.includes(",")) {
      const I = /\.\d+/.exec(C), N = I ? I[0] : "";
      v = /* @__PURE__ */ w((O) => "$" + Tu("," + N)(O), "valueFormat");
    } else if (C.startsWith("$")) {
      const I = C.substring(1);
      v = /* @__PURE__ */ w((N) => "$" + Tu(I || "")(N), "valueFormat");
    } else
      v = Tu(C);
  } catch (C) {
    ae.error("Error creating format function:", C), v = Tu(",");
  }
  const y = Bu().range([
    "transparent",
    u.cScale0,
    u.cScale1,
    u.cScale2,
    u.cScale3,
    u.cScale4,
    u.cScale5,
    u.cScale6,
    u.cScale7,
    u.cScale8,
    u.cScale9,
    u.cScale10,
    u.cScale11
  ]), b = Bu().range([
    "transparent",
    u.cScalePeer0,
    u.cScalePeer1,
    u.cScalePeer2,
    u.cScalePeer3,
    u.cScalePeer4,
    u.cScalePeer5,
    u.cScalePeer6,
    u.cScalePeer7,
    u.cScalePeer8,
    u.cScalePeer9,
    u.cScalePeer10,
    u.cScalePeer11
  ]), x = Bu().range([
    u.cScaleLabel0,
    u.cScaleLabel1,
    u.cScaleLabel2,
    u.cScaleLabel3,
    u.cScaleLabel4,
    u.cScaleLabel5,
    u.cScaleLabel6,
    u.cScaleLabel7,
    u.cScaleLabel8,
    u.cScaleLabel9,
    u.cScaleLabel10,
    u.cScaleLabel11
  ]);
  o && f.append("text").attr("x", g / 2).attr("y", h / 2).attr("class", "treemapTitle").attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(o);
  const T = f.append("g").attr("transform", `translate(0, ${h})`).attr("class", "treemapContainer"), E = S9(l).sum((C) => C.value ?? 0).sort((C, I) => (I.value ?? 0) - (C.value ?? 0)), S = p1e().size([d, p]).paddingTop(
    (C) => C.children && C.children.length > 0 ? _p + ff : 0
  ).paddingInner(s).paddingLeft((C) => C.children && C.children.length > 0 ? ff : 0).paddingRight((C) => C.children && C.children.length > 0 ? ff : 0).paddingBottom((C) => C.children && C.children.length > 0 ? ff : 0).round(!0)(E), k = S.descendants().filter((C) => C.children && C.children.length > 0), _ = T.selectAll(".treemapSection").data(k).enter().append("g").attr("class", "treemapSection").attr("transform", (C) => `translate(${C.x0},${C.y0})`);
  _.append("rect").attr("width", (C) => C.x1 - C.x0).attr("height", _p).attr("class", "treemapSectionHeader").attr("fill", "none").attr("fill-opacity", 0.6).attr("stroke-width", 0.6).attr("style", (C) => C.depth === 0 ? "display: none;" : ""), _.append("clipPath").attr("id", (C, I) => `clip-section-${e}-${I}`).append("rect").attr("width", (C) => Math.max(0, C.x1 - C.x0 - 12)).attr("height", _p), _.append("rect").attr("width", (C) => C.x1 - C.x0).attr("height", (C) => C.y1 - C.y0).attr("class", (C, I) => `treemapSection section${I}`).attr("fill", (C) => y(C.data.name)).attr("fill-opacity", 0.6).attr("stroke", (C) => b(C.data.name)).attr("stroke-width", 2).attr("stroke-opacity", 0.4).attr("style", (C) => {
    if (C.depth === 0)
      return "display: none;";
    const I = kt({ cssCompiledStyles: C.data.cssCompiledStyles });
    return I.nodeStyles + ";" + I.borderStyles.join(";");
  }), _.append("text").attr("class", "treemapSectionLabel").attr("x", 6).attr("y", _p / 2).attr("dominant-baseline", "middle").text((C) => C.depth === 0 ? "" : C.data.name).attr("font-weight", "bold").attr("style", (C) => {
    if (C.depth === 0)
      return "display: none;";
    const I = "dominant-baseline: middle; font-size: 12px; fill:" + x(C.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;", N = kt({ cssCompiledStyles: C.data.cssCompiledStyles });
    return I + N.labelStyles.replace("color:", "fill:");
  }).each(function(C) {
    if (C.depth === 0)
      return;
    const I = Qe(this), N = C.data.name;
    I.text(N);
    const O = C.x1 - C.x0, D = 6;
    let $;
    a.showValues !== !1 && C.value ? $ = O - 10 - 30 - 10 - D : $ = O - D - 6;
    const B = Math.max(15, $), G = I.node();
    if (G.getComputedTextLength() > B) {
      let U = N;
      for (; U.length > 0; ) {
        if (U = N.substring(0, U.length - 1), U.length === 0) {
          I.text("..."), G.getComputedTextLength() > B && I.text("");
          break;
        }
        if (I.text(U + "..."), G.getComputedTextLength() <= B)
          break;
      }
    }
  }), a.showValues !== !1 && _.append("text").attr("class", "treemapSectionValue").attr("x", (C) => C.x1 - C.x0 - 10).attr("y", _p / 2).attr("text-anchor", "end").attr("dominant-baseline", "middle").text((C) => C.value ? v(C.value) : "").attr("font-style", "italic").attr("style", (C) => {
    if (C.depth === 0)
      return "display: none;";
    const I = "text-anchor: end; dominant-baseline: middle; font-size: 10px; fill:" + x(C.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;", N = kt({ cssCompiledStyles: C.data.cssCompiledStyles });
    return I + N.labelStyles.replace("color:", "fill:");
  });
  const R = S.leaves(), L = T.selectAll(".treemapLeafGroup").data(R).enter().append("g").attr("class", (C, I) => `treemapNode treemapLeafGroup leaf${I}${C.data.classSelector ? ` ${C.data.classSelector}` : ""}x`).attr("transform", (C) => `translate(${C.x0},${C.y0})`);
  L.append("rect").attr("width", (C) => C.x1 - C.x0).attr("height", (C) => C.y1 - C.y0).attr("class", "treemapLeaf").attr("fill", (C) => C.parent ? y(C.parent.data.name) : y(C.data.name)).attr("style", (C) => kt({ cssCompiledStyles: C.data.cssCompiledStyles }).nodeStyles).attr("fill-opacity", 0.3).attr("stroke", (C) => C.parent ? y(C.parent.data.name) : y(C.data.name)).attr("stroke-width", 3), L.append("clipPath").attr("id", (C, I) => `clip-${e}-${I}`).append("rect").attr("width", (C) => Math.max(0, C.x1 - C.x0 - 4)).attr("height", (C) => Math.max(0, C.y1 - C.y0 - 4)), L.append("text").attr("class", "treemapLabel").attr("x", (C) => (C.x1 - C.x0) / 2).attr("y", (C) => (C.y1 - C.y0) / 2).attr("style", (C) => {
    const I = "text-anchor: middle; dominant-baseline: middle; font-size: 38px;fill:" + x(C.data.name) + ";", N = kt({ cssCompiledStyles: C.data.cssCompiledStyles });
    return I + N.labelStyles.replace("color:", "fill:");
  }).attr("clip-path", (C, I) => `url(#clip-${e}-${I})`).text((C) => C.data.name).each(function(C) {
    const I = Qe(this), N = C.x1 - C.x0, O = C.y1 - C.y0, D = I.node(), $ = 4, z = N - 2 * $, B = O - 2 * $;
    if (z < 10 || B < 10) {
      I.style("display", "none");
      return;
    }
    let G = parseInt(I.style("font-size"), 10);
    const W = 8, V = 28, U = 0.6, Z = 6, K = 2;
    for (; D.getComputedTextLength() > z && G > W; )
      G--, I.style("font-size", `${G}px`);
    let ce = Math.max(
      Z,
      Math.min(V, Math.round(G * U))
    ), J = G + K + ce;
    for (; J > B && G > W && (G--, ce = Math.max(
      Z,
      Math.min(V, Math.round(G * U))
    ), !(ce < Z && G === W)); )
      I.style("font-size", `${G}px`), J = G + K + ce;
    I.style("font-size", `${G}px`), (D.getComputedTextLength() > z || G < W || B < G) && I.style("display", "none");
  }), a.showValues !== !1 && L.append("text").attr("class", "treemapValue").attr("x", (I) => (I.x1 - I.x0) / 2).attr("y", function(I) {
    return (I.y1 - I.y0) / 2;
  }).attr("style", (I) => {
    const N = "text-anchor: middle; dominant-baseline: hanging; font-size: 28px;fill:" + x(I.data.name) + ";", O = kt({ cssCompiledStyles: I.data.cssCompiledStyles });
    return N + O.labelStyles.replace("color:", "fill:");
  }).attr("clip-path", (I, N) => `url(#clip-${e}-${N})`).text((I) => I.value ? v(I.value) : "").each(function(I) {
    const N = Qe(this), O = this.parentNode;
    if (!O) {
      N.style("display", "none");
      return;
    }
    const D = Qe(O).select(".treemapLabel");
    if (D.empty() || D.style("display") === "none") {
      N.style("display", "none");
      return;
    }
    const $ = parseFloat(D.style("font-size")), z = 28, B = 0.6, G = 6, W = 2, V = Math.max(
      G,
      Math.min(z, Math.round($ * B))
    );
    N.style("font-size", `${V}px`);
    const Z = (I.y1 - I.y0) / 2 + $ / 2 + W;
    N.attr("y", Z);
    const K = I.x1 - I.x0, ee = I.y1 - I.y0 - 4, j = K - 8;
    N.node().getComputedTextLength() > j || Z + V > ee || V < G ? N.style("display", "none") : N.style("display", null);
  });
  const P = a.diagramPadding ?? 8;
  Oh(f, P, "flowchart", a?.useMaxWidth || !1);
}, "draw"), $lt = /* @__PURE__ */ w(function(t, e) {
  return e.db.getClasses();
}, "getClasses"), Blt = { draw: Plt, getClasses: $lt }, Flt = {
  sectionStrokeColor: "black",
  sectionStrokeWidth: "1",
  sectionFillColor: "#efefef",
  leafStrokeColor: "black",
  leafStrokeWidth: "1",
  leafFillColor: "#efefef",
  labelColor: "black",
  labelFontSize: "12px",
  valueFontSize: "10px",
  valueColor: "black",
  titleColor: "black",
  titleFontSize: "14px"
}, zlt = /* @__PURE__ */ w(({
  treemap: t
} = {}) => {
  const e = Xi(Flt, t);
  return `
  .treemapNode.section {
    stroke: ${e.sectionStrokeColor};
    stroke-width: ${e.sectionStrokeWidth};
    fill: ${e.sectionFillColor};
  }
  .treemapNode.leaf {
    stroke: ${e.leafStrokeColor};
    stroke-width: ${e.leafStrokeWidth};
    fill: ${e.leafFillColor};
  }
  .treemapLabel {
    fill: ${e.labelColor};
    font-size: ${e.labelFontSize};
  }
  .treemapValue {
    fill: ${e.valueColor};
    font-size: ${e.valueFontSize};
  }
  .treemapTitle {
    fill: ${e.titleColor};
    font-size: ${e.titleFontSize};
  }
  `;
}, "getStyles"), qlt = zlt, Glt = {
  parser: fhe,
  get db() {
    return new uhe();
  },
  renderer: Blt,
  styles: qlt
};
const Ult = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Glt
}, Symbol.toStringTag, { value: "Module" })), Vlt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InfoModule: wle,
  createInfoServices: Tle
}, Symbol.toStringTag, { value: "Module" })), Hlt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PacketModule: Ele,
  createPacketServices: Sle
}, Symbol.toStringTag, { value: "Module" })), Wlt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PieModule: kle,
  createPieServices: Cle
}, Symbol.toStringTag, { value: "Module" })), Ylt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArchitectureModule: _le,
  createArchitectureServices: Ale
}, Symbol.toStringTag, { value: "Module" })), Xlt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GitGraphModule: ble,
  createGitGraphServices: xle
}, Symbol.toStringTag, { value: "Module" })), jlt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RadarModule: Lle,
  createRadarServices: Rle
}, Symbol.toStringTag, { value: "Module" })), Klt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TreemapModule: Mle,
  createTreemapServices: Nle
}, Symbol.toStringTag, { value: "Module" }));
export {
  qSe as Diagram,
  zSe as DiagramPreview,
  oct as default,
  GSe as version
};
